{"version":3,"file":"testing.js","names":["parsed: T"],"sources":["../src/lib/compare.ts","../src/testing.ts"],"sourcesContent":["import type { Query } from './search-params'\n\nexport function compareQuery<T extends Query>(\n  a: T | null,\n  b: T | null\n): boolean {\n  if (a === b) {\n    return true // Referentially stable\n  }\n  if (a === null || b === null) {\n    return false\n  }\n  // we expect either strings or arrays, not a mix of both\n  if (typeof a === 'string' || typeof b === 'string') {\n    return false\n  }\n\n  if (a.length !== b.length) {\n    return false\n  }\n\n  return a.every((value, index) => value === b[index]!)\n}\n","import { compareQuery } from './lib/compare'\nimport type {\n  GenericParserBuilder,\n  MultiParserBuilder,\n  SingleParserBuilder\n} from './parsers'\n\nexport function isParserBijective<T>(\n  parser: SingleParserBuilder<T>,\n  serialized: string,\n  input: T\n): boolean\nexport function isParserBijective<T>(\n  parser: MultiParserBuilder<T>,\n  serialized: Array<string>,\n  input: T\n): boolean\n\n/**\n * Test that a parser is bijective (serialize then parse gives back the same value).\n *\n * It will throw if the parser does not serialize the input to the expected serialized value,\n * or if the parser does not parse the serialized value to the expected input value.\n * The parser's `eq` function (if provided, otherwise `===`) is used to compare the values.\n *\n * Usage:\n * ```ts\n * // Expect it to pass (no error thrown)\n * expect(isParserBijective(parseAsInteger, '42', 42)).toBe(true)\n * // Expect it to fail\n * expect(() => isParserBijective(parseAsInteger, '42', 47)).toThrow()\n * ```\n *\n * @param parser The parser to test\n * @param serialized The serialized representation of the input to test against\n * @param input An input value to test against\n * @returns `true` if the test passes, otherwise it will throw.\n */\nexport function isParserBijective<T>(\n  parser: GenericParserBuilder<T>,\n  serialized: string | Array<string>,\n  input: T\n): boolean {\n  if (parser.type === 'multi' && Array.isArray(serialized)) {\n    // Test either sides of the bijectivitiy\n    testSerializeThenParse(parser, input)\n    testParseThenSerialize(parser, serialized)\n  } else if (parser.type !== 'multi' && typeof serialized === 'string') {\n    // Test either sides of the bijectivitiy\n    testSerializeThenParse(parser, input)\n    testParseThenSerialize(parser, serialized)\n  } else {\n    // Shouldn't happen with correct overload types, but better be safe and fail the test.\n    throw new Error(\n      `[nuqs] isParserBijective: mismatched parser type and serialized value type`\n    )\n  }\n  // Test value equality\n  if (!compareQuery(parser.serialize(input), serialized)) {\n    throw new Error(\n      `[nuqs] parser.serialize does not match expected serialized value\n  Expected: '${serialized}'\n  Received: '${parser.serialize(input)}'\n  `\n    )\n  }\n  // @ts-expect-error - might return null\n  const parsed: T = parser.parse(serialized)\n  if (!parser.eq(parsed, input)) {\n    throw new Error(\n      `[nuqs] parser.parse does not match expected input value\n  Expected: ${input}\n  Received: ${parsed}\n  `\n    )\n  }\n  return true\n}\n\nexport function testSerializeThenParse<T>(\n  parser: SingleParserBuilder<T>,\n  input: T\n): boolean\nexport function testSerializeThenParse<T>(\n  parser: MultiParserBuilder<T>,\n  input: T\n): boolean\n\n/**\n * Test that a parser is bijective (serialize then parse gives back the same value).\n *\n * It will throw if the parser is not bijective (if the parsed value is not equal to the input value).\n * The parser's `eq` function is used to compare the values.\n *\n * Usage:\n * ```ts\n * // Expect it to pass (no error thrown)\n * expect(testSerializeThenParse(myParser, 'foo')).toBe(true)\n * // Expect it to fail\n * expect(() => testSerializeThenParse(myParser, 'bar')).toThrow()\n * ```\n *\n * @param parser The parser to test\n * @param input An input value to test against\n * @returns `true` if the test passes, otherwise it will throw.\n */\nexport function testSerializeThenParse<T>(\n  parser: GenericParserBuilder<T>,\n  input: T\n): boolean {\n  const serialized = parser.serialize(input)\n  const parsed =\n    parser.type == 'multi' && Array.isArray(serialized)\n      ? parser.parse(serialized)\n      : parser.type !== 'multi' && typeof serialized === 'string'\n        ? parser.parse(serialized)\n        : null\n  if (parsed === null) {\n    throw new Error(\n      `[nuqs] testSerializeThenParse: parsed value is null (when parsing ${serialized} serialized from ${input})`\n    )\n  }\n  if (!parser.eq(input, parsed)) {\n    throw new Error(\n      `[nuqs] parser is not bijective (in testSerializeThenParse)\n  Expected value:         ${typeof input === 'object' ? JSON.stringify(input) : input}\n  Received parsed value:  ${typeof parsed === 'object' ? JSON.stringify(parsed) : parsed}\n  Serialized as: '${serialized}'\n  `\n    )\n  }\n  return true\n}\n\nexport function testParseThenSerialize<T>(\n  parser: SingleParserBuilder<T>,\n  input: string\n): boolean\nexport function testParseThenSerialize<T>(\n  parser: MultiParserBuilder<T>,\n  input: Array<string>\n): boolean\n\n/**\n * Tests that a parser is bijective (parse then serialize gives back the same query string).\n *\n * It will throw if the parser is not bijective (if the serialized value is not equal to the input query).\n *\n * Usage:\n * ```ts\n * // Expect it to pass (no error thrown)\n * expect(testParseThenSerialize(myParser, 'foo')).toBe(true)\n * // Expect it to fail\n * expect(() => testParseThenSerialize(myParser, 'bar')).toThrow()\n * ```\n *\n * @param parser The parser to test\n * @param input A query string to test against\n * @returns `true` if the test passes, otherwise it will throw.\n */\nexport function testParseThenSerialize<T>(\n  parser: GenericParserBuilder<T>,\n  input: string | Array<string>\n): boolean {\n  const parsed =\n    parser.type === 'multi' && Array.isArray(input)\n      ? parser.parse(input)\n      : parser.type !== 'multi' && typeof input === 'string'\n        ? parser.parse(input)\n        : null\n  if (parsed === null) {\n    throw new Error(\n      `[nuqs] testParseThenSerialize: parsed value is null (when parsing ${input})`\n    )\n  }\n  const serialized = parser.serialize(parsed)\n  if (!compareQuery(serialized, input)) {\n    throw new Error(\n      `[nuqs] parser is not bijective (in testParseThenSerialize)\n  Expected query: '${input}'\n  Received query: '${serialized}'\n  Parsed value: ${parsed}\n`\n    )\n  }\n  return true\n}\n"],"mappings":";AAEA,SAAgB,aACd,GACA,GACS;AACT,KAAI,MAAM,EACR,QAAO;AAET,KAAI,MAAM,QAAQ,MAAM,KACtB,QAAO;AAGT,KAAI,OAAO,MAAM,YAAY,OAAO,MAAM,SACxC,QAAO;AAGT,KAAI,EAAE,WAAW,EAAE,OACjB,QAAO;AAGT,QAAO,EAAE,OAAO,OAAO,UAAU,UAAU,EAAE,OAAQ;;;;;;;;;;;;;;;;;;;;;;;;;ACiBvD,SAAgB,kBACd,QACA,YACA,OACS;AACT,KAAI,OAAO,SAAS,WAAW,MAAM,QAAQ,WAAW,EAAE;AAExD,yBAAuB,QAAQ,MAAM;AACrC,yBAAuB,QAAQ,WAAW;YACjC,OAAO,SAAS,WAAW,OAAO,eAAe,UAAU;AAEpE,yBAAuB,QAAQ,MAAM;AACrC,yBAAuB,QAAQ,WAAW;OAG1C,OAAM,IAAI,MACR,6EACD;AAGH,KAAI,CAAC,aAAa,OAAO,UAAU,MAAM,EAAE,WAAW,CACpD,OAAM,IAAI,MACR;eACS,WAAW;eACX,OAAO,UAAU,MAAM,CAAC;IAElC;CAGH,MAAMA,SAAY,OAAO,MAAM,WAAW;AAC1C,KAAI,CAAC,OAAO,GAAG,QAAQ,MAAM,CAC3B,OAAM,IAAI,MACR;cACQ,MAAM;cACN,OAAO;IAEhB;AAEH,QAAO;;;;;;;;;;;;;;;;;;;;AA8BT,SAAgB,uBACd,QACA,OACS;CACT,MAAM,aAAa,OAAO,UAAU,MAAM;CAC1C,MAAM,SACJ,OAAO,QAAQ,WAAW,MAAM,QAAQ,WAAW,GAC/C,OAAO,MAAM,WAAW,GACxB,OAAO,SAAS,WAAW,OAAO,eAAe,WAC/C,OAAO,MAAM,WAAW,GACxB;AACR,KAAI,WAAW,KACb,OAAM,IAAI,MACR,qEAAqE,WAAW,mBAAmB,MAAM,GAC1G;AAEH,KAAI,CAAC,OAAO,GAAG,OAAO,OAAO,CAC3B,OAAM,IAAI,MACR;4BACsB,OAAO,UAAU,WAAW,KAAK,UAAU,MAAM,GAAG,MAAM;4BAC1D,OAAO,WAAW,WAAW,KAAK,UAAU,OAAO,GAAG,OAAO;oBACrE,WAAW;IAE1B;AAEH,QAAO;;;;;;;;;;;;;;;;;;;AA6BT,SAAgB,uBACd,QACA,OACS;CACT,MAAM,SACJ,OAAO,SAAS,WAAW,MAAM,QAAQ,MAAM,GAC3C,OAAO,MAAM,MAAM,GACnB,OAAO,SAAS,WAAW,OAAO,UAAU,WAC1C,OAAO,MAAM,MAAM,GACnB;AACR,KAAI,WAAW,KACb,OAAM,IAAI,MACR,qEAAqE,MAAM,GAC5E;CAEH,MAAM,aAAa,OAAO,UAAU,OAAO;AAC3C,KAAI,CAAC,aAAa,YAAY,MAAM,CAClC,OAAM,IAAI,MACR;qBACe,MAAM;qBACN,WAAW;kBACd,OAAO;EAEpB;AAEH,QAAO"}