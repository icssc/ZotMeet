{"version":3,"file":"migrator.js","names":["queriesToRun: string[]"],"sources":["../../src/pg-proxy/migrator.ts"],"sourcesContent":["import type { MigrationConfig } from '~/migrator.ts';\nimport { readMigrationFiles } from '~/migrator.ts';\nimport type { AnyRelations } from '~/relations.ts';\nimport { sql } from '~/sql/sql.ts';\nimport type { PgRemoteDatabase } from './driver.ts';\n\nexport type ProxyMigrator = (migrationQueries: string[]) => Promise<void>;\n\nexport async function migrate<\n\tTSchema extends Record<string, unknown>,\n\tTRelations extends AnyRelations,\n>(\n\tdb: PgRemoteDatabase<TSchema, TRelations>,\n\tcallback: ProxyMigrator,\n\tconfig: MigrationConfig,\n) {\n\tconst migrations = readMigrationFiles(config);\n\n\tconst migrationsTable = typeof config === 'string'\n\t\t? '__drizzle_migrations'\n\t\t: config.migrationsTable ?? '__drizzle_migrations';\n\tconst migrationsSchema = typeof config === 'string' ? 'drizzle' : config.migrationsSchema ?? 'drizzle';\n\tconst migrationTableCreate = sql`\n\t\tCREATE TABLE IF NOT EXISTS ${sql.identifier(migrationsSchema)}.${sql.identifier(migrationsTable)} (\n\t\t\tid SERIAL PRIMARY KEY,\n\t\t\thash text NOT NULL,\n\t\t\tcreated_at bigint\n\t\t)\n\t`;\n\n\tawait db.execute(sql`CREATE SCHEMA IF NOT EXISTS ${sql.identifier(migrationsSchema)}`);\n\tawait db.execute(migrationTableCreate);\n\n\tconst dbMigrations = await db.execute<{ id: number; hash: string; created_at: string }>(\n\t\tsql`select id, hash, created_at from ${sql.identifier(migrationsSchema)}.${\n\t\t\tsql.identifier(migrationsTable)\n\t\t} order by created_at desc limit 1`,\n\t);\n\n\tif (typeof config === 'object' && config.init) {\n\t\tif (dbMigrations.length) {\n\t\t\treturn { exitCode: 'databaseMigrations' as const };\n\t\t}\n\n\t\tif (migrations.length > 1) {\n\t\t\treturn { exitCode: 'localMigrations' as const };\n\t\t}\n\n\t\tconst [migration] = migrations;\n\n\t\tif (!migration) return;\n\n\t\tawait callback(\n\t\t\t[\n\t\t\t\tdb.dialect.sqlToQuery(\n\t\t\t\t\tsql`insert into ${sql.identifier(migrationsSchema)}.${\n\t\t\t\t\t\tsql.identifier(migrationsTable)\n\t\t\t\t\t} (\"hash\", \"created_at\") values(${migration.hash}, ${migration.folderMillis})`.inlineParams(),\n\t\t\t\t).sql,\n\t\t\t],\n\t\t);\n\n\t\treturn;\n\t}\n\n\tconst lastDbMigration = dbMigrations[0] ?? undefined;\n\tconst queriesToRun: string[] = [];\n\tfor (const migration of migrations) {\n\t\tif (\n\t\t\t!lastDbMigration\n\t\t\t|| Number(lastDbMigration.created_at)! < migration.folderMillis\n\t\t) {\n\t\t\tqueriesToRun.push(\n\t\t\t\t...migration.sql,\n\t\t\t\tdb.dialect.sqlToQuery(\n\t\t\t\t\tsql`insert into ${sql.identifier(migrationsSchema)}.${\n\t\t\t\t\t\tsql.identifier(migrationsTable)\n\t\t\t\t\t} (\"hash\", \"created_at\") values(${migration.hash}, '${migration.folderMillis}')`.inlineParams(),\n\t\t\t\t).sql,\n\t\t\t);\n\t\t}\n\t}\n\n\tawait callback(queriesToRun);\n\n\treturn;\n}\n"],"mappings":";;;;AAQA,eAAsB,QAIrB,IACA,UACA,QACC;CACD,MAAM,aAAa,mBAAmB,OAAO;CAE7C,MAAM,kBAAkB,OAAO,WAAW,WACvC,yBACA,OAAO,mBAAmB;CAC7B,MAAM,mBAAmB,OAAO,WAAW,WAAW,YAAY,OAAO,oBAAoB;CAC7F,MAAM,uBAAuB,GAAG;+BACF,IAAI,WAAW,iBAAiB,CAAC,GAAG,IAAI,WAAW,gBAAgB,CAAC;;;;;;AAOlG,OAAM,GAAG,QAAQ,GAAG,+BAA+B,IAAI,WAAW,iBAAiB,GAAG;AACtF,OAAM,GAAG,QAAQ,qBAAqB;CAEtC,MAAM,eAAe,MAAM,GAAG,QAC7B,GAAG,oCAAoC,IAAI,WAAW,iBAAiB,CAAC,GACvE,IAAI,WAAW,gBAAgB,CAC/B,mCACD;AAED,KAAI,OAAO,WAAW,YAAY,OAAO,MAAM;AAC9C,MAAI,aAAa,OAChB,QAAO,EAAE,UAAU,sBAA+B;AAGnD,MAAI,WAAW,SAAS,EACvB,QAAO,EAAE,UAAU,mBAA4B;EAGhD,MAAM,CAAC,aAAa;AAEpB,MAAI,CAAC,UAAW;AAEhB,QAAM,SACL,CACC,GAAG,QAAQ,WACV,GAAG,eAAe,IAAI,WAAW,iBAAiB,CAAC,GAClD,IAAI,WAAW,gBAAgB,CAC/B,iCAAiC,UAAU,KAAK,IAAI,UAAU,aAAa,GAAG,cAAc,CAC7F,CAAC,IACF,CACD;AAED;;CAGD,MAAM,kBAAkB,aAAa,MAAM;CAC3C,MAAMA,eAAyB,EAAE;AACjC,MAAK,MAAM,aAAa,WACvB,KACC,CAAC,mBACE,OAAO,gBAAgB,WAAW,GAAI,UAAU,aAEnD,cAAa,KACZ,GAAG,UAAU,KACb,GAAG,QAAQ,WACV,GAAG,eAAe,IAAI,WAAW,iBAAiB,CAAC,GAClD,IAAI,WAAW,gBAAgB,CAC/B,iCAAiC,UAAU,KAAK,KAAK,UAAU,aAAa,IAAI,cAAc,CAC/F,CAAC,IACF;AAIH,OAAM,SAAS,aAAa"}