{"version":3,"file":"session.cjs","names":["SQLiteSession","entityKind","client: Client","relations: TRelations","schema: V1.RelationalSchemaConfig<TSchema> | undefined","options: LibSQLSessionOptions","tx: Transaction | undefined","NoopLogger","NoopCache","preparedQueries: PreparedQuery[]","builtQueries: InStatement[]","SQLiteTransaction","sql","SQLitePreparedQuery","logger: Logger","fields: SelectedFieldsOrdered | undefined","_isResponseInArrayMode: boolean","customResultMapper?: (\n\t\t\trows: TIsRqbV2 extends true ? Record<string, unknown>[] : unknown[][],\n\t\t\tmapColumnValue?: (value: unknown) => unknown,\n\t\t) => unknown","isRqbV2Query?: TIsRqbV2","stmt: InStatement","rows"],"sources":["../../src/libsql/session.ts"],"sourcesContent":["import type { Client, InArgs, InStatement, ResultSet, Transaction } from '@libsql/client';\nimport type * as V1 from '~/_relations.ts';\nimport type { BatchItem } from '~/batch.ts';\nimport { type Cache, NoopCache } from '~/cache/core/index.ts';\nimport type { WithCacheConfig } from '~/cache/core/types.ts';\nimport { entityKind } from '~/entity.ts';\nimport type { Logger } from '~/logger.ts';\nimport { NoopLogger } from '~/logger.ts';\nimport type { AnyRelations } from '~/relations.ts';\nimport type { PreparedQuery } from '~/session.ts';\nimport { fillPlaceholders, type Query, sql } from '~/sql/sql.ts';\nimport type { SQLiteAsyncDialect } from '~/sqlite-core/dialect.ts';\nimport { SQLiteTransaction } from '~/sqlite-core/index.ts';\nimport type { SelectedFieldsOrdered } from '~/sqlite-core/query-builders/select.types.ts';\nimport type {\n\tPreparedQueryConfig as PreparedQueryConfigBase,\n\tSQLiteExecuteMethod,\n\tSQLiteTransactionConfig,\n} from '~/sqlite-core/session.ts';\nimport { SQLitePreparedQuery, SQLiteSession } from '~/sqlite-core/session.ts';\nimport { mapResultRow } from '~/utils.ts';\n\nexport interface LibSQLSessionOptions {\n\tlogger?: Logger;\n\tcache?: Cache;\n}\n\ntype PreparedQueryConfig = Omit<PreparedQueryConfigBase, 'statement' | 'run'>;\n\nexport class LibSQLSession<\n\tTFullSchema extends Record<string, unknown>,\n\tTRelations extends AnyRelations,\n\tTSchema extends V1.TablesRelationalConfig,\n> extends SQLiteSession<'async', ResultSet, TFullSchema, TRelations, TSchema> {\n\tstatic override readonly [entityKind]: string = 'LibSQLSession';\n\n\tprivate logger: Logger;\n\tprivate cache: Cache;\n\n\tconstructor(\n\t\tprivate client: Client,\n\t\tdialect: SQLiteAsyncDialect,\n\t\tprivate relations: TRelations,\n\t\tprivate schema: V1.RelationalSchemaConfig<TSchema> | undefined,\n\t\tprivate options: LibSQLSessionOptions,\n\t\tprivate tx: Transaction | undefined,\n\t) {\n\t\tsuper(dialect);\n\t\tthis.logger = options.logger ?? new NoopLogger();\n\t\tthis.cache = options.cache ?? new NoopCache();\n\t}\n\n\tprepareQuery<T extends Omit<PreparedQueryConfig, 'run'>>(\n\t\tquery: Query,\n\t\tfields: SelectedFieldsOrdered | undefined,\n\t\texecuteMethod: SQLiteExecuteMethod,\n\t\tisResponseInArrayMode: boolean,\n\t\tcustomResultMapper?: (rows: unknown[][]) => unknown,\n\t\tqueryMetadata?: {\n\t\t\ttype: 'select' | 'update' | 'delete' | 'insert';\n\t\t\ttables: string[];\n\t\t},\n\t\tcacheConfig?: WithCacheConfig,\n\t): LibSQLPreparedQuery<T> {\n\t\treturn new LibSQLPreparedQuery(\n\t\t\tthis.client,\n\t\t\tquery,\n\t\t\tthis.logger,\n\t\t\tthis.cache,\n\t\t\tqueryMetadata,\n\t\t\tcacheConfig,\n\t\t\tfields,\n\t\t\tthis.tx,\n\t\t\texecuteMethod,\n\t\t\tisResponseInArrayMode,\n\t\t\tcustomResultMapper,\n\t\t);\n\t}\n\n\tprepareRelationalQuery<T extends Omit<PreparedQueryConfig, 'run'>>(\n\t\tquery: Query,\n\t\tfields: SelectedFieldsOrdered | undefined,\n\t\texecuteMethod: SQLiteExecuteMethod,\n\t\tcustomResultMapper: (rows: Record<string, unknown>[]) => unknown,\n\t): LibSQLPreparedQuery<T, true> {\n\t\treturn new LibSQLPreparedQuery(\n\t\t\tthis.client,\n\t\t\tquery,\n\t\t\tthis.logger,\n\t\t\tthis.cache,\n\t\t\tundefined,\n\t\t\tundefined,\n\t\t\tfields,\n\t\t\tthis.tx,\n\t\t\texecuteMethod,\n\t\t\tfalse,\n\t\t\tcustomResultMapper,\n\t\t\ttrue,\n\t\t);\n\t}\n\n\tasync batch<T extends BatchItem<'sqlite'>[] | readonly BatchItem<'sqlite'>[]>(queries: T) {\n\t\tconst preparedQueries: PreparedQuery[] = [];\n\t\tconst builtQueries: InStatement[] = [];\n\n\t\tfor (const query of queries) {\n\t\t\tconst preparedQuery = query._prepare();\n\t\t\tconst builtQuery = preparedQuery.getQuery();\n\t\t\tpreparedQueries.push(preparedQuery);\n\t\t\tbuiltQueries.push({ sql: builtQuery.sql, args: builtQuery.params as InArgs });\n\t\t}\n\n\t\tconst batchResults = await this.client.batch(builtQueries);\n\t\treturn batchResults.map((result, i) => preparedQueries[i]!.mapResult(result, true));\n\t}\n\n\tasync migrate<T extends BatchItem<'sqlite'>[] | readonly BatchItem<'sqlite'>[]>(queries: T) {\n\t\tconst preparedQueries: PreparedQuery[] = [];\n\t\tconst builtQueries: InStatement[] = [];\n\n\t\tfor (const query of queries) {\n\t\t\tconst preparedQuery = query._prepare();\n\t\t\tconst builtQuery = preparedQuery.getQuery();\n\t\t\tpreparedQueries.push(preparedQuery);\n\t\t\tbuiltQueries.push({ sql: builtQuery.sql, args: builtQuery.params as InArgs });\n\t\t}\n\n\t\tconst batchResults = await this.client.migrate(builtQueries);\n\t\treturn batchResults.map((result, i) => preparedQueries[i]!.mapResult(result, true));\n\t}\n\n\toverride async transaction<T>(\n\t\ttransaction: (db: LibSQLTransaction<TFullSchema, TRelations, TSchema>) => T | Promise<T>,\n\t\t_config?: SQLiteTransactionConfig,\n\t): Promise<T> {\n\t\t// TODO: support transaction behavior\n\t\tconst libsqlTx = await this.client.transaction();\n\t\tconst session = new LibSQLSession<TFullSchema, TRelations, TSchema>(\n\t\t\tthis.client,\n\t\t\tthis.dialect,\n\t\t\tthis.relations,\n\t\t\tthis.schema,\n\t\t\tthis.options,\n\t\t\tlibsqlTx,\n\t\t);\n\t\tconst tx = new LibSQLTransaction<TFullSchema, TRelations, TSchema>(\n\t\t\t'async',\n\t\t\tthis.dialect,\n\t\t\tsession,\n\t\t\tthis.relations,\n\t\t\tthis.schema,\n\t\t);\n\t\ttry {\n\t\t\tconst result = await transaction(tx);\n\t\t\tawait libsqlTx.commit();\n\t\t\treturn result;\n\t\t} catch (err) {\n\t\t\tawait libsqlTx.rollback();\n\t\t\tthrow err;\n\t\t}\n\t}\n\n\toverride extractRawAllValueFromBatchResult(result: unknown): unknown {\n\t\treturn (result as ResultSet).rows;\n\t}\n\n\toverride extractRawGetValueFromBatchResult(result: unknown): unknown {\n\t\treturn (result as ResultSet).rows[0];\n\t}\n\n\toverride extractRawValuesValueFromBatchResult(result: unknown): unknown {\n\t\treturn (result as ResultSet).rows;\n\t}\n}\n\nexport class LibSQLTransaction<\n\tTFullSchema extends Record<string, unknown>,\n\tTRelations extends AnyRelations,\n\tTSchema extends V1.TablesRelationalConfig,\n> extends SQLiteTransaction<'async', ResultSet, TFullSchema, TRelations, TSchema> {\n\tstatic override readonly [entityKind]: string = 'LibSQLTransaction';\n\n\toverride async transaction<T>(\n\t\ttransaction: (tx: LibSQLTransaction<TFullSchema, TRelations, TSchema>) => Promise<T>,\n\t): Promise<T> {\n\t\tconst savepointName = `sp${this.nestedIndex}`;\n\t\tconst tx = new LibSQLTransaction(\n\t\t\t'async',\n\t\t\tthis.dialect,\n\t\t\tthis.session,\n\t\t\tthis.relations,\n\t\t\tthis.schema,\n\t\t\tthis.nestedIndex + 1,\n\t\t);\n\t\tawait this.session.run(sql.raw(`savepoint ${savepointName}`));\n\t\ttry {\n\t\t\tconst result = await transaction(tx);\n\t\t\tawait this.session.run(sql.raw(`release savepoint ${savepointName}`));\n\t\t\treturn result;\n\t\t} catch (err) {\n\t\t\tawait this.session.run(sql.raw(`rollback to savepoint ${savepointName}`));\n\t\t\tthrow err;\n\t\t}\n\t}\n}\n\nexport class LibSQLPreparedQuery<T extends PreparedQueryConfig = PreparedQueryConfig, TIsRqbV2 extends boolean = false>\n\textends SQLitePreparedQuery<\n\t\t{ type: 'async'; run: ResultSet; all: T['all']; get: T['get']; values: T['values']; execute: T['execute'] }\n\t>\n{\n\tstatic override readonly [entityKind]: string = 'LibSQLPreparedQuery';\n\n\tconstructor(\n\t\tprivate client: Client,\n\t\tquery: Query,\n\t\tprivate logger: Logger,\n\t\tcache: Cache,\n\t\tqueryMetadata: {\n\t\t\ttype: 'select' | 'update' | 'delete' | 'insert';\n\t\t\ttables: string[];\n\t\t} | undefined,\n\t\tcacheConfig: WithCacheConfig | undefined,\n\t\t/** @internal */ public fields: SelectedFieldsOrdered | undefined,\n\t\tprivate tx: Transaction | undefined,\n\t\texecuteMethod: SQLiteExecuteMethod,\n\t\tprivate _isResponseInArrayMode: boolean,\n\t\tprivate customResultMapper?: (\n\t\t\trows: TIsRqbV2 extends true ? Record<string, unknown>[] : unknown[][],\n\t\t\tmapColumnValue?: (value: unknown) => unknown,\n\t\t) => unknown,\n\t\tprivate isRqbV2Query?: TIsRqbV2,\n\t) {\n\t\tsuper('async', executeMethod, query, cache, queryMetadata, cacheConfig);\n\t}\n\n\tasync run(placeholderValues?: Record<string, unknown>): Promise<ResultSet> {\n\t\tconst params = fillPlaceholders(this.query.params, placeholderValues ?? {});\n\t\tthis.logger.logQuery(this.query.sql, params);\n\t\treturn await this.queryWithCache(this.query.sql, params, async () => {\n\t\t\tconst stmt: InStatement = { sql: this.query.sql, args: params as InArgs };\n\t\t\treturn this.tx ? this.tx.execute(stmt) : this.client.execute(stmt);\n\t\t});\n\t}\n\n\tasync all(placeholderValues?: Record<string, unknown>): Promise<T['all']> {\n\t\tif (this.isRqbV2Query) return this.allRqbV2(placeholderValues);\n\n\t\tconst { fields, logger, query, tx, client, customResultMapper } = this;\n\t\tif (!fields && !customResultMapper) {\n\t\t\tconst params = fillPlaceholders(query.params, placeholderValues ?? {});\n\t\t\tlogger.logQuery(query.sql, params);\n\t\t\treturn await this.queryWithCache(query.sql, params, async () => {\n\t\t\t\tconst stmt: InStatement = { sql: query.sql, args: params as InArgs };\n\t\t\t\treturn (tx ? tx.execute(stmt) : client.execute(stmt)).then(({ rows }) => this.mapAllResult(rows));\n\t\t\t});\n\t\t}\n\n\t\tconst rows = await this.values(placeholderValues) as unknown[][];\n\n\t\treturn this.mapAllResult(rows);\n\t}\n\n\tprivate async allRqbV2(placeholderValues?: Record<string, unknown>): Promise<T['all']> {\n\t\tconst { logger, query, tx, client, customResultMapper } = this;\n\n\t\tconst params = fillPlaceholders(query.params, placeholderValues ?? {});\n\t\tlogger.logQuery(query.sql, params);\n\t\tconst stmt: InStatement = { sql: query.sql, args: params as InArgs };\n\n\t\tconst rows = await (tx ?? client).execute(stmt).then(({ rows }) => rows.map((row) => normalizeRow(row)));\n\n\t\treturn (customResultMapper as (\n\t\t\trows: Record<string, unknown>[],\n\t\t\tmapColumnValue?: (value: unknown) => unknown,\n\t\t) => unknown)(rows as Record<string, unknown>[], normalizeFieldValue) as T['all'];\n\t}\n\n\toverride mapAllResult(rows: unknown, isFromBatch?: boolean): unknown {\n\t\tif (isFromBatch) {\n\t\t\trows = (rows as ResultSet).rows;\n\t\t}\n\n\t\tif (!this.fields && !this.customResultMapper) {\n\t\t\treturn (rows as unknown[]).map((row) => normalizeRow(row));\n\t\t}\n\n\t\tif (this.customResultMapper) {\n\t\t\treturn (this.customResultMapper as (\n\t\t\t\trows: unknown[][],\n\t\t\t\tmapColumnValue?: (value: unknown) => unknown,\n\t\t\t) => unknown)(rows as unknown[][], normalizeFieldValue) as T['all'];\n\t\t}\n\n\t\treturn (rows as unknown[]).map((row) => {\n\t\t\treturn mapResultRow(\n\t\t\t\tthis.fields!,\n\t\t\t\tArray.prototype.slice.call(row).map((v) => normalizeFieldValue(v)),\n\t\t\t\tthis.joinsNotNullableMap,\n\t\t\t);\n\t\t});\n\t}\n\n\tasync get(placeholderValues?: Record<string, unknown>): Promise<T['get']> {\n\t\tif (this.isRqbV2Query) return this.getRqbV2(placeholderValues);\n\n\t\tconst { fields, logger, query, tx, client, customResultMapper } = this;\n\t\tif (!fields && !customResultMapper) {\n\t\t\tconst params = fillPlaceholders(query.params, placeholderValues ?? {});\n\t\t\tlogger.logQuery(query.sql, params);\n\t\t\treturn await this.queryWithCache(query.sql, params, async () => {\n\t\t\t\tconst stmt: InStatement = { sql: query.sql, args: params as InArgs };\n\t\t\t\treturn (tx ? tx.execute(stmt) : client.execute(stmt)).then(({ rows }) => this.mapGetResult(rows));\n\t\t\t});\n\t\t}\n\n\t\tconst rows = await this.values(placeholderValues) as unknown[][];\n\n\t\treturn this.mapGetResult(rows);\n\t}\n\n\tprivate async getRqbV2(placeholderValues?: Record<string, unknown>) {\n\t\tconst { logger, query, tx, client, customResultMapper } = this;\n\n\t\tconst params = fillPlaceholders(query.params, placeholderValues ?? {});\n\t\tlogger.logQuery(query.sql, params);\n\t\tconst stmt: InStatement = { sql: query.sql, args: params as InArgs };\n\n\t\tconst { rows } = await (tx ?? client).execute(stmt);\n\t\tif (rows[0] === undefined) return;\n\n\t\tconst row = normalizeRow((rows as unknown[])[0]);\n\n\t\treturn (customResultMapper as (\n\t\t\trows: Record<string, unknown>[],\n\t\t\tmapColumnValue?: (value: unknown) => unknown,\n\t\t) => unknown)([row] as Record<string, unknown>[], normalizeFieldValue) as T['get'];\n\t}\n\n\toverride mapGetResult(rows: unknown, isFromBatch?: boolean): unknown {\n\t\tif (isFromBatch) {\n\t\t\trows = (rows as ResultSet).rows;\n\t\t}\n\n\t\tconst row = (rows as unknown[])[0];\n\n\t\tif (!this.fields && !this.customResultMapper) {\n\t\t\treturn normalizeRow(row);\n\t\t}\n\n\t\tif (!row) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\tif (this.customResultMapper) {\n\t\t\treturn (this.customResultMapper as (\n\t\t\t\trows: unknown[][],\n\t\t\t\tmapColumnValue?: (value: unknown) => unknown,\n\t\t\t) => unknown)(rows as unknown[][], normalizeFieldValue) as T['get'];\n\t\t}\n\n\t\treturn mapResultRow(\n\t\t\tthis.fields!,\n\t\t\tArray.prototype.slice.call(row).map((v) => normalizeFieldValue(v)),\n\t\t\tthis.joinsNotNullableMap,\n\t\t);\n\t}\n\n\tasync values(placeholderValues?: Record<string, unknown>): Promise<T['values']> {\n\t\tconst params = fillPlaceholders(this.query.params, placeholderValues ?? {});\n\t\tthis.logger.logQuery(this.query.sql, params);\n\t\treturn await this.queryWithCache(this.query.sql, params, async () => {\n\t\t\tconst stmt: InStatement = { sql: this.query.sql, args: params as InArgs };\n\t\t\treturn (this.tx ? this.tx.execute(stmt) : this.client.execute(stmt)).then(({ rows }) => rows) as Promise<\n\t\t\t\tT['values']\n\t\t\t>;\n\t\t});\n\t}\n\n\t/** @internal */\n\tisResponseInArrayMode(): boolean {\n\t\treturn this._isResponseInArrayMode;\n\t}\n}\n\nfunction normalizeRow(obj: any) {\n\t// The libSQL node-sqlite3 compatibility wrapper returns rows\n\t// that can be accessed both as objects and arrays. Let's\n\t// turn them into objects what's what other SQLite drivers\n\t// do.\n\treturn Object.keys(obj).reduce((acc: Record<string, any>, key) => {\n\t\tif (Object.prototype.propertyIsEnumerable.call(obj, key)) {\n\t\t\tacc[key] = obj[key];\n\t\t}\n\t\treturn acc;\n\t}, {});\n}\n\nfunction normalizeFieldValue(value: unknown) {\n\tif (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) { // oxlint-disable-line drizzle-internal/no-instanceof\n\t\tif (typeof Buffer !== 'undefined') {\n\t\t\tif (!(value instanceof Buffer)) { // oxlint-disable-line drizzle-internal/no-instanceof\n\t\t\t\treturn Buffer.from(value);\n\t\t\t}\n\t\t\treturn value;\n\t\t}\n\t\tif (typeof TextDecoder !== 'undefined') {\n\t\t\treturn new TextDecoder().decode(value);\n\t\t}\n\t\tthrow new Error('TextDecoder is not available. Please provide either Buffer or TextDecoder polyfill.');\n\t}\n\treturn value;\n}\n"],"mappings":"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"}