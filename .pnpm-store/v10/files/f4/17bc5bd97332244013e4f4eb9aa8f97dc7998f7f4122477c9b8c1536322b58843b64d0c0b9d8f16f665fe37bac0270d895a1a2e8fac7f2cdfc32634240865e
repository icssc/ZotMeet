const require_ddl = require('./ddl-SsGc2gVn.js');
const require_utils = require('./utils-D2E5ChQ0.js');
const require_grammar = require('./grammar-B2XVJ90y.js');

//#region src/utils/node-assert/deep-strict-equal.ts
var AssertionError = class extends Error {
	actual;
	expected;
	operator;
	constructor(options) {
		super(options.message || `${JSON.stringify(options.actual)} ${options.operator} ${JSON.stringify(options.expected)}`);
		this.name = "AssertionError";
		this.actual = options.actual;
		this.expected = options.expected;
		this.operator = options.operator;
	}
};
function deepStrictEqualInternal(actual, expected) {
	if (actual === expected) return true;
	if (actual === null || expected === null) return false;
	if (typeof actual !== "object" || typeof expected !== "object") return false;
	if (Array.isArray(actual) && Array.isArray(expected)) {
		if (actual.length !== expected.length) return false;
		for (let i = 0; i < actual.length; i++) if (!deepStrictEqualInternal(actual[i], expected[i])) return false;
		return true;
	}
	if (Array.isArray(actual) !== Array.isArray(expected)) return false;
	const actualObj = actual;
	const expectedObj = expected;
	const actualKeys = Object.keys(actualObj);
	const expectedKeys = Object.keys(expectedObj);
	if (actualKeys.length !== expectedKeys.length) return false;
	for (const key of actualKeys) {
		if (!Object.prototype.hasOwnProperty.call(expectedObj, key)) return false;
		if (!deepStrictEqualInternal(actualObj[key], expectedObj[key])) return false;
	}
	return true;
}
/**
* Tests for deep strict equality between two JSON-compatible values.
* Supports: objects, arrays, strings, numbers, booleans, null.
*
* @param actual - The actual value to test
* @param expected - The expected value
* @param message - Optional message for the assertion error
* @throws {AssertionError} If actual and expected are not deeply strictly equal
*/
function deepStrictEqual(actual, expected, message) {
	if (!deepStrictEqualInternal(actual, expected)) {
		if (message instanceof Error) throw message;
		throw new AssertionError({
			message: message || `Expected values to be strictly deep-equal`,
			actual,
			expected,
			operator: "deepStrictEqual"
		});
	}
}

//#endregion
//#region src/utils/sequence-matcher.ts
/**
* A sequence matcher for string arrays that finds differences
* and tracks positions of added elements.
*/
function diffStringArrays(oldArr, newArr) {
	return formatResult(getOpcodes(oldArr, newArr), oldArr, newArr);
}
/**
* Get edit operations between two arrays
*/
function getOpcodes(oldArray, newArray) {
	const matchingBlocks = getMatchingBlocks(oldArray, newArray);
	const opcodes = [];
	let oldIndex = 0;
	let newIndex = 0;
	for (const [oldBlockStart, newBlockStart, matchLength] of matchingBlocks) {
		if (oldIndex < oldBlockStart || newIndex < newBlockStart) {
			const tag = oldIndex < oldBlockStart && newIndex < newBlockStart ? "replace" : oldIndex < oldBlockStart ? "delete" : "insert";
			opcodes.push([
				tag,
				oldIndex,
				oldBlockStart,
				newIndex,
				newBlockStart
			]);
		}
		if (matchLength > 0) opcodes.push([
			"equal",
			oldBlockStart,
			oldBlockStart + matchLength,
			newBlockStart,
			newBlockStart + matchLength
		]);
		oldIndex = oldBlockStart + matchLength;
		newIndex = newBlockStart + matchLength;
	}
	return opcodes;
}
/**
* Get matching blocks between two arrays
*/
function getMatchingBlocks(oldArray, newArray) {
	if (oldArray.length === 0 && newArray.length === 0) return [[
		0,
		0,
		0
	]];
	const matchQueue = [[
		0,
		oldArray.length,
		0,
		newArray.length
	]];
	const matches = [];
	while (matchQueue.length > 0) {
		const [oldStart, oldEnd, newStart, newEnd] = matchQueue.pop();
		const [oldMatchStart, newMatchStart, matchLength] = findLongestMatch(oldArray, newArray, oldStart, oldEnd, newStart, newEnd);
		if (matchLength > 0) {
			matches.push([
				oldMatchStart,
				newMatchStart,
				matchLength
			]);
			if (oldStart < oldMatchStart && newStart < newMatchStart) matchQueue.push([
				oldStart,
				oldMatchStart,
				newStart,
				newMatchStart
			]);
			if (oldMatchStart + matchLength < oldEnd && newMatchStart + matchLength < newEnd) matchQueue.push([
				oldMatchStart + matchLength,
				oldEnd,
				newMatchStart + matchLength,
				newEnd
			]);
		}
	}
	matches.sort((a, b) => a[0] - b[0]);
	matches.push([
		oldArray.length,
		newArray.length,
		0
	]);
	return matches;
}
/**
* Find the longest matching block in oldArray[oldStart:oldEnd] and newArray[newStart:newEnd]
*/
function findLongestMatch(oldArray, newArray, oldStart, oldEnd, newStart, newEnd) {
	let bestOldStart = oldStart;
	let bestNewStart = newStart;
	let bestMatchLength = 0;
	const newElementPositions = /* @__PURE__ */ new Map();
	for (let newIndex = newStart; newIndex < newEnd; newIndex++) {
		const element = newArray[newIndex];
		if (!newElementPositions.has(element)) newElementPositions.set(element, []);
		newElementPositions.get(element).push(newIndex);
	}
	for (let oldIndex = oldStart; oldIndex < oldEnd; oldIndex++) {
		const element = oldArray[oldIndex];
		if (!newElementPositions.has(element)) continue;
		for (const newIndex of newElementPositions.get(element)) {
			if (newIndex >= newEnd) continue;
			let currentMatchLength = 1;
			while (oldIndex + currentMatchLength < oldEnd && newIndex + currentMatchLength < newEnd && oldArray[oldIndex + currentMatchLength] === newArray[newIndex + currentMatchLength]) currentMatchLength++;
			if (currentMatchLength > bestMatchLength) {
				bestOldStart = oldIndex;
				bestNewStart = newIndex;
				bestMatchLength = currentMatchLength;
			}
		}
	}
	return [
		bestOldStart,
		bestNewStart,
		bestMatchLength
	];
}
/**
* Format the opcodes into the requested result format
*/
function formatResult(opcodes, oldArray, newArray) {
	const result = [];
	for (const [tag, oldStart, oldEnd, newStart, newEnd] of opcodes) {
		if (tag === "equal") {
			for (let oldIndex = oldStart; oldIndex < oldEnd; oldIndex++) result.push({
				type: "same",
				value: oldArray[oldIndex]
			});
			continue;
		}
		if (tag === "delete") {
			for (let oldIndex = oldStart; oldIndex < oldEnd; oldIndex++) result.push({
				type: "removed",
				value: oldArray[oldIndex]
			});
			continue;
		}
		if (tag === "insert") {
			for (let newIndex = newStart; newIndex < newEnd; newIndex++) addWithPosition(newArray[newIndex], newIndex, newArray, oldArray, result);
			continue;
		}
		if (tag === "replace") {
			for (let oldIndex = oldStart; oldIndex < oldEnd; oldIndex++) result.push({
				type: "removed",
				value: oldArray[oldIndex]
			});
			for (let newIndex = newStart; newIndex < newEnd; newIndex++) addWithPosition(newArray[newIndex], newIndex, newArray, oldArray, result);
			continue;
		}
	}
	return result;
}
/**
* Helper function to add an element with position information
*/
function addWithPosition(value, currentIndex, newArray, oldElementSet, result) {
	let beforeValue = void 0;
	for (let lookAheadIndex = currentIndex + 1; lookAheadIndex < newArray.length; lookAheadIndex++) if (oldElementSet.indexOf(newArray[lookAheadIndex]) >= 0) {
		beforeValue = newArray[lookAheadIndex];
		break;
	}
	result.push({
		type: "added",
		value,
		beforeValue
	});
}

//#endregion
//#region src/dialects/postgres/convertor.ts
const convertor = (type, convertor$1) => {
	return {
		type,
		can: (st) => {
			return st.type === type;
		},
		convert: convertor$1
	};
};
const createSchemaConvertor = convertor("create_schema", (st) => {
	return `CREATE SCHEMA "${st.name}";\n`;
});
const dropSchemaConvertor = convertor("drop_schema", (st) => {
	return `DROP SCHEMA "${st.name}";\n`;
});
const renameSchemaConvertor = convertor("rename_schema", (st) => {
	return `ALTER SCHEMA "${st.from.name}" RENAME TO "${st.to.name}";\n`;
});
const createViewConvertor = convertor("create_view", (st) => {
	const { definition, name: viewName, schema, with: withOption, materialized, withNoData, tablespace, using } = st.view;
	const name = schema !== "public" ? `"${schema}"."${viewName}"` : `"${viewName}"`;
	let statement = materialized ? `CREATE MATERIALIZED VIEW ${name}` : `CREATE VIEW ${name}`;
	if (using) statement += ` USING "${using}"`;
	const options = [];
	if (withOption) {
		statement += ` WITH (`;
		for (const [key, value] of Object.entries(withOption)) {
			if (value === null) continue;
			options.push(`${key.snake_case()} = ${value}`);
		}
		statement += options.join(", ");
		statement += `)`;
	}
	if (tablespace) statement += ` TABLESPACE ${tablespace}`;
	statement += ` AS (${definition})`;
	if (withNoData) statement += ` WITH NO DATA`;
	statement += `;`;
	return statement;
});
const dropViewConvertor = convertor("drop_view", (st) => {
	const { name: viewName, schema, materialized } = st.view;
	const name = schema !== "public" ? `"${schema}"."${viewName}"` : `"${viewName}"`;
	return `DROP${materialized ? " MATERIALIZED" : ""} VIEW ${name};`;
});
const renameViewConvertor = convertor("rename_view", (st) => {
	const materialized = st.from.materialized;
	const nameFrom = st.from.schema !== "public" ? `"${st.from.schema}"."${st.from.name}"` : `"${st.from.name}"`;
	return `ALTER${materialized ? " MATERIALIZED" : ""} VIEW ${nameFrom} RENAME TO "${st.to.name}";`;
});
const moveViewConvertor = convertor("move_view", (st) => {
	const { fromSchema, toSchema, view } = st;
	const from = fromSchema === "public" ? `"${view.name}"` : `"${fromSchema}"."${view.name}"`;
	return `ALTER${view.materialized ? " MATERIALIZED" : ""} VIEW ${from} SET SCHEMA "${toSchema}";`;
});
const alterViewConvertor = convertor("alter_view", (st) => {
	const diff$1 = st.diff;
	const statements = [];
	const key = st.view.schema !== "public" ? `"${st.view.schema}"."${st.view.name}"` : `"${st.view.name}"`;
	const viewClause = st.view.materialized ? `MATERIALIZED VIEW ${key}` : `VIEW ${key}`;
	const withFrom = diff$1.with?.from || {};
	const withTo = diff$1.with?.to || {};
	const resetOptions = Object.entries(withFrom).filter(([key$1, val]) => {
		return val !== null && (key$1 in withTo ? withTo[key$1] === null : true);
	}).map((it) => it[0].snake_case());
	const setOptions = Object.entries(withTo).filter(([key$1, val]) => {
		const from = key$1 in withFrom ? withFrom[key$1] : null;
		return val !== null && from !== val;
	}).map((it) => `${it[0].snake_case()} = ${it[1]}`).join(", ");
	if (setOptions.length > 0) statements.push(`ALTER ${viewClause} SET (${setOptions});`);
	if (resetOptions.length > 0) statements.push(`ALTER ${viewClause} RESET (${resetOptions.join(", ")});`);
	if (diff$1.tablespace) {
		const to = diff$1.tablespace.to || require_grammar.defaults.tablespace;
		statements.push(`ALTER ${viewClause} SET TABLESPACE "${to}";`);
	}
	if (diff$1.using) {
		const toUsing = diff$1.using.to ?? require_grammar.defaults.accessMethod;
		statements.push(`ALTER ${viewClause} SET ACCESS METHOD "${toUsing}";`);
	}
	return statements;
});
const createTableConvertor = convertor("create_table", (st) => {
	const { schema, name, columns, pk, uniques, checks, policies, isRlsEnabled } = st.table;
	const statements = [];
	let statement = "";
	const key = schema !== "public" ? `"${schema}"."${name}"` : `"${name}"`;
	statement += `CREATE TABLE ${key} (\n`;
	for (let i = 0; i < columns.length; i++) {
		const column = columns[i];
		const isPK = pk && pk.columns.length === 1 && pk.columns[0] === column.name && pk.name === require_grammar.defaultNameForPK(column.table);
		const isSerial = require_grammar.isSerialType(column.type);
		const primaryKeyStatement = isPK ? " PRIMARY KEY" : "";
		const notNullStatement = pk?.columns.includes(column.name) || isSerial ? "" : column.notNull && !column.identity ? " NOT NULL" : "";
		const defaultStatement = column.default ? ` DEFAULT ${require_grammar.defaultToSQL(column)}` : "";
		const unique = uniques.find((u) => u.columns.length === 1 && u.columns[0] === column.name);
		const unqiueConstraintPrefix = unique ? unique.nameExplicit ? `CONSTRAINT "${unique.name}" UNIQUE` : "UNIQUE" : "";
		const uniqueConstraintStatement = unique ? ` ${unqiueConstraintPrefix}${unique.nullsNotDistinct ? " NULLS NOT DISTINCT" : ""}` : "";
		const type = `${column.typeSchema && column.typeSchema !== "public" ? `"${column.typeSchema}".` : ""}${column.typeSchema ? `"${column.type}"` : column.type}${"[]".repeat(column.dimensions)}`;
		const generated = column.generated;
		const generatedStatement = generated ? ` GENERATED ALWAYS AS (${generated?.as}) STORED` : "";
		const identityWithSchema = schema !== "public" ? `"${schema}"."${column.identity?.name}"` : `"${column.identity?.name}"`;
		const identity = column.identity ? ` GENERATED ${column.identity.type === "always" ? "ALWAYS" : "BY DEFAULT"} AS IDENTITY (sequence name ${identityWithSchema}${column.identity.increment ? ` INCREMENT BY ${column.identity.increment}` : ""}${column.identity.minValue ? ` MINVALUE ${column.identity.minValue}` : ""}${column.identity.maxValue ? ` MAXVALUE ${column.identity.maxValue}` : ""}${column.identity.startWith ? ` START WITH ${column.identity.startWith}` : ""}${column.identity.cache ? ` CACHE ${column.identity.cache}` : ""}${column.identity.cycle ? ` CYCLE` : ""})` : "";
		statement += `	"${column.name}" ${type}${primaryKeyStatement}${defaultStatement}${generatedStatement}${notNullStatement}${uniqueConstraintStatement}${identity}`;
		statement += i === columns.length - 1 ? "" : ",\n";
	}
	if (pk && (pk.columns.length > 1 || pk.name !== require_grammar.defaultNameForPK(st.table.name))) {
		statement += ",\n";
		statement += `\tCONSTRAINT "${pk.name}" PRIMARY KEY("${pk.columns.join(`","`)}")`;
	}
	for (const it of uniques.filter((u) => u.columns.length > 1)) {
		statement += ",\n";
		statement += `\tCONSTRAINT "${it.name}" UNIQUE${it.nullsNotDistinct ? " NULLS NOT DISTINCT" : ""}("${it.columns.join(`","`)}")`;
	}
	for (const check of checks) {
		statement += ",\n";
		statement += `\tCONSTRAINT "${check.name}" CHECK (${check.value})`;
	}
	statement += `\n);`;
	statement += `\n`;
	statements.push(statement);
	if (policies && policies.length > 0 || isRlsEnabled) statements.push(toggleRlsConvertor.convert({
		isRlsEnabled: true,
		name: st.table.name,
		schema: st.table.schema
	}));
	return statements;
});
const dropTableConvertor = convertor("drop_table", (st) => {
	const { name, schema, policies } = st.table;
	const tableNameWithSchema = schema !== "public" ? `"${schema}"."${name}"` : `"${name}"`;
	return [...policies.map((policy) => dropPolicyConvertor.convert({ policy })), `DROP TABLE ${tableNameWithSchema};`];
});
const renameTableConvertor = convertor("rename_table", (st) => {
	return `ALTER TABLE ${st.schema !== "public" ? `"${st.schema}".` : ""}"${st.from}" RENAME TO "${st.to}";`;
});
const moveTableConvertor = convertor("move_table", (st) => {
	return `ALTER TABLE ${st.from !== "public" ? `"${st.from}"."${st.name}"` : `"${st.name}"`} SET SCHEMA "${st.to}";\n`;
});
const addColumnConvertor = convertor("add_column", (st) => {
	const { schema, table, name, identity, generated } = st.column;
	const column = st.column;
	const primaryKeyStatement = st.isPK ? " PRIMARY KEY" : "";
	const tableNameWithSchema = schema !== "public" ? `"${schema}"."${table}"` : `"${table}"`;
	const defaultStatement = column.default ? ` DEFAULT ${require_grammar.defaultToSQL(column)}` : "";
	let fixedType = `${column.typeSchema && column.typeSchema !== "public" ? `"${column.typeSchema}".` : ""}${column.typeSchema ? `"${column.type}"` : column.type}${"[]".repeat(column.dimensions)}`;
	const isSerial = require_grammar.isSerialType(column.type);
	const notNullStatement = column.notNull && !identity && !generated && !isSerial && !st.isCompositePK ? " NOT NULL" : "";
	const identityWithSchema = schema !== "public" ? `"${schema}"."${identity?.name}"` : `"${identity?.name}"`;
	const identityStatement = identity ? ` GENERATED ${identity.type === "always" ? "ALWAYS" : "BY DEFAULT"} AS IDENTITY (sequence name ${identityWithSchema}${identity.increment ? ` INCREMENT BY ${identity.increment}` : ""}${identity.minValue ? ` MINVALUE ${identity.minValue}` : ""}${identity.maxValue ? ` MAXVALUE ${identity.maxValue}` : ""}${identity.startWith ? ` START WITH ${identity.startWith}` : ""}${identity.cache ? ` CACHE ${identity.cache}` : ""}${identity.cycle ? ` CYCLE` : ""})` : "";
	return `ALTER TABLE ${tableNameWithSchema} ADD COLUMN "${name}" ${fixedType}${primaryKeyStatement}${defaultStatement}${column.generated ? ` GENERATED ALWAYS AS (${column.generated.as}) STORED` : ""}${notNullStatement}${identityStatement};`;
});
const dropColumnConvertor = convertor("drop_column", (st) => {
	const { schema, table, name } = st.column;
	return `ALTER TABLE ${schema !== "public" ? `"${schema}"."${table}"` : `"${table}"`} DROP COLUMN "${name}";`;
});
const renameColumnConvertor = convertor("rename_column", (st) => {
	const { table, schema } = st.from;
	return `ALTER TABLE ${schema !== "public" ? `"${schema}"."${table}"` : `"${table}"`} RENAME COLUMN "${st.from.name}" TO "${st.to.name}";`;
});
const recreateColumnConvertor = convertor("recreate_column", (st) => {
	const r = st.diff.$right;
	return [dropColumnConvertor.convert({ column: r }), addColumnConvertor.convert({
		column: r,
		isPK: st.isPK,
		isCompositePK: false
	})];
});
const recreateIndexConvertor = convertor("recreate_index", (st) => {
	return [dropIndexConvertor.convert({ index: st.index }), createIndexConvertor.convert({ index: st.index })];
});
const alterColumnConvertor = convertor("alter_column", (st) => {
	const { diff: diff$1, to: column, isEnum, wasEnum, wasSerial, toSerial } = st;
	const statements = [];
	const key = column.schema !== "public" ? `"${column.schema}"."${column.table}"` : `"${column.table}"`;
	const recreateDefault = diff$1.type && (isEnum || wasEnum) && diff$1.$left.default;
	if (recreateDefault) statements.push(`ALTER TABLE ${key} ALTER COLUMN "${column.name}" DROP DEFAULT;`);
	if (diff$1.type) {
		const typeSchema = column.typeSchema && column.typeSchema !== "public" ? `"${column.typeSchema}".` : "";
		const textProxy = wasEnum && isEnum ? "text::" : "";
		const suffix = isEnum ? ` USING "${column.name}"::${textProxy}${typeSchema}"${column.type}"${"[]".repeat(column.dimensions)}` : ` USING "${column.name}"::${toSerial ? require_grammar.mapSerialToInt(column.type) : column.type}${"[]".repeat(column.dimensions)}`;
		const type = diff$1.typeSchema?.to && diff$1.typeSchema.to !== "public" ? `"${diff$1.typeSchema.to}"."${diff$1.type.to}"` : isEnum ? `"${diff$1.type.to}"` : toSerial ? require_grammar.mapSerialToInt(diff$1.type.to) : diff$1.type.to;
		if (wasSerial) {
			statements.push(`ALTER TABLE ${key} ALTER COLUMN "${column.name}" DROP DEFAULT;`);
			const sequenceKey = column.schema !== "public" ? `"${column.schema}"."${column.table}_${column.name}_seq"` : `"${column.table}_${column.name}_seq"`;
			statements.push(`DROP SEQUENCE ${sequenceKey};`);
		}
		if (toSerial) {
			const sequenceKey = column.schema !== "public" ? `"${column.schema}"."${column.table}_${column.name}_seq"` : `"${column.table}_${column.name}_seq"`;
			const sequenceName = column.schema !== "public" ? `${column.schema}.${column.table}_${column.name}_seq` : `${column.table}_${column.name}_seq`;
			statements.push(`CREATE SEQUENCE ${sequenceKey};`);
			statements.push(`ALTER TABLE ${key} ALTER COLUMN "${column.name}" SET DEFAULT nextval('${sequenceName}')`);
			statements.push(`ALTER SEQUENCE ${sequenceKey} OWNED BY "${column.schema}"."${column.table}"."${column.name}";`);
		}
		statements.push(`ALTER TABLE ${key} ALTER COLUMN "${column.name}" SET DATA TYPE ${type}${"[]".repeat(column.dimensions)}${suffix};`);
		if (recreateDefault && column.default) statements.push(`ALTER TABLE ${key} ALTER COLUMN "${column.name}" SET DEFAULT ${require_grammar.defaultToSQL(column)};`);
	}
	if (diff$1.default && !recreateDefault) if (diff$1.default.to) statements.push(`ALTER TABLE ${key} ALTER COLUMN "${column.name}" SET DEFAULT ${require_grammar.defaultToSQL(diff$1.$right)};`);
	else statements.push(`ALTER TABLE ${key} ALTER COLUMN "${column.name}" DROP DEFAULT;`);
	if (diff$1.generated && diff$1.generated.to === null) statements.push(`ALTER TABLE ${key} ALTER COLUMN "${column.name}" DROP EXPRESSION;`);
	if (diff$1.identity) if (diff$1.identity.from === null) {
		const identity = column.identity;
		const identityWithSchema = column.schema !== "public" ? `"${column.schema}"."${identity.name}"` : `"${identity.name}"`;
		const identityStatement = `GENERATED ${identity.type === "always" ? "ALWAYS" : "BY DEFAULT"} AS IDENTITY (sequence name ${identityWithSchema}${identity.increment ? ` INCREMENT BY ${identity.increment}` : ""}${identity.minValue ? ` MINVALUE ${identity.minValue}` : ""}${identity.maxValue ? ` MAXVALUE ${identity.maxValue}` : ""}${identity.startWith ? ` START WITH ${identity.startWith}` : ""}${identity.cache ? ` CACHE ${identity.cache}` : ""}${identity.cycle ? ` CYCLE` : ""})`;
		statements.push(`ALTER TABLE ${key} ALTER COLUMN "${column.name}" ADD ${identityStatement};`);
		if (wasSerial && column.identity) statements.push(`SELECT setval('${column.identity.name}'::regclass, (SELECT COALESCE(MAX(id), 1) FROM ${key}), false);`);
	} else if (diff$1.identity.to === null) statements.push(`ALTER TABLE ${key} ALTER COLUMN "${column.name}" DROP IDENTITY;`);
	else {
		const { from, to } = diff$1.identity;
		if (from.type !== to.type) {
			const typeClause = to.type === "always" ? "ALWAYS" : "BY DEFAULT";
			statements.push(`ALTER TABLE ${key} ALTER COLUMN "${column.name}" SET GENERATED ${typeClause};`);
		}
		if (from.minValue !== to.minValue) statements.push(`ALTER TABLE ${key} ALTER COLUMN "${column.name}" SET MINVALUE ${to.minValue};`);
		if (from.maxValue !== to.maxValue) statements.push(`ALTER TABLE ${key} ALTER COLUMN "${column.name}" SET MAXVALUE ${to.maxValue};`);
		if (from.increment !== to.increment) statements.push(`ALTER TABLE ${key} ALTER COLUMN "${column.name}" SET INCREMENT BY ${to.increment};`);
		if (from.startWith !== to.startWith) statements.push(`ALTER TABLE ${key} ALTER COLUMN "${column.name}" SET START WITH ${to.startWith};`);
		if (from.cache !== to.cache) statements.push(`ALTER TABLE ${key} ALTER COLUMN "${column.name}" SET CACHE ${to.cache};`);
		if (from.cycle !== to.cycle) statements.push(`ALTER TABLE ${key} ALTER COLUMN "${column.name}" SET ${to.cycle ? `CYCLE` : "NO CYCLE"};`);
	}
	if (diff$1.notNull && !(diff$1.notNull.to && diff$1.identity && diff$1.identity.to)) {
		const clause = diff$1.notNull.to ? "SET NOT NULL" : "DROP NOT NULL";
		statements.push(`ALTER TABLE ${key} ALTER COLUMN "${column.name}" ${clause};`);
	}
	return statements;
});
const createIndexConvertor = convertor("create_index", (st) => {
	const { schema, table, name, columns, isUnique, concurrently, with: w, method, where } = st.index;
	const indexPart = isUnique ? "UNIQUE INDEX" : "INDEX";
	const value = columns.map((it) => {
		return `${it.isExpression ? it.value : `"${it.value}"`}${it.opclass && !it.opclass.default ? ` ${it.opclass.name}` : ""}${it.asc ? "" : " DESC"}${it.asc && !it.nullsFirst || !it.asc && it.nullsFirst ? "" : it.nullsFirst ? " NULLS FIRST" : " NULLS LAST"}`;
	}).join(",");
	const key = schema !== "public" ? `"${schema}"."${table}"` : `"${table}"`;
	const concur = concurrently ? " CONCURRENTLY" : "";
	const withClause = w ? ` WITH (${w})` : "";
	const whereClause = where ? ` WHERE ${where}` : "";
	return `CREATE ${indexPart}${concur} "${name}" ON ${key}${method !== require_grammar.defaults.index.method ? ` USING ${method}` : ""} (${value})${withClause}${whereClause};`;
});
const dropIndexConvertor = convertor("drop_index", (st) => {
	return `DROP INDEX "${st.index.name}";`;
});
const renameIndexConvertor = convertor("rename_index", (st) => {
	return `ALTER INDEX ${st.schema !== "public" ? `"${st.schema}"."${st.from}"` : `"${st.from}"`} RENAME TO "${st.to}";`;
});
const addPrimaryKeyConvertor = convertor("add_pk", (st) => {
	const { pk } = st;
	const key = pk.schema !== "public" ? `"${pk.schema}"."${pk.table}"` : `"${pk.table}"`;
	if (!pk.nameExplicit) return `ALTER TABLE ${key} ADD PRIMARY KEY ("${pk.columns.join("\",\"")}");`;
	return `ALTER TABLE ${key} ADD CONSTRAINT "${pk.name}" PRIMARY KEY("${pk.columns.join("\",\"")}");`;
});
const dropPrimaryKeyConvertor = convertor("drop_pk", (st) => {
	const pk = st.pk;
	return `ALTER TABLE ${pk.schema !== "public" ? `"${pk.schema}"."${pk.table}"` : `"${pk.table}"`} DROP CONSTRAINT "${pk.name}";`;
});
const recreatePrimaryKeyConvertor = convertor("alter_pk", (it) => {
	const st = [];
	if (!it.deleted) st.push(dropPrimaryKeyConvertor.convert({ pk: it.pk }));
	st.push(addPrimaryKeyConvertor.convert({ pk: it.pk }));
	return st;
});
const renameConstraintConvertor = convertor("rename_constraint", (st) => {
	return `ALTER TABLE ${st.schema !== "public" ? `"${st.schema}"."${st.table}"` : `"${st.table}"`} RENAME CONSTRAINT "${st.from}" TO "${st.to}";`;
});
const createForeignKeyConvertor = convertor("create_fk", (st) => {
	const { schema, table, name, tableTo, columns, columnsTo, onDelete, onUpdate, schemaTo } = st.fk;
	const onDeleteStatement = onDelete && !require_grammar.isDefaultAction(onDelete) ? ` ON DELETE ${onDelete}` : "";
	const onUpdateStatement = onUpdate && !require_grammar.isDefaultAction(onUpdate) ? ` ON UPDATE ${onUpdate}` : "";
	const fromColumnsString = columns.map((it) => `"${it}"`).join(",");
	const toColumnsString = columnsTo.map((it) => `"${it}"`).join(",");
	return `ALTER TABLE ${schema !== "public" ? `"${schema}"."${table}"` : `"${table}"`} ADD CONSTRAINT "${name}" FOREIGN KEY (${fromColumnsString}) REFERENCES ${schemaTo !== "public" ? `"${schemaTo}"."${tableTo}"` : `"${tableTo}"`}(${toColumnsString})${onDeleteStatement}${onUpdateStatement};`;
});
const recreateFKConvertor = convertor("recreate_fk", (st) => {
	const { fk } = st;
	const key = fk.schema !== "public" ? `"${fk.schema}"."${fk.table}"` : `"${fk.table}"`;
	const onDeleteStatement = fk.onDelete !== "NO ACTION" ? ` ON DELETE ${fk.onDelete}` : "";
	const onUpdateStatement = fk.onUpdate !== "NO ACTION" ? ` ON UPDATE ${fk.onUpdate}` : "";
	const fromColumnsString = fk.columns.map((it) => `"${it}"`).join(",");
	const toColumnsString = fk.columnsTo.map((it) => `"${it}"`).join(",");
	const tableToNameWithSchema = fk.schemaTo !== "public" ? `"${fk.schemaTo}"."${fk.tableTo}"` : `"${fk.tableTo}"`;
	let sql = `ALTER TABLE ${key} DROP CONSTRAINT "${fk.name}", `;
	sql += `ADD CONSTRAINT "${fk.name}" FOREIGN KEY (${fromColumnsString}) `;
	sql += `REFERENCES ${tableToNameWithSchema}(${toColumnsString})${onDeleteStatement}${onUpdateStatement};`;
	return sql;
});
const dropForeignKeyConvertor = convertor("drop_fk", (st) => {
	const { schema, table, name } = st.fk;
	return `ALTER TABLE ${schema !== "public" ? `"${schema}"."${table}"` : `"${table}"`} DROP CONSTRAINT "${name}";`;
});
const addCheckConvertor = convertor("add_check", (st) => {
	const { check } = st;
	return `ALTER TABLE ${check.schema !== "public" ? `"${check.schema}"."${check.table}"` : `"${check.table}"`} ADD CONSTRAINT "${check.name}" CHECK (${check.value});`;
});
const dropCheckConvertor = convertor("drop_check", (st) => {
	const { check } = st;
	return `ALTER TABLE ${check.schema !== "public" ? `"${check.schema}"."${check.table}"` : `"${check.table}"`} DROP CONSTRAINT "${check.name}";`;
});
const recreateCheckConvertor = convertor("alter_check", (st) => {
	const { diff: diff$1 } = st;
	const check = diff$1.$right;
	let sql = `ALTER TABLE ${check.schema !== "public" ? `"${check.schema}"."${check.table}"` : `"${check.table}"`} DROP CONSTRAINT "${check.name}", `;
	sql += `ADD CONSTRAINT "${check.name}" CHECK (${check.value});`;
	return sql;
});
const addUniqueConvertor = convertor("add_unique", (st) => {
	const { unique } = st;
	return `ALTER TABLE ${unique.schema !== "public" ? `"${unique.schema}"."${unique.table}"` : `"${unique.table}"`} ADD CONSTRAINT "${unique.name}" UNIQUE${unique.nullsNotDistinct ? " NULLS NOT DISTINCT" : ""}("${unique.columns.join("\",\"")}");`;
});
const dropUniqueConvertor = convertor("drop_unique", (st) => {
	const { unique } = st;
	return `ALTER TABLE ${unique.schema !== "public" ? `"${unique.schema}"."${unique.table}"` : `"${unique.table}"`} DROP CONSTRAINT "${unique.name}";`;
});
const createEnumConvertor = convertor("create_enum", (st) => {
	const { name, schema, values } = st.enum;
	const enumNameWithSchema = schema !== "public" ? `"${schema}"."${name}"` : `"${name}"`;
	let valuesStatement = "(";
	valuesStatement += values.map((it) => require_utils.wrapWith(it.replaceAll("'", "''"), "'")).join(", ");
	valuesStatement += ")";
	return `CREATE TYPE ${enumNameWithSchema} AS ENUM${valuesStatement};`;
});
const dropEnumConvertor = convertor("drop_enum", (st) => {
	const { name, schema } = st.enum;
	return `DROP TYPE ${schema !== "public" ? `"${schema}"."${name}"` : `"${name}"`};`;
});
const renameEnumConvertor = convertor("rename_enum", (st) => {
	return `ALTER TYPE ${st.schema !== "public" ? `"${st.schema}"."${st.from}"` : `"${st.from}"`} RENAME TO "${st.to}";`;
});
const moveEnumConvertor = convertor("move_enum", (st) => {
	const { from, to } = st;
	return `ALTER TYPE ${from.schema !== "public" ? `"${from.schema}"."${from.name}"` : `"${from.name}"`} SET SCHEMA "${to.schema || "public"}";`;
});
const alterEnumConvertor = convertor("alter_enum", (st) => {
	const { diff: diff$1, to: e } = st;
	const key = e.schema !== "public" ? `"${e.schema}"."${e.name}"` : `"${e.name}"`;
	const statements = [];
	for (const d of diff$1.filter((it) => it.type === "added")) if (d.beforeValue) statements.push(`ALTER TYPE ${key} ADD VALUE '${d.value}' BEFORE '${d.beforeValue}';`);
	else statements.push(`ALTER TYPE ${key} ADD VALUE '${d.value}';`);
	return statements;
});
const recreateEnumConvertor = convertor("recreate_enum", (st) => {
	const { to, columns } = st;
	const statements = [];
	for (const column of columns) {
		const key = column.schema !== "public" ? `"${column.schema}"."${column.table}"` : `"${column.table}"`;
		statements.push(`ALTER TABLE ${key} ALTER COLUMN "${column.name}" SET DATA TYPE text${"[]".repeat(column.dimensions)};`);
		if (column.default.left) statements.push(`ALTER TABLE ${key} ALTER COLUMN "${column.name}" DROP DEFAULT;`);
	}
	statements.push(dropEnumConvertor.convert({ enum: to }));
	statements.push(createEnumConvertor.convert({ enum: to }));
	for (const column of columns) {
		const key = column.schema !== "public" ? `"${column.schema}"."${column.table}"` : `"${column.table}"`;
		const enumType = to.schema !== "public" ? `"${to.schema}"."${to.name}"` : `"${to.name}"`;
		statements.push(`ALTER TABLE ${key} ALTER COLUMN "${column.name}" SET DATA TYPE ${enumType}${"[]".repeat(column.dimensions)} USING "${column.name}"::${enumType}${"[]".repeat(column.dimensions)};`);
		if (column.default.right) statements.push(`ALTER TABLE ${key} ALTER COLUMN "${column.name}" SET DEFAULT ${require_grammar.defaultToSQL({
			default: column.default.right,
			dimensions: column.dimensions,
			type: column.type,
			typeSchema: column.typeSchema
		})};`);
	}
	return statements;
});
const createSequenceConvertor = convertor("create_sequence", (st) => {
	const { name, schema, minValue, maxValue, incrementBy, startWith, cacheSize, cycle } = st.sequence;
	return `CREATE SEQUENCE ${schema ? `"${schema}"."${name}"` : `"${name}"`}${incrementBy ? ` INCREMENT BY ${incrementBy}` : ""}${minValue ? ` MINVALUE ${minValue}` : ""}${maxValue ? ` MAXVALUE ${maxValue}` : ""}${startWith ? ` START WITH ${startWith}` : ""}${cacheSize ? ` CACHE ${cacheSize}` : ""}${cycle ? ` CYCLE` : ""};`;
});
const dropSequenceConvertor = convertor("drop_sequence", (st) => {
	const { name, schema } = st.sequence;
	return `DROP SEQUENCE ${schema ? `"${schema}"."${name}"` : `"${name}"`};`;
});
const renameSequenceConvertor = convertor("rename_sequence", (st) => {
	return `ALTER SEQUENCE ${st.from.schema !== "public" ? `"${st.from.schema}"."${st.from.name}"` : `"${st.from.name}"`} RENAME TO "${st.to.name}";`;
});
const moveSequenceConvertor = convertor("move_sequence", (st) => {
	const { from, to } = st;
	return `ALTER SEQUENCE ${from.schema !== "public" ? `"${from.schema}"."${from.name}"` : `"${from.name}"`} SET SCHEMA ${`"${to.schema}"`};`;
});
const alterSequenceConvertor = convertor("alter_sequence", (st) => {
	const { schema, name, incrementBy, minValue, maxValue, startWith, cacheSize, cycle } = st.sequence;
	return `ALTER SEQUENCE ${schema !== "public" ? `"${schema}"."${name}"` : `"${name}"`}${incrementBy ? ` INCREMENT BY ${incrementBy}` : ""}${minValue ? ` MINVALUE ${minValue}` : ""}${maxValue ? ` MAXVALUE ${maxValue}` : ""}${startWith ? ` START WITH ${startWith}` : ""}${cacheSize ? ` CACHE ${cacheSize}` : ""}${cycle ? ` CYCLE` : ""};`;
});
const createRoleConvertor = convertor("create_role", (st) => {
	const { name, superuser, createDb, createRole, inherit, canLogin, replication, bypassRls, connLimit, password, validUntil } = st.role;
	return `CREATE ROLE "${name}"${superuser || createDb || createRole || !inherit || canLogin || replication || bypassRls || validUntil || typeof connLimit === "number" && connLimit !== -1 || password ? ` WITH${superuser ? " SUPERUSER" : ""}${createDb ? " CREATEDB" : ""}${createRole ? " CREATEROLE" : ""}${inherit ? "" : " NOINHERIT"}${canLogin ? " LOGIN" : ""}${replication ? " REPLICATION" : ""}${bypassRls ? " BYPASSRLS" : ""}${typeof connLimit === "number" && connLimit !== -1 ? ` CONNECTION LIMIT ${connLimit}` : ""}${password ? ` PASSWORD '${require_utils.escapeSingleQuotes(password)}'` : ""}${validUntil ? ` VALID UNTIL '${validUntil}'` : ""}` : ""};`;
});
const dropRoleConvertor = convertor("drop_role", (st) => {
	return `DROP ROLE "${st.role.name}";`;
});
const renameRoleConvertor = convertor("rename_role", (st) => {
	return `ALTER ROLE "${st.from.name}" RENAME TO "${st.to.name}";`;
});
const alterRoleConvertor = convertor("alter_role", ({ diff: diff$1, role }) => {
	const { name } = role;
	return `ALTER ROLE "${name}" WITH${diff$1.superuser ? diff$1.superuser.to ? " SUPERUSER" : " NOSUPERUSER" : ""}${diff$1.createDb ? diff$1.createDb.to ? " CREATEDB" : " NOCREATEDB" : ""}${diff$1.createRole ? diff$1.createRole.to ? " CREATEROLE" : " NOCREATEROLE" : ""}${diff$1.inherit ? diff$1.inherit.to ? " INHERIT" : " NOINHERIT" : ""}${diff$1.canLogin ? diff$1.canLogin.to ? " LOGIN" : " NOLOGIN" : ""}${diff$1.replication ? diff$1.replication.to ? " REPLICATION" : " NOREPLICATION" : ""}${diff$1.bypassRls ? diff$1.bypassRls.to ? " BYPASSRLS" : " NOBYPASSRLS" : ""}${diff$1.connLimit ? typeof diff$1.connLimit.to === "number" ? ` CONNECTION LIMIT ${diff$1.connLimit.to}` : " CONNECTION LIMIT -1" : ""}${diff$1.password ? diff$1.password.to ? ` PASSWORD '${require_utils.escapeSingleQuotes(diff$1.password.to)}'` : " PASSWORD NULL" : ""}${diff$1.validUntil ? diff$1.validUntil.to ? ` VALID UNTIL '${diff$1.validUntil.to}'` : ` VALID UNTIL 'infinity'` : ""};`;
});
const grantPrivilegeConvertor = convertor("grant_privilege", (st) => {
	const { schema, table } = st.privilege;
	const privilege = st.privilege;
	return `GRANT ${privilege.type} ON ${schema !== "public" ? `"${schema}"."${table}"` : `"${table}"`} TO ${privilege.grantee}${privilege.isGrantable ? " WITH GRANT OPTION" : ""} GRANTED BY ${privilege.grantor};`;
});
const revokePrivilegeConvertor = convertor("revoke_privilege", (st) => {
	const { schema, table } = st.privilege;
	const privilege = st.privilege;
	return `REVOKE ${privilege.type} ON ${schema !== "public" ? `"${schema}"."${table}"` : `"${table}"`} FROM ${privilege.grantee};`;
});
const regrantPrivilegeConvertor = convertor("regrant_privilege", (st) => {
	const privilege = st.privilege;
	return [revokePrivilegeConvertor.convert({ privilege }), grantPrivilegeConvertor.convert({ privilege })];
});
const createPolicyConvertor = convertor("create_policy", (st) => {
	const { schema, table } = st.policy;
	const policy = st.policy;
	const tableNameWithSchema = schema !== "public" ? `"${schema}"."${table}"` : `"${table}"`;
	const usingPart = policy.using ? ` USING (${policy.using})` : "";
	const withCheckPart = policy.withCheck ? ` WITH CHECK (${policy.withCheck})` : "";
	const policyToPart = policy.roles?.map((v) => [
		"current_user",
		"current_role",
		"session_user",
		"public"
	].includes(v) ? v : `"${v}"`).join(", ");
	return `CREATE POLICY "${policy.name}" ON ${tableNameWithSchema} AS ${policy.as?.toUpperCase()} FOR ${policy.for?.toUpperCase()} TO ${policyToPart}${usingPart}${withCheckPart};`;
});
const dropPolicyConvertor = convertor("drop_policy", (st) => {
	const policy = st.policy;
	const tableNameWithSchema = policy.schema !== "public" ? `"${policy.schema}"."${policy.table}"` : `"${policy.table}"`;
	return `DROP POLICY "${policy.name}" ON ${tableNameWithSchema};`;
});
const renamePolicyConvertor = convertor("rename_policy", (st) => {
	const { from, to } = st;
	const tableNameWithSchema = to.schema !== "public" ? `"${to.schema}"."${to.table}"` : `"${to.table}"`;
	return `ALTER POLICY "${from.name}" ON ${tableNameWithSchema} RENAME TO "${to.name}";`;
});
const alterPolicyConvertor = convertor("alter_policy", (st) => {
	const { policy } = st;
	const tableNameWithSchema = policy.schema !== "public" ? `"${policy.schema}"."${policy.table}"` : `"${policy.table}"`;
	const usingPart = policy.using ? ` USING (${policy.using})` : "";
	const withCheckPart = policy.withCheck ? ` WITH CHECK (${policy.withCheck})` : "";
	const toClause = policy.roles?.map((v) => [
		"current_user",
		"current_role",
		"session_user",
		"public"
	].includes(v) ? v : `"${v}"`).join(", ");
	return `ALTER POLICY "${policy.name}" ON ${tableNameWithSchema} TO ${toClause}${usingPart}${withCheckPart};`;
});
const recreatePolicy = convertor("recreate_policy", (st) => {
	return [dropPolicyConvertor.convert({ policy: st.policy }), createPolicyConvertor.convert({ policy: st.policy })];
});
const toggleRlsConvertor = convertor("alter_rls", (st) => {
	const { schema, name, isRlsEnabled } = st;
	return `ALTER TABLE ${schema !== "public" ? `"${schema}"."${name}"` : `"${name}"`} ${isRlsEnabled ? "ENABLE" : "DISABLE"} ROW LEVEL SECURITY;`;
});
const convertors = [
	createSchemaConvertor,
	dropSchemaConvertor,
	renameSchemaConvertor,
	createViewConvertor,
	dropViewConvertor,
	renameViewConvertor,
	moveViewConvertor,
	alterViewConvertor,
	createTableConvertor,
	dropTableConvertor,
	renameTableConvertor,
	moveTableConvertor,
	addColumnConvertor,
	dropColumnConvertor,
	renameColumnConvertor,
	recreateColumnConvertor,
	alterColumnConvertor,
	createIndexConvertor,
	dropIndexConvertor,
	recreateIndexConvertor,
	renameIndexConvertor,
	addPrimaryKeyConvertor,
	dropPrimaryKeyConvertor,
	recreatePrimaryKeyConvertor,
	createForeignKeyConvertor,
	recreateFKConvertor,
	dropForeignKeyConvertor,
	addCheckConvertor,
	dropCheckConvertor,
	recreateCheckConvertor,
	addUniqueConvertor,
	dropUniqueConvertor,
	renameConstraintConvertor,
	createEnumConvertor,
	dropEnumConvertor,
	renameEnumConvertor,
	moveEnumConvertor,
	alterEnumConvertor,
	recreateEnumConvertor,
	createSequenceConvertor,
	dropSequenceConvertor,
	renameSequenceConvertor,
	moveSequenceConvertor,
	alterSequenceConvertor,
	createRoleConvertor,
	dropRoleConvertor,
	renameRoleConvertor,
	alterRoleConvertor,
	grantPrivilegeConvertor,
	revokePrivilegeConvertor,
	regrantPrivilegeConvertor,
	createPolicyConvertor,
	dropPolicyConvertor,
	renamePolicyConvertor,
	alterPolicyConvertor,
	recreatePolicy,
	toggleRlsConvertor
];
function fromJson(statements) {
	const grouped = statements.map((statement) => {
		const filtered = convertors.filter((it) => {
			return it.can(statement);
		});
		const convertor$1 = filtered.length === 1 ? filtered[0] : void 0;
		if (!convertor$1) throw new Error(`No convertor for: ${statement.type} statement`);
		const sqlStatements = convertor$1.convert(statement);
		return {
			jsonStatement: statement,
			sqlStatements: typeof sqlStatements === "string" ? [sqlStatements] : sqlStatements
		};
	}).filter((it) => it !== null);
	return {
		sqlStatements: grouped.map((it) => it.sqlStatements).flat(),
		groupedStatements: grouped
	};
}

//#endregion
//#region src/dialects/postgres/statements.ts
const prepareStatement = (type, args) => {
	return {
		type,
		...args
	};
};

//#endregion
//#region src/dialects/postgres/diff.ts
const ddlDiff = async (ddl1, ddl2, schemasResolver, enumsResolver, sequencesResolver, policyResolver, roleResolver, privilegesResolver, tablesResolver, columnsResolver, viewsResolver, uniquesResolver, indexesResolver, checksResolver, pksResolver, fksResolver, mode) => {
	const ddl1Copy = require_ddl.createDDL();
	for (const entity of ddl1.entities.list()) ddl1Copy.entities.push(entity);
	const schemasDiff = require_ddl.diff(ddl1, ddl2, "schemas");
	const { created: createdSchemas, deleted: deletedSchemas, renamedOrMoved: renamedSchemas } = await schemasResolver({
		created: schemasDiff.filter((it) => it.$diffType === "create"),
		deleted: schemasDiff.filter((it) => it.$diffType === "drop")
	});
	for (const rename of renamedSchemas) {
		ddl1.entities.update({
			set: { schema: rename.to.name },
			where: { schema: rename.from.name }
		});
		ddl1.fks.update({
			set: { schemaTo: rename.to.name },
			where: { schemaTo: rename.from.name }
		});
	}
	const enumsDiff = require_ddl.diff(ddl1, ddl2, "enums");
	const { created: createdEnums, deleted: deletedEnums, renamedOrMoved: renamedOrMovedEnums } = await enumsResolver({
		created: enumsDiff.filter((it) => it.$diffType === "create"),
		deleted: enumsDiff.filter((it) => it.$diffType === "drop")
	});
	const renamedEnums = renamedOrMovedEnums.filter((it) => it.from.name !== it.to.name);
	const movedEnums = renamedOrMovedEnums.filter((it) => it.from.schema !== it.to.schema);
	for (const rename of renamedEnums) {
		ddl1.enums.update({
			set: {
				name: rename.to.name,
				schema: rename.to.schema
			},
			where: {
				name: rename.from.name,
				schema: rename.from.schema
			}
		});
		ddl1.columns.update({
			set: {
				type: rename.to.name,
				typeSchema: rename.to.schema
			},
			where: {
				type: rename.from.name,
				typeSchema: rename.from.schema
			}
		});
	}
	for (const move of movedEnums) {
		ddl1.enums.update({
			set: { schema: move.to.schema },
			where: {
				name: move.from.name,
				schema: move.from.schema
			}
		});
		ddl1.columns.update({
			set: { typeSchema: move.to.schema },
			where: {
				type: move.from.name,
				typeSchema: move.from.schema
			}
		});
	}
	const sequencesDiff = require_ddl.diff(ddl1, ddl2, "sequences");
	const { created: createdSequences, deleted: deletedSequences, renamedOrMoved: renamedOrMovedSequences } = await sequencesResolver({
		created: sequencesDiff.filter((it) => it.$diffType === "create"),
		deleted: sequencesDiff.filter((it) => it.$diffType === "drop")
	});
	const renamedSequences = renamedOrMovedSequences.filter((it) => it.from.schema === it.to.schema);
	const movedSequences = renamedOrMovedSequences.filter((it) => it.from.schema !== it.to.schema);
	for (const rename of renamedSequences) ddl1.sequences.update({
		set: {
			name: rename.to.name,
			schema: rename.to.schema
		},
		where: {
			name: rename.from.name,
			schema: rename.from.schema
		}
	});
	for (const move of movedSequences) ddl1.sequences.update({
		set: { schema: move.to.schema },
		where: {
			name: move.from.name,
			schema: move.from.schema
		}
	});
	const rolesDiff = require_ddl.diff(ddl1, ddl2, "roles");
	const { created: createdRoles, deleted: deletedRoles, renamedOrMoved: renamedRoles } = await roleResolver({
		created: rolesDiff.filter((it) => it.$diffType === "create"),
		deleted: rolesDiff.filter((it) => it.$diffType === "drop")
	});
	for (const rename of renamedRoles) ddl1.roles.update({
		set: { name: rename.to.name },
		where: { name: rename.from.name }
	});
	const privilegesDiff = require_ddl.diff(ddl1, ddl2, "privileges");
	const { created: createdPrivileges, deleted: deletedPrivileges } = await privilegesResolver({
		created: privilegesDiff.filter((it) => it.$diffType === "create"),
		deleted: privilegesDiff.filter((it) => it.$diffType === "drop")
	});
	const tablesDiff = require_ddl.diff(ddl1, ddl2, "tables");
	const { created: createdTables, deleted: deletedTables, renamedOrMoved: renamedOrMovedTables } = await tablesResolver({
		created: tablesDiff.filter((it) => it.$diffType === "create"),
		deleted: tablesDiff.filter((it) => it.$diffType === "drop")
	});
	const renamedTables = renamedOrMovedTables.filter((it) => it.from.name !== it.to.name);
	const movedTables = renamedOrMovedTables.filter((it) => it.from.schema !== it.to.schema);
	for (const rename of renamedOrMovedTables) {
		ddl1.tables.update({
			set: {
				name: rename.to.name,
				schema: rename.to.schema
			},
			where: {
				name: rename.from.name,
				schema: rename.from.schema
			}
		});
		ddl1.fks.update({
			set: {
				schemaTo: rename.to.schema,
				tableTo: rename.to.name
			},
			where: {
				schemaTo: rename.from.schema,
				tableTo: rename.from.name
			}
		});
		ddl2.fks.update({
			set: {
				schemaTo: rename.to.schema,
				tableTo: rename.to.name
			},
			where: {
				schemaTo: rename.from.schema,
				tableTo: rename.from.name
			}
		});
		ddl1.fks.update({
			set: {
				schema: rename.to.schema,
				table: rename.to.name
			},
			where: {
				schema: rename.from.schema,
				table: rename.from.name
			}
		});
		ddl1.entities.update({
			set: {
				table: rename.to.name,
				schema: rename.to.schema
			},
			where: {
				table: rename.from.name,
				schema: rename.from.schema
			}
		});
		ddl2.entities.update({
			set: {
				table: rename.to.name,
				schema: rename.to.schema
			},
			where: {
				table: rename.from.name,
				schema: rename.from.schema
			}
		});
	}
	const columnsDiff = require_ddl.diff(ddl1, ddl2, "columns");
	const columnRenames = [];
	const columnsToCreate = [];
	const columnsToDelete = [];
	const groupedByTable = require_grammar.groupDiffs(columnsDiff);
	for (let it of groupedByTable) {
		const { created, deleted, renamedOrMoved } = await columnsResolver({
			created: it.inserted,
			deleted: it.deleted
		});
		columnsToCreate.push(...created);
		columnsToDelete.push(...deleted);
		columnRenames.push(...renamedOrMoved);
	}
	for (const rename of columnRenames) {
		ddl1.columns.update({
			set: {
				name: rename.to.name,
				schema: rename.to.schema
			},
			where: {
				name: rename.from.name,
				schema: rename.from.schema
			}
		});
		const update1 = {
			set: { columns: (it) => {
				if (!it.isExpression && it.value === rename.from.name) return {
					...it,
					value: rename.to.name
				};
				return it;
			} },
			where: {
				schema: rename.from.schema,
				table: rename.from.table
			}
		};
		ddl1.indexes.update(update1);
		ddl2.indexes.update(update1);
		const update2 = {
			set: { columns: (it) => {
				return it === rename.from.name ? rename.to.name : it;
			} },
			where: {
				schema: rename.from.schema,
				table: rename.from.table
			}
		};
		ddl1.pks.update(update2);
		ddl2.pks.update(update2);
		const update3 = {
			set: { columns: (it) => {
				return it === rename.from.name ? rename.to.name : it;
			} },
			where: {
				schema: rename.from.schema,
				table: rename.from.table
			}
		};
		ddl1.fks.update(update3);
		ddl2.fks.update(update3);
		const update4 = {
			set: { columnsTo: (it) => {
				return it === rename.from.name ? rename.to.name : it;
			} },
			where: {
				schemaTo: rename.from.schema,
				tableTo: rename.from.table
			}
		};
		ddl1.fks.update(update4);
		ddl2.fks.update(update4);
		const update5 = {
			set: { columns: (it) => {
				return it === rename.from.name ? rename.to.name : it;
			} },
			where: {
				schema: rename.from.schema,
				table: rename.from.table
			}
		};
		ddl1.uniques.update(update5);
		ddl2.uniques.update(update5);
		const update6 = {
			set: { value: rename.to.name },
			where: {
				schema: rename.from.schema,
				table: rename.from.table,
				value: rename.from.name
			}
		};
		ddl1.checks.update(update6);
		ddl2.checks.update(update6);
	}
	require_grammar.preserveEntityNames(ddl1.uniques, ddl2.uniques, mode);
	require_grammar.preserveEntityNames(ddl1.fks, ddl2.fks, mode);
	require_grammar.preserveEntityNames(ddl1.pks, ddl2.pks, mode);
	require_grammar.preserveEntityNames(ddl1.indexes, ddl2.indexes, mode);
	const groupedUniquesDiff = require_grammar.groupDiffs(require_ddl.diff(ddl1, ddl2, "uniques"));
	const uniqueRenames = [];
	const uniqueCreates = [];
	const uniqueDeletes = [];
	for (const entry of groupedUniquesDiff) {
		const { renamedOrMoved: renamed, created, deleted } = await uniquesResolver({
			created: entry.inserted,
			deleted: entry.deleted
		});
		uniqueCreates.push(...created);
		uniqueDeletes.push(...deleted);
		uniqueRenames.push(...renamed);
	}
	for (const rename of uniqueRenames) ddl1.uniques.update({
		set: {
			name: rename.to.name,
			schema: rename.to.schema
		},
		where: {
			name: rename.from.name,
			schema: rename.from.schema
		}
	});
	const groupedChecksDiff = require_grammar.groupDiffs(require_ddl.diff(ddl1, ddl2, "checks"));
	const checkRenames = [];
	const checkCreates = [];
	const checkDeletes = [];
	for (const entry of groupedChecksDiff) {
		const { renamedOrMoved, created, deleted } = await checksResolver({
			created: entry.inserted,
			deleted: entry.deleted
		});
		checkCreates.push(...created);
		checkDeletes.push(...deleted);
		checkRenames.push(...renamedOrMoved);
	}
	for (const rename of checkRenames) ddl1.checks.update({
		set: {
			name: rename.to.name,
			schema: rename.to.schema
		},
		where: {
			name: rename.from.name,
			schema: rename.from.schema
		}
	});
	const groupedIndexesDiff = require_grammar.groupDiffs(require_ddl.diff(ddl1, ddl2, "indexes"));
	const indexesRenames = [];
	const indexesCreates = [];
	const indexesDeletes = [];
	for (const entry of groupedIndexesDiff) {
		const { renamedOrMoved, created, deleted } = await indexesResolver({
			created: entry.inserted,
			deleted: entry.deleted
		});
		indexesCreates.push(...created);
		indexesDeletes.push(...deleted);
		indexesRenames.push(...renamedOrMoved);
	}
	for (const rename of indexesRenames) ddl1.indexes.update({
		set: {
			name: rename.to.name,
			schema: rename.to.schema
		},
		where: {
			name: rename.from.name,
			schema: rename.from.schema
		}
	});
	const groupedPKsDiff = require_grammar.groupDiffs(require_ddl.diff(ddl1, ddl2, "pks"));
	const pksRenames = [];
	const pksCreates = [];
	const pksDeletes = [];
	for (const entry of groupedPKsDiff) {
		const { renamedOrMoved, created, deleted } = await pksResolver({
			created: entry.inserted,
			deleted: entry.deleted
		});
		pksCreates.push(...created);
		pksDeletes.push(...deleted);
		pksRenames.push(...renamedOrMoved);
	}
	for (const rename of pksRenames) ddl1.pks.update({
		set: {
			name: rename.to.name,
			schema: rename.to.schema
		},
		where: {
			name: rename.from.name,
			schema: rename.from.schema
		}
	});
	const groupedFKsDiff = require_grammar.groupDiffs(require_ddl.diff(ddl1, ddl2, "fks"));
	const fksRenames = [];
	const fksCreates = [];
	const fksDeletes = [];
	for (const entry of groupedFKsDiff) {
		const { renamedOrMoved, created, deleted } = await fksResolver({
			created: entry.inserted,
			deleted: entry.deleted
		});
		fksCreates.push(...created);
		fksDeletes.push(...deleted);
		fksRenames.push(...renamedOrMoved);
	}
	for (const rename of fksRenames) ddl1.fks.update({
		set: {
			name: rename.to.name,
			schema: rename.to.schema
		},
		where: {
			name: rename.from.name,
			schema: rename.from.schema
		}
	});
	const policiesDiffGrouped = require_grammar.groupDiffs(require_ddl.diff(ddl1, ddl2, "policies"));
	const policyRenames = [];
	const policyCreates = [];
	const policyDeletes = [];
	for (const entry of policiesDiffGrouped) {
		const { renamedOrMoved, created, deleted } = await policyResolver({
			created: entry.inserted,
			deleted: entry.deleted
		});
		policyCreates.push(...created);
		policyDeletes.push(...deleted);
		policyRenames.push(...renamedOrMoved);
	}
	for (const rename of policyRenames) ddl1.policies.update({
		set: {
			name: rename.to.name,
			schema: rename.to.schema
		},
		where: {
			name: rename.from.name,
			schema: rename.from.schema
		}
	});
	const viewsDiff = require_ddl.diff(ddl1, ddl2, "views");
	const { created: createdViews, deleted: deletedViews, renamedOrMoved: renamedOrMovedViews } = await viewsResolver({
		created: viewsDiff.filter((it) => it.$diffType === "create"),
		deleted: viewsDiff.filter((it) => it.$diffType === "drop")
	});
	const renamedViews = renamedOrMovedViews.filter((it) => it.from.schema === it.to.schema);
	const movedViews = renamedOrMovedViews.filter((it) => it.from.schema !== it.to.schema);
	for (const rename of renamedViews) ddl1.views.update({
		set: {
			name: rename.to.name,
			schema: rename.to.schema
		},
		where: {
			name: rename.from.name,
			schema: rename.from.schema
		}
	});
	for (const move of movedViews) ddl1.views.update({
		set: { schema: move.to.schema },
		where: {
			name: move.from.name,
			schema: move.from.schema
		}
	});
	const alters = require_ddl.diff.alters(ddl1, ddl2);
	const jsonStatements = [];
	const tablesFilter = (type) => {
		return (it) => {
			if (type === "created") return !createdTables.some((t) => t.schema === it.schema && t.name === it.table);
			else return !deletedTables.some((t) => t.schema === it.schema && t.name === it.table);
		};
	};
	const jsonCreateIndexes = indexesCreates.map((index) => prepareStatement("create_index", { index }));
	const jsonDropIndexes = indexesDeletes.filter(tablesFilter("deleted")).map((index) => prepareStatement("drop_index", { index }));
	const jsonRenameIndexes = indexesRenames.map((r) => {
		return prepareStatement("rename_index", {
			schema: r.to.schema,
			from: r.from.name,
			to: r.to.name
		});
	});
	const indexesAlters = alters.filter((it) => {
		if (it.entityType !== "indexes") return false;
		delete it.concurrently;
		return ddl2.indexes.hasDiff(it);
	});
	const jsonRecreateIndex = [];
	for (const idx of indexesAlters) {
		const forWhere = !!idx.where && (idx.where.from !== null && idx.where.to !== null ? mode !== "push" : true);
		const forColumns = !!idx.columns && (idx.columns.from.length === idx.columns.to.length ? mode !== "push" : true);
		if (idx.isUnique || idx.concurrently || idx.method || idx.with || forColumns || forWhere) {
			const index = ddl2.indexes.one({
				schema: idx.schema,
				table: idx.table,
				name: idx.name
			});
			jsonRecreateIndex.push(prepareStatement("recreate_index", {
				index,
				diff: idx
			}));
		}
	}
	const jsonDropTables = deletedTables.map((it) => {
		const oldSchema = renamedSchemas.find((x) => x.to.name === it.schema);
		const key = oldSchema ? `"${oldSchema.from.name}"."${it.name}"` : `"${it.schema}"."${it.name}"`;
		return prepareStatement("drop_table", {
			table: require_ddl.tableFromDDL(it, ddl2),
			key
		});
	});
	const jsonRenameTables = renamedTables.map((it) => prepareStatement("rename_table", {
		schema: it.from.schema,
		from: it.from.name,
		to: it.to.name
	}));
	const jsonRenameColumnsStatements = columnRenames.map((it) => prepareStatement("rename_column", it));
	const jsonDropColumnsStatemets = columnsToDelete.filter(tablesFilter("deleted")).map((it) => prepareStatement("drop_column", { column: it }));
	const jsonAddColumnsStatemets = columnsToCreate.filter(tablesFilter("created")).map((it) => prepareStatement("add_column", {
		column: it,
		isPK: false,
		isCompositePK: ddl2.pks.one({
			schema: it.schema,
			table: it.table,
			columns: { CONTAINS: it.name }
		}) !== null
	}));
	const columnAlters = alters.filter((it) => it.entityType === "columns").filter((it) => {
		if (it.default && (it.$left.type === "json" && it.$right.type === "json" || it.$left.type === "jsonb" && it.$right.type === "jsonb")) {
			if (it.default.from !== null && it.default.to !== null) {
				const parsedLeft = require_grammar.parse(require_utils.trimChar(it.default.from, "'"));
				const parsedRight = require_grammar.parse(require_utils.trimChar(it.default.to, "'"));
				try {
					deepStrictEqual(parsedLeft, parsedRight);
					delete it.default;
				} catch {}
			}
		}
		if (!it.type && it.default && require_grammar.defaultsCommutative(it.default, it.$right.type, it.$right.dimensions)) delete it.default;
		if (it.type) {
			if (it.type.from === it.type.to.replace("numeric", "decimal") || it.type.to === it.type.from.replace("numeric", "decimal")) delete it.type;
		}
		if (it.type && it.$right.type.startsWith("geometry(point") && it.$left.type.startsWith("geometry(point")) {
			const leftSrid = it.$left.type.split(",")[1]?.replace(")", "");
			const rightSrid = it.$right.type.split(",")[1]?.replace(")", "");
			if (typeof leftSrid === "undefined" && rightSrid === "0") delete it.type;
			if (typeof rightSrid === "undefined" && leftSrid === "0") delete it.type;
		}
		if (it.type && it.type.from.replace(",0)", ")") === it.type.to) delete it.type;
		return ddl2.columns.hasDiff(it);
	});
	const jsonAlteredUniqueConstraints = alters.filter((it) => it.entityType === "uniques").filter((it) => {
		if (it.nameExplicit) delete it.nameExplicit;
		return ddl2.uniques.hasDiff(it);
	}).map((it) => prepareStatement("alter_unique", { diff: it }));
	const jsonAddedUniqueConstraints = uniqueCreates.filter(tablesFilter("created")).map((it) => prepareStatement("add_unique", { unique: it }));
	const jsonDropUniqueConstraints = uniqueDeletes.filter(tablesFilter("deleted")).map((it) => prepareStatement("drop_unique", { unique: it }));
	const jsonRenamedUniqueConstraints = uniqueRenames.map((it) => prepareStatement("rename_constraint", {
		schema: it.to.schema,
		table: it.to.table,
		from: it.from.name,
		to: it.to.name
	}));
	const jsonAddPrimaryKeys = pksCreates.filter(tablesFilter("created")).map((it) => prepareStatement("add_pk", { pk: it }));
	const jsonDropPrimaryKeys = pksDeletes.filter(tablesFilter("deleted")).map((it) => prepareStatement("drop_pk", { pk: it }));
	const jsonRenamePrimaryKey = pksRenames.map((it) => {
		return prepareStatement("rename_constraint", {
			schema: it.to.schema,
			table: it.to.table,
			from: it.from.name,
			to: it.to.name
		});
	});
	const jsonSetTableSchemas = movedTables.map((it) => prepareStatement("move_table", {
		name: it.to.name,
		from: it.from.schema,
		to: it.to.schema
	}));
	const jsonCreatedCheckConstraints = checkCreates.filter(tablesFilter("created")).map((it) => prepareStatement("add_check", { check: it }));
	const jsonDropCheckConstraints = checkDeletes.filter(tablesFilter("deleted")).map((it) => prepareStatement("drop_check", { check: it }));
	const alteredPKs = alters.filter((it) => it.entityType === "pks").filter((it) => {
		return !!it.columns;
	});
	const alteredChecks = alters.filter((it) => it.entityType === "checks");
	const jsonAlteredPKs = alteredPKs.map((it) => {
		const deleted = columnsToDelete.some((x) => it.columns?.from.includes(x.name));
		return prepareStatement("alter_pk", {
			diff: it,
			pk: it.$right,
			deleted
		});
	});
	const jsonRecreateFKs = alters.filter((it) => it.entityType === "fks").filter((x) => {
		if (x.nameExplicit && (mode === "push" && x.nameExplicit.from && !x.nameExplicit.to || x.nameExplicit.to && !x.nameExplicit.from)) delete x.nameExplicit;
		return ddl2.fks.hasDiff(x);
	}).map((it) => prepareStatement("recreate_fk", {
		fk: it.$right,
		diff: it
	}));
	const jsonCreateFKs = fksCreates.map((it) => prepareStatement("create_fk", { fk: it }));
	const jsonDropFKs = fksDeletes.filter((fk) => {
		const fromDeletedTable = deletedTables.some((x) => x.schema === fk.schema && x.name === fk.table);
		const toDeletedTable = fk.table !== fk.tableTo && deletedTables.some((x) => x.schema === fk.schemaTo && x.name === fk.tableTo);
		if (fromDeletedTable && !toDeletedTable) return false;
		return true;
	}).map((it) => prepareStatement("drop_fk", { fk: it }));
	const jsonRenameReferences = fksRenames.map((it) => prepareStatement("rename_constraint", {
		schema: it.to.schema,
		table: it.to.table,
		from: it.from.name,
		to: it.to.name
	}));
	const jsonAlterCheckConstraints = alteredChecks.filter((it) => it.value && mode !== "push").map((it) => prepareStatement("alter_check", { diff: it }));
	const jsonCreatePoliciesStatements = policyCreates.map((it) => prepareStatement("create_policy", { policy: it }));
	const jsonDropPoliciesStatements = policyDeletes.map((it) => prepareStatement("drop_policy", { policy: it }));
	const jsonRenamePoliciesStatements = policyRenames.map((it) => prepareStatement("rename_policy", it));
	const jsonAlterOrRecreatePoliciesStatements = alters.filter((it) => it.entityType === "policies").filter((it) => {
		if (it.withCheck && it.withCheck.from && it.withCheck.to) {
			if (it.withCheck.from === `(${it.withCheck.to})` || it.withCheck.to === `(${it.withCheck.from})`) delete it.withCheck;
		}
		return ddl1.policies.hasDiff(it);
	}).filter((it) => {
		return it.as || it.for || it.roles || !((it.using || it.withCheck) && mode === "push");
	}).map((it) => {
		const to = ddl2.policies.one({
			schema: it.schema,
			table: it.table,
			name: it.name
		});
		if (it.for || it.as) return prepareStatement("recreate_policy", {
			diff: it,
			policy: to
		});
		else return prepareStatement("alter_policy", {
			diff: it,
			policy: to
		});
	});
	const rlsAlters = alters.filter((it) => it.entityType === "tables").filter((it) => it.isRlsEnabled);
	const jsonAlterRlsStatements = rlsAlters.map((it) => prepareStatement("alter_rls", {
		schema: it.schema,
		name: it.name,
		isRlsEnabled: it.isRlsEnabled?.to || false
	}));
	for (const it of policyDeletes) {
		if (rlsAlters.some((alter) => alter.schema === it.schema && alter.name === it.table)) continue;
		const had = ddl1.policies.list({
			schema: it.schema,
			table: it.table
		}).length;
		const has = ddl2.policies.list({
			schema: it.schema,
			table: it.table
		}).length;
		const prevTable = ddl1.tables.one({
			schema: it.schema,
			name: it.table
		});
		if (ddl2.tables.one({
			schema: it.schema,
			name: it.table
		}) !== null && had > 0 && has === 0 && prevTable && prevTable.isRlsEnabled === false && !jsonAlterRlsStatements.some((st) => st.schema === it.schema && st.name === it.table)) jsonAlterRlsStatements.push(prepareStatement("alter_rls", {
			schema: it.schema,
			name: it.table,
			isRlsEnabled: false
		}));
	}
	for (const it of policyCreates) {
		if (rlsAlters.some((alter) => alter.schema === it.schema && alter.name === it.table)) continue;
		if (createdTables.some((t) => t.schema === it.schema && t.name === it.table)) continue;
		if (jsonAlterRlsStatements.some((st) => st.schema === it.schema && st.name === it.table)) continue;
		const had = ddl1.policies.list({
			schema: it.schema,
			table: it.table
		}).length;
		const has = ddl2.policies.list({
			schema: it.schema,
			table: it.table
		}).length;
		const table = ddl2.tables.one({
			schema: it.schema,
			name: it.table
		});
		if (table !== null && had === 0 && has > 0 && !table.isRlsEnabled) jsonAlterRlsStatements.push(prepareStatement("alter_rls", {
			schema: it.schema,
			name: it.table,
			isRlsEnabled: true
		}));
	}
	const jsonCreateEnums = createdEnums.map((it) => prepareStatement("create_enum", { enum: it }));
	const jsonDropEnums = deletedEnums.map((it) => prepareStatement("drop_enum", { enum: it }));
	const jsonMoveEnums = movedEnums.map((it) => prepareStatement("move_enum", it));
	const jsonRenameEnums = renamedEnums.map((it) => prepareStatement("rename_enum", {
		schema: it.to.schema,
		from: it.from.name,
		to: it.to.name
	}));
	const enumsAlters = alters.filter((it) => it.entityType === "enums");
	const recreateEnums = [];
	const jsonAlterEnums = [];
	for (const alter of enumsAlters) {
		const values = alter.values;
		const res = diffStringArrays(values.from, values.to);
		const e = {
			...alter,
			values: values.to
		};
		if (res.some((it) => it.type === "removed")) {
			const columns = ddl1.columns.list({
				typeSchema: alter.schema,
				type: alter.name
			}).map((it) => {
				const c2 = ddl2.columns.one({
					schema: it.schema,
					table: it.table,
					name: it.name
				});
				if (c2 === null) return null;
				const def = {
					right: c2.default,
					left: it.default
				};
				return {
					...it,
					default: def
				};
			}).filter((x) => x !== null);
			recreateEnums.push(prepareStatement("recreate_enum", {
				to: e,
				columns,
				from: alter.$left
			}));
		} else jsonAlterEnums.push(prepareStatement("alter_enum", {
			diff: res,
			to: e,
			from: alter.$left
		}));
	}
	const jsonAlterColumns = columnAlters.filter((it) => !(it.generated && it.generated.to !== null)).filter((it) => {
		if (it.default && recreateEnums.some((x) => x.columns.some((c) => it.schema === c.schema && it.table === c.table && it.name === c.name))) delete it.default;
		if (it.notNull && it.notNull.to && (it.$right.generated || it.$right.identity)) delete it.notNull;
		const pkIn2 = ddl2.pks.one({
			schema: it.schema,
			table: it.table,
			columns: { CONTAINS: it.name }
		});
		if (it.notNull && pkIn2) delete it.notNull;
		return ddl2.columns.hasDiff(it);
	}).map((it) => {
		const column = it.$right;
		const wasSerial = require_grammar.isSerialType(it.$left.type);
		const toSerial = !require_grammar.isSerialType(it.$left.type) && require_grammar.isSerialType(it.$right.type);
		return prepareStatement("alter_column", {
			diff: it,
			to: column,
			isEnum: ddl2.enums.one({
				schema: column.typeSchema ?? "public",
				name: column.type
			}) !== null,
			wasEnum: (it.type && ddl1.enums.one({
				schema: column.typeSchema ?? "public",
				name: it.type.from
			}) !== null) ?? false,
			wasSerial,
			toSerial
		});
	});
	const createSequences = createdSequences.map((it) => prepareStatement("create_sequence", { sequence: it }));
	const dropSequences = deletedSequences.map((it) => prepareStatement("drop_sequence", { sequence: it }));
	const moveSequences = movedSequences.map((it) => prepareStatement("move_sequence", it));
	const renameSequences = renamedSequences.map((it) => prepareStatement("rename_sequence", it));
	const jsonAlterSequences = alters.filter((it) => it.entityType === "sequences").map((it) => prepareStatement("alter_sequence", {
		diff: it,
		sequence: it.$right
	}));
	const jsonCreateRoles = createdRoles.map((it) => prepareStatement("create_role", { role: it }));
	const jsonDropRoles = deletedRoles.map((it) => prepareStatement("drop_role", { role: it }));
	const jsonRenameRoles = renamedRoles.map((it) => prepareStatement("rename_role", it));
	const jsonAlterRoles = alters.filter((it) => it.entityType === "roles").map((it) => prepareStatement("alter_role", {
		diff: it,
		role: it.$right
	}));
	const jsonGrantPrivileges = createdPrivileges.map((it) => prepareStatement("grant_privilege", { privilege: it }));
	const jsonRevokePrivileges = deletedPrivileges.map((it) => prepareStatement("revoke_privilege", { privilege: it }));
	const jsonAlterPrivileges = alters.filter((it) => it.entityType === "privileges").map((it) => prepareStatement("regrant_privilege", {
		privilege: it.$right,
		diff: it
	}));
	const createSchemas = createdSchemas.map((it) => prepareStatement("create_schema", it));
	const dropSchemas = deletedSchemas.map((it) => prepareStatement("drop_schema", it));
	const renameSchemas = renamedSchemas.map((it) => prepareStatement("rename_schema", it));
	const createTables = createdTables.map((it) => prepareStatement("create_table", { table: require_ddl.tableFromDDL(it, ddl2) }));
	const createViews = createdViews.map((it) => prepareStatement("create_view", { view: it }));
	const jsonDropViews = deletedViews.map((it) => prepareStatement("drop_view", {
		view: it,
		cause: null
	}));
	const jsonRenameViews = renamedViews.map((it) => prepareStatement("rename_view", it));
	const jsonMoveViews = movedViews.map((it) => prepareStatement("move_view", {
		fromSchema: it.from.schema,
		toSchema: it.to.schema,
		view: it.to
	}));
	const viewsAlters = alters.filter((it) => {
		if (it.entityType !== "views") return false;
		if (it.definition && mode === "push") delete it.definition;
		if (mode === "push" && it.using && !it.using.to && it.using.from === require_grammar.defaults.accessMethod) delete it.using;
		if (mode === "push" && it.tablespace && it.tablespace.from === null && it.tablespace.to === require_grammar.defaults.tablespace) delete it.tablespace;
		return ddl2.views.hasDiff(it);
	}).map((it) => ({
		diff: it,
		view: it.$right
	}));
	const jsonAlterViews = viewsAlters.filter((it) => !it.diff.definition).map((it) => {
		return prepareStatement("alter_view", {
			diff: it.diff,
			view: it.view
		});
	});
	viewsAlters.filter((it) => it.diff.definition).forEach((entry) => {
		const it = entry.view;
		const schemaRename = renamedSchemas.find((r) => r.to.name === it.schema);
		const schema = schemaRename ? schemaRename.from.name : it.schema;
		const viewRename = renamedViews.find((r) => r.to.schema === it.schema && r.to.name === it.name);
		const name = viewRename ? viewRename.from.name : it.name;
		const from = ddl1Copy.views.one({
			schema,
			name
		});
		if (!from) throw new Error(`
				Missing view in original ddl:
				${it.schema}:${it.name}
				${schema}:${name}
				`);
		jsonDropViews.push(prepareStatement("drop_view", {
			view: it,
			cause: from
		}));
		createViews.push(prepareStatement("create_view", { view: it }));
	});
	const jsonRecreateColumns = columnAlters.filter((it) => it.generated && it.generated.to !== null).filter((it) => {
		return !(it.generated?.to && it.generated.from && mode === "push");
	}).map((it) => {
		const indexes = ddl2.indexes.list({
			table: it.table,
			schema: it.schema
		}).filter((index) => index.columns.some((column) => require_utils.trimChar(column.value, "`") === it.name));
		for (const index of indexes) jsonCreateIndexes.push({
			type: "create_index",
			index
		});
		const uniques = ddl2.uniques.list({
			table: it.table,
			schema: it.schema,
			columns: { CONTAINS: it.name }
		});
		for (const unique of uniques) jsonAddedUniqueConstraints.push({
			type: "add_unique",
			unique
		});
		const fksFrom = ddl2.fks.list({
			table: it.table,
			schema: it.schema,
			columns: { CONTAINS: it.name }
		});
		const fksTo = ddl2.fks.list({
			tableTo: it.table,
			schemaTo: it.schema,
			columnsTo: { CONTAINS: it.name }
		});
		for (const fkFrom of fksFrom) jsonDropFKs.push({
			type: "drop_fk",
			fk: fkFrom
		});
		for (const fkTo of fksTo) {
			jsonDropFKs.push({
				type: "drop_fk",
				fk: fkTo
			});
			jsonCreateFKs.push({
				type: "create_fk",
				fk: fkTo
			});
		}
		return prepareStatement("recreate_column", {
			diff: it,
			isPK: ddl2.pks.one({
				schema: it.schema,
				table: it.table,
				columns: [it.name]
			}) !== null
		});
	});
	jsonStatements.push(...createSchemas);
	jsonStatements.push(...renameSchemas);
	jsonStatements.push(...jsonCreateEnums);
	jsonStatements.push(...jsonMoveEnums);
	jsonStatements.push(...jsonRenameEnums);
	jsonStatements.push(...jsonAlterEnums);
	jsonStatements.push(...createSequences);
	jsonStatements.push(...moveSequences);
	jsonStatements.push(...renameSequences);
	jsonStatements.push(...jsonAlterSequences);
	jsonStatements.push(...jsonRenameRoles);
	jsonStatements.push(...jsonDropRoles);
	jsonStatements.push(...jsonCreateRoles);
	jsonStatements.push(...jsonAlterRoles);
	jsonStatements.push(...jsonRevokePrivileges);
	jsonStatements.push(...jsonGrantPrivileges);
	jsonStatements.push(...jsonAlterPrivileges);
	jsonStatements.push(...createTables);
	jsonStatements.push(...jsonDropViews);
	jsonStatements.push(...jsonRenameViews);
	jsonStatements.push(...jsonMoveViews);
	jsonStatements.push(...jsonAlterViews);
	jsonStatements.push(...jsonRenameTables);
	jsonStatements.push(...jsonDropPoliciesStatements);
	jsonStatements.push(...jsonDropFKs);
	jsonStatements.push(...jsonDropTables);
	jsonStatements.push(...jsonAlterRlsStatements);
	jsonStatements.push(...jsonSetTableSchemas);
	jsonStatements.push(...jsonRenameColumnsStatements);
	jsonStatements.push(...jsonDropUniqueConstraints);
	jsonStatements.push(...jsonDropCheckConstraints);
	jsonStatements.push(...jsonRenameIndexes);
	jsonStatements.push(...jsonDropIndexes);
	jsonStatements.push(...jsonDropPrimaryKeys);
	jsonStatements.push(...jsonRenameReferences);
	jsonStatements.push(...jsonAddColumnsStatemets);
	jsonStatements.push(...jsonAddPrimaryKeys);
	jsonStatements.push(...jsonRenamePrimaryKey);
	jsonStatements.push(...recreateEnums);
	jsonStatements.push(...jsonRecreateColumns);
	jsonStatements.push(...jsonDropColumnsStatemets);
	jsonStatements.push(...jsonAlteredPKs);
	jsonStatements.push(...jsonAlterColumns);
	jsonStatements.push(...jsonRecreateIndex);
	jsonStatements.push(...jsonRenamedUniqueConstraints);
	jsonStatements.push(...jsonAddedUniqueConstraints);
	jsonStatements.push(...jsonAlteredUniqueConstraints);
	jsonStatements.push(...jsonCreateIndexes);
	jsonStatements.push(...jsonCreateFKs);
	jsonStatements.push(...jsonRecreateFKs);
	jsonStatements.push(...jsonCreatedCheckConstraints);
	jsonStatements.push(...jsonAlterCheckConstraints);
	jsonStatements.push(...createViews);
	jsonStatements.push(...jsonRenamePoliciesStatements);
	jsonStatements.push(...jsonCreatePoliciesStatements);
	jsonStatements.push(...jsonAlterOrRecreatePoliciesStatements);
	jsonStatements.push(...jsonDropEnums);
	jsonStatements.push(...dropSequences);
	jsonStatements.push(...dropSchemas);
	const { groupedStatements, sqlStatements } = fromJson(jsonStatements);
	return {
		statements: jsonStatements,
		sqlStatements,
		groupedStatements,
		renames: require_utils.prepareMigrationRenames([
			...renameSchemas,
			...renamedEnums,
			...renamedOrMovedTables,
			...columnRenames,
			...uniqueRenames,
			...checkRenames,
			...indexesRenames,
			...pksRenames,
			...fksRenames,
			...policyRenames,
			...renamedOrMovedViews,
			...renamedRoles,
			...renamedOrMovedSequences
		])
	};
};

//#endregion
Object.defineProperty(exports, 'ddlDiff', {
  enumerable: true,
  get: function () {
    return ddlDiff;
  }
});