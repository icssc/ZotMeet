{"version":3,"file":"sql.js","names":["result: QueryWithTypings","queryChunks: SQLChunk[]","result: SQLChunk[]","typings: QueryTypingsValue[]","value: string","noopDecoder: DriverValueDecoder<any, any>","noopEncoder: DriverValueEncoder<any, any>","noopMapper: DriverValueMapper<any, any>","value: TDataType","encoder: DriverValueEncoder<TDataType, TDriverParamType>","param","placeholder","name","sql: SQL<T>","fieldAlias: string","name: TName"],"sources":["../../src/sql/sql.ts"],"sourcesContent":["import type { CasingCache } from '~/casing.ts';\nimport { entityKind, is } from '~/entity.ts';\nimport type { SelectResult } from '~/query-builders/select.types.ts';\nimport { Subquery } from '~/subquery.ts';\nimport { TableName } from '~/table.utils.ts';\nimport { tracer } from '~/tracing.ts';\nimport type { Assume, Equal } from '~/utils.ts';\nimport { ViewBaseConfig } from '~/view-common.ts';\nimport type { AnyColumn } from '../column.ts';\nimport { Column } from '../column.ts';\nimport { IsAlias, OriginalName, Table, TableColumns, TableSchema } from '../table.ts';\n\n/**\n * This class is used to indicate a primitive param value that is used in `sql` tag.\n * It is only used on type level and is never instantiated at runtime.\n * If you see a value of this type in the code, its runtime value is actually the primitive param value.\n */\nexport class FakePrimitiveParam {\n\tstatic readonly [entityKind]: string = 'FakePrimitiveParam';\n}\n\nexport type Chunk =\n\t| string\n\t| Table\n\t| View\n\t| AnyColumn\n\t| Name\n\t| Param\n\t| Placeholder\n\t| SQL;\n\nexport interface BuildQueryConfig {\n\tcasing: CasingCache;\n\tescapeName(name: string): string;\n\tescapeParam(num: number, value: unknown): string;\n\tescapeString(str: string): string;\n\tprepareTyping?: (encoder: DriverValueEncoder<unknown, unknown>) => QueryTypingsValue;\n\tparamStartIndex?: { value: number };\n\tinlineParams?: boolean;\n\tinvokeSource?: 'indexes' | 'mssql-check' | 'mssql-view-with-schemabinding' | undefined;\n}\n\nexport type QueryTypingsValue = 'json' | 'decimal' | 'time' | 'timestamp' | 'uuid' | 'date' | 'none';\n\nexport interface Query {\n\tsql: string;\n\tparams: unknown[];\n}\n\nexport interface QueryWithTypings extends Query {\n\ttypings?: QueryTypingsValue[];\n}\n\n/**\n * Any value that implements the `getSQL` method. The implementations include:\n * - `Table`\n * - `Column`\n * - `View`\n * - `Subquery`\n * - `SQL`\n * - `SQL.Aliased`\n * - `Placeholder`\n * - `Param`\n */\nexport interface SQLWrapper<T = unknown> {\n\tgetSQL(): SQL<T>;\n\tshouldOmitSQLParens?(): boolean;\n}\n\nexport function isSQLWrapper(value: unknown): value is SQLWrapper {\n\treturn value !== null && value !== undefined && typeof (value as any).getSQL === 'function';\n}\n\nfunction mergeQueries(queries: QueryWithTypings[]): QueryWithTypings {\n\tconst result: QueryWithTypings = { sql: '', params: [] };\n\tfor (const query of queries) {\n\t\tresult.sql += query.sql;\n\t\tresult.params.push(...query.params);\n\t\tif (query.typings?.length) {\n\t\t\tif (!result.typings) {\n\t\t\t\tresult.typings = [];\n\t\t\t}\n\t\t\tresult.typings.push(...query.typings);\n\t\t}\n\t}\n\treturn result;\n}\n\nexport class StringChunk implements SQLWrapper {\n\tstatic readonly [entityKind]: string = 'StringChunk';\n\n\treadonly value: string[];\n\n\tconstructor(value: string | string[]) {\n\t\tthis.value = Array.isArray(value) ? value : [value];\n\t}\n\n\tgetSQL(): SQL<unknown> {\n\t\treturn new SQL([this]);\n\t}\n}\n\nexport class SQL<T = unknown> implements SQLWrapper<T> {\n\tstatic readonly [entityKind]: string = 'SQL';\n\n\tdeclare _: {\n\t\tbrand: 'SQL';\n\t\ttype: T;\n\t};\n\n\t/** @internal */\n\tdecoder: DriverValueDecoder<T, any> = noopDecoder;\n\t/** @internal */\n\tpublic shouldInlineParams = false;\n\n\t/** @internal */\n\tusedTables: string[] = [];\n\n\tconstructor(readonly queryChunks: SQLChunk[]) {\n\t\tfor (const chunk of queryChunks) {\n\t\t\tif (is(chunk, Table)) {\n\t\t\t\tconst schemaName = chunk[Table.Symbol.Schema];\n\n\t\t\t\tthis.usedTables.push(\n\t\t\t\t\tschemaName === undefined\n\t\t\t\t\t\t? chunk[Table.Symbol.Name]\n\t\t\t\t\t\t: schemaName + '.' + chunk[Table.Symbol.Name],\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\n\tappend(query: SQL): this {\n\t\tthis.queryChunks.push(...query.queryChunks);\n\t\treturn this;\n\t}\n\n\ttoQuery(config: BuildQueryConfig): QueryWithTypings {\n\t\treturn tracer.startActiveSpan('drizzle.buildSQL', (span) => {\n\t\t\tconst query = this.buildQueryFromSourceParams(this.queryChunks, config);\n\t\t\tspan?.setAttributes({\n\t\t\t\t'drizzle.query.text': query.sql,\n\t\t\t\t'drizzle.query.params': JSON.stringify(query.params),\n\t\t\t});\n\t\t\treturn query;\n\t\t});\n\t}\n\n\tbuildQueryFromSourceParams(chunks: SQLChunk[], _config: BuildQueryConfig): Query {\n\t\tconst config = Object.assign({}, _config, {\n\t\t\tinlineParams: _config.inlineParams || this.shouldInlineParams,\n\t\t\tparamStartIndex: _config.paramStartIndex || { value: 0 },\n\t\t});\n\n\t\tconst {\n\t\t\tcasing,\n\t\t\tescapeName,\n\t\t\tescapeParam,\n\t\t\tprepareTyping,\n\t\t\tinlineParams,\n\t\t\tparamStartIndex,\n\t\t\tinvokeSource,\n\t\t} = config;\n\n\t\treturn mergeQueries(chunks.map((chunk): QueryWithTypings => {\n\t\t\tif (is(chunk, StringChunk)) {\n\t\t\t\treturn { sql: chunk.value.join(''), params: [] };\n\t\t\t}\n\n\t\t\tif (is(chunk, Name)) {\n\t\t\t\treturn { sql: escapeName(chunk.value), params: [] };\n\t\t\t}\n\n\t\t\tif (chunk === undefined) {\n\t\t\t\treturn { sql: '', params: [] };\n\t\t\t}\n\n\t\t\tif (Array.isArray(chunk)) {\n\t\t\t\tconst result: SQLChunk[] = [new StringChunk('(')];\n\t\t\t\tfor (const [i, p] of chunk.entries()) {\n\t\t\t\t\tresult.push(p);\n\t\t\t\t\tif (i < chunk.length - 1) {\n\t\t\t\t\t\tresult.push(new StringChunk(', '));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tresult.push(new StringChunk(')'));\n\t\t\t\treturn this.buildQueryFromSourceParams(result, config);\n\t\t\t}\n\n\t\t\tif (is(chunk, SQL)) {\n\t\t\t\treturn this.buildQueryFromSourceParams(chunk.queryChunks, {\n\t\t\t\t\t...config,\n\t\t\t\t\tinlineParams: inlineParams || chunk.shouldInlineParams,\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tif (is(chunk, Table)) {\n\t\t\t\tconst schemaName = chunk[Table.Symbol.Schema];\n\t\t\t\tconst tableName = chunk[Table.Symbol.Name];\n\n\t\t\t\tif (invokeSource === 'mssql-view-with-schemabinding') {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tsql: (schemaName === undefined ? escapeName('dbo') : escapeName(schemaName)) + '.'\n\t\t\t\t\t\t\t+ escapeName(tableName),\n\t\t\t\t\t\tparams: [],\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\treturn {\n\t\t\t\t\tsql: schemaName === undefined || chunk[IsAlias]\n\t\t\t\t\t\t? escapeName(tableName)\n\t\t\t\t\t\t: escapeName(schemaName) + '.' + escapeName(tableName),\n\t\t\t\t\tparams: [],\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tif (is(chunk, Column)) {\n\t\t\t\tconst columnName = casing.getColumnCasing(chunk);\n\t\t\t\tif (_config.invokeSource === 'indexes') {\n\t\t\t\t\treturn { sql: escapeName(columnName), params: [] };\n\t\t\t\t}\n\n\t\t\t\tconst schemaName = invokeSource === 'mssql-check' ? undefined : chunk.table[Table.Symbol.Schema];\n\t\t\t\treturn {\n\t\t\t\t\tsql: chunk.isAlias ? escapeName(chunk.name) : chunk.table[IsAlias] || schemaName === undefined\n\t\t\t\t\t\t? escapeName(chunk.table[Table.Symbol.Name]) + '.' + escapeName(columnName)\n\t\t\t\t\t\t: escapeName(schemaName) + '.' + escapeName(chunk.table[Table.Symbol.Name]) + '.'\n\t\t\t\t\t\t\t+ escapeName(columnName),\n\t\t\t\t\tparams: [],\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tif (is(chunk, View)) {\n\t\t\t\tconst schemaName = chunk[ViewBaseConfig].schema;\n\t\t\t\tconst viewName = chunk[ViewBaseConfig].name;\n\t\t\t\treturn {\n\t\t\t\t\tsql: schemaName === undefined || chunk[ViewBaseConfig].isAlias\n\t\t\t\t\t\t? escapeName(viewName)\n\t\t\t\t\t\t: escapeName(schemaName) + '.' + escapeName(viewName),\n\t\t\t\t\tparams: [],\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tif (is(chunk, Param)) {\n\t\t\t\tif (is(chunk.value, Placeholder)) {\n\t\t\t\t\treturn { sql: escapeParam(paramStartIndex.value++, chunk), params: [chunk], typings: ['none'] };\n\t\t\t\t}\n\n\t\t\t\tconst mappedValue = chunk.value === null ? null : chunk.encoder.mapToDriverValue(chunk.value);\n\n\t\t\t\tif (is(mappedValue, SQL)) {\n\t\t\t\t\treturn this.buildQueryFromSourceParams([mappedValue], config);\n\t\t\t\t}\n\n\t\t\t\tif (inlineParams) {\n\t\t\t\t\treturn { sql: this.mapInlineParam(mappedValue, config), params: [] };\n\t\t\t\t}\n\n\t\t\t\tlet typings: QueryTypingsValue[] = ['none'];\n\t\t\t\tif (prepareTyping) {\n\t\t\t\t\ttypings = [prepareTyping(chunk.encoder)];\n\t\t\t\t}\n\n\t\t\t\treturn { sql: escapeParam(paramStartIndex.value++, mappedValue), params: [mappedValue], typings };\n\t\t\t}\n\n\t\t\tif (is(chunk, Placeholder)) {\n\t\t\t\treturn { sql: escapeParam(paramStartIndex.value++, chunk), params: [chunk], typings: ['none'] };\n\t\t\t}\n\n\t\t\tif (is(chunk, SQL.Aliased) && chunk.fieldAlias !== undefined) {\n\t\t\t\treturn { sql: escapeName(chunk.fieldAlias), params: [] };\n\t\t\t}\n\n\t\t\tif (is(chunk, Subquery)) {\n\t\t\t\tif (chunk._.isWith) {\n\t\t\t\t\treturn { sql: escapeName(chunk._.alias), params: [] };\n\t\t\t\t}\n\t\t\t\treturn this.buildQueryFromSourceParams([\n\t\t\t\t\tnew StringChunk('('),\n\t\t\t\t\tchunk._.sql,\n\t\t\t\t\tnew StringChunk(') '),\n\t\t\t\t\tnew Name(chunk._.alias),\n\t\t\t\t], config);\n\t\t\t}\n\n\t\t\tif (typeof chunk === 'function' && 'enumName' in chunk) {\n\t\t\t\tif ('schema' in chunk && chunk.schema) {\n\t\t\t\t\treturn { sql: escapeName(chunk.schema as string) + '.' + escapeName(chunk.enumName as string), params: [] };\n\t\t\t\t}\n\t\t\t\treturn { sql: escapeName(chunk.enumName as string), params: [] };\n\t\t\t}\n\n\t\t\tif (isSQLWrapper(chunk)) {\n\t\t\t\tif (chunk.shouldOmitSQLParens?.()) {\n\t\t\t\t\treturn this.buildQueryFromSourceParams([chunk.getSQL()], config);\n\t\t\t\t}\n\t\t\t\treturn this.buildQueryFromSourceParams([\n\t\t\t\t\tnew StringChunk('('),\n\t\t\t\t\tchunk.getSQL(),\n\t\t\t\t\tnew StringChunk(')'),\n\t\t\t\t], config);\n\t\t\t}\n\n\t\t\tif (inlineParams) {\n\t\t\t\treturn { sql: this.mapInlineParam(chunk, config), params: [] };\n\t\t\t}\n\n\t\t\treturn { sql: escapeParam(paramStartIndex.value++, chunk), params: [chunk], typings: ['none'] };\n\t\t}));\n\t}\n\n\tprivate mapInlineParam(\n\t\tchunk: unknown,\n\t\t{ escapeString }: BuildQueryConfig,\n\t): string {\n\t\tif (chunk === null) {\n\t\t\treturn 'null';\n\t\t}\n\t\tif (typeof chunk === 'number' || typeof chunk === 'boolean' || typeof chunk === 'bigint') {\n\t\t\treturn chunk.toString();\n\t\t}\n\t\tif (typeof chunk === 'string') {\n\t\t\treturn escapeString(chunk);\n\t\t}\n\t\tif (typeof chunk === 'object') {\n\t\t\tconst mappedValueAsString = chunk.toString();\n\t\t\tif (mappedValueAsString === '[object Object]') {\n\t\t\t\treturn escapeString(JSON.stringify(chunk));\n\t\t\t}\n\t\t\treturn escapeString(mappedValueAsString);\n\t\t}\n\t\tthrow new Error('Unexpected param value: ' + chunk);\n\t}\n\n\tgetSQL(): SQL<T> {\n\t\treturn this;\n\t}\n\n\tas(alias: string): SQL.Aliased<T>;\n\t/**\n\t * @deprecated\n\t * Use ``sql<DataType>`query`.as(alias)`` instead.\n\t */\n\tas<TData>(): SQL<TData>;\n\t/**\n\t * @deprecated\n\t * Use ``sql<DataType>`query`.as(alias)`` instead.\n\t */\n\tas<TData>(alias: string): SQL.Aliased<TData>;\n\tas(alias?: string): SQL<T> | SQL.Aliased<T> {\n\t\t// TODO: remove with deprecated overloads\n\t\tif (alias === undefined) {\n\t\t\treturn this;\n\t\t}\n\n\t\treturn new SQL.Aliased(this, alias);\n\t}\n\n\tmapWith<\n\t\tTDecoder extends\n\t\t\t| DriverValueDecoder<any, any>\n\t\t\t| DriverValueDecoder<any, any>['mapFromDriverValue'],\n\t>(decoder: TDecoder): SQL<GetDecoderResult<TDecoder>> {\n\t\tthis.decoder = typeof decoder === 'function' ? { mapFromDriverValue: decoder } : decoder;\n\t\treturn this as SQL<GetDecoderResult<TDecoder>>;\n\t}\n\n\tinlineParams(): this {\n\t\tthis.shouldInlineParams = true;\n\t\treturn this;\n\t}\n\n\t/**\n\t * This method is used to conditionally include a part of the query.\n\t *\n\t * @param condition - Condition to check\n\t * @returns itself if the condition is `true`, otherwise `undefined`\n\t */\n\tif(condition: any | undefined): this | undefined {\n\t\treturn condition ? this : undefined;\n\t}\n}\n\nexport type GetDecoderResult<T> = T extends Column ? T['_']['data'] : T extends\n\t| DriverValueDecoder<infer TData, any>\n\t| DriverValueDecoder<infer TData, any>['mapFromDriverValue'] ? TData\n: never;\n\n/**\n * Any DB name (table, column, index etc.)\n */\nexport class Name implements SQLWrapper {\n\tstatic readonly [entityKind]: string = 'Name';\n\n\tprotected brand!: 'Name';\n\n\tconstructor(readonly value: string) {}\n\n\tgetSQL(): SQL<unknown> {\n\t\treturn new SQL([this]);\n\t}\n}\n\n/**\n * Any DB name (table, column, index etc.)\n * @deprecated Use `sql.identifier` instead.\n */\nexport function name(value: string): Name {\n\treturn new Name(value);\n}\n\nexport interface DriverValueDecoder<TData, TDriverParam> {\n\tmapFromDriverValue(value: TDriverParam): TData;\n}\n\nexport interface DriverValueEncoder<TData, TDriverParam> {\n\tmapToDriverValue(value: TData): TDriverParam | SQL;\n}\n\nexport function isDriverValueEncoder(value: unknown): value is DriverValueEncoder<any, any> {\n\treturn typeof value === 'object' && value !== null && 'mapToDriverValue' in value\n\t\t&& typeof (value as any).mapToDriverValue === 'function';\n}\n\nexport const noopDecoder: DriverValueDecoder<any, any> = {\n\tmapFromDriverValue: (value) => value,\n};\n\nexport const noopEncoder: DriverValueEncoder<any, any> = {\n\tmapToDriverValue: (value) => value,\n};\n\nexport interface DriverValueMapper<TData, TDriverParam>\n\textends DriverValueDecoder<TData, TDriverParam>, DriverValueEncoder<TData, TDriverParam>\n{}\n\nexport const noopMapper: DriverValueMapper<any, any> = {\n\t...noopDecoder,\n\t...noopEncoder,\n};\n\n/** Parameter value that is optionally bound to an encoder (for example, a column). */\nexport class Param<TDataType = unknown, TDriverParamType = TDataType> implements SQLWrapper {\n\tstatic readonly [entityKind]: string = 'Param';\n\n\tprotected brand!: 'BoundParamValue';\n\n\t/**\n\t * @param value - Parameter value\n\t * @param encoder - Encoder to convert the value to a driver parameter\n\t */\n\tconstructor(\n\t\treadonly value: TDataType,\n\t\treadonly encoder: DriverValueEncoder<TDataType, TDriverParamType> = noopEncoder,\n\t) {}\n\n\tgetSQL(): SQL<unknown> {\n\t\treturn new SQL([this]);\n\t}\n}\n\n/** @deprecated Use `sql.param` instead. */\nexport function param<TData, TDriver>(\n\tvalue: TData,\n\tencoder?: DriverValueEncoder<TData, TDriver>,\n): Param<TData, TDriver> {\n\treturn new Param(value, encoder);\n}\n\n/**\n * Anything that can be passed to the `` sql`...` `` tagged function.\n */\nexport type SQLChunk =\n\t| StringChunk\n\t| SQLChunk[]\n\t| SQLWrapper\n\t| SQL\n\t| Table\n\t| View\n\t| Subquery\n\t| AnyColumn\n\t| Param\n\t| Name\n\t| undefined\n\t| FakePrimitiveParam\n\t| Placeholder;\n\nexport type SQLGenerator<T = unknown> = typeof sql<T>;\n\nexport function sql<T>(strings: TemplateStringsArray, ...params: any[]): SQL<T>;\n/*\n\tThe type of `params` is specified as `SQLChunk[]`, but that's slightly incorrect -\n\tin runtime, users won't pass `FakePrimitiveParam` instances as `params` - they will pass primitive values\n\twhich will be wrapped in `Param`. That's why the overload specifies `params` as `any[]` and not as `SQLSourceParam[]`.\n\tThis type is used to make our lives easier and the type checker happy.\n*/\nexport function sql(strings: TemplateStringsArray, ...params: SQLChunk[]): SQL {\n\tconst queryChunks: SQLChunk[] = [];\n\tif (params.length > 0 || (strings.length > 0 && strings[0] !== '')) {\n\t\tqueryChunks.push(new StringChunk(strings[0]!));\n\t}\n\tfor (const [paramIndex, param] of params.entries()) {\n\t\tqueryChunks.push(param, new StringChunk(strings[paramIndex + 1]!));\n\t}\n\n\treturn new SQL(queryChunks);\n}\n\nexport namespace sql {\n\texport function empty(): SQL {\n\t\treturn new SQL([]);\n\t}\n\n\t/** @deprecated - use `sql.join()` */\n\texport function fromList(list: SQLChunk[]): SQL {\n\t\treturn new SQL(list);\n\t}\n\n\t/**\n\t * Convenience function to create an SQL query from a raw string.\n\t * @param str The raw SQL query string.\n\t */\n\texport function raw(str: string): SQL {\n\t\treturn new SQL([new StringChunk(str)]);\n\t}\n\n\t/**\n\t * Join a list of SQL chunks with a separator.\n\t * @example\n\t * ```ts\n\t * const query = sql.join([sql`a`, sql`b`, sql`c`]);\n\t * // sql`abc`\n\t * ```\n\t * @example\n\t * ```ts\n\t * const query = sql.join([sql`a`, sql`b`, sql`c`], sql`, `);\n\t * // sql`a, b, c`\n\t * ```\n\t */\n\texport function join(chunks: SQLChunk[], separator?: SQLChunk): SQL {\n\t\tconst result: SQLChunk[] = [];\n\t\tfor (const [i, chunk] of chunks.entries()) {\n\t\t\tif (i > 0 && separator !== undefined) {\n\t\t\t\tresult.push(separator);\n\t\t\t}\n\t\t\tresult.push(chunk);\n\t\t}\n\t\treturn new SQL(result);\n\t}\n\n\t/**\n\t * Create a SQL chunk that represents a DB identifier (table, column, index etc.).\n\t * When used in a query, the identifier will be escaped based on the DB engine.\n\t * For example, in PostgreSQL, identifiers are escaped with double quotes.\n\t *\n\t * **WARNING: This function does not offer any protection against SQL injections, so you must validate any user input beforehand.**\n\t *\n\t * @example ```ts\n\t * const query = sql`SELECT * FROM ${sql.identifier('my-table')}`;\n\t * // 'SELECT * FROM \"my-table\"'\n\t * ```\n\t */\n\texport function identifier(value: string): Name {\n\t\treturn new Name(value);\n\t}\n\n\texport function placeholder<TName extends string>(name: TName): Placeholder<TName> {\n\t\treturn new Placeholder(name);\n\t}\n\n\texport function param<TData, TDriver>(\n\t\tvalue: TData,\n\t\tencoder?: DriverValueEncoder<TData, TDriver>,\n\t): Param<TData, TDriver> {\n\t\treturn new Param(value, encoder);\n\t}\n}\n\nexport namespace SQL {\n\texport class Aliased<T = unknown> implements SQLWrapper<T> {\n\t\tstatic readonly [entityKind]: string = 'SQL.Aliased';\n\n\t\tdeclare _: {\n\t\t\tbrand: 'SQL.Aliased';\n\t\t\ttype: T;\n\t\t};\n\n\t\t/** @internal */\n\t\tisSelectionField = false;\n\n\t\tconstructor(\n\t\t\treadonly sql: SQL<T>,\n\t\t\treadonly fieldAlias: string,\n\t\t) {}\n\n\t\tgetSQL(): SQL<T> {\n\t\t\treturn this.sql as SQL<T>;\n\t\t}\n\n\t\t/** @internal */\n\t\tclone() {\n\t\t\treturn new Aliased<T>(this.sql, this.fieldAlias);\n\t\t}\n\t}\n}\n\nexport class Placeholder<TName extends string = string, TValue = any> implements SQLWrapper {\n\tstatic readonly [entityKind]: string = 'Placeholder';\n\n\tdeclare protected: TValue;\n\n\tconstructor(readonly name: TName) {}\n\n\tgetSQL(): SQL {\n\t\treturn new SQL([this]);\n\t}\n}\n\n/** @deprecated Use `sql.placeholder` instead. */\nexport function placeholder<TName extends string>(name: TName): Placeholder<TName> {\n\treturn new Placeholder(name);\n}\n\nexport function fillPlaceholders(params: unknown[], values: Record<string, unknown>): unknown[] {\n\treturn params.map((p) => {\n\t\tif (is(p, Placeholder)) {\n\t\t\tif (!(p.name in values)) {\n\t\t\t\tthrow new Error(`No value for placeholder \"${p.name}\" was provided`);\n\t\t\t}\n\n\t\t\treturn values[p.name];\n\t\t}\n\n\t\tif (is(p, Param) && is(p.value, Placeholder)) {\n\t\t\tif (!(p.value.name in values)) {\n\t\t\t\tthrow new Error(`No value for placeholder \"${p.value.name}\" was provided`);\n\t\t\t}\n\n\t\t\treturn p.encoder.mapToDriverValue(values[p.value.name]);\n\t\t}\n\n\t\treturn p;\n\t});\n}\n\nexport type ColumnsSelection = Record<string, unknown>;\n\nconst IsDrizzleView = Symbol.for('drizzle:IsDrizzleView');\n\nexport abstract class View<\n\tTName extends string = string,\n\tTExisting extends boolean = boolean,\n\tTSelection extends ColumnsSelection = ColumnsSelection,\n> {\n\tstatic readonly [entityKind]: string = 'View';\n\n\tdeclare _: {\n\t\tbrand: 'View';\n\t\tviewBrand: string;\n\t\tname: TName;\n\t\texisting: TExisting;\n\t\tselectedFields: TSelection;\n\t};\n\n\t/** @internal */\n\t[ViewBaseConfig]: {\n\t\tname: TName;\n\t\toriginalName: TName;\n\t\tschema: string | undefined;\n\t\tselectedFields: ColumnsSelection;\n\t\tisExisting: TExisting;\n\t\tquery: TExisting extends true ? undefined : SQL;\n\t\tisAlias: boolean;\n\t};\n\n\t/** @internal */\n\t[IsDrizzleView] = true;\n\n\t/** @internal */\n\tpublic get [TableName]() {\n\t\treturn this[ViewBaseConfig].name;\n\t}\n\n\t/** @internal */\n\tpublic get [TableSchema]() {\n\t\treturn this[ViewBaseConfig].schema;\n\t}\n\n\t/** @internal */\n\tpublic get [IsAlias]() {\n\t\treturn this[ViewBaseConfig].isAlias;\n\t}\n\n\t/** @internal */\n\tpublic get [OriginalName]() {\n\t\treturn this[ViewBaseConfig].originalName;\n\t}\n\n\t/** @internal */\n\tpublic get [TableColumns]() {\n\t\treturn (this[ViewBaseConfig].selectedFields) as any as Record<string, unknown>;\n\t}\n\n\tdeclare readonly $inferSelect: InferSelectViewModel<View<Assume<TName, string>, TExisting, TSelection>>;\n\n\tconstructor(\n\t\t{ name, schema, selectedFields, query }: {\n\t\t\tname: TName;\n\t\t\tschema: string | undefined;\n\t\t\tselectedFields: ColumnsSelection;\n\t\t\tquery: SQL | undefined;\n\t\t},\n\t) {\n\t\tthis[ViewBaseConfig] = {\n\t\t\tname,\n\t\t\toriginalName: name,\n\t\t\tschema,\n\t\t\tselectedFields,\n\t\t\tquery: query as (TExisting extends true ? undefined : SQL),\n\t\t\tisExisting: !query as TExisting,\n\t\t\tisAlias: false,\n\t\t};\n\t}\n}\n\nexport function isView(view: unknown): view is View {\n\treturn typeof view === 'object' && view !== null && IsDrizzleView in view;\n}\n\nexport function getViewName<T extends View>(view: T): T['_']['name'] {\n\treturn view[ViewBaseConfig].name;\n}\n\nexport type InferSelectViewModel<TView extends View> =\n\tEqual<TView['_']['selectedFields'], { [x: string]: unknown }> extends true ? { [x: string]: unknown }\n\t\t: SelectResult<\n\t\t\tTView['_']['selectedFields'],\n\t\t\t'single',\n\t\t\tRecord<TView['_']['name'], 'not-null'>\n\t\t>;\n\n// Defined separately from the Column class to resolve circular dependency\nColumn.prototype.getSQL = function() {\n\treturn new SQL([this]);\n};\n// Defined separately from the Column class to resolve circular dependency\nSubquery.prototype.getSQL = function() {\n\treturn new SQL([this]);\n};\n\nexport type SQLEntity = SQL | SQLWrapper | SQL.Aliased | Table | View;\n"],"mappings":"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"}