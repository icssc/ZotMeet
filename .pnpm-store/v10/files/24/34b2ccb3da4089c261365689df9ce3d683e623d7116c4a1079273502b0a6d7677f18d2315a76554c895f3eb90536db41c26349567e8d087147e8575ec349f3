{"version":3,"sources":["../../../../../src/server/lib/router-utils/resolve-routes.ts"],"sourcesContent":["import type { FsOutput } from './filesystem'\nimport type { IncomingMessage, ServerResponse } from 'http'\nimport type { NextConfigRuntime } from '../../config-shared'\nimport type { RenderServer, initialize } from '../router-server'\nimport type { PatchMatcher } from '../../../shared/lib/router/utils/path-match'\nimport type { Redirect } from '../../../types'\nimport type { Header } from '../../../lib/load-custom-routes'\nimport type { UnwrapPromise } from '../../../lib/coalesced-function'\nimport type { NextUrlWithParsedQuery } from '../../request-meta'\n\nimport url from 'url'\nimport path from 'node:path'\nimport setupDebug from 'next/dist/compiled/debug'\nimport { getCloneableBody } from '../../body-streams'\nimport { filterReqHeaders, ipcForbiddenHeaders } from '../server-ipc/utils'\nimport { stringifyQuery } from '../../server-route-utils'\nimport { formatHostname } from '../format-hostname'\nimport { toNodeOutgoingHttpHeaders } from '../../web/utils'\nimport { isAbortError } from '../../pipe-readable'\nimport { getHostname } from '../../../shared/lib/get-hostname'\nimport {\n  getRedirectStatus,\n  allowedStatusCodes,\n} from '../../../lib/redirect-status'\nimport { normalizeRepeatedSlashes } from '../../../shared/lib/utils'\nimport { getRelativeURL } from '../../../shared/lib/router/utils/relativize-url'\nimport { addPathPrefix } from '../../../shared/lib/router/utils/add-path-prefix'\nimport { pathHasPrefix } from '../../../shared/lib/router/utils/path-has-prefix'\nimport { detectDomainLocale } from '../../../shared/lib/i18n/detect-domain-locale'\nimport { normalizeLocalePath } from '../../../shared/lib/i18n/normalize-locale-path'\nimport { removePathPrefix } from '../../../shared/lib/router/utils/remove-path-prefix'\nimport { NextDataPathnameNormalizer } from '../../normalizers/request/next-data'\nimport { BasePathPathnameNormalizer } from '../../normalizers/request/base-path'\n\nimport { addRequestMeta } from '../../request-meta'\nimport {\n  compileNonPath,\n  matchHas,\n  prepareDestination,\n} from '../../../shared/lib/router/utils/prepare-destination'\nimport type { TLSSocket } from 'tls'\nimport {\n  NEXT_REWRITTEN_PATH_HEADER,\n  NEXT_REWRITTEN_QUERY_HEADER,\n  RSC_HEADER,\n} from '../../../client/components/app-router-headers'\n\nconst debug = setupDebug('next:router-server:resolve-routes')\n\nexport function getResolveRoutes(\n  fsChecker: UnwrapPromise<\n    ReturnType<typeof import('./filesystem').setupFsCheck>\n  >,\n  config: NextConfigRuntime,\n  opts: Parameters<typeof initialize>[0],\n  renderServer: RenderServer,\n  renderServerOpts: Parameters<RenderServer['initialize']>[0],\n  ensureMiddleware?: (url?: string) => Promise<void>\n) {\n  type Route = {\n    /**\n     * The path matcher to check if this route applies to this request.\n     */\n    match: PatchMatcher\n    check?: boolean\n    name?: string\n  } & Partial<Header> &\n    Partial<Redirect>\n\n  let routes: Route[] | null = null\n  const calculateRoutes = () => {\n    return [\n      // _next/data with middleware handling\n      { match: () => ({}), name: 'middleware_next_data' },\n\n      ...(opts.minimalMode ? [] : fsChecker.headers),\n      ...(opts.minimalMode ? [] : fsChecker.redirects),\n\n      // check middleware (using matchers)\n      { match: () => ({}), name: 'middleware' },\n\n      ...(opts.minimalMode ? [] : fsChecker.rewrites.beforeFiles),\n\n      // check middleware (using matchers)\n      { match: () => ({}), name: 'before_files_end' },\n\n      // we check exact matches on fs before continuing to\n      // after files rewrites\n      { match: () => ({}), name: 'check_fs' },\n\n      ...(opts.minimalMode ? [] : fsChecker.rewrites.afterFiles),\n\n      // we always do the check: true handling before continuing to\n      // fallback rewrites\n      {\n        check: true,\n        match: () => ({}),\n        name: 'after files check: true',\n      },\n\n      ...(opts.minimalMode ? [] : fsChecker.rewrites.fallback),\n    ]\n  }\n\n  async function resolveRoutes({\n    req,\n    res,\n    isUpgradeReq,\n    invokedOutputs,\n  }: {\n    req: IncomingMessage\n    res: ServerResponse\n    isUpgradeReq: boolean\n    signal: AbortSignal\n    invokedOutputs?: Set<string>\n  }): Promise<{\n    finished: boolean\n    statusCode?: number\n    bodyStream?: ReadableStream | null\n    resHeaders: Record<string, string | string[]> | null\n    parsedUrl: NextUrlWithParsedQuery\n    matchedOutput?: FsOutput | null\n  }> {\n    let finished = false\n    let resHeaders: Record<string, string | string[]> = {}\n    let matchedOutput: FsOutput | null = null\n    let parsedUrl = url.parse(req.url || '', true) as NextUrlWithParsedQuery\n    let didRewrite = false\n\n    const urlParts = (req.url || '').split('?', 1)\n    const urlNoQuery = urlParts[0]\n\n    // Refresh the routes every time in development mode, but only initialize them\n    // once in production. We don't need to recompute these every time unless the routes\n    // are changing like in development, and the performance can be costly.\n    if (!routes || opts.dev) {\n      routes = calculateRoutes()\n    }\n\n    // this normalizes repeated slashes in the path e.g. hello//world ->\n    // hello/world or backslashes to forward slashes, this does not\n    // handle trailing slash as that is handled the same as a next.config.js\n    // redirect\n    if (urlNoQuery?.match(/(\\\\|\\/\\/)/)) {\n      parsedUrl = url.parse(normalizeRepeatedSlashes(req.url!), true)\n      return {\n        parsedUrl,\n        resHeaders,\n        finished: true,\n        statusCode: 308,\n      }\n    }\n    // TODO: inherit this from higher up\n    const protocol =\n      (req?.socket as TLSSocket)?.encrypted ||\n      req.headers['x-forwarded-proto']?.includes('https')\n        ? 'https'\n        : 'http'\n\n    // When there are hostname and port we build an absolute URL\n    const initUrl = (config.experimental as any).trustHostHeader\n      ? `https://${req.headers.host || 'localhost'}${req.url}`\n      : opts.port\n        ? `${protocol}://${formatHostname(opts.hostname || 'localhost')}:${\n            opts.port\n          }${req.url}`\n        : req.url || ''\n\n    addRequestMeta(req, 'initURL', initUrl)\n    addRequestMeta(req, 'initQuery', { ...parsedUrl.query })\n    addRequestMeta(req, 'initProtocol', protocol)\n\n    if (!isUpgradeReq) {\n      const bodySizeLimit = config.experimental.proxyClientMaxBodySize as\n        | number\n        | undefined\n      addRequestMeta(req, 'clonableBody', getCloneableBody(req, bodySizeLimit))\n    }\n\n    const maybeAddTrailingSlash = (pathname: string) => {\n      if (\n        config.trailingSlash &&\n        !config.skipProxyUrlNormalize &&\n        !pathname.endsWith('/')\n      ) {\n        return `${pathname}/`\n      }\n      return pathname\n    }\n\n    let domainLocale: ReturnType<typeof detectDomainLocale> | undefined\n    let defaultLocale: string | undefined\n    let initialLocaleResult:\n      | ReturnType<typeof normalizeLocalePath>\n      | undefined = undefined\n\n    if (config.i18n) {\n      const hadTrailingSlash = parsedUrl.pathname?.endsWith('/')\n      const hadBasePath = pathHasPrefix(\n        parsedUrl.pathname || '',\n        config.basePath\n      )\n      let normalizedPath = parsedUrl.pathname || '/'\n\n      if (config.basePath && pathHasPrefix(normalizedPath, config.basePath)) {\n        normalizedPath = removePathPrefix(normalizedPath, config.basePath)\n      } else if (\n        config.assetPrefix &&\n        pathHasPrefix(normalizedPath, config.assetPrefix)\n      ) {\n        normalizedPath = removePathPrefix(normalizedPath, config.assetPrefix)\n      }\n\n      initialLocaleResult = normalizeLocalePath(\n        normalizedPath,\n        config.i18n.locales\n      )\n\n      domainLocale = detectDomainLocale(\n        config.i18n.domains,\n        getHostname(parsedUrl, req.headers)\n      )\n      defaultLocale = domainLocale?.defaultLocale || config.i18n.defaultLocale\n\n      addRequestMeta(req, 'defaultLocale', defaultLocale)\n      addRequestMeta(\n        req,\n        'locale',\n        initialLocaleResult.detectedLocale || defaultLocale\n      )\n\n      // ensure locale is present for resolving routes\n      if (\n        !initialLocaleResult.detectedLocale &&\n        !initialLocaleResult.pathname.startsWith('/_next/')\n      ) {\n        parsedUrl.pathname = addPathPrefix(\n          initialLocaleResult.pathname === '/'\n            ? `/${defaultLocale}`\n            : addPathPrefix(\n                initialLocaleResult.pathname || '',\n                `/${defaultLocale}`\n              ),\n          hadBasePath ? config.basePath : ''\n        )\n\n        if (hadTrailingSlash) {\n          parsedUrl.pathname = maybeAddTrailingSlash(parsedUrl.pathname)\n        }\n      }\n    }\n\n    const checkLocaleApi = (pathname: string) => {\n      if (\n        config.i18n &&\n        pathname === urlNoQuery &&\n        initialLocaleResult?.detectedLocale &&\n        pathHasPrefix(initialLocaleResult.pathname, '/api')\n      ) {\n        return true\n      }\n    }\n\n    async function checkTrue() {\n      const pathname = parsedUrl.pathname || '/'\n\n      if (checkLocaleApi(pathname)) {\n        return\n      }\n      if (!invokedOutputs?.has(pathname)) {\n        const output = await fsChecker.getItem(pathname)\n\n        if (output) {\n          if (\n            config.useFileSystemPublicRoutes ||\n            didRewrite ||\n            (output.type !== 'appFile' && output.type !== 'pageFile')\n          ) {\n            return output\n          }\n        }\n      }\n      const dynamicRoutes = fsChecker.getDynamicRoutes()\n      let curPathname = parsedUrl.pathname\n\n      if (config.basePath) {\n        if (!pathHasPrefix(curPathname || '', config.basePath)) {\n          return\n        }\n        curPathname = curPathname?.substring(config.basePath.length) || '/'\n      }\n      const localeResult = fsChecker.handleLocale(curPathname || '')\n\n      for (const route of dynamicRoutes) {\n        // when resolving fallback: false the\n        // render worker may return a no-fallback response\n        // which signals we need to continue resolving.\n        // TODO: optimize this to collect static paths\n        // to use at the routing layer\n        if (invokedOutputs?.has(route.page)) {\n          continue\n        }\n        const params = route.match(localeResult.pathname)\n\n        if (params) {\n          const pageOutput = await fsChecker.getItem(\n            addPathPrefix(route.page, config.basePath || '')\n          )\n\n          // i18n locales aren't matched for app dir\n          if (\n            pageOutput?.type === 'appFile' &&\n            initialLocaleResult?.detectedLocale\n          ) {\n            continue\n          }\n\n          if (pageOutput && curPathname?.startsWith('/_next/data')) {\n            addRequestMeta(req, 'isNextDataReq', true)\n          }\n\n          if (config.useFileSystemPublicRoutes || didRewrite) {\n            return pageOutput\n          }\n        }\n      }\n    }\n\n    const normalizers = {\n      basePath:\n        config.basePath && config.basePath !== '/'\n          ? new BasePathPathnameNormalizer(config.basePath)\n          : undefined,\n      data: new NextDataPathnameNormalizer(fsChecker.buildId),\n    }\n\n    async function handleRoute(\n      route: Route\n    ): Promise<UnwrapPromise<ReturnType<typeof resolveRoutes>> | void> {\n      let curPathname = parsedUrl.pathname || '/'\n\n      if (config.i18n && route.internal) {\n        const hadTrailingSlash = curPathname.endsWith('/')\n\n        if (config.basePath) {\n          curPathname = removePathPrefix(curPathname, config.basePath)\n        }\n        const hadBasePath = curPathname !== parsedUrl.pathname\n\n        const localeResult = normalizeLocalePath(\n          curPathname,\n          config.i18n.locales\n        )\n        const isDefaultLocale = localeResult.detectedLocale === defaultLocale\n\n        if (isDefaultLocale) {\n          curPathname =\n            localeResult.pathname === '/' && hadBasePath\n              ? config.basePath\n              : addPathPrefix(\n                  localeResult.pathname,\n                  hadBasePath ? config.basePath : ''\n                )\n        } else if (hadBasePath) {\n          curPathname =\n            curPathname === '/'\n              ? config.basePath\n              : addPathPrefix(curPathname, config.basePath)\n        }\n\n        if ((isDefaultLocale || hadBasePath) && hadTrailingSlash) {\n          curPathname = maybeAddTrailingSlash(curPathname)\n        }\n      }\n      let params = route.match(curPathname)\n\n      if ((route.has || route.missing) && params) {\n        const hasParams = matchHas(\n          req,\n          parsedUrl.query,\n          route.has,\n          route.missing\n        )\n        if (hasParams) {\n          Object.assign(params, hasParams)\n        } else {\n          params = false\n        }\n      }\n\n      if (params) {\n        if (\n          fsChecker.exportPathMapRoutes &&\n          route.name === 'before_files_end'\n        ) {\n          for (const exportPathMapRoute of fsChecker.exportPathMapRoutes) {\n            const result = await handleRoute(exportPathMapRoute)\n\n            if (result) {\n              return result\n            }\n          }\n        }\n\n        if (route.name === 'middleware_next_data' && parsedUrl.pathname) {\n          if (fsChecker.getMiddlewareMatchers()?.length) {\n            let normalized = parsedUrl.pathname\n\n            // Remove the base path if it exists.\n            const hadBasePath = normalizers.basePath?.match(parsedUrl.pathname)\n            if (hadBasePath && normalizers.basePath) {\n              normalized = normalizers.basePath.normalize(normalized, true)\n            }\n\n            let updated = false\n            if (normalizers.data.match(normalized)) {\n              updated = true\n              addRequestMeta(req, 'isNextDataReq', true)\n              normalized = normalizers.data.normalize(normalized, true)\n            }\n\n            if (config.i18n) {\n              const curLocaleResult = normalizeLocalePath(\n                normalized,\n                config.i18n.locales\n              )\n\n              if (curLocaleResult.detectedLocale) {\n                addRequestMeta(req, 'locale', curLocaleResult.detectedLocale)\n              }\n            }\n\n            // If we updated the pathname, and it had a base path, re-add the\n            // base path.\n            if (updated) {\n              if (hadBasePath) {\n                normalized =\n                  normalized === '/'\n                    ? config.basePath\n                    : path.posix.join(config.basePath, normalized)\n              }\n\n              // Re-add the trailing slash (if required).\n              normalized = maybeAddTrailingSlash(normalized)\n\n              parsedUrl.pathname = normalized\n            }\n          }\n        }\n\n        if (route.name === 'check_fs') {\n          const pathname = parsedUrl.pathname || '/'\n\n          if (invokedOutputs?.has(pathname) || checkLocaleApi(pathname)) {\n            return\n          }\n          const output = await fsChecker.getItem(pathname)\n\n          if (\n            output &&\n            !(\n              config.i18n &&\n              initialLocaleResult?.detectedLocale &&\n              pathHasPrefix(pathname, '/api')\n            )\n          ) {\n            if (\n              config.useFileSystemPublicRoutes ||\n              didRewrite ||\n              (output.type !== 'appFile' && output.type !== 'pageFile')\n            ) {\n              matchedOutput = output\n\n              if (output.locale) {\n                addRequestMeta(req, 'locale', output.locale)\n              }\n              return {\n                parsedUrl,\n                resHeaders,\n                finished: true,\n                matchedOutput,\n              }\n            }\n          }\n        }\n\n        if (!opts.minimalMode && route.name === 'middleware') {\n          const match = fsChecker.getMiddlewareMatchers()\n          let maybeDecodedPathname = parsedUrl.pathname || '/'\n\n          try {\n            maybeDecodedPathname = decodeURIComponent(maybeDecodedPathname)\n          } catch {\n            /* non-fatal we can't decode so can't match it */\n          }\n\n          if (\n            // @ts-expect-error BaseNextRequest stuff\n            match?.(parsedUrl.pathname, req, parsedUrl.query) ||\n            match?.(\n              maybeDecodedPathname,\n              // @ts-expect-error BaseNextRequest stuff\n              req,\n              parsedUrl.query\n            )\n          ) {\n            if (ensureMiddleware) {\n              await ensureMiddleware(req.url)\n            }\n\n            const serverResult =\n              await renderServer?.initialize(renderServerOpts)\n\n            if (!serverResult) {\n              throw new Error(`Failed to initialize render server \"middleware\"`)\n            }\n\n            addRequestMeta(req, 'invokePath', '')\n            addRequestMeta(req, 'invokeOutput', '')\n            addRequestMeta(req, 'invokeQuery', {})\n            addRequestMeta(req, 'middlewareInvoke', true)\n            if (opts.dev) {\n              addRequestMeta(\n                req,\n                'devRequestTimingMiddlewareStart',\n                process.hrtime.bigint()\n              )\n            }\n            debug('invoking middleware', req.url, req.headers)\n\n            let middlewareRes: Response | undefined = undefined\n            let bodyStream: ReadableStream | undefined = undefined\n            try {\n              try {\n                await serverResult.requestHandler(req, res, parsedUrl)\n              } catch (err: any) {\n                if (!('result' in err) || !('response' in err.result)) {\n                  throw err\n                }\n                middlewareRes = err.result.response as Response\n                res.statusCode = middlewareRes.status\n\n                if (middlewareRes.body) {\n                  bodyStream = middlewareRes.body\n                } else if (middlewareRes.status) {\n                  bodyStream = new ReadableStream({\n                    start(controller) {\n                      controller.enqueue('')\n                      controller.close()\n                    },\n                  })\n                }\n              } finally {\n                if (opts.dev) {\n                  addRequestMeta(\n                    req,\n                    'devRequestTimingMiddlewareEnd',\n                    process.hrtime.bigint()\n                  )\n                }\n              }\n            } catch (e) {\n              // If the client aborts before we can receive a response object\n              // (when the headers are flushed), then we can early exit without\n              // further processing.\n              if (isAbortError(e)) {\n                return {\n                  parsedUrl,\n                  resHeaders,\n                  finished: true,\n                }\n              }\n              throw e\n            }\n\n            if (res.closed || res.finished || !middlewareRes) {\n              return {\n                parsedUrl,\n                resHeaders,\n                finished: true,\n              }\n            }\n\n            const middlewareHeaders = toNodeOutgoingHttpHeaders(\n              middlewareRes.headers\n            ) as Record<string, string | string[] | undefined>\n\n            debug('middleware res', middlewareRes.status, middlewareHeaders)\n\n            if (middlewareHeaders['x-middleware-override-headers']) {\n              const overriddenHeaders: Set<string> = new Set()\n              let overrideHeaders: string | string[] =\n                middlewareHeaders['x-middleware-override-headers']\n\n              if (typeof overrideHeaders === 'string') {\n                overrideHeaders = overrideHeaders.split(',')\n              }\n\n              for (const key of overrideHeaders) {\n                overriddenHeaders.add(key.trim())\n              }\n              delete middlewareHeaders['x-middleware-override-headers']\n\n              // Delete headers.\n              for (const key of Object.keys(req.headers)) {\n                if (!overriddenHeaders.has(key)) {\n                  delete req.headers[key]\n                }\n              }\n\n              // Update or add headers.\n              for (const key of overriddenHeaders.keys()) {\n                const valueKey = 'x-middleware-request-' + key\n                const newValue = middlewareHeaders[valueKey]\n                const oldValue = req.headers[key]\n\n                if (oldValue !== newValue) {\n                  req.headers[key] = newValue === null ? undefined : newValue\n                }\n                delete middlewareHeaders[valueKey]\n              }\n            }\n\n            if (\n              !middlewareHeaders['x-middleware-rewrite'] &&\n              !middlewareHeaders['x-middleware-next'] &&\n              !middlewareHeaders['location']\n            ) {\n              middlewareHeaders['x-middleware-refresh'] = '1'\n            }\n            delete middlewareHeaders['x-middleware-next']\n\n            for (const [key, value] of Object.entries({\n              ...filterReqHeaders(middlewareHeaders, ipcForbiddenHeaders),\n            })) {\n              if (\n                [\n                  'content-length',\n                  'x-middleware-rewrite',\n                  'x-middleware-redirect',\n                  'x-middleware-refresh',\n                ].includes(key)\n              ) {\n                continue\n              }\n\n              // for set-cookie, the header shouldn't be added to the response\n              // as it's only needed for the request to the middleware function.\n              if (key === 'x-middleware-set-cookie') {\n                req.headers[key] = value\n                continue\n              }\n\n              if (value) {\n                resHeaders[key] = value\n                req.headers[key] = value\n              }\n            }\n\n            if (middlewareHeaders['x-middleware-rewrite']) {\n              const value = middlewareHeaders['x-middleware-rewrite'] as string\n              const destination = getRelativeURL(value, initUrl)\n              resHeaders['x-middleware-rewrite'] = destination\n\n              parsedUrl = url.parse(destination, true)\n\n              if (parsedUrl.protocol) {\n                return {\n                  parsedUrl,\n                  resHeaders,\n                  finished: true,\n                }\n              }\n\n              if (config.i18n) {\n                const curLocaleResult = normalizeLocalePath(\n                  parsedUrl.pathname || '',\n                  config.i18n.locales\n                )\n\n                if (curLocaleResult.detectedLocale) {\n                  addRequestMeta(req, 'locale', curLocaleResult.detectedLocale)\n                }\n              }\n            }\n\n            if (middlewareHeaders['location']) {\n              const value = middlewareHeaders['location'] as string\n\n              // Only process Location header as a redirect if it has a proper redirect status\n              // This prevents a Location header with non-redirect status from being treated as a redirect\n              const isRedirectStatus = allowedStatusCodes.has(\n                middlewareRes.status\n              )\n\n              if (isRedirectStatus) {\n                // Process as redirect: update parsedUrl and convert to relative URL\n                const rel = getRelativeURL(value, initUrl)\n                resHeaders['location'] = rel\n                parsedUrl = url.parse(rel, true)\n\n                return {\n                  parsedUrl,\n                  resHeaders,\n                  finished: true,\n                  statusCode: middlewareRes.status,\n                }\n              } else {\n                // Not a redirect: just pass through the Location header\n                resHeaders['location'] = value\n\n                return {\n                  parsedUrl,\n                  resHeaders,\n                  finished: true,\n                  bodyStream,\n                  statusCode: middlewareRes.status,\n                }\n              }\n            }\n\n            if (middlewareHeaders['x-middleware-refresh']) {\n              return {\n                parsedUrl,\n                resHeaders,\n                finished: true,\n                bodyStream,\n                statusCode: middlewareRes.status,\n              }\n            }\n          }\n        }\n\n        // handle redirect\n        if (\n          ('statusCode' in route || 'permanent' in route) &&\n          route.destination\n        ) {\n          const { parsedDestination } = prepareDestination({\n            appendParamsToQuery: false,\n            destination: route.destination,\n            params: params,\n            query: parsedUrl.query,\n          })\n\n          const { query } = parsedDestination\n          delete (parsedDestination as any).query\n\n          parsedDestination.search = stringifyQuery(req as any, query)\n\n          parsedDestination.pathname = normalizeRepeatedSlashes(\n            parsedDestination.pathname\n          )\n\n          // @ts-expect-error // custom ParsedUrl\n          const unsafeParsedUrl: NextUrlWithParsedQuery = parsedDestination\n          return {\n            finished: true,\n            parsedUrl: unsafeParsedUrl,\n            resHeaders: null,\n            statusCode: getRedirectStatus(route),\n          }\n        }\n\n        // handle headers\n        if (route.headers) {\n          const hasParams = Object.keys(params).length > 0\n          for (const header of route.headers) {\n            let { key, value } = header\n            if (hasParams) {\n              key = compileNonPath(key, params)\n              value = compileNonPath(value, params)\n            }\n\n            if (key.toLowerCase() === 'set-cookie') {\n              if (!Array.isArray(resHeaders[key])) {\n                const val = resHeaders[key]\n                resHeaders[key] = typeof val === 'string' ? [val] : []\n              }\n              ;(resHeaders[key] as string[]).push(value)\n            } else {\n              resHeaders[key] = value\n            }\n          }\n        }\n\n        // handle rewrite\n        if (route.destination) {\n          let rewriteParams = params\n\n          const { parsedDestination } = prepareDestination({\n            appendParamsToQuery: true,\n            destination: route.destination,\n            params: rewriteParams,\n            query: parsedUrl.query,\n          })\n\n          // Check to see if this is a non-relative rewrite. If it is, we need\n          // to check to see if it's an allowed origin to receive the rewritten\n          // headers.\n          const parsedDestinationOrigin = parsedDestination.origin\n          const isAllowedOrigin = parsedDestinationOrigin\n            ? config.experimental.clientParamParsingOrigins?.some((origin) =>\n                new RegExp(origin).test(parsedDestinationOrigin)\n              )\n            : false\n\n          // Set the rewrite headers only if this is a RSC request.\n          if (\n            req.headers[RSC_HEADER] === '1' &&\n            (!parsedDestination.origin || isAllowedOrigin)\n          ) {\n            // We set the rewritten path and query headers on the response now\n            // that we know that the it's not an external rewrite.\n            if (parsedUrl.pathname !== parsedDestination.pathname) {\n              res.setHeader(\n                NEXT_REWRITTEN_PATH_HEADER,\n                parsedDestination.pathname\n              )\n            }\n            if (parsedUrl.search !== parsedDestination.search) {\n              res.setHeader(\n                NEXT_REWRITTEN_QUERY_HEADER,\n                // remove the leading ? from the search\n                parsedDestination.search.slice(1)\n              )\n            }\n          }\n\n          if (parsedDestination.protocol) {\n            // @ts-expect-error // custom ParsedUrl\n            const unsafeParsedUrl: NextUrlWithParsedQuery = parsedDestination\n            return {\n              parsedUrl: unsafeParsedUrl,\n              resHeaders: null,\n              finished: true,\n            }\n          }\n\n          if (config.i18n) {\n            const curLocaleResult = normalizeLocalePath(\n              removePathPrefix(parsedDestination.pathname, config.basePath),\n              config.i18n.locales\n            )\n\n            if (curLocaleResult.detectedLocale) {\n              addRequestMeta(req, 'locale', curLocaleResult.detectedLocale)\n            }\n          }\n          didRewrite = true\n          parsedUrl.pathname = parsedDestination.pathname\n          Object.assign(parsedUrl.query, parsedDestination.query)\n        }\n\n        // handle check: true\n        if (route.check) {\n          const output = await checkTrue()\n\n          if (output) {\n            return {\n              parsedUrl,\n              resHeaders,\n              finished: true,\n              matchedOutput: output,\n            }\n          }\n        }\n      }\n    }\n\n    for (const route of routes) {\n      const result = await handleRoute(route)\n      if (result) {\n        return result\n      }\n    }\n\n    return {\n      finished,\n      parsedUrl,\n      resHeaders,\n      matchedOutput,\n    }\n  }\n\n  return resolveRoutes\n}\n"],"names":["url","path","setupDebug","getCloneableBody","filterReqHeaders","ipcForbiddenHeaders","stringifyQuery","formatHostname","toNodeOutgoingHttpHeaders","isAbortError","getHostname","getRedirectStatus","allowedStatusCodes","normalizeRepeatedSlashes","getRelativeURL","addPathPrefix","pathHasPrefix","detectDomainLocale","normalizeLocalePath","removePathPrefix","NextDataPathnameNormalizer","BasePathPathnameNormalizer","addRequestMeta","compileNonPath","matchHas","prepareDestination","NEXT_REWRITTEN_PATH_HEADER","NEXT_REWRITTEN_QUERY_HEADER","RSC_HEADER","debug","getResolveRoutes","fsChecker","config","opts","renderServer","renderServerOpts","ensureMiddleware","routes","calculateRoutes","match","name","minimalMode","headers","redirects","rewrites","beforeFiles","afterFiles","check","fallback","resolveRoutes","req","res","isUpgradeReq","invokedOutputs","finished","resHeaders","matchedOutput","parsedUrl","parse","didRewrite","urlParts","split","urlNoQuery","dev","statusCode","protocol","socket","encrypted","includes","initUrl","experimental","trustHostHeader","host","port","hostname","query","bodySizeLimit","proxyClientMaxBodySize","maybeAddTrailingSlash","pathname","trailingSlash","skipProxyUrlNormalize","endsWith","domainLocale","defaultLocale","initialLocaleResult","undefined","i18n","hadTrailingSlash","hadBasePath","basePath","normalizedPath","assetPrefix","locales","domains","detectedLocale","startsWith","checkLocaleApi","checkTrue","has","output","getItem","useFileSystemPublicRoutes","type","dynamicRoutes","getDynamicRoutes","curPathname","substring","length","localeResult","handleLocale","route","page","params","pageOutput","normalizers","data","buildId","handleRoute","internal","isDefaultLocale","missing","hasParams","Object","assign","exportPathMapRoutes","exportPathMapRoute","result","getMiddlewareMatchers","normalized","normalize","updated","curLocaleResult","posix","join","locale","maybeDecodedPathname","decodeURIComponent","serverResult","initialize","Error","process","hrtime","bigint","middlewareRes","bodyStream","requestHandler","err","response","status","body","ReadableStream","start","controller","enqueue","close","e","closed","middlewareHeaders","overriddenHeaders","Set","overrideHeaders","key","add","trim","keys","valueKey","newValue","oldValue","value","entries","destination","isRedirectStatus","rel","parsedDestination","appendParamsToQuery","search","unsafeParsedUrl","header","toLowerCase","Array","isArray","val","push","rewriteParams","parsedDestinationOrigin","origin","isAllowedOrigin","clientParamParsingOrigins","some","RegExp","test","setHeader","slice"],"mappings":"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","ignoreList":[0]}