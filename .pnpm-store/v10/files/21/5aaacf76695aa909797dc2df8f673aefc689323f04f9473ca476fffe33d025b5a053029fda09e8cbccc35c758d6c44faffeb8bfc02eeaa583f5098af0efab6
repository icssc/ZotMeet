const require_chunk = require('./chunk-CdAKIUsw.js');
const require_ddl = require('./ddl-SsGc2gVn.js');
const require_utils = require('./utils-D2E5ChQ0.js');
const require_grammar = require('./grammar-B2XVJ90y.js');
const require_types = require('./types-KQgd7P_m.js');
const require_snapshot = require('./snapshot-BG6vPgbm.js');
const require_brace_expansion$1 = require('./brace-expansion-BfFnz-Zg.js');
let _js_temporal_polyfill = require("@js-temporal/polyfill");
let crypto = require("crypto");
let url = require("url");

//#region ../node_modules/.pnpm/fs.realpath@1.0.0/node_modules/fs.realpath/old.js
var require_old = /* @__PURE__ */ require_chunk.__commonJSMin(((exports) => {
	var pathModule = require("path");
	var isWindows = process.platform === "win32";
	var fs$3 = require("fs");
	var DEBUG = process.env.NODE_DEBUG && /fs/.test(process.env.NODE_DEBUG);
	function rethrow() {
		var callback;
		if (DEBUG) {
			var backtrace = /* @__PURE__ */ new Error();
			callback = debugCallback;
		} else callback = missingCallback;
		return callback;
		function debugCallback(err) {
			if (err) {
				backtrace.message = err.message;
				err = backtrace;
				missingCallback(err);
			}
		}
		function missingCallback(err) {
			if (err) {
				if (process.throwDeprecation) throw err;
				else if (!process.noDeprecation) {
					var msg = "fs: missing callback " + (err.stack || err.message);
					if (process.traceDeprecation) console.trace(msg);
					else console.error(msg);
				}
			}
		}
	}
	function maybeCallback(cb) {
		return typeof cb === "function" ? cb : rethrow();
	}
	pathModule.normalize;
	if (isWindows) var nextPartRe = /(.*?)(?:[\/\\]+|$)/g;
	else var nextPartRe = /(.*?)(?:[\/]+|$)/g;
	if (isWindows) var splitRootRe = /^(?:[a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/][^\\\/]+)?[\\\/]*/;
	else var splitRootRe = /^[\/]*/;
	exports.realpathSync = function realpathSync(p, cache) {
		p = pathModule.resolve(p);
		if (cache && Object.prototype.hasOwnProperty.call(cache, p)) return cache[p];
		var original = p, seenLinks = {}, knownHard = {};
		var pos;
		var current;
		var base;
		var previous;
		start();
		function start() {
			var m = splitRootRe.exec(p);
			pos = m[0].length;
			current = m[0];
			base = m[0];
			previous = "";
			if (isWindows && !knownHard[base]) {
				fs$3.lstatSync(base);
				knownHard[base] = true;
			}
		}
		while (pos < p.length) {
			nextPartRe.lastIndex = pos;
			var result = nextPartRe.exec(p);
			previous = current;
			current += result[0];
			base = previous + result[1];
			pos = nextPartRe.lastIndex;
			if (knownHard[base] || cache && cache[base] === base) continue;
			var resolvedLink;
			if (cache && Object.prototype.hasOwnProperty.call(cache, base)) resolvedLink = cache[base];
			else {
				var stat = fs$3.lstatSync(base);
				if (!stat.isSymbolicLink()) {
					knownHard[base] = true;
					if (cache) cache[base] = base;
					continue;
				}
				var linkTarget = null;
				if (!isWindows) {
					var id = stat.dev.toString(32) + ":" + stat.ino.toString(32);
					if (seenLinks.hasOwnProperty(id)) linkTarget = seenLinks[id];
				}
				if (linkTarget === null) {
					fs$3.statSync(base);
					linkTarget = fs$3.readlinkSync(base);
				}
				resolvedLink = pathModule.resolve(previous, linkTarget);
				if (cache) cache[base] = resolvedLink;
				if (!isWindows) seenLinks[id] = linkTarget;
			}
			p = pathModule.resolve(resolvedLink, p.slice(pos));
			start();
		}
		if (cache) cache[original] = p;
		return p;
	};
	exports.realpath = function realpath(p, cache, cb) {
		if (typeof cb !== "function") {
			cb = maybeCallback(cache);
			cache = null;
		}
		p = pathModule.resolve(p);
		if (cache && Object.prototype.hasOwnProperty.call(cache, p)) return process.nextTick(cb.bind(null, null, cache[p]));
		var original = p, seenLinks = {}, knownHard = {};
		var pos;
		var current;
		var base;
		var previous;
		start();
		function start() {
			var m = splitRootRe.exec(p);
			pos = m[0].length;
			current = m[0];
			base = m[0];
			previous = "";
			if (isWindows && !knownHard[base]) fs$3.lstat(base, function(err) {
				if (err) return cb(err);
				knownHard[base] = true;
				LOOP();
			});
			else process.nextTick(LOOP);
		}
		function LOOP() {
			if (pos >= p.length) {
				if (cache) cache[original] = p;
				return cb(null, p);
			}
			nextPartRe.lastIndex = pos;
			var result = nextPartRe.exec(p);
			previous = current;
			current += result[0];
			base = previous + result[1];
			pos = nextPartRe.lastIndex;
			if (knownHard[base] || cache && cache[base] === base) return process.nextTick(LOOP);
			if (cache && Object.prototype.hasOwnProperty.call(cache, base)) return gotResolvedLink(cache[base]);
			return fs$3.lstat(base, gotStat);
		}
		function gotStat(err, stat) {
			if (err) return cb(err);
			if (!stat.isSymbolicLink()) {
				knownHard[base] = true;
				if (cache) cache[base] = base;
				return process.nextTick(LOOP);
			}
			if (!isWindows) {
				var id = stat.dev.toString(32) + ":" + stat.ino.toString(32);
				if (seenLinks.hasOwnProperty(id)) return gotTarget(null, seenLinks[id], base);
			}
			fs$3.stat(base, function(err$1) {
				if (err$1) return cb(err$1);
				fs$3.readlink(base, function(err$2, target) {
					if (!isWindows) seenLinks[id] = target;
					gotTarget(err$2, target);
				});
			});
		}
		function gotTarget(err, target, base$1) {
			if (err) return cb(err);
			var resolvedLink = pathModule.resolve(previous, target);
			if (cache) cache[base$1] = resolvedLink;
			gotResolvedLink(resolvedLink);
		}
		function gotResolvedLink(resolvedLink) {
			p = pathModule.resolve(resolvedLink, p.slice(pos));
			start();
		}
	};
}));

//#endregion
//#region ../node_modules/.pnpm/fs.realpath@1.0.0/node_modules/fs.realpath/index.js
var require_fs = /* @__PURE__ */ require_chunk.__commonJSMin(((exports, module) => {
	module.exports = realpath;
	realpath.realpath = realpath;
	realpath.sync = realpathSync;
	realpath.realpathSync = realpathSync;
	realpath.monkeypatch = monkeypatch;
	realpath.unmonkeypatch = unmonkeypatch;
	var fs$2 = require("fs");
	var origRealpath = fs$2.realpath;
	var origRealpathSync = fs$2.realpathSync;
	var version = process.version;
	var ok = /^v[0-5]\./.test(version);
	var old = require_old();
	function newError(er) {
		return er && er.syscall === "realpath" && (er.code === "ELOOP" || er.code === "ENOMEM" || er.code === "ENAMETOOLONG");
	}
	function realpath(p, cache, cb) {
		if (ok) return origRealpath(p, cache, cb);
		if (typeof cache === "function") {
			cb = cache;
			cache = null;
		}
		origRealpath(p, cache, function(er, result) {
			if (newError(er)) old.realpath(p, cache, cb);
			else cb(er, result);
		});
	}
	function realpathSync(p, cache) {
		if (ok) return origRealpathSync(p, cache);
		try {
			return origRealpathSync(p, cache);
		} catch (er) {
			if (newError(er)) return old.realpathSync(p, cache);
			else throw er;
		}
	}
	function monkeypatch() {
		fs$2.realpath = realpath;
		fs$2.realpathSync = realpathSync;
	}
	function unmonkeypatch() {
		fs$2.realpath = origRealpath;
		fs$2.realpathSync = origRealpathSync;
	}
}));

//#endregion
//#region ../node_modules/.pnpm/minimatch@5.1.6/node_modules/minimatch/lib/path.js
var require_path = /* @__PURE__ */ require_chunk.__commonJSMin(((exports, module) => {
	const isWindows = typeof process === "object" && process && process.platform === "win32";
	module.exports = isWindows ? { sep: "\\" } : { sep: "/" };
}));

//#endregion
//#region ../node_modules/.pnpm/minimatch@5.1.6/node_modules/minimatch/minimatch.js
var require_minimatch = /* @__PURE__ */ require_chunk.__commonJSMin(((exports, module) => {
	const minimatch = module.exports = (p, pattern, options = {}) => {
		assertValidPattern(pattern);
		if (!options.nocomment && pattern.charAt(0) === "#") return false;
		return new Minimatch(pattern, options).match(p);
	};
	module.exports = minimatch;
	const path = require_path();
	minimatch.sep = path.sep;
	const GLOBSTAR = Symbol("globstar **");
	minimatch.GLOBSTAR = GLOBSTAR;
	const expand = require_brace_expansion$1.require_brace_expansion();
	const plTypes = {
		"!": {
			open: "(?:(?!(?:",
			close: "))[^/]*?)"
		},
		"?": {
			open: "(?:",
			close: ")?"
		},
		"+": {
			open: "(?:",
			close: ")+"
		},
		"*": {
			open: "(?:",
			close: ")*"
		},
		"@": {
			open: "(?:",
			close: ")"
		}
	};
	const qmark = "[^/]";
	const star = qmark + "*?";
	const twoStarDot = "(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?";
	const twoStarNoDot = "(?:(?!(?:\\/|^)\\.).)*?";
	const charSet = (s) => s.split("").reduce((set, c) => {
		set[c] = true;
		return set;
	}, {});
	const reSpecials = charSet("().*{}+?[]^$\\!");
	const addPatternStartSet = charSet("[.(");
	const slashSplit = /\/+/;
	minimatch.filter = (pattern, options = {}) => (p, i, list) => minimatch(p, pattern, options);
	const ext = (a, b = {}) => {
		const t = {};
		Object.keys(a).forEach((k) => t[k] = a[k]);
		Object.keys(b).forEach((k) => t[k] = b[k]);
		return t;
	};
	minimatch.defaults = (def) => {
		if (!def || typeof def !== "object" || !Object.keys(def).length) return minimatch;
		const orig = minimatch;
		const m = (p, pattern, options) => orig(p, pattern, ext(def, options));
		m.Minimatch = class Minimatch extends orig.Minimatch {
			constructor(pattern, options) {
				super(pattern, ext(def, options));
			}
		};
		m.Minimatch.defaults = (options) => orig.defaults(ext(def, options)).Minimatch;
		m.filter = (pattern, options) => orig.filter(pattern, ext(def, options));
		m.defaults = (options) => orig.defaults(ext(def, options));
		m.makeRe = (pattern, options) => orig.makeRe(pattern, ext(def, options));
		m.braceExpand = (pattern, options) => orig.braceExpand(pattern, ext(def, options));
		m.match = (list, pattern, options) => orig.match(list, pattern, ext(def, options));
		return m;
	};
	minimatch.braceExpand = (pattern, options) => braceExpand(pattern, options);
	const braceExpand = (pattern, options = {}) => {
		assertValidPattern(pattern);
		if (options.nobrace || !/\{(?:(?!\{).)*\}/.test(pattern)) return [pattern];
		return expand(pattern);
	};
	const MAX_PATTERN_LENGTH = 1024 * 64;
	const assertValidPattern = (pattern) => {
		if (typeof pattern !== "string") throw new TypeError("invalid pattern");
		if (pattern.length > MAX_PATTERN_LENGTH) throw new TypeError("pattern is too long");
	};
	const SUBPARSE = Symbol("subparse");
	minimatch.makeRe = (pattern, options) => new Minimatch(pattern, options || {}).makeRe();
	minimatch.match = (list, pattern, options = {}) => {
		const mm = new Minimatch(pattern, options);
		list = list.filter((f) => mm.match(f));
		if (mm.options.nonull && !list.length) list.push(pattern);
		return list;
	};
	const globUnescape = (s) => s.replace(/\\(.)/g, "$1");
	const charUnescape = (s) => s.replace(/\\([^-\]])/g, "$1");
	const regExpEscape = (s) => s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
	const braExpEscape = (s) => s.replace(/[[\]\\]/g, "\\$&");
	var Minimatch = class {
		constructor(pattern, options) {
			assertValidPattern(pattern);
			if (!options) options = {};
			this.options = options;
			this.set = [];
			this.pattern = pattern;
			this.windowsPathsNoEscape = !!options.windowsPathsNoEscape || options.allowWindowsEscape === false;
			if (this.windowsPathsNoEscape) this.pattern = this.pattern.replace(/\\/g, "/");
			this.regexp = null;
			this.negate = false;
			this.comment = false;
			this.empty = false;
			this.partial = !!options.partial;
			this.make();
		}
		debug() {}
		make() {
			const pattern = this.pattern;
			const options = this.options;
			if (!options.nocomment && pattern.charAt(0) === "#") {
				this.comment = true;
				return;
			}
			if (!pattern) {
				this.empty = true;
				return;
			}
			this.parseNegate();
			let set = this.globSet = this.braceExpand();
			if (options.debug) this.debug = (...args) => console.error(...args);
			this.debug(this.pattern, set);
			set = this.globParts = set.map((s) => s.split(slashSplit));
			this.debug(this.pattern, set);
			set = set.map((s, si, set$1) => s.map(this.parse, this));
			this.debug(this.pattern, set);
			set = set.filter((s) => s.indexOf(false) === -1);
			this.debug(this.pattern, set);
			this.set = set;
		}
		parseNegate() {
			if (this.options.nonegate) return;
			const pattern = this.pattern;
			let negate = false;
			let negateOffset = 0;
			for (let i = 0; i < pattern.length && pattern.charAt(i) === "!"; i++) {
				negate = !negate;
				negateOffset++;
			}
			if (negateOffset) this.pattern = pattern.slice(negateOffset);
			this.negate = negate;
		}
		matchOne(file, pattern, partial) {
			var options = this.options;
			this.debug("matchOne", {
				"this": this,
				file,
				pattern
			});
			this.debug("matchOne", file.length, pattern.length);
			for (var fi = 0, pi = 0, fl = file.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++) {
				this.debug("matchOne loop");
				var p = pattern[pi];
				var f = file[fi];
				this.debug(pattern, p, f);
				/* istanbul ignore if */
				if (p === false) return false;
				if (p === GLOBSTAR) {
					this.debug("GLOBSTAR", [
						pattern,
						p,
						f
					]);
					var fr = fi;
					var pr = pi + 1;
					if (pr === pl) {
						this.debug("** at the end");
						for (; fi < fl; fi++) if (file[fi] === "." || file[fi] === ".." || !options.dot && file[fi].charAt(0) === ".") return false;
						return true;
					}
					while (fr < fl) {
						var swallowee = file[fr];
						this.debug("\nglobstar while", file, fr, pattern, pr, swallowee);
						if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
							this.debug("globstar found match!", fr, fl, swallowee);
							return true;
						} else {
							if (swallowee === "." || swallowee === ".." || !options.dot && swallowee.charAt(0) === ".") {
								this.debug("dot detected!", file, fr, pattern, pr);
								break;
							}
							this.debug("globstar swallow a segment, and continue");
							fr++;
						}
					}
					/* istanbul ignore if */
					if (partial) {
						this.debug("\n>>> no match, partial?", file, fr, pattern, pr);
						if (fr === fl) return true;
					}
					return false;
				}
				var hit;
				if (typeof p === "string") {
					hit = f === p;
					this.debug("string match", p, f, hit);
				} else {
					hit = f.match(p);
					this.debug("pattern match", p, f, hit);
				}
				if (!hit) return false;
			}
			if (fi === fl && pi === pl) return true;
			else if (fi === fl) return partial;
			else if (pi === pl) return fi === fl - 1 && file[fi] === "";
			/* istanbul ignore next */
			throw new Error("wtf?");
		}
		braceExpand() {
			return braceExpand(this.pattern, this.options);
		}
		parse(pattern, isSub) {
			assertValidPattern(pattern);
			const options = this.options;
			if (pattern === "**") if (!options.noglobstar) return GLOBSTAR;
			else pattern = "*";
			if (pattern === "") return "";
			let re = "";
			let hasMagic = false;
			let escaping = false;
			const patternListStack = [];
			const negativeLists = [];
			let stateChar;
			let inClass = false;
			let reClassStart = -1;
			let classStart = -1;
			let cs;
			let pl;
			let sp;
			let dotTravAllowed = pattern.charAt(0) === ".";
			let dotFileAllowed = options.dot || dotTravAllowed;
			const patternStart = () => dotTravAllowed ? "" : dotFileAllowed ? "(?!(?:^|\\/)\\.{1,2}(?:$|\\/))" : "(?!\\.)";
			const subPatternStart = (p) => p.charAt(0) === "." ? "" : options.dot ? "(?!(?:^|\\/)\\.{1,2}(?:$|\\/))" : "(?!\\.)";
			const clearStateChar = () => {
				if (stateChar) {
					switch (stateChar) {
						case "*":
							re += star;
							hasMagic = true;
							break;
						case "?":
							re += qmark;
							hasMagic = true;
							break;
						default:
							re += "\\" + stateChar;
							break;
					}
					this.debug("clearStateChar %j %j", stateChar, re);
					stateChar = false;
				}
			};
			for (let i = 0, c; i < pattern.length && (c = pattern.charAt(i)); i++) {
				this.debug("%s	%s %s %j", pattern, i, re, c);
				if (escaping) {
					/* istanbul ignore next - completely not allowed, even escaped. */
					if (c === "/") return false;
					if (reSpecials[c]) re += "\\";
					re += c;
					escaping = false;
					continue;
				}
				switch (c) {
					case "/": return false;
					case "\\":
						if (inClass && pattern.charAt(i + 1) === "-") {
							re += c;
							continue;
						}
						clearStateChar();
						escaping = true;
						continue;
					case "?":
					case "*":
					case "+":
					case "@":
					case "!":
						this.debug("%s	%s %s %j <-- stateChar", pattern, i, re, c);
						if (inClass) {
							this.debug("  in class");
							if (c === "!" && i === classStart + 1) c = "^";
							re += c;
							continue;
						}
						this.debug("call clearStateChar %j", stateChar);
						clearStateChar();
						stateChar = c;
						if (options.noext) clearStateChar();
						continue;
					case "(": {
						if (inClass) {
							re += "(";
							continue;
						}
						if (!stateChar) {
							re += "\\(";
							continue;
						}
						const plEntry = {
							type: stateChar,
							start: i - 1,
							reStart: re.length,
							open: plTypes[stateChar].open,
							close: plTypes[stateChar].close
						};
						this.debug(this.pattern, "	", plEntry);
						patternListStack.push(plEntry);
						re += plEntry.open;
						if (plEntry.start === 0 && plEntry.type !== "!") {
							dotTravAllowed = true;
							re += subPatternStart(pattern.slice(i + 1));
						}
						this.debug("plType %j %j", stateChar, re);
						stateChar = false;
						continue;
					}
					case ")": {
						const plEntry = patternListStack[patternListStack.length - 1];
						if (inClass || !plEntry) {
							re += "\\)";
							continue;
						}
						patternListStack.pop();
						clearStateChar();
						hasMagic = true;
						pl = plEntry;
						re += pl.close;
						if (pl.type === "!") negativeLists.push(Object.assign(pl, { reEnd: re.length }));
						continue;
					}
					case "|": {
						const plEntry = patternListStack[patternListStack.length - 1];
						if (inClass || !plEntry) {
							re += "\\|";
							continue;
						}
						clearStateChar();
						re += "|";
						if (plEntry.start === 0 && plEntry.type !== "!") {
							dotTravAllowed = true;
							re += subPatternStart(pattern.slice(i + 1));
						}
						continue;
					}
					case "[":
						clearStateChar();
						if (inClass) {
							re += "\\" + c;
							continue;
						}
						inClass = true;
						classStart = i;
						reClassStart = re.length;
						re += c;
						continue;
					case "]":
						if (i === classStart + 1 || !inClass) {
							re += "\\" + c;
							continue;
						}
						cs = pattern.substring(classStart + 1, i);
						try {
							RegExp("[" + braExpEscape(charUnescape(cs)) + "]");
							re += c;
						} catch (er) {
							re = re.substring(0, reClassStart) + "(?:$.)";
						}
						hasMagic = true;
						inClass = false;
						continue;
					default:
						clearStateChar();
						if (reSpecials[c] && !(c === "^" && inClass)) re += "\\";
						re += c;
						break;
				}
			}
			if (inClass) {
				cs = pattern.slice(classStart + 1);
				sp = this.parse(cs, SUBPARSE);
				re = re.substring(0, reClassStart) + "\\[" + sp[0];
				hasMagic = hasMagic || sp[1];
			}
			for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {
				let tail;
				tail = re.slice(pl.reStart + pl.open.length);
				this.debug("setting tail", re, pl);
				tail = tail.replace(/((?:\\{2}){0,64})(\\?)\|/g, (_, $1, $2) => {
					/* istanbul ignore else - should already be done */
					if (!$2) $2 = "\\";
					return $1 + $1 + $2 + "|";
				});
				this.debug("tail=%j\n   %s", tail, tail, pl, re);
				const t = pl.type === "*" ? star : pl.type === "?" ? qmark : "\\" + pl.type;
				hasMagic = true;
				re = re.slice(0, pl.reStart) + t + "\\(" + tail;
			}
			clearStateChar();
			if (escaping) re += "\\\\";
			const addPatternStart = addPatternStartSet[re.charAt(0)];
			for (let n = negativeLists.length - 1; n > -1; n--) {
				const nl = negativeLists[n];
				const nlBefore = re.slice(0, nl.reStart);
				const nlFirst = re.slice(nl.reStart, nl.reEnd - 8);
				let nlAfter = re.slice(nl.reEnd);
				const nlLast = re.slice(nl.reEnd - 8, nl.reEnd) + nlAfter;
				const closeParensBefore = nlBefore.split(")").length;
				const openParensBefore = nlBefore.split("(").length - closeParensBefore;
				let cleanAfter = nlAfter;
				for (let i = 0; i < openParensBefore; i++) cleanAfter = cleanAfter.replace(/\)[+*?]?/, "");
				nlAfter = cleanAfter;
				const dollar = nlAfter === "" && isSub !== SUBPARSE ? "(?:$|\\/)" : "";
				re = nlBefore + nlFirst + nlAfter + dollar + nlLast;
			}
			if (re !== "" && hasMagic) re = "(?=.)" + re;
			if (addPatternStart) re = patternStart() + re;
			if (isSub === SUBPARSE) return [re, hasMagic];
			if (options.nocase && !hasMagic) hasMagic = pattern.toUpperCase() !== pattern.toLowerCase();
			if (!hasMagic) return globUnescape(pattern);
			const flags = options.nocase ? "i" : "";
			try {
				return Object.assign(new RegExp("^" + re + "$", flags), {
					_glob: pattern,
					_src: re
				});
			} catch (er) 			/* istanbul ignore next - should be impossible */ {
				return /* @__PURE__ */ new RegExp("$.");
			}
		}
		makeRe() {
			if (this.regexp || this.regexp === false) return this.regexp;
			const set = this.set;
			if (!set.length) {
				this.regexp = false;
				return this.regexp;
			}
			const options = this.options;
			const twoStar = options.noglobstar ? star : options.dot ? twoStarDot : twoStarNoDot;
			const flags = options.nocase ? "i" : "";
			let re = set.map((pattern) => {
				pattern = pattern.map((p) => typeof p === "string" ? regExpEscape(p) : p === GLOBSTAR ? GLOBSTAR : p._src).reduce((set$1, p) => {
					if (!(set$1[set$1.length - 1] === GLOBSTAR && p === GLOBSTAR)) set$1.push(p);
					return set$1;
				}, []);
				pattern.forEach((p, i) => {
					if (p !== GLOBSTAR || pattern[i - 1] === GLOBSTAR) return;
					if (i === 0) if (pattern.length > 1) pattern[i + 1] = "(?:\\/|" + twoStar + "\\/)?" + pattern[i + 1];
					else pattern[i] = twoStar;
					else if (i === pattern.length - 1) pattern[i - 1] += "(?:\\/|" + twoStar + ")?";
					else {
						pattern[i - 1] += "(?:\\/|\\/" + twoStar + "\\/)" + pattern[i + 1];
						pattern[i + 1] = GLOBSTAR;
					}
				});
				return pattern.filter((p) => p !== GLOBSTAR).join("/");
			}).join("|");
			re = "^(?:" + re + ")$";
			if (this.negate) re = "^(?!" + re + ").*$";
			try {
				this.regexp = new RegExp(re, flags);
			} catch (ex) 			/* istanbul ignore next - should be impossible */ {
				this.regexp = false;
			}
			return this.regexp;
		}
		match(f, partial = this.partial) {
			this.debug("match", f, this.pattern);
			if (this.comment) return false;
			if (this.empty) return f === "";
			if (f === "/" && partial) return true;
			const options = this.options;
			if (path.sep !== "/") f = f.split(path.sep).join("/");
			f = f.split(slashSplit);
			this.debug(this.pattern, "split", f);
			const set = this.set;
			this.debug(this.pattern, "set", set);
			let filename;
			for (let i = f.length - 1; i >= 0; i--) {
				filename = f[i];
				if (filename) break;
			}
			for (let i = 0; i < set.length; i++) {
				const pattern = set[i];
				let file = f;
				if (options.matchBase && pattern.length === 1) file = [filename];
				if (this.matchOne(file, pattern, partial)) {
					if (options.flipNegate) return true;
					return !this.negate;
				}
			}
			if (options.flipNegate) return false;
			return this.negate;
		}
		static defaults(def) {
			return minimatch.defaults(def).Minimatch;
		}
	};
	minimatch.Minimatch = Minimatch;
}));

//#endregion
//#region ../node_modules/.pnpm/inherits@2.0.4/node_modules/inherits/inherits_browser.js
var require_inherits_browser = /* @__PURE__ */ require_chunk.__commonJSMin(((exports, module) => {
	if (typeof Object.create === "function") module.exports = function inherits(ctor, superCtor) {
		if (superCtor) {
			ctor.super_ = superCtor;
			ctor.prototype = Object.create(superCtor.prototype, { constructor: {
				value: ctor,
				enumerable: false,
				writable: true,
				configurable: true
			} });
		}
	};
	else module.exports = function inherits(ctor, superCtor) {
		if (superCtor) {
			ctor.super_ = superCtor;
			var TempCtor = function() {};
			TempCtor.prototype = superCtor.prototype;
			ctor.prototype = new TempCtor();
			ctor.prototype.constructor = ctor;
		}
	};
}));

//#endregion
//#region ../node_modules/.pnpm/inherits@2.0.4/node_modules/inherits/inherits.js
var require_inherits = /* @__PURE__ */ require_chunk.__commonJSMin(((exports, module) => {
	try {
		var util = require("util");
		/* istanbul ignore next */
		if (typeof util.inherits !== "function") throw "";
		module.exports = util.inherits;
	} catch (e) {
		/* istanbul ignore next */
		module.exports = require_inherits_browser();
	}
}));

//#endregion
//#region ../node_modules/.pnpm/glob@8.1.0/node_modules/glob/common.js
var require_common = /* @__PURE__ */ require_chunk.__commonJSMin(((exports) => {
	exports.setopts = setopts;
	exports.ownProp = ownProp;
	exports.makeAbs = makeAbs;
	exports.finish = finish;
	exports.mark = mark;
	exports.isIgnored = isIgnored;
	exports.childrenIgnored = childrenIgnored;
	function ownProp(obj, field) {
		return Object.prototype.hasOwnProperty.call(obj, field);
	}
	var fs$1 = require("fs");
	var path$3 = require("path");
	var minimatch = require_minimatch();
	var isAbsolute$2 = require("path").isAbsolute;
	var Minimatch = minimatch.Minimatch;
	function alphasort(a, b) {
		return a.localeCompare(b, "en");
	}
	function setupIgnores(self, options) {
		self.ignore = options.ignore || [];
		if (!Array.isArray(self.ignore)) self.ignore = [self.ignore];
		if (self.ignore.length) self.ignore = self.ignore.map(ignoreMap);
	}
	function ignoreMap(pattern) {
		var gmatcher = null;
		if (pattern.slice(-3) === "/**") gmatcher = new Minimatch(pattern.replace(/(\/\*\*)+$/, ""), { dot: true });
		return {
			matcher: new Minimatch(pattern, { dot: true }),
			gmatcher
		};
	}
	function setopts(self, pattern, options) {
		if (!options) options = {};
		if (options.matchBase && -1 === pattern.indexOf("/")) {
			if (options.noglobstar) throw new Error("base matching requires globstar");
			pattern = "**/" + pattern;
		}
		self.windowsPathsNoEscape = !!options.windowsPathsNoEscape || options.allowWindowsEscape === false;
		if (self.windowsPathsNoEscape) pattern = pattern.replace(/\\/g, "/");
		self.silent = !!options.silent;
		self.pattern = pattern;
		self.strict = options.strict !== false;
		self.realpath = !!options.realpath;
		self.realpathCache = options.realpathCache || Object.create(null);
		self.follow = !!options.follow;
		self.dot = !!options.dot;
		self.mark = !!options.mark;
		self.nodir = !!options.nodir;
		if (self.nodir) self.mark = true;
		self.sync = !!options.sync;
		self.nounique = !!options.nounique;
		self.nonull = !!options.nonull;
		self.nosort = !!options.nosort;
		self.nocase = !!options.nocase;
		self.stat = !!options.stat;
		self.noprocess = !!options.noprocess;
		self.absolute = !!options.absolute;
		self.fs = options.fs || fs$1;
		self.maxLength = options.maxLength || Infinity;
		self.cache = options.cache || Object.create(null);
		self.statCache = options.statCache || Object.create(null);
		self.symlinks = options.symlinks || Object.create(null);
		setupIgnores(self, options);
		self.changedCwd = false;
		var cwd = process.cwd();
		if (!ownProp(options, "cwd")) self.cwd = path$3.resolve(cwd);
		else {
			self.cwd = path$3.resolve(options.cwd);
			self.changedCwd = self.cwd !== cwd;
		}
		self.root = options.root || path$3.resolve(self.cwd, "/");
		self.root = path$3.resolve(self.root);
		self.cwdAbs = isAbsolute$2(self.cwd) ? self.cwd : makeAbs(self, self.cwd);
		self.nomount = !!options.nomount;
		if (process.platform === "win32") {
			self.root = self.root.replace(/\\/g, "/");
			self.cwd = self.cwd.replace(/\\/g, "/");
			self.cwdAbs = self.cwdAbs.replace(/\\/g, "/");
		}
		options.nonegate = true;
		options.nocomment = true;
		self.minimatch = new Minimatch(pattern, options);
		self.options = self.minimatch.options;
	}
	function finish(self) {
		var nou = self.nounique;
		var all = nou ? [] : Object.create(null);
		for (var i = 0, l = self.matches.length; i < l; i++) {
			var matches = self.matches[i];
			if (!matches || Object.keys(matches).length === 0) {
				if (self.nonull) {
					var literal = self.minimatch.globSet[i];
					if (nou) all.push(literal);
					else all[literal] = true;
				}
			} else {
				var m = Object.keys(matches);
				if (nou) all.push.apply(all, m);
				else m.forEach(function(m$1) {
					all[m$1] = true;
				});
			}
		}
		if (!nou) all = Object.keys(all);
		if (!self.nosort) all = all.sort(alphasort);
		if (self.mark) {
			for (var i = 0; i < all.length; i++) all[i] = self._mark(all[i]);
			if (self.nodir) all = all.filter(function(e) {
				var notDir = !/\/$/.test(e);
				var c = self.cache[e] || self.cache[makeAbs(self, e)];
				if (notDir && c) notDir = c !== "DIR" && !Array.isArray(c);
				return notDir;
			});
		}
		if (self.ignore.length) all = all.filter(function(m$1) {
			return !isIgnored(self, m$1);
		});
		self.found = all;
	}
	function mark(self, p) {
		var abs = makeAbs(self, p);
		var c = self.cache[abs];
		var m = p;
		if (c) {
			var isDir = c === "DIR" || Array.isArray(c);
			var slash = p.slice(-1) === "/";
			if (isDir && !slash) m += "/";
			else if (!isDir && slash) m = m.slice(0, -1);
			if (m !== p) {
				var mabs = makeAbs(self, m);
				self.statCache[mabs] = self.statCache[abs];
				self.cache[mabs] = self.cache[abs];
			}
		}
		return m;
	}
	function makeAbs(self, f) {
		var abs = f;
		if (f.charAt(0) === "/") abs = path$3.join(self.root, f);
		else if (isAbsolute$2(f) || f === "") abs = f;
		else if (self.changedCwd) abs = path$3.resolve(self.cwd, f);
		else abs = path$3.resolve(f);
		if (process.platform === "win32") abs = abs.replace(/\\/g, "/");
		return abs;
	}
	function isIgnored(self, path$4) {
		if (!self.ignore.length) return false;
		return self.ignore.some(function(item) {
			return item.matcher.match(path$4) || !!(item.gmatcher && item.gmatcher.match(path$4));
		});
	}
	function childrenIgnored(self, path$4) {
		if (!self.ignore.length) return false;
		return self.ignore.some(function(item) {
			return !!(item.gmatcher && item.gmatcher.match(path$4));
		});
	}
}));

//#endregion
//#region ../node_modules/.pnpm/glob@8.1.0/node_modules/glob/sync.js
var require_sync = /* @__PURE__ */ require_chunk.__commonJSMin(((exports, module) => {
	module.exports = globSync;
	globSync.GlobSync = GlobSync;
	var rp = require_fs();
	var minimatch = require_minimatch();
	minimatch.Minimatch;
	require_glob().Glob;
	require("util");
	var path$2 = require("path");
	var assert$1 = require("assert");
	var isAbsolute$1 = require("path").isAbsolute;
	var common = require_common();
	var setopts = common.setopts;
	var ownProp = common.ownProp;
	var childrenIgnored = common.childrenIgnored;
	var isIgnored = common.isIgnored;
	function globSync(pattern, options) {
		if (typeof options === "function" || arguments.length === 3) throw new TypeError("callback provided to sync glob\nSee: https://github.com/isaacs/node-glob/issues/167");
		return new GlobSync(pattern, options).found;
	}
	function GlobSync(pattern, options) {
		if (!pattern) throw new Error("must provide pattern");
		if (typeof options === "function" || arguments.length === 3) throw new TypeError("callback provided to sync glob\nSee: https://github.com/isaacs/node-glob/issues/167");
		if (!(this instanceof GlobSync)) return new GlobSync(pattern, options);
		setopts(this, pattern, options);
		if (this.noprocess) return this;
		var n = this.minimatch.set.length;
		this.matches = new Array(n);
		for (var i = 0; i < n; i++) this._process(this.minimatch.set[i], i, false);
		this._finish();
	}
	GlobSync.prototype._finish = function() {
		assert$1.ok(this instanceof GlobSync);
		if (this.realpath) {
			var self = this;
			this.matches.forEach(function(matchset, index$4) {
				var set = self.matches[index$4] = Object.create(null);
				for (var p in matchset) try {
					p = self._makeAbs(p);
					var real = rp.realpathSync(p, self.realpathCache);
					set[real] = true;
				} catch (er) {
					if (er.syscall === "stat") set[self._makeAbs(p)] = true;
					else throw er;
				}
			});
		}
		common.finish(this);
	};
	GlobSync.prototype._process = function(pattern, index$4, inGlobStar) {
		assert$1.ok(this instanceof GlobSync);
		var n = 0;
		while (typeof pattern[n] === "string") n++;
		var prefix;
		switch (n) {
			case pattern.length:
				this._processSimple(pattern.join("/"), index$4);
				return;
			case 0:
				prefix = null;
				break;
			default:
				prefix = pattern.slice(0, n).join("/");
				break;
		}
		var remain = pattern.slice(n);
		var read;
		if (prefix === null) read = ".";
		else if (isAbsolute$1(prefix) || isAbsolute$1(pattern.map(function(p) {
			return typeof p === "string" ? p : "[*]";
		}).join("/"))) {
			if (!prefix || !isAbsolute$1(prefix)) prefix = "/" + prefix;
			read = prefix;
		} else read = prefix;
		var abs = this._makeAbs(read);
		if (childrenIgnored(this, read)) return;
		if (remain[0] === minimatch.GLOBSTAR) this._processGlobStar(prefix, read, abs, remain, index$4, inGlobStar);
		else this._processReaddir(prefix, read, abs, remain, index$4, inGlobStar);
	};
	GlobSync.prototype._processReaddir = function(prefix, read, abs, remain, index$4, inGlobStar) {
		var entries = this._readdir(abs, inGlobStar);
		if (!entries) return;
		var pn = remain[0];
		var negate = !!this.minimatch.negate;
		var rawGlob = pn._glob;
		var dotOk = this.dot || rawGlob.charAt(0) === ".";
		var matchedEntries = [];
		for (var i = 0; i < entries.length; i++) {
			var e = entries[i];
			if (e.charAt(0) !== "." || dotOk) {
				var m;
				if (negate && !prefix) m = !e.match(pn);
				else m = e.match(pn);
				if (m) matchedEntries.push(e);
			}
		}
		var len = matchedEntries.length;
		if (len === 0) return;
		if (remain.length === 1 && !this.mark && !this.stat) {
			if (!this.matches[index$4]) this.matches[index$4] = Object.create(null);
			for (var i = 0; i < len; i++) {
				var e = matchedEntries[i];
				if (prefix) if (prefix.slice(-1) !== "/") e = prefix + "/" + e;
				else e = prefix + e;
				if (e.charAt(0) === "/" && !this.nomount) e = path$2.join(this.root, e);
				this._emitMatch(index$4, e);
			}
			return;
		}
		remain.shift();
		for (var i = 0; i < len; i++) {
			var e = matchedEntries[i];
			var newPattern;
			if (prefix) newPattern = [prefix, e];
			else newPattern = [e];
			this._process(newPattern.concat(remain), index$4, inGlobStar);
		}
	};
	GlobSync.prototype._emitMatch = function(index$4, e) {
		if (isIgnored(this, e)) return;
		var abs = this._makeAbs(e);
		if (this.mark) e = this._mark(e);
		if (this.absolute) e = abs;
		if (this.matches[index$4][e]) return;
		if (this.nodir) {
			var c = this.cache[abs];
			if (c === "DIR" || Array.isArray(c)) return;
		}
		this.matches[index$4][e] = true;
		if (this.stat) this._stat(e);
	};
	GlobSync.prototype._readdirInGlobStar = function(abs) {
		if (this.follow) return this._readdir(abs, false);
		var entries;
		var lstat;
		try {
			lstat = this.fs.lstatSync(abs);
		} catch (er) {
			if (er.code === "ENOENT") return null;
		}
		var isSym = lstat && lstat.isSymbolicLink();
		this.symlinks[abs] = isSym;
		if (!isSym && lstat && !lstat.isDirectory()) this.cache[abs] = "FILE";
		else entries = this._readdir(abs, false);
		return entries;
	};
	GlobSync.prototype._readdir = function(abs, inGlobStar) {
		if (inGlobStar && !ownProp(this.symlinks, abs)) return this._readdirInGlobStar(abs);
		if (ownProp(this.cache, abs)) {
			var c = this.cache[abs];
			if (!c || c === "FILE") return null;
			if (Array.isArray(c)) return c;
		}
		try {
			return this._readdirEntries(abs, this.fs.readdirSync(abs));
		} catch (er) {
			this._readdirError(abs, er);
			return null;
		}
	};
	GlobSync.prototype._readdirEntries = function(abs, entries) {
		if (!this.mark && !this.stat) for (var i = 0; i < entries.length; i++) {
			var e = entries[i];
			if (abs === "/") e = abs + e;
			else e = abs + "/" + e;
			this.cache[e] = true;
		}
		this.cache[abs] = entries;
		return entries;
	};
	GlobSync.prototype._readdirError = function(f, er) {
		switch (er.code) {
			case "ENOTSUP":
			case "ENOTDIR":
				var abs = this._makeAbs(f);
				this.cache[abs] = "FILE";
				if (abs === this.cwdAbs) {
					var error = /* @__PURE__ */ new Error(er.code + " invalid cwd " + this.cwd);
					error.path = this.cwd;
					error.code = er.code;
					throw error;
				}
				break;
			case "ENOENT":
			case "ELOOP":
			case "ENAMETOOLONG":
			case "UNKNOWN":
				this.cache[this._makeAbs(f)] = false;
				break;
			default:
				this.cache[this._makeAbs(f)] = false;
				if (this.strict) throw er;
				if (!this.silent) console.error("glob error", er);
				break;
		}
	};
	GlobSync.prototype._processGlobStar = function(prefix, read, abs, remain, index$4, inGlobStar) {
		var entries = this._readdir(abs, inGlobStar);
		if (!entries) return;
		var remainWithoutGlobStar = remain.slice(1);
		var gspref = prefix ? [prefix] : [];
		var noGlobStar = gspref.concat(remainWithoutGlobStar);
		this._process(noGlobStar, index$4, false);
		var len = entries.length;
		if (this.symlinks[abs] && inGlobStar) return;
		for (var i = 0; i < len; i++) {
			if (entries[i].charAt(0) === "." && !this.dot) continue;
			var instead = gspref.concat(entries[i], remainWithoutGlobStar);
			this._process(instead, index$4, true);
			var below = gspref.concat(entries[i], remain);
			this._process(below, index$4, true);
		}
	};
	GlobSync.prototype._processSimple = function(prefix, index$4) {
		var exists = this._stat(prefix);
		if (!this.matches[index$4]) this.matches[index$4] = Object.create(null);
		if (!exists) return;
		if (prefix && isAbsolute$1(prefix) && !this.nomount) {
			var trail = /[\/\\]$/.test(prefix);
			if (prefix.charAt(0) === "/") prefix = path$2.join(this.root, prefix);
			else {
				prefix = path$2.resolve(this.root, prefix);
				if (trail) prefix += "/";
			}
		}
		if (process.platform === "win32") prefix = prefix.replace(/\\/g, "/");
		this._emitMatch(index$4, prefix);
	};
	GlobSync.prototype._stat = function(f) {
		var abs = this._makeAbs(f);
		var needDir = f.slice(-1) === "/";
		if (f.length > this.maxLength) return false;
		if (!this.stat && ownProp(this.cache, abs)) {
			var c = this.cache[abs];
			if (Array.isArray(c)) c = "DIR";
			if (!needDir || c === "DIR") return c;
			if (needDir && c === "FILE") return false;
		}
		var stat = this.statCache[abs];
		if (!stat) {
			var lstat;
			try {
				lstat = this.fs.lstatSync(abs);
			} catch (er) {
				if (er && (er.code === "ENOENT" || er.code === "ENOTDIR")) {
					this.statCache[abs] = false;
					return false;
				}
			}
			if (lstat && lstat.isSymbolicLink()) try {
				stat = this.fs.statSync(abs);
			} catch (er) {
				stat = lstat;
			}
			else stat = lstat;
		}
		this.statCache[abs] = stat;
		var c = true;
		if (stat) c = stat.isDirectory() ? "DIR" : "FILE";
		this.cache[abs] = this.cache[abs] || c;
		if (needDir && c === "FILE") return false;
		return c;
	};
	GlobSync.prototype._mark = function(p) {
		return common.mark(this, p);
	};
	GlobSync.prototype._makeAbs = function(f) {
		return common.makeAbs(this, f);
	};
}));

//#endregion
//#region ../node_modules/.pnpm/wrappy@1.0.2/node_modules/wrappy/wrappy.js
var require_wrappy = /* @__PURE__ */ require_chunk.__commonJSMin(((exports, module) => {
	module.exports = wrappy;
	function wrappy(fn, cb) {
		if (fn && cb) return wrappy(fn)(cb);
		if (typeof fn !== "function") throw new TypeError("need wrapper function");
		Object.keys(fn).forEach(function(k) {
			wrapper[k] = fn[k];
		});
		return wrapper;
		function wrapper() {
			var args = new Array(arguments.length);
			for (var i = 0; i < args.length; i++) args[i] = arguments[i];
			var ret = fn.apply(this, args);
			var cb$1 = args[args.length - 1];
			if (typeof ret === "function" && ret !== cb$1) Object.keys(cb$1).forEach(function(k) {
				ret[k] = cb$1[k];
			});
			return ret;
		}
	}
}));

//#endregion
//#region ../node_modules/.pnpm/once@1.4.0/node_modules/once/once.js
var require_once = /* @__PURE__ */ require_chunk.__commonJSMin(((exports, module) => {
	var wrappy = require_wrappy();
	module.exports = wrappy(once);
	module.exports.strict = wrappy(onceStrict);
	once.proto = once(function() {
		Object.defineProperty(Function.prototype, "once", {
			value: function() {
				return once(this);
			},
			configurable: true
		});
		Object.defineProperty(Function.prototype, "onceStrict", {
			value: function() {
				return onceStrict(this);
			},
			configurable: true
		});
	});
	function once(fn) {
		var f = function() {
			if (f.called) return f.value;
			f.called = true;
			return f.value = fn.apply(this, arguments);
		};
		f.called = false;
		return f;
	}
	function onceStrict(fn) {
		var f = function() {
			if (f.called) throw new Error(f.onceError);
			f.called = true;
			return f.value = fn.apply(this, arguments);
		};
		f.onceError = (fn.name || "Function wrapped with `once`") + " shouldn't be called more than once";
		f.called = false;
		return f;
	}
}));

//#endregion
//#region ../node_modules/.pnpm/inflight@1.0.6/node_modules/inflight/inflight.js
var require_inflight = /* @__PURE__ */ require_chunk.__commonJSMin(((exports, module) => {
	var wrappy = require_wrappy();
	var reqs = Object.create(null);
	var once = require_once();
	module.exports = wrappy(inflight);
	function inflight(key, cb) {
		if (reqs[key]) {
			reqs[key].push(cb);
			return null;
		} else {
			reqs[key] = [cb];
			return makeres(key);
		}
	}
	function makeres(key) {
		return once(function RES() {
			var cbs = reqs[key];
			var len = cbs.length;
			var args = slice(arguments);
			try {
				for (var i = 0; i < len; i++) cbs[i].apply(null, args);
			} finally {
				if (cbs.length > len) {
					cbs.splice(0, len);
					process.nextTick(function() {
						RES.apply(null, args);
					});
				} else delete reqs[key];
			}
		});
	}
	function slice(args) {
		var length = args.length;
		var array$1 = [];
		for (var i = 0; i < length; i++) array$1[i] = args[i];
		return array$1;
	}
}));

//#endregion
//#region ../node_modules/.pnpm/glob@8.1.0/node_modules/glob/glob.js
var require_glob = /* @__PURE__ */ require_chunk.__commonJSMin(((exports, module) => {
	module.exports = glob;
	var rp = require_fs();
	var minimatch = require_minimatch();
	minimatch.Minimatch;
	var inherits = require_inherits();
	var EE = require("events").EventEmitter;
	var path$1 = require("path");
	var assert = require("assert");
	var isAbsolute = require("path").isAbsolute;
	var globSync = require_sync();
	var common = require_common();
	var setopts = common.setopts;
	var ownProp = common.ownProp;
	var inflight = require_inflight();
	require("util");
	var childrenIgnored = common.childrenIgnored;
	var isIgnored = common.isIgnored;
	var once = require_once();
	function glob(pattern, options, cb) {
		if (typeof options === "function") cb = options, options = {};
		if (!options) options = {};
		if (options.sync) {
			if (cb) throw new TypeError("callback provided to sync glob");
			return globSync(pattern, options);
		}
		return new Glob(pattern, options, cb);
	}
	glob.sync = globSync;
	var GlobSync = glob.GlobSync = globSync.GlobSync;
	glob.glob = glob;
	function extend(origin, add) {
		if (add === null || typeof add !== "object") return origin;
		var keys = Object.keys(add);
		var i = keys.length;
		while (i--) origin[keys[i]] = add[keys[i]];
		return origin;
	}
	glob.hasMagic = function(pattern, options_) {
		var options = extend({}, options_);
		options.noprocess = true;
		var set = new Glob(pattern, options).minimatch.set;
		if (!pattern) return false;
		if (set.length > 1) return true;
		for (var j = 0; j < set[0].length; j++) if (typeof set[0][j] !== "string") return true;
		return false;
	};
	glob.Glob = Glob;
	inherits(Glob, EE);
	function Glob(pattern, options, cb) {
		if (typeof options === "function") {
			cb = options;
			options = null;
		}
		if (options && options.sync) {
			if (cb) throw new TypeError("callback provided to sync glob");
			return new GlobSync(pattern, options);
		}
		if (!(this instanceof Glob)) return new Glob(pattern, options, cb);
		setopts(this, pattern, options);
		this._didRealPath = false;
		var n = this.minimatch.set.length;
		this.matches = new Array(n);
		if (typeof cb === "function") {
			cb = once(cb);
			this.on("error", cb);
			this.on("end", function(matches) {
				cb(null, matches);
			});
		}
		var self = this;
		this._processing = 0;
		this._emitQueue = [];
		this._processQueue = [];
		this.paused = false;
		if (this.noprocess) return this;
		if (n === 0) return done();
		var sync = true;
		for (var i = 0; i < n; i++) this._process(this.minimatch.set[i], i, false, done);
		sync = false;
		function done() {
			--self._processing;
			if (self._processing <= 0) if (sync) process.nextTick(function() {
				self._finish();
			});
			else self._finish();
		}
	}
	Glob.prototype._finish = function() {
		assert(this instanceof Glob);
		if (this.aborted) return;
		if (this.realpath && !this._didRealpath) return this._realpath();
		common.finish(this);
		this.emit("end", this.found);
	};
	Glob.prototype._realpath = function() {
		if (this._didRealpath) return;
		this._didRealpath = true;
		var n = this.matches.length;
		if (n === 0) return this._finish();
		var self = this;
		for (var i = 0; i < this.matches.length; i++) this._realpathSet(i, next);
		function next() {
			if (--n === 0) self._finish();
		}
	};
	Glob.prototype._realpathSet = function(index$4, cb) {
		var matchset = this.matches[index$4];
		if (!matchset) return cb();
		var found = Object.keys(matchset);
		var self = this;
		var n = found.length;
		if (n === 0) return cb();
		var set = this.matches[index$4] = Object.create(null);
		found.forEach(function(p, i) {
			p = self._makeAbs(p);
			rp.realpath(p, self.realpathCache, function(er, real) {
				if (!er) set[real] = true;
				else if (er.syscall === "stat") set[p] = true;
				else self.emit("error", er);
				if (--n === 0) {
					self.matches[index$4] = set;
					cb();
				}
			});
		});
	};
	Glob.prototype._mark = function(p) {
		return common.mark(this, p);
	};
	Glob.prototype._makeAbs = function(f) {
		return common.makeAbs(this, f);
	};
	Glob.prototype.abort = function() {
		this.aborted = true;
		this.emit("abort");
	};
	Glob.prototype.pause = function() {
		if (!this.paused) {
			this.paused = true;
			this.emit("pause");
		}
	};
	Glob.prototype.resume = function() {
		if (this.paused) {
			this.emit("resume");
			this.paused = false;
			if (this._emitQueue.length) {
				var eq = this._emitQueue.slice(0);
				this._emitQueue.length = 0;
				for (var i = 0; i < eq.length; i++) {
					var e = eq[i];
					this._emitMatch(e[0], e[1]);
				}
			}
			if (this._processQueue.length) {
				var pq = this._processQueue.slice(0);
				this._processQueue.length = 0;
				for (var i = 0; i < pq.length; i++) {
					var p = pq[i];
					this._processing--;
					this._process(p[0], p[1], p[2], p[3]);
				}
			}
		}
	};
	Glob.prototype._process = function(pattern, index$4, inGlobStar, cb) {
		assert(this instanceof Glob);
		assert(typeof cb === "function");
		if (this.aborted) return;
		this._processing++;
		if (this.paused) {
			this._processQueue.push([
				pattern,
				index$4,
				inGlobStar,
				cb
			]);
			return;
		}
		var n = 0;
		while (typeof pattern[n] === "string") n++;
		var prefix;
		switch (n) {
			case pattern.length:
				this._processSimple(pattern.join("/"), index$4, cb);
				return;
			case 0:
				prefix = null;
				break;
			default:
				prefix = pattern.slice(0, n).join("/");
				break;
		}
		var remain = pattern.slice(n);
		var read;
		if (prefix === null) read = ".";
		else if (isAbsolute(prefix) || isAbsolute(pattern.map(function(p) {
			return typeof p === "string" ? p : "[*]";
		}).join("/"))) {
			if (!prefix || !isAbsolute(prefix)) prefix = "/" + prefix;
			read = prefix;
		} else read = prefix;
		var abs = this._makeAbs(read);
		if (childrenIgnored(this, read)) return cb();
		if (remain[0] === minimatch.GLOBSTAR) this._processGlobStar(prefix, read, abs, remain, index$4, inGlobStar, cb);
		else this._processReaddir(prefix, read, abs, remain, index$4, inGlobStar, cb);
	};
	Glob.prototype._processReaddir = function(prefix, read, abs, remain, index$4, inGlobStar, cb) {
		var self = this;
		this._readdir(abs, inGlobStar, function(er, entries) {
			return self._processReaddir2(prefix, read, abs, remain, index$4, inGlobStar, entries, cb);
		});
	};
	Glob.prototype._processReaddir2 = function(prefix, read, abs, remain, index$4, inGlobStar, entries, cb) {
		if (!entries) return cb();
		var pn = remain[0];
		var negate = !!this.minimatch.negate;
		var rawGlob = pn._glob;
		var dotOk = this.dot || rawGlob.charAt(0) === ".";
		var matchedEntries = [];
		for (var i = 0; i < entries.length; i++) {
			var e = entries[i];
			if (e.charAt(0) !== "." || dotOk) {
				var m;
				if (negate && !prefix) m = !e.match(pn);
				else m = e.match(pn);
				if (m) matchedEntries.push(e);
			}
		}
		var len = matchedEntries.length;
		if (len === 0) return cb();
		if (remain.length === 1 && !this.mark && !this.stat) {
			if (!this.matches[index$4]) this.matches[index$4] = Object.create(null);
			for (var i = 0; i < len; i++) {
				var e = matchedEntries[i];
				if (prefix) if (prefix !== "/") e = prefix + "/" + e;
				else e = prefix + e;
				if (e.charAt(0) === "/" && !this.nomount) e = path$1.join(this.root, e);
				this._emitMatch(index$4, e);
			}
			return cb();
		}
		remain.shift();
		for (var i = 0; i < len; i++) {
			var e = matchedEntries[i];
			if (prefix) if (prefix !== "/") e = prefix + "/" + e;
			else e = prefix + e;
			this._process([e].concat(remain), index$4, inGlobStar, cb);
		}
		cb();
	};
	Glob.prototype._emitMatch = function(index$4, e) {
		if (this.aborted) return;
		if (isIgnored(this, e)) return;
		if (this.paused) {
			this._emitQueue.push([index$4, e]);
			return;
		}
		var abs = isAbsolute(e) ? e : this._makeAbs(e);
		if (this.mark) e = this._mark(e);
		if (this.absolute) e = abs;
		if (this.matches[index$4][e]) return;
		if (this.nodir) {
			var c = this.cache[abs];
			if (c === "DIR" || Array.isArray(c)) return;
		}
		this.matches[index$4][e] = true;
		var st = this.statCache[abs];
		if (st) this.emit("stat", e, st);
		this.emit("match", e);
	};
	Glob.prototype._readdirInGlobStar = function(abs, cb) {
		if (this.aborted) return;
		if (this.follow) return this._readdir(abs, false, cb);
		var lstatkey = "lstat\0" + abs;
		var self = this;
		var lstatcb = inflight(lstatkey, lstatcb_);
		if (lstatcb) self.fs.lstat(abs, lstatcb);
		function lstatcb_(er, lstat) {
			if (er && er.code === "ENOENT") return cb();
			var isSym = lstat && lstat.isSymbolicLink();
			self.symlinks[abs] = isSym;
			if (!isSym && lstat && !lstat.isDirectory()) {
				self.cache[abs] = "FILE";
				cb();
			} else self._readdir(abs, false, cb);
		}
	};
	Glob.prototype._readdir = function(abs, inGlobStar, cb) {
		if (this.aborted) return;
		cb = inflight("readdir\0" + abs + "\0" + inGlobStar, cb);
		if (!cb) return;
		if (inGlobStar && !ownProp(this.symlinks, abs)) return this._readdirInGlobStar(abs, cb);
		if (ownProp(this.cache, abs)) {
			var c = this.cache[abs];
			if (!c || c === "FILE") return cb();
			if (Array.isArray(c)) return cb(null, c);
		}
		this.fs.readdir(abs, readdirCb(this, abs, cb));
	};
	function readdirCb(self, abs, cb) {
		return function(er, entries) {
			if (er) self._readdirError(abs, er, cb);
			else self._readdirEntries(abs, entries, cb);
		};
	}
	Glob.prototype._readdirEntries = function(abs, entries, cb) {
		if (this.aborted) return;
		if (!this.mark && !this.stat) for (var i = 0; i < entries.length; i++) {
			var e = entries[i];
			if (abs === "/") e = abs + e;
			else e = abs + "/" + e;
			this.cache[e] = true;
		}
		this.cache[abs] = entries;
		return cb(null, entries);
	};
	Glob.prototype._readdirError = function(f, er, cb) {
		if (this.aborted) return;
		switch (er.code) {
			case "ENOTSUP":
			case "ENOTDIR":
				var abs = this._makeAbs(f);
				this.cache[abs] = "FILE";
				if (abs === this.cwdAbs) {
					var error = /* @__PURE__ */ new Error(er.code + " invalid cwd " + this.cwd);
					error.path = this.cwd;
					error.code = er.code;
					this.emit("error", error);
					this.abort();
				}
				break;
			case "ENOENT":
			case "ELOOP":
			case "ENAMETOOLONG":
			case "UNKNOWN":
				this.cache[this._makeAbs(f)] = false;
				break;
			default:
				this.cache[this._makeAbs(f)] = false;
				if (this.strict) {
					this.emit("error", er);
					this.abort();
				}
				if (!this.silent) console.error("glob error", er);
				break;
		}
		return cb();
	};
	Glob.prototype._processGlobStar = function(prefix, read, abs, remain, index$4, inGlobStar, cb) {
		var self = this;
		this._readdir(abs, inGlobStar, function(er, entries) {
			self._processGlobStar2(prefix, read, abs, remain, index$4, inGlobStar, entries, cb);
		});
	};
	Glob.prototype._processGlobStar2 = function(prefix, read, abs, remain, index$4, inGlobStar, entries, cb) {
		if (!entries) return cb();
		var remainWithoutGlobStar = remain.slice(1);
		var gspref = prefix ? [prefix] : [];
		var noGlobStar = gspref.concat(remainWithoutGlobStar);
		this._process(noGlobStar, index$4, false, cb);
		var isSym = this.symlinks[abs];
		var len = entries.length;
		if (isSym && inGlobStar) return cb();
		for (var i = 0; i < len; i++) {
			if (entries[i].charAt(0) === "." && !this.dot) continue;
			var instead = gspref.concat(entries[i], remainWithoutGlobStar);
			this._process(instead, index$4, true, cb);
			var below = gspref.concat(entries[i], remain);
			this._process(below, index$4, true, cb);
		}
		cb();
	};
	Glob.prototype._processSimple = function(prefix, index$4, cb) {
		var self = this;
		this._stat(prefix, function(er, exists) {
			self._processSimple2(prefix, index$4, er, exists, cb);
		});
	};
	Glob.prototype._processSimple2 = function(prefix, index$4, er, exists, cb) {
		if (!this.matches[index$4]) this.matches[index$4] = Object.create(null);
		if (!exists) return cb();
		if (prefix && isAbsolute(prefix) && !this.nomount) {
			var trail = /[\/\\]$/.test(prefix);
			if (prefix.charAt(0) === "/") prefix = path$1.join(this.root, prefix);
			else {
				prefix = path$1.resolve(this.root, prefix);
				if (trail) prefix += "/";
			}
		}
		if (process.platform === "win32") prefix = prefix.replace(/\\/g, "/");
		this._emitMatch(index$4, prefix);
		cb();
	};
	Glob.prototype._stat = function(f, cb) {
		var abs = this._makeAbs(f);
		var needDir = f.slice(-1) === "/";
		if (f.length > this.maxLength) return cb();
		if (!this.stat && ownProp(this.cache, abs)) {
			var c = this.cache[abs];
			if (Array.isArray(c)) c = "DIR";
			if (!needDir || c === "DIR") return cb(null, c);
			if (needDir && c === "FILE") return cb();
		}
		var stat = this.statCache[abs];
		if (stat !== void 0) if (stat === false) return cb(null, stat);
		else {
			var type = stat.isDirectory() ? "DIR" : "FILE";
			if (needDir && type === "FILE") return cb();
			else return cb(null, type, stat);
		}
		var self = this;
		var statcb = inflight("stat\0" + abs, lstatcb_);
		if (statcb) self.fs.lstat(abs, statcb);
		function lstatcb_(er, lstat) {
			if (lstat && lstat.isSymbolicLink()) return self.fs.stat(abs, function(er$1, stat$1) {
				if (er$1) self._stat2(f, abs, null, lstat, cb);
				else self._stat2(f, abs, er$1, stat$1, cb);
			});
			else self._stat2(f, abs, er, lstat, cb);
		}
	};
	Glob.prototype._stat2 = function(f, abs, er, stat, cb) {
		if (er && (er.code === "ENOENT" || er.code === "ENOTDIR")) {
			this.statCache[abs] = false;
			return cb();
		}
		var needDir = f.slice(-1) === "/";
		this.statCache[abs] = stat;
		if (abs.slice(-1) === "/" && stat && !stat.isDirectory()) return cb(null, false, stat);
		var c = true;
		if (stat) c = stat.isDirectory() ? "DIR" : "FILE";
		this.cache[abs] = this.cache[abs] || c;
		if (needDir && c === "FILE") return cb();
		return cb(null, c, stat);
	};
}));

//#endregion
//#region src/dialects/mysql/grammar.ts
const checkNumber$1 = (it) => {
	const check = Number(it);
	if (Number.isNaN(check)) return "NaN";
	if (check >= Number.MIN_SAFE_INTEGER && check <= Number.MAX_SAFE_INTEGER) return "number";
	return "bigint";
};
const IntOps = {
	defaultFromDrizzle: function(value) {
		if (typeof value === "number") return String(value);
		return String(value);
	},
	defaultFromIntrospect: function(value) {
		return value;
	}
};
const Int$1 = {
	is: (type) => /^(?:int)(?:[\s(].*)?$/i.test(type),
	drizzleImport: () => "int",
	defaultFromDrizzle: IntOps.defaultFromDrizzle,
	defaultFromIntrospect: IntOps.defaultFromIntrospect,
	toTs: (type, value) => {
		const options = type.includes("unsigned") ? { unsigned: true } : void 0;
		const check = Number(value);
		if (Number.isNaN(check)) return {
			options,
			default: `sql\`${value}\``
		};
		return {
			options,
			default: value ?? ""
		};
	}
};
const TinyInt$1 = {
	is: (type) => /^(?:tinyint)(?:[\s(].*)?$/i.test(type),
	drizzleImport: () => "tinyint",
	defaultFromDrizzle: IntOps.defaultFromDrizzle,
	defaultFromIntrospect: IntOps.defaultFromIntrospect,
	toTs: Int$1.toTs
};
const SmallInt$1 = {
	is: (type) => /^(?:smallint)(?:[\s(].*)?$/i.test(type),
	drizzleImport: () => "smallint",
	defaultFromDrizzle: IntOps.defaultFromDrizzle,
	defaultFromIntrospect: IntOps.defaultFromIntrospect,
	toTs: Int$1.toTs
};
const MediumInt = {
	is: (type) => /^(?:mediumint)(?:[\s(].*)?$/i.test(type),
	drizzleImport: () => "mediumint",
	defaultFromDrizzle: IntOps.defaultFromDrizzle,
	defaultFromIntrospect: IntOps.defaultFromIntrospect,
	toTs: Int$1.toTs
};
const Real$2 = {
	is: (type) => /^(?:real)(?:[\s(].*)?$/i.test(type),
	drizzleImport: () => "real",
	defaultFromDrizzle: (value) => {
		return String(value);
	},
	defaultFromIntrospect: (value) => {
		return require_utils.trimChar(require_utils.trimChar(require_utils.trimChar(value, "("), ")"), "'");
	},
	toTs: (type, value) => {
		const options = type.includes("unsigned") || type.includes("UNSIGNED") ? { unsigned: true } : {};
		const [precision, scale] = require_grammar.parseParams(type);
		if (precision) options["precision"] = Number(precision);
		if (scale) options["scale"] = Number(scale);
		if (!value) return {
			options,
			default: ""
		};
		const numType = checkNumber$1(value);
		if (numType === "NaN") return {
			options,
			default: `sql\`${value}\``
		};
		if (numType === "number") return {
			options,
			default: value
		};
		if (numType === "bigint") return {
			options,
			default: `${value}n`
		};
		require_utils.assertUnreachable(numType);
	}
};
const Double = {
	is: (type) => /^(?:double)(?:[\s(].*)?$/i.test(type) || /^(?:double precision)(?:[\s(].*)?$/i.test(type),
	drizzleImport: () => "double",
	defaultFromDrizzle: Real$2.defaultFromDrizzle,
	defaultFromIntrospect: Real$2.defaultFromIntrospect,
	toTs: Real$2.toTs
};
const Float$2 = {
	is: (type) => /^(?:float)(?:[\s(].*)?$/i.test(type),
	drizzleImport: () => "float",
	defaultFromDrizzle: Real$2.defaultFromDrizzle,
	defaultFromIntrospect: Real$2.defaultFromIntrospect,
	toTs: Real$2.toTs
};
const Char$2 = {
	is: (type) => /^(?:char)(?:[\s(].*)?$/i.test(type) || /^(?:character)(?:[\s(].*)?$/i.test(type),
	drizzleImport: () => "char",
	defaultFromDrizzle: (value) => {
		return `'${require_grammar.escapeForSqlDefault(String(value))}'`;
	},
	defaultFromIntrospect: (value) => {
		if (value.startsWith("(")) return value;
		return `'${require_grammar.escapeForSqlDefault(require_utils.trimChar(value, "'"))}'`;
	},
	toTs: (type, value) => {
		const options = {};
		const [length] = require_grammar.parseParams(type);
		if (length) options["length"] = Number(length);
		if (!value) return {
			options,
			default: ""
		};
		if (value.startsWith("(")) return {
			options,
			default: `sql\`${value}\``
		};
		return {
			options,
			default: require_grammar.escapeForTsLiteral(require_grammar.unescapeFromSqlDefault(require_utils.trimChar(value, "'")))
		};
	}
};
const Varchar$2 = {
	is: (type) => {
		return /^(?:varchar)(?:[\s(].*)?$/i.test(type) || /^(?:nvarchar)(?:[\s(].*)?$/i.test(type) || /^(?:character varying)(?:[\s(].*)?$/i.test(type);
	},
	drizzleImport: () => "varchar",
	defaultFromDrizzle: Char$2.defaultFromDrizzle,
	defaultFromIntrospect: Char$2.defaultFromIntrospect,
	toTs: Char$2.toTs
};
const TinyText = {
	is: (type) => /^\s*tinytext\s*$/i.test(type),
	drizzleImport: () => "tinytext",
	defaultFromDrizzle: (value) => {
		return `('${require_grammar.escapeForSqlDefault(value)}')`;
	},
	defaultFromIntrospect: (value) => {
		return value;
	},
	toTs: (type, value) => {
		const options = {};
		const [length] = require_grammar.parseParams(type);
		if (length) options["length"] = Number(length);
		if (!value) return {
			options,
			default: ""
		};
		if (value.startsWith("(") || !value.startsWith("'")) return {
			options,
			default: `sql\`${value}\``
		};
		const trimmed = require_utils.trimChar(value, "'");
		return {
			options,
			default: value ? require_grammar.escapeForTsLiteral(require_grammar.unescapeFromSqlDefault(trimmed)) : ""
		};
	}
};
const MediumText = {
	is: (type) => /^\s*mediumtext\s*$/i.test(type),
	drizzleImport: () => "mediumtext",
	defaultFromDrizzle: TinyText.defaultFromDrizzle,
	defaultFromIntrospect: TinyText.defaultFromIntrospect,
	toTs: TinyText.toTs
};
const Text$1 = {
	is: (type) => /^\s*text\s*$/i.test(type),
	drizzleImport: () => "text",
	defaultFromDrizzle: TinyText.defaultFromDrizzle,
	defaultFromIntrospect: TinyText.defaultFromIntrospect,
	toTs: TinyText.toTs
};
const LongText = {
	is: (type) => /^\s*longtext\s*$/i.test(type),
	drizzleImport: () => "longtext",
	defaultFromDrizzle: TinyText.defaultFromDrizzle,
	defaultFromIntrospect: TinyText.defaultFromIntrospect,
	toTs: TinyText.toTs
};
const TinyBlob = {
	is: (type) => /^\s*tinyblob\s*$/i.test(type),
	drizzleImport: () => "tinyblob",
	defaultFromDrizzle: (value) => {
		if (typeof Buffer !== "undefined" && typeof Buffer.isBuffer === "function" && Buffer.isBuffer(value)) return `(0x${value.toString("hex").toLowerCase()})`;
		if (Array.isArray(value) || typeof value === "object" || typeof value === "string") return Text$1.defaultFromDrizzle(value);
		throw new Error("unexpected");
	},
	defaultFromIntrospect: (value) => {
		return value;
	},
	toTs: (type, value) => {
		if (value === null) return { default: "" };
		if (typeof Buffer !== "undefined" && value.startsWith("0x")) return {
			options: { mode: "buffer" },
			default: `Buffer.from("${Buffer.from(value.slice(2, value.length), "hex").toString("utf-8").replaceAll("\\", "\\\\").replace("\"", "\\\"")}")`
		};
		const { default: stringDef } = Text$1.toTs(type, value);
		return {
			default: stringDef,
			options: { mode: "string" }
		};
	}
};
const MediumBlob = {
	is: (type) => /^\s*mediumblob\s*$/i.test(type),
	drizzleImport: () => "mediumblob",
	defaultFromDrizzle: TinyBlob.defaultFromDrizzle,
	defaultFromIntrospect: TinyBlob.defaultFromIntrospect,
	toTs: TinyBlob.toTs
};
const LongBlob = {
	is: (type) => /^\s*longblob\s*$/i.test(type),
	drizzleImport: () => "longblob",
	defaultFromDrizzle: TinyBlob.defaultFromDrizzle,
	defaultFromIntrospect: TinyBlob.defaultFromIntrospect,
	toTs: TinyBlob.toTs
};
const Blob = {
	is: (type) => /^\s*blob\s*$/i.test(type),
	drizzleImport: () => "blob",
	defaultFromDrizzle: TinyBlob.defaultFromDrizzle,
	defaultFromIntrospect: TinyBlob.defaultFromIntrospect,
	toTs: TinyBlob.toTs
};
const Binary$1 = {
	is: (type) => /^(?:binary)(?:[\s(].*)?$/i.test(type),
	drizzleImport: () => "binary",
	defaultFromDrizzle: TinyText.defaultFromDrizzle,
	defaultFromIntrospect: (value) => {
		if (value.startsWith("0x")) return `'${Buffer.from(value.slice(2), "hex").toString("utf-8")}'`;
		return value;
	},
	toTs: TinyText.toTs
};
const Timestamp = {
	is: (type) => /^(?:timestamp)(?:[\s(].*)?$/i.test(type),
	drizzleImport: () => "timestamp",
	defaultFromDrizzle: (value) => {
		if (value instanceof Date) return `'${value.toISOString().replace("T", " ").slice(0, 23)}'`;
		return `'${value}'`;
	},
	defaultFromIntrospect: (value) => {
		if (!isNaN(Date.parse(value))) return `'${value}'`;
		return value;
	},
	toTs: (type, def) => {
		const options = {};
		const [fsp] = require_grammar.parseParams(type);
		if (fsp) options["fsp"] = Number(fsp);
		if (!def) return {
			options,
			default: ""
		};
		const trimmed = require_utils.trimChar(def, "'");
		if (trimmed === "now()" || trimmed === "(now())" || trimmed === "(CURRENT_TIMESTAMP)" || trimmed === "CURRENT_TIMESTAMP") return {
			options,
			default: ".defaultNow()"
		};
		if (trimmed.includes("now(") || trimmed.includes("CURRENT_TIMESTAMP(")) return {
			options,
			default: `sql\`${trimmed}\``
		};
		if (fsp && Number(fsp) > 3) return {
			options,
			default: `sql\`'${trimmed}'\``
		};
		return {
			options,
			default: `new Date("${trimmed}Z")`
		};
	}
};
const DateTime = {
	is: (type) => /^(?:datetime)(?:[\s(].*)?$/i.test(type),
	drizzleImport: () => "datetime",
	defaultFromDrizzle: Timestamp.defaultFromDrizzle,
	defaultFromIntrospect: Timestamp.defaultFromIntrospect,
	toTs: (type, def) => {
		const options = {};
		const [fsp] = require_grammar.parseParams(type);
		if (fsp) options["fsp"] = Number(fsp);
		if (!def) return {
			options,
			default: ""
		};
		const trimmed = require_utils.trimChar(def, "'");
		if (trimmed.includes("now(") || trimmed.includes("CURRENT_TIMESTAMP(")) return {
			options,
			default: `sql\`${trimmed}\``
		};
		if (fsp && Number(fsp) > 3) return {
			options,
			default: `sql\`'${trimmed}'\``
		};
		return {
			options,
			default: `new Date("${trimmed}Z")`
		};
	}
};

//#endregion
//#region src/dialects/mysql/ddl.ts
const createDDL$3 = () => {
	return require_ddl.create({
		tables: {},
		columns: {
			table: "required",
			type: "string",
			notNull: "boolean",
			autoIncrement: "boolean",
			default: "string?",
			onUpdateNow: "boolean",
			onUpdateNowFsp: "number?",
			charSet: "string?",
			collation: "string?",
			generated: {
				type: ["stored", "virtual"],
				as: "string"
			}
		},
		pks: {
			table: "required",
			columns: "string[]"
		},
		fks: {
			table: "required",
			columns: "string[]",
			tableTo: "string",
			columnsTo: "string[]",
			onUpdate: [
				"NO ACTION",
				"RESTRICT",
				"SET NULL",
				"CASCADE",
				"SET DEFAULT",
				null
			],
			onDelete: [
				"NO ACTION",
				"RESTRICT",
				"SET NULL",
				"CASCADE",
				"SET DEFAULT",
				null
			],
			nameExplicit: "boolean"
		},
		indexes: {
			table: "required",
			columns: [{
				value: "string",
				isExpression: "boolean"
			}],
			isUnique: "boolean",
			using: [
				"btree",
				"hash",
				null
			],
			algorithm: [
				"default",
				"inplace",
				"copy",
				null
			],
			lock: [
				"default",
				"none",
				"shared",
				"exclusive",
				null
			],
			nameExplicit: "boolean"
		},
		checks: {
			table: "required",
			value: "string"
		},
		views: {
			definition: "string",
			algorithm: [
				"undefined",
				"merge",
				"temptable"
			],
			sqlSecurity: ["definer", "invoker"],
			withCheckOption: [
				"local",
				"cascaded",
				null
			]
		}
	});
};

//#endregion
//#region src/dialects/mysql/snapshot.ts
const index$3 = require_types.objectType({
	name: require_types.stringType(),
	columns: require_types.stringType().array(),
	isUnique: require_types.booleanType(),
	using: require_types.enumType(["btree", "hash"]).optional(),
	algorithm: require_types.enumType([
		"default",
		"inplace",
		"copy"
	]).optional(),
	lock: require_types.enumType([
		"default",
		"none",
		"shared",
		"exclusive"
	]).optional()
}).strict();
const fk$2 = require_types.objectType({
	name: require_types.stringType(),
	tableFrom: require_types.stringType(),
	columnsFrom: require_types.stringType().array(),
	tableTo: require_types.stringType(),
	columnsTo: require_types.stringType().array(),
	onUpdate: require_types.stringType().optional(),
	onDelete: require_types.stringType().optional()
}).strict();
const column$3 = require_types.objectType({
	name: require_types.stringType(),
	type: require_types.stringType(),
	primaryKey: require_types.booleanType(),
	notNull: require_types.booleanType(),
	autoincrement: require_types.booleanType().optional(),
	default: require_types.anyType().optional(),
	onUpdate: require_types.anyType().optional(),
	generated: require_types.objectType({
		type: require_types.enumType(["stored", "virtual"]),
		as: require_types.stringType()
	}).optional()
}).strict();
const tableV3 = require_types.objectType({
	name: require_types.stringType(),
	columns: require_types.recordType(require_types.stringType(), column$3),
	indexes: require_types.recordType(require_types.stringType(), index$3),
	foreignKeys: require_types.recordType(require_types.stringType(), fk$2)
}).strict();
const compositePK$3 = require_types.objectType({
	name: require_types.stringType(),
	columns: require_types.stringType().array()
}).strict();
const uniqueConstraint$3 = require_types.objectType({
	name: require_types.stringType(),
	columns: require_types.stringType().array()
}).strict();
const checkConstraint$2 = require_types.objectType({
	name: require_types.stringType(),
	value: require_types.stringType()
}).strict();
const tableV4 = require_types.objectType({
	name: require_types.stringType(),
	schema: require_types.stringType().optional(),
	columns: require_types.recordType(require_types.stringType(), column$3),
	indexes: require_types.recordType(require_types.stringType(), index$3),
	foreignKeys: require_types.recordType(require_types.stringType(), fk$2)
}).strict();
const table$3 = require_types.objectType({
	name: require_types.stringType(),
	columns: require_types.recordType(require_types.stringType(), column$3),
	indexes: require_types.recordType(require_types.stringType(), index$3),
	foreignKeys: require_types.recordType(require_types.stringType(), fk$2),
	compositePrimaryKeys: require_types.recordType(require_types.stringType(), compositePK$3),
	uniqueConstraints: require_types.recordType(require_types.stringType(), uniqueConstraint$3).default({}),
	checkConstraint: require_types.recordType(require_types.stringType(), checkConstraint$2).default({})
}).strict();
const viewMeta = require_types.objectType({
	algorithm: require_types.enumType([
		"undefined",
		"merge",
		"temptable"
	]),
	sqlSecurity: require_types.enumType(["definer", "invoker"]),
	withCheckOption: require_types.enumType(["local", "cascaded"]).optional()
}).strict();
const view$2 = require_types.objectType({
	name: require_types.stringType(),
	columns: require_types.recordType(require_types.stringType(), column$3),
	definition: require_types.stringType().optional(),
	isExisting: require_types.booleanType()
}).strict().merge(viewMeta);
const kitInternals$2 = require_types.objectType({
	tables: require_types.recordType(require_types.stringType(), require_types.objectType({ columns: require_types.recordType(require_types.stringType(), require_types.objectType({ isDefaultAnExpression: require_types.booleanType().optional() }).optional()) }).optional()).optional(),
	indexes: require_types.recordType(require_types.stringType(), require_types.objectType({ columns: require_types.recordType(require_types.stringType(), require_types.objectType({ isExpression: require_types.booleanType().optional() }).optional()) }).optional()).optional()
}).optional();
const dialect$2 = require_types.literalType("mysql");
const schemaHash$3 = require_types.objectType({
	id: require_types.stringType(),
	prevIds: require_types.arrayType(require_types.stringType())
});
const schemaHashV6 = require_types.objectType({
	id: require_types.stringType(),
	prevId: require_types.stringType()
});
const schemaInternalV3 = require_types.objectType({
	version: require_types.literalType("3"),
	dialect: dialect$2,
	tables: require_types.recordType(require_types.stringType(), tableV3)
}).strict();
const schemaInternalV4 = require_types.objectType({
	version: require_types.literalType("4"),
	dialect: dialect$2,
	tables: require_types.recordType(require_types.stringType(), tableV4),
	schemas: require_types.recordType(require_types.stringType(), require_types.stringType())
}).strict();
const schemaInternalV5$1 = require_types.objectType({
	version: require_types.literalType("5"),
	dialect: dialect$2,
	tables: require_types.recordType(require_types.stringType(), table$3),
	schemas: require_types.recordType(require_types.stringType(), require_types.stringType()),
	_meta: require_types.objectType({
		schemas: require_types.recordType(require_types.stringType(), require_types.stringType()),
		tables: require_types.recordType(require_types.stringType(), require_types.stringType()),
		columns: require_types.recordType(require_types.stringType(), require_types.stringType())
	}),
	internal: kitInternals$2
}).strict();
const schemaInternal$1 = require_types.objectType({
	version: require_types.literalType("5"),
	dialect: dialect$2,
	tables: require_types.recordType(require_types.stringType(), table$3),
	views: require_types.recordType(require_types.stringType(), view$2).default({}),
	_meta: require_types.objectType({
		tables: require_types.recordType(require_types.stringType(), require_types.stringType()),
		columns: require_types.recordType(require_types.stringType(), require_types.stringType())
	}),
	internal: kitInternals$2
}).strict();
const schemaV3 = schemaInternalV3.merge(schemaHash$3);
const schemaV4 = schemaInternalV4.merge(schemaHash$3);
const schemaV5$1 = schemaInternalV5$1.merge(schemaHash$3);
const schemaV6$1 = schemaInternal$1.merge(schemaHashV6);
const schema$2 = schemaInternal$1.merge(schemaHash$3);
const tableSquashedV4 = require_types.objectType({
	name: require_types.stringType(),
	schema: require_types.stringType().optional(),
	columns: require_types.recordType(require_types.stringType(), column$3),
	indexes: require_types.recordType(require_types.stringType(), require_types.stringType()),
	foreignKeys: require_types.recordType(require_types.stringType(), require_types.stringType())
}).strict();
const tableSquashed$2 = require_types.objectType({
	name: require_types.stringType(),
	schema: require_types.stringType().optional(),
	columns: require_types.recordType(require_types.stringType(), column$3),
	indexes: require_types.recordType(require_types.stringType(), require_types.stringType()),
	foreignKeys: require_types.recordType(require_types.stringType(), require_types.stringType()),
	compositePrimaryKeys: require_types.recordType(require_types.stringType(), require_types.stringType()),
	uniqueConstraints: require_types.recordType(require_types.stringType(), require_types.stringType()).default({}),
	checkConstraints: require_types.recordType(require_types.stringType(), require_types.stringType()).default({})
}).strict();
const viewSquashed = view$2.omit({
	algorithm: true,
	sqlSecurity: true,
	withCheckOption: true
}).extend({ meta: require_types.stringType() });
const schemaSquashed$2 = require_types.objectType({
	version: require_types.literalType("5"),
	dialect: dialect$2,
	tables: require_types.recordType(require_types.stringType(), tableSquashed$2),
	views: require_types.recordType(require_types.stringType(), viewSquashed)
}).strict();
const schemaSquashedV4 = require_types.objectType({
	version: require_types.literalType("4"),
	dialect: dialect$2,
	tables: require_types.recordType(require_types.stringType(), tableSquashedV4),
	schemas: require_types.recordType(require_types.stringType(), require_types.stringType())
}).strict();
const ddl$4 = createDDL$3();
const snapshotValidator$4 = require_snapshot.validator({
	version: ["6"],
	dialect: ["mysql"],
	id: "string",
	prevIds: require_snapshot.array((_) => true),
	ddl: require_snapshot.array((it) => ddl$4.entities.validate(it)),
	renames: require_snapshot.array((_) => true)
});
const drySnapshot$3 = snapshotValidator$4.strict({
	version: "6",
	dialect: "mysql",
	id: require_utils.originUUID,
	prevIds: [],
	ddl: [],
	renames: []
});

//#endregion
//#region src/dialects/singlestore/snapshot.ts
const index$2 = require_types.objectType({
	name: require_types.stringType(),
	columns: require_types.stringType().array(),
	isUnique: require_types.booleanType(),
	using: require_types.enumType(["btree", "hash"]).optional(),
	algorithm: require_types.enumType([
		"default",
		"inplace",
		"copy"
	]).optional(),
	lock: require_types.enumType([
		"default",
		"none",
		"shared",
		"exclusive"
	]).optional()
}).strict();
const column$2 = require_types.objectType({
	name: require_types.stringType(),
	type: require_types.stringType(),
	typeSchema: require_types.stringType().optional(),
	primaryKey: require_types.booleanType(),
	notNull: require_types.booleanType(),
	autoincrement: require_types.booleanType().optional(),
	default: require_types.anyType().optional(),
	onUpdate: require_types.anyType().optional(),
	generated: require_types.objectType({
		type: require_types.enumType(["stored", "virtual"]),
		as: require_types.stringType()
	}).optional()
}).strict();
const compositePK$2 = require_types.objectType({
	name: require_types.stringType(),
	columns: require_types.stringType().array()
}).strict();
const uniqueConstraint$2 = require_types.objectType({
	name: require_types.stringType(),
	columns: require_types.stringType().array()
}).strict();
const table$2 = require_types.objectType({
	name: require_types.stringType(),
	columns: require_types.recordType(require_types.stringType(), column$2),
	indexes: require_types.recordType(require_types.stringType(), index$2),
	compositePrimaryKeys: require_types.recordType(require_types.stringType(), compositePK$2),
	uniqueConstraints: require_types.recordType(require_types.stringType(), uniqueConstraint$2).default({})
}).strict();
const kitInternals$1 = require_types.objectType({
	tables: require_types.recordType(require_types.stringType(), require_types.objectType({ columns: require_types.recordType(require_types.stringType(), require_types.objectType({ isDefaultAnExpression: require_types.booleanType().optional() }).optional()) }).optional()).optional(),
	indexes: require_types.recordType(require_types.stringType(), require_types.objectType({ columns: require_types.recordType(require_types.stringType(), require_types.objectType({ isExpression: require_types.booleanType().optional() }).optional()) }).optional()).optional()
}).optional();
const dialect$1 = require_types.literalType("singlestore");
const schemaHashV1 = require_types.objectType({
	id: require_types.stringType(),
	prevId: require_types.stringType()
});
const schemaHash$2 = require_types.objectType({
	id: require_types.stringType(),
	prevIds: require_types.arrayType(require_types.stringType())
});
const schemaInternal = require_types.objectType({
	version: require_types.literalType("1"),
	dialect: dialect$1,
	tables: require_types.recordType(require_types.stringType(), table$2),
	_meta: require_types.objectType({
		tables: require_types.recordType(require_types.stringType(), require_types.stringType()),
		columns: require_types.recordType(require_types.stringType(), require_types.stringType())
	}),
	internal: kitInternals$1
}).strict();
const schemaV1 = schemaInternal.merge(schemaHashV1);
const schema$1 = schemaInternal.merge(schemaHash$2);
const tableSquashed$1 = require_types.objectType({
	name: require_types.stringType(),
	schema: require_types.stringType().optional(),
	columns: require_types.recordType(require_types.stringType(), column$2),
	indexes: require_types.recordType(require_types.stringType(), require_types.stringType()),
	compositePrimaryKeys: require_types.recordType(require_types.stringType(), require_types.stringType()),
	uniqueConstraints: require_types.recordType(require_types.stringType(), require_types.stringType()).default({})
}).strict();
const schemaSquashed$1 = require_types.objectType({
	version: require_types.literalType("1"),
	dialect: dialect$1,
	tables: require_types.recordType(require_types.stringType(), tableSquashed$1)
}).strict();
const ddl$3 = createDDL$3();
const snapshotValidator$3 = require_snapshot.validator({
	version: ["2"],
	dialect: ["singlestore"],
	id: "string",
	prevIds: require_snapshot.array((_) => true),
	ddl: require_snapshot.array((it) => ddl$3.entities.validate(it)),
	renames: require_snapshot.array((_) => true)
});
const drySnapshot$2 = snapshotValidator$3.strict({
	version: "2",
	dialect: "singlestore",
	id: require_utils.originUUID,
	prevIds: [],
	ddl: [],
	renames: []
});

//#endregion
//#region src/dialects/cockroach/grammar.ts
const escapeForSqlDefault = (input, mode = "default") => {
	let value = input.replace(/\\/g, "\\\\");
	if (mode === "arr") value = value.replace(/'/g, "''").replaceAll("\"", "\\\"");
	else if (mode === "enum-arr") value = value.replace(/'/g, "''").replaceAll("\"", "\\\"").replace(",", "\\,");
	else value = value.replace(/'/g, "\\'");
	return value;
};
const unescapeFromSqlDefault = (input) => {
	input = /^e'.*'$/s.test(input) ? input.replace(/e'/g, "'") : input;
	input = require_utils.trimChar(input, "'");
	return input.replace(/\\"/g, "\"").replace(/\\'/g, "'").replace(/\\\\/g, "\\");
};
const escapeForTsLiteral = (input) => {
	return input.replace(/\\/g, "\\\\").replace(/"/g, "\\\"");
};
const defaults$1 = {
	identity: {
		startWith: "1",
		increment: "1",
		min: "1",
		maxFor: (type) => {
			if (type === "int2") return "32767";
			if (type === "int4") return "2147483647";
			if (type === "int8") return "9223372036854775807";
			throw new Error(`Unknow identity column type: ${type}`);
		},
		cache: 1
	},
	index: { method: "btree" }
};
const Int2 = {
	is: (type) => /^\s*int2(?:\s*\[\s*\])*\s*$/i.test(type),
	drizzleImport: () => "int2",
	defaultFromDrizzle: (value) => {
		return String(value);
	},
	defaultArrayFromDrizzle: (value) => {
		return `'${require_utils.stringifyArray(value, "sql", (v) => String(v))}'`;
	},
	defaultFromIntrospect: (value) => {
		return value;
	},
	defaultArrayFromIntrospect: (value) => {
		return value;
	},
	toTs: (_, value) => ({ default: value ?? "" }),
	toArrayTs: (_, value) => {
		if (!value) return { default: "" };
		try {
			return { default: require_utils.stringifyArray(require_grammar.parseArray(require_utils.trimChar(require_utils.trimChar(value, ["(", ")"]), "'")), "ts", (v) => {
				return `${v}`;
			}) };
		} catch {
			return { default: `sql\`${value}\`` };
		}
	}
};
const Int4 = {
	is: (type) => /^\s*int4(?:\s*\[\s*\])*\s*$/i.test(type),
	drizzleImport: () => "int4",
	defaultFromDrizzle: Int2.defaultFromDrizzle,
	defaultArrayFromDrizzle: Int2.defaultArrayFromDrizzle,
	defaultFromIntrospect: Int2.defaultFromIntrospect,
	defaultArrayFromIntrospect: Int2.defaultArrayFromIntrospect,
	toTs: Int2.toTs,
	toArrayTs: Int2.toArrayTs
};
const Real$1 = {
	is: (type) => /^\s*real(?:\s*\[\s*\])*\s*$/i.test(type),
	drizzleImport: () => "real",
	defaultFromDrizzle: (value) => {
		return String(value);
	},
	defaultArrayFromDrizzle: (value) => {
		return `'${require_utils.stringifyArray(value, "sql", (v) => String(v))}'`;
	},
	defaultFromIntrospect: (value) => {
		return value;
	},
	defaultArrayFromIntrospect: (value) => {
		return value;
	},
	toTs: (_, value) => ({ default: value ?? "" }),
	toArrayTs: (_, value) => {
		if (!value) return { default: "" };
		try {
			return { default: require_utils.stringifyArray(require_grammar.parseArray(require_utils.trimChar(require_utils.trimChar(value, ["(", ")"]), "'")), "ts", (v) => {
				return `${v}`;
			}) };
		} catch {
			return { default: `sql\`${value}\`` };
		}
	}
};
const Float$1 = {
	is: (type) => /^\s*float(?:\s*\[\s*\])*\s*$/i.test(type),
	drizzleImport: () => "float",
	defaultFromDrizzle: Real$1.defaultFromDrizzle,
	defaultArrayFromDrizzle: Real$1.defaultArrayFromDrizzle,
	defaultFromIntrospect: Real$1.defaultFromIntrospect,
	defaultArrayFromIntrospect: Real$1.defaultArrayFromIntrospect,
	toTs: Real$1.toTs,
	toArrayTs: Real$1.toArrayTs
};
const Bit = {
	is: (type) => /^\s*bit(?:\(\d+(?:,\d+)?\))?(?:\s*\[\s*\])*\s*$/i.test(type),
	drizzleImport: () => "bit",
	defaultFromDrizzle: (value) => {
		return `'${value}'`;
	},
	defaultArrayFromDrizzle: (value) => {
		return `'${require_utils.stringifyArray(value, "sql", (v) => String(v))}'`;
	},
	defaultFromIntrospect: (value) => {
		return value.replace(/^B'/, "'");
	},
	defaultArrayFromIntrospect: (value) => {
		return value;
	},
	toTs: (type, value) => {
		const [length] = require_grammar.parseParams(type);
		const options = length ? { length: Number(length) } : {};
		if (!value) return {
			options,
			default: ""
		};
		if (/^'[01]+'$/.test(value)) return {
			options,
			default: value
		};
		return {
			options,
			default: `sql\`${value}\``
		};
	},
	toArrayTs: (type, value) => {
		const [length] = require_grammar.parseParams(type);
		const options = length ? { length: Number(length) } : {};
		if (!value) return {
			options,
			default: ""
		};
		let isDrizzleSql = false;
		try {
			const def = require_utils.stringifyArray(require_grammar.parseArray(require_utils.trimChar(require_utils.trimChar(value, ["(", ")"]), "'")), "ts", (v) => {
				if (!/^[01]+$/.test(v)) isDrizzleSql = true;
				return `"${v}"`;
			});
			return {
				options,
				default: isDrizzleSql ? `sql\`${value}\`` : def
			};
		} catch {
			return {
				options,
				default: `sql\`${value}\``
			};
		}
	}
};
const VarBit = {
	is: (type) => /^\s*varbit(?:\(\d+(?:,\d+)?\))?(?:\s*\[\s*\])*\s*$/i.test(type),
	drizzleImport: () => "varbit",
	defaultFromDrizzle: Bit.defaultFromDrizzle,
	defaultArrayFromDrizzle: Bit.defaultArrayFromDrizzle,
	defaultFromIntrospect: Bit.defaultFromIntrospect,
	defaultArrayFromIntrospect: Bit.defaultArrayFromIntrospect,
	toTs: Bit.toTs,
	toArrayTs: Bit.toArrayTs
};
const Time$1 = {
	is: (type) => /^\s*time(?:\(\d+(?:,\d+)?\))?(?:\s*\[\s*\])*\s*$/i.test(type),
	drizzleImport: () => "time",
	defaultFromDrizzle: (value) => {
		return `'${String(value)}'`;
	},
	defaultArrayFromDrizzle(value) {
		return `'${require_utils.stringifyArray(value, "sql", (v) => String(v))}'`;
	},
	defaultFromIntrospect: (value) => {
		return value;
	},
	defaultArrayFromIntrospect: (value) => {
		return value;
	},
	toTs: (type, value) => {
		const options = {};
		const [precision] = require_grammar.parseParams(type);
		if (precision) options.precision = Number(precision);
		if (!value) return {
			default: "",
			options
		};
		if (value === "now()" || value === "current_timestamp()") return {
			default: ".defaultNow()",
			options
		};
		try {
			_js_temporal_polyfill.Temporal.PlainTime.from(value.substring(1, value.length - 1));
			return {
				default: value,
				options
			};
		} catch {
			return {
				default: `sql\`${value}\``,
				options
			};
		}
	},
	toArrayTs: (type, value) => {
		const options = {};
		const [precision] = require_grammar.parseParams(type);
		if (precision) options.precision = Number(precision);
		if (!value) return {
			default: "",
			options
		};
		try {
			return {
				options,
				default: require_utils.stringifyArray(require_grammar.parseArray(require_utils.trimChar(require_utils.trimChar(value, ["(", ")"]), "'")), "ts", (v) => `"${v}"`)
			};
		} catch {
			return {
				options,
				default: `sql\`${value}\``
			};
		}
	}
};
const TimeTz = {
	is: (type) => /^\s*timetz(?:\(\d+(?:,\d+)?\))?(?:\s*\[\s*\])*\s*$/i.test(type),
	drizzleImport: () => "time",
	defaultFromDrizzle: Time$1.defaultFromDrizzle,
	defaultArrayFromDrizzle: Time$1.defaultArrayFromDrizzle,
	defaultFromIntrospect: Time$1.defaultFromIntrospect,
	defaultArrayFromIntrospect: Time$1.defaultArrayFromIntrospect,
	toTs: (type, value) => {
		const options = { withTimezone: true };
		const [precision] = require_grammar.parseParams(type);
		if (precision) options.precision = Number(precision);
		if (!value) return {
			default: "",
			options
		};
		if (value === "now()" || value === "current_timestamp()") return {
			default: ".defaultNow()",
			options
		};
		try {
			_js_temporal_polyfill.Temporal.PlainTime.from(value.substring(1, value.length - 1));
			return {
				default: value,
				options
			};
		} catch {
			return {
				default: `sql\`${value}\``,
				options
			};
		}
	},
	toArrayTs: (type, value) => {
		const options = { withTimezone: true };
		const [precision] = require_grammar.parseParams(type);
		if (precision) options.precision = Number(precision);
		if (!value) return {
			default: "",
			options
		};
		try {
			return {
				options,
				default: require_utils.stringifyArray(require_grammar.parseArray(require_utils.trimChar(require_utils.trimChar(value, ["(", ")"]), "'")), "ts", (v) => `"${v}"`)
			};
		} catch {
			return {
				options,
				default: `sql\`${value}\``
			};
		}
	}
};
const Char$1 = {
	is: (type) => /^\s*char|character(?:\(\d+(?:,\d+)?\))?(?:\s*\[\s*\])*\s*$/i.test(type),
	drizzleImport: () => "char",
	defaultFromDrizzle: (value) => {
		const escaped = escapeForSqlDefault(String(value));
		return String(value).includes("\\") || String(value).includes("'") ? `e'${escaped}'` : `'${escaped}'`;
	},
	defaultArrayFromDrizzle: (value) => {
		return `'${require_utils.stringifyArray(value, "sql", (v) => {
			if (typeof v !== "string") throw new Error();
			const escaped = escapeForSqlDefault(v, "arr");
			if (v.includes("\\") || v.includes("\"") || v.includes(",")) return `"${escaped}"`;
			return escaped;
		})}'`;
	},
	defaultFromIntrospect: (value) => {
		return value;
	},
	defaultArrayFromIntrospect: (value) => {
		return value;
	},
	toTs: (type, value) => {
		const options = {};
		const [length] = require_grammar.parseParams(type);
		if (length) options["length"] = Number(length);
		if (!value) return {
			options,
			default: ""
		};
		return {
			options,
			default: `"${escapeForTsLiteral(unescapeFromSqlDefault(value))}"`
		};
	},
	toArrayTs: (type, value) => {
		const options = {};
		const [length] = require_grammar.parseParams(type);
		if (length) options["length"] = Number(length);
		if (!value) return {
			options,
			default: ""
		};
		try {
			return {
				options,
				default: require_utils.stringifyArray(require_grammar.parseArray(require_utils.trimChar(require_utils.trimChar(value, ["(", ")"]), "'")), "ts", (v) => {
					return `"${escapeForTsLiteral(unescapeFromSqlDefault(v))}"`;
				})
			};
		} catch {
			return {
				options,
				default: `sql\`${value}\``
			};
		}
	}
};
const Varchar$1 = {
	is: (type) => /^\s*varchar|character varying(?:\(\d+(?:,\d+)?\))?(?:\s*\[\s*\])*\s*$/i.test(type),
	drizzleImport: () => "varchar",
	defaultFromDrizzle: Char$1.defaultFromDrizzle,
	defaultArrayFromDrizzle: Char$1.defaultArrayFromDrizzle,
	defaultFromIntrospect: Char$1.defaultFromIntrospect,
	defaultArrayFromIntrospect: Char$1.defaultArrayFromIntrospect,
	toTs: Char$1.toTs,
	toArrayTs: Char$1.toArrayTs
};
const StringType = {
	is: (type) => /^\s*string(?:\(\d+(?:,\d+)?\))?(?:\s*\[\s*\])*\s*$/i.test(type),
	drizzleImport: () => "string",
	defaultFromDrizzle: Char$1.defaultFromDrizzle,
	defaultArrayFromDrizzle: Char$1.defaultArrayFromDrizzle,
	defaultFromIntrospect: Char$1.defaultFromIntrospect,
	defaultArrayFromIntrospect: Char$1.defaultArrayFromIntrospect,
	toTs: Char$1.toTs,
	toArrayTs: Char$1.toArrayTs
};

//#endregion
//#region src/dialects/cockroach/ddl.ts
const createDDL$2 = () => {
	return require_ddl.create({
		schemas: {},
		tables: {
			schema: "required",
			isRlsEnabled: "boolean"
		},
		enums: {
			schema: "required",
			values: "string[]"
		},
		columns: {
			schema: "required",
			table: "required",
			type: "string",
			typeSchema: "string?",
			notNull: "boolean",
			dimensions: "number",
			default: "string?",
			generated: {
				type: ["stored", "virtual"],
				as: "string"
			},
			identity: {
				type: ["always", "byDefault"],
				increment: "string?",
				minValue: "string?",
				maxValue: "string?",
				startWith: "string?",
				cache: "number?"
			}
		},
		indexes: {
			schema: "required",
			table: "required",
			nameExplicit: "boolean",
			columns: [{
				value: "string",
				isExpression: "boolean",
				asc: "boolean"
			}],
			isUnique: "boolean",
			where: "string?",
			method: "string?"
		},
		fks: {
			schema: "required",
			table: "required",
			nameExplicit: "boolean",
			columns: "string[]",
			schemaTo: "string",
			tableTo: "string",
			columnsTo: "string[]",
			onUpdate: [
				"NO ACTION",
				"RESTRICT",
				"SET NULL",
				"CASCADE",
				"SET DEFAULT",
				null
			],
			onDelete: [
				"NO ACTION",
				"RESTRICT",
				"SET NULL",
				"CASCADE",
				"SET DEFAULT",
				null
			]
		},
		pks: {
			schema: "required",
			table: "required",
			columns: "string[]",
			nameExplicit: "boolean"
		},
		checks: {
			schema: "required",
			table: "required",
			value: "string"
		},
		sequences: {
			schema: "required",
			incrementBy: "string?",
			minValue: "string?",
			maxValue: "string?",
			startWith: "string?",
			cacheSize: "number?"
		},
		roles: {
			createDb: "boolean?",
			createRole: "boolean?"
		},
		policies: {
			schema: "required",
			table: "required",
			as: ["PERMISSIVE", "RESTRICTIVE"],
			for: [
				"ALL",
				"SELECT",
				"INSERT",
				"UPDATE",
				"DELETE"
			],
			roles: "string[]",
			using: "string?",
			withCheck: "string?"
		},
		views: {
			schema: "required",
			definition: "string?",
			withNoData: "boolean?",
			materialized: "boolean"
		}
	});
};

//#endregion
//#region src/dialects/cockroach/snapshot.ts
const enumSchema = require_types.objectType({
	name: require_types.stringType(),
	schema: require_types.stringType(),
	values: require_types.stringType().array()
}).strict();
const indexColumn = require_types.objectType({
	expression: require_types.stringType(),
	isExpression: require_types.booleanType(),
	asc: require_types.booleanType(),
	nulls: require_types.stringType().optional(),
	opclass: require_types.stringType().optional()
});
const index$1 = require_types.objectType({
	name: require_types.stringType(),
	columns: indexColumn.array(),
	isUnique: require_types.booleanType(),
	with: require_types.recordType(require_types.stringType(), require_types.anyType()).optional(),
	method: require_types.stringType().default(defaults$1.index.method),
	where: require_types.stringType().optional(),
	concurrently: require_types.booleanType().default(false)
}).strict();
const fk$1 = require_types.objectType({
	name: require_types.stringType(),
	tableFrom: require_types.stringType(),
	columnsFrom: require_types.stringType().array(),
	tableTo: require_types.stringType(),
	schemaTo: require_types.stringType().optional(),
	columnsTo: require_types.stringType().array(),
	onUpdate: require_types.stringType().optional(),
	onDelete: require_types.stringType().optional()
}).strict();
const sequenceSchema = require_types.objectType({
	name: require_types.stringType(),
	increment: require_types.stringType().optional(),
	minValue: require_types.stringType().optional(),
	maxValue: require_types.stringType().optional(),
	startWith: require_types.stringType().optional(),
	cache: require_types.stringType().optional(),
	cycle: require_types.booleanType().optional(),
	schema: require_types.stringType()
}).strict();
const identitySchema = sequenceSchema.omit({ schema: true }).merge(require_types.objectType({ type: require_types.enumType(["always", "byDefault"]) }));
const roleSchema = require_types.objectType({
	name: require_types.stringType(),
	createDb: require_types.booleanType().optional(),
	createRole: require_types.booleanType().optional(),
	inherit: require_types.booleanType().optional()
}).strict();
const column$1 = require_types.objectType({
	name: require_types.stringType(),
	type: require_types.stringType(),
	typeSchema: require_types.stringType().optional(),
	primaryKey: require_types.booleanType(),
	notNull: require_types.booleanType(),
	default: require_types.anyType().optional(),
	generated: require_types.objectType({
		type: require_types.literalType("stored"),
		as: require_types.stringType()
	}).optional(),
	identity: identitySchema.optional()
}).strict();
const checkConstraint$1 = require_types.objectType({
	name: require_types.stringType(),
	value: require_types.stringType()
}).strict();
const compositePK$1 = require_types.objectType({
	name: require_types.stringType(),
	columns: require_types.stringType().array()
}).strict();
const uniqueConstraint$1 = require_types.objectType({
	name: require_types.stringType(),
	columns: require_types.stringType().array(),
	nullsNotDistinct: require_types.booleanType()
}).strict();
const policy = require_types.objectType({
	name: require_types.stringType(),
	as: require_types.enumType(["PERMISSIVE", "RESTRICTIVE"]).optional(),
	for: require_types.enumType([
		"ALL",
		"SELECT",
		"INSERT",
		"UPDATE",
		"DELETE"
	]).optional(),
	to: require_types.stringType().array().optional(),
	using: require_types.stringType().optional(),
	withCheck: require_types.stringType().optional(),
	on: require_types.stringType().optional(),
	schema: require_types.stringType().optional()
}).strict();
const viewWithOption = require_types.objectType({
	checkOption: require_types.enumType(["local", "cascaded"]).optional(),
	securityBarrier: require_types.booleanType().optional(),
	securityInvoker: require_types.booleanType().optional()
}).strict();
const matViewWithOption = require_types.objectType({
	fillfactor: require_types.numberType().optional(),
	toastTupleTarget: require_types.numberType().optional(),
	parallelWorkers: require_types.numberType().optional(),
	autovacuumEnabled: require_types.booleanType().optional(),
	vacuumIndexCleanup: require_types.enumType([
		"auto",
		"off",
		"on"
	]).optional(),
	vacuumTruncate: require_types.booleanType().optional(),
	autovacuumVacuumThreshold: require_types.numberType().optional(),
	autovacuumVacuumScaleFactor: require_types.numberType().optional(),
	autovacuumVacuumCostDelay: require_types.numberType().optional(),
	autovacuumVacuumCostLimit: require_types.numberType().optional(),
	autovacuumFreezeMinAge: require_types.numberType().optional(),
	autovacuumFreezeMaxAge: require_types.numberType().optional(),
	autovacuumFreezeTableAge: require_types.numberType().optional(),
	autovacuumMultixactFreezeMinAge: require_types.numberType().optional(),
	autovacuumMultixactFreezeMaxAge: require_types.numberType().optional(),
	autovacuumMultixactFreezeTableAge: require_types.numberType().optional(),
	logAutovacuumMinDuration: require_types.numberType().optional(),
	userCatalogTable: require_types.booleanType().optional()
}).strict();
const mergedViewWithOption = viewWithOption.merge(matViewWithOption).strict();
const view$1 = require_types.objectType({
	name: require_types.stringType(),
	schema: require_types.stringType(),
	columns: require_types.recordType(require_types.stringType(), column$1),
	definition: require_types.stringType().optional(),
	materialized: require_types.booleanType(),
	with: mergedViewWithOption.optional(),
	isExisting: require_types.booleanType(),
	withNoData: require_types.booleanType().optional(),
	using: require_types.stringType().optional(),
	tablespace: require_types.stringType().optional()
}).strict();
const table$1 = require_types.objectType({
	name: require_types.stringType(),
	schema: require_types.stringType(),
	columns: require_types.recordType(require_types.stringType(), column$1),
	indexes: require_types.recordType(require_types.stringType(), index$1),
	foreignKeys: require_types.recordType(require_types.stringType(), fk$1),
	compositePrimaryKeys: require_types.recordType(require_types.stringType(), compositePK$1),
	uniqueConstraints: require_types.recordType(require_types.stringType(), uniqueConstraint$1).default({}),
	policies: require_types.recordType(require_types.stringType(), policy).default({}),
	checkConstraints: require_types.recordType(require_types.stringType(), checkConstraint$1).default({}),
	isRLSEnabled: require_types.booleanType().default(false).optional()
}).strict();
const schemaHash$1 = require_types.objectType({
	id: require_types.stringType(),
	prevId: require_types.stringType()
});
const kitInternals = require_types.objectType({ tables: require_types.recordType(require_types.stringType(), require_types.objectType({ columns: require_types.recordType(require_types.stringType(), require_types.objectType({
	isArray: require_types.booleanType().optional(),
	dimensions: require_types.numberType().optional(),
	rawType: require_types.stringType().optional(),
	isDefaultAnExpression: require_types.booleanType().optional()
}).optional()) }).optional()) }).optional();
const cockroachSchemaInternal = require_types.objectType({
	version: require_types.literalType("1"),
	dialect: require_types.literalType("cockroach"),
	tables: require_types.recordType(require_types.stringType(), table$1),
	enums: require_types.recordType(require_types.stringType(), enumSchema),
	schemas: require_types.recordType(require_types.stringType(), require_types.stringType()),
	views: require_types.recordType(require_types.stringType(), view$1).default({}),
	sequences: require_types.recordType(require_types.stringType(), sequenceSchema).default({}),
	roles: require_types.recordType(require_types.stringType(), roleSchema).default({}),
	policies: require_types.recordType(require_types.stringType(), policy).default({}),
	_meta: require_types.objectType({
		schemas: require_types.recordType(require_types.stringType(), require_types.stringType()),
		tables: require_types.recordType(require_types.stringType(), require_types.stringType()),
		columns: require_types.recordType(require_types.stringType(), require_types.stringType())
	}),
	internal: kitInternals
}).strict();
const cockroachSchema = cockroachSchemaInternal.merge(schemaHash$1);
const ddl$2 = createDDL$2();
const snapshotValidator$2 = require_snapshot.validator({
	version: ["1"],
	dialect: ["cockroach"],
	id: "string",
	prevIds: require_snapshot.array((_) => true),
	ddl: require_snapshot.array((it) => {
		const res = ddl$2.entities.validate(it);
		if (!res) console.log(it);
		return res;
	}),
	renames: require_snapshot.array((_) => true)
});
const drySnapshot$1 = snapshotValidator$2.strict({
	version: "1",
	dialect: "cockroach",
	id: require_utils.originUUID,
	prevIds: [],
	ddl: [],
	renames: []
});

//#endregion
//#region src/dialects/mssql/grammar.ts
const getDefaultOptions = (x) => {
	return defaults.options[x] ? Object.values(defaults.options[x]).join(",") : null;
};
const defaults = {
	options: {
		numeric: {
			precision: 18,
			scale: 0
		},
		decimal: {
			precision: 18,
			scale: 0
		},
		time: { precision: 7 },
		float: { precision: 53 },
		varchar: { length: 1 },
		char: { length: 1 },
		nvarchar: { length: 1 },
		nchar: { length: 1 },
		datetime2: { precision: 7 },
		datetimeoffset: { precision: 7 },
		binary: { length: 1 },
		varbinary: { length: 1 }
	},
	max_int_value: 2147483647,
	min_int_value: -2147483648
};
const bufferToBinary = (str) => {
	return "0x" + str.toString("hex").toUpperCase();
};
const commutativeTypes = [
	["char", `char(${getDefaultOptions("char")})`],
	["nchar", `nchar(${getDefaultOptions("nchar")})`],
	["varchar", `varchar(${getDefaultOptions("varchar")})`],
	["nvarchar", `nvarchar(${getDefaultOptions("nvarchar")})`],
	["datetime2", `datetime2(${getDefaultOptions("datetime2")})`],
	["datetimeoffset", `datetimeoffset(${getDefaultOptions("datetimeoffset")})`],
	["time", `time(${getDefaultOptions("time")})`],
	["binary", `binary(${getDefaultOptions("binary")})`],
	["varbinary", `varbinary(${getDefaultOptions("varbinary")})`],
	["decimal", `decimal(${getDefaultOptions("decimal")})`],
	["numeric", `numeric(${getDefaultOptions("numeric")})`],
	["float", `float(${getDefaultOptions("float")})`]
];
const checkNumber = (it) => {
	const check = Number(it);
	if (Number.isNaN(check)) return "NaN";
	if (check >= Number.MIN_SAFE_INTEGER && check <= Number.MAX_SAFE_INTEGER) return "number";
	return "bigint";
};
const Int = {
	is: (type) => type === "int",
	drizzleImport: () => "int",
	defaultFromDrizzle: (value) => {
		return `((${String(value)}))`;
	},
	defaultFromIntrospect: (value) => {
		const tmp = value.replace(".))", "))");
		if (checkNumber(require_utils.trimChar(require_utils.trimChar(tmp, ["(", ")"]), ["(", ")"])) === "NaN") return value;
		return tmp;
	},
	toTs: (_type, value) => {
		if (!value) return { default: "" };
		value = value.substring(1, value.length - 1);
		const trimmed = require_utils.trimChar(value, ["(", ")"]);
		if (checkNumber(trimmed) === "NaN") return { default: `sql\`${value}\`` };
		return { default: trimmed };
	}
};
const TinyInt = {
	is: (type) => type === "tinyint",
	drizzleImport: () => "tinyint",
	defaultFromDrizzle: Int.defaultFromDrizzle,
	defaultFromIntrospect: Int.defaultFromIntrospect,
	toTs: Int.toTs
};
const SmallInt = {
	is: (type) => type === "smallint",
	drizzleImport: () => "smallint",
	defaultFromDrizzle: Int.defaultFromDrizzle,
	defaultFromIntrospect: Int.defaultFromIntrospect,
	toTs: Int.toTs
};
const BigInt = {
	is: (type) => type === "bigint",
	drizzleImport: () => "bigint",
	defaultFromDrizzle: (value) => {
		return `((${String(value)}))`;
	},
	defaultFromIntrospect: Int.defaultFromIntrospect,
	toTs: (_type, value) => {
		if (value === null) return {
			options: { mode: "number" },
			default: ""
		};
		value = value.substring(1, value.length - 1);
		const trimmed = require_utils.trimChar(value.replaceAll(".)", ")"), ["(", ")"]);
		const numType = checkNumber(trimmed);
		if (numType === "NaN") return {
			options: { mode: "bigint" },
			default: `sql\`${value}\``
		};
		if (numType === "number") return {
			options: { mode: "number" },
			default: trimmed
		};
		if (numType === "bigint") return {
			options: { mode: "bigint" },
			default: `${trimmed}n`
		};
		require_utils.assertUnreachable(numType);
	}
};
const Char = {
	is: (type) => type === "char" || type.startsWith("char("),
	drizzleImport: () => "char",
	defaultFromDrizzle: (value) => {
		return `('${require_grammar.escapeForSqlDefault(String(value))}')`;
	},
	defaultFromIntrospect: (value) => {
		return value;
	},
	toTs: (type, value) => {
		let optionsToSet;
		const param = require_grammar.parseParams(type)[0];
		if (param) optionsToSet = { length: param === "max" ? "max" : Number(param) };
		if (!value) return {
			default: "",
			options: optionsToSet
		};
		value = value.substring(1, value.length - 1);
		const isTSQLStringLiteral = (str) => {
			if (!/^'.*'$/.test(str.trim())) return false;
			const inner = str.trim().slice(1, -1);
			return !/[^']'[^']/.test(inner);
		};
		if (isTSQLStringLiteral(value)) {
			value = value.substring(1, value.length - 1);
			const escaped = require_grammar.escapeForTsLiteral(require_grammar.unescapeFromSqlDefault(value));
			return {
				options: optionsToSet,
				default: escaped
			};
		}
		return {
			options: optionsToSet,
			default: `sql\`${value}\``
		};
	}
};
const NChar = {
	is: (type) => type === "nchar" || type.startsWith("nchar("),
	drizzleImport: () => "nchar",
	defaultFromDrizzle: Char.defaultFromDrizzle,
	defaultFromIntrospect: Char.defaultFromIntrospect,
	toTs: Char.toTs
};
const Varchar = {
	is: (type) => type === "varchar" || type.startsWith("varchar("),
	drizzleImport: () => "varchar",
	defaultFromDrizzle: Char.defaultFromDrizzle,
	defaultFromIntrospect: Char.defaultFromIntrospect,
	toTs: Char.toTs
};
const NVarchar = {
	is: (type) => type === "nvarchar" || type.startsWith("nvarchar("),
	drizzleImport: () => "nvarchar",
	defaultFromDrizzle: (value) => {
		let result;
		if (typeof value === "string") result = require_grammar.escapeForSqlDefault(value);
		else if (typeof value === "object" || Array.isArray(value)) result = require_grammar.stringify(value, (_, value$1) => {
			if (typeof value$1 !== "string") return value$1;
			return value$1.replaceAll("'", "''");
		});
		else throw new Error(`unexpected default: ${value}`);
		return `('${result}')`;
	},
	defaultFromIntrospect: Char.defaultFromIntrospect,
	toTs: (type, value) => {
		let optionsToSet;
		const param = require_grammar.parseParams(type)[0];
		if (param) optionsToSet = { length: param === "max" ? "max" : Number(param) };
		if (!value) return {
			default: "",
			options: optionsToSet
		};
		value = value.substring(1, value.length - 1);
		const isTSQLStringLiteral = (str) => {
			if (!/^'.*'$/.test(str.trim())) return false;
			const inner = str.trim().slice(1, -1);
			return !/[^']'[^']/.test(inner);
		};
		if (!isTSQLStringLiteral(value)) return {
			options: optionsToSet,
			default: `sql\`${value}\``
		};
		try {
			return {
				default: require_grammar.stringify(require_grammar.parse(require_utils.trimChar(value, "'"), (_, v) => {
					if (typeof v === "string") return require_grammar.unescapeFromSqlDefault(v);
					return v;
				}), void 0, void 0, true),
				options: {
					mode: "json",
					...optionsToSet
				}
			};
		} catch {}
		value = value.substring(1, value.length - 1);
		const escaped = require_grammar.escapeForTsLiteral(require_grammar.unescapeFromSqlDefault(value));
		return {
			options: optionsToSet,
			default: escaped
		};
	}
};
const Text = {
	is: (type) => type === "text" || type.startsWith("text("),
	drizzleImport: () => "text",
	defaultFromDrizzle: Char.defaultFromDrizzle,
	defaultFromIntrospect: Char.defaultFromIntrospect,
	toTs: Char.toTs
};
const NText = {
	is: (type) => type === "ntext" || type.startsWith("ntext("),
	drizzleImport: () => "ntext",
	defaultFromDrizzle: Text.defaultFromDrizzle,
	defaultFromIntrospect: Text.defaultFromIntrospect,
	toTs: Text.toTs
};
const Decimal = {
	is: (type) => type === "decimal" || type.startsWith("decimal("),
	drizzleImport: () => "decimal",
	defaultFromDrizzle: (value) => {
		return `((${String(value)}))`;
	},
	defaultFromIntrospect: (value) => {
		const tmp = value.replace(".))", "))");
		if (checkNumber(require_utils.trimChar(require_utils.trimChar(tmp, ["(", ")"]), ["(", ")"])) === "NaN") return value;
		return tmp;
	},
	toTs: (type, value) => {
		const optionsToSet = {};
		const params = require_grammar.parseParams(type);
		if (params.length) {
			const [p, s] = params;
			if (p) optionsToSet["precision"] = Number(p);
			if (s) optionsToSet["scale"] = Number(s);
		}
		if (!value) return {
			options: optionsToSet,
			default: ""
		};
		value = value.substring(1, value.length - 1);
		const trimmed = require_utils.trimChar(value, ["(", ")"]);
		const numType = checkNumber(trimmed);
		if (numType === "NaN") return {
			options: {
				...optionsToSet,
				mode: "bigint"
			},
			default: `sql\`${value}\``
		};
		if (numType === "number") return {
			options: {
				...optionsToSet,
				mode: "number"
			},
			default: trimmed
		};
		if (numType === "bigint") return {
			options: {
				...optionsToSet,
				mode: "bigint"
			},
			default: `${trimmed}n`
		};
		require_utils.assertUnreachable(numType);
	}
};
const Numeric = {
	is: (type) => type === "numeric" || type.startsWith("numeric("),
	drizzleImport: () => "numeric",
	defaultFromDrizzle: Decimal.defaultFromDrizzle,
	defaultFromIntrospect: Decimal.defaultFromIntrospect,
	toTs: Decimal.toTs
};
const Float = {
	is: (type) => type === "float" || type.startsWith("float("),
	drizzleImport: () => "float",
	defaultFromDrizzle: (value) => {
		return `((${String(value)}))`;
	},
	defaultFromIntrospect: (value) => {
		const tmp = value.replace(".))", "))");
		if (checkNumber(require_utils.trimChar(require_utils.trimChar(tmp, ["(", ")"]), ["(", ")"])) === "NaN") return value;
		return tmp;
	},
	toTs: (type, value) => {
		const param = require_grammar.parseParams(type)[0];
		const optionsToSet = { precision: Number(param) };
		if (!value) return {
			default: "",
			options: optionsToSet
		};
		value = value.substring(1, value.length - 1);
		const trimmed = require_utils.trimChar(value, ["(", ")"]);
		if (checkNumber(trimmed) === "NaN") return {
			options: optionsToSet,
			default: `sql\`${value}\``
		};
		return {
			options: optionsToSet,
			default: trimmed
		};
	}
};
const Real = {
	is: (type) => type === "real" || type.startsWith("real("),
	drizzleImport: () => "real",
	defaultFromDrizzle: Float.defaultFromDrizzle,
	defaultFromIntrospect: Float.defaultFromIntrospect,
	toTs: (_type, value) => {
		if (!value) return { default: "" };
		value = value.substring(1, value.length - 1);
		const trimmed = require_utils.trimChar(value, ["(", ")"]);
		const numType = checkNumber(trimmed);
		if (numType === "NaN") return { default: `sql\`${value}\`` };
		if (numType === "number") return { default: trimmed };
		if (numType === "bigint") return { default: `${trimmed}n` };
		require_utils.assertUnreachable(numType);
	}
};
const Datetime = {
	is: (type) => type === "datetime" || type.startsWith("datetime("),
	drizzleImport: () => "datetime",
	defaultFromDrizzle: (value) => {
		if (value instanceof Date) return `('${value.toISOString().replace("T", " ").replace("Z", "")}')`;
		return `('${String(value)}')`;
	},
	defaultFromIntrospect: (value) => {
		return value;
	},
	toTs: (_type, value) => {
		const options = { mode: "string" };
		if (!value) return {
			default: "",
			options
		};
		if (value === "(getdate())") return {
			default: ".defaultGetDate()",
			options
		};
		value = value.substring(1, value.length - 1);
		if (isNaN(Date.parse(value.substring(1, value.length - 1)))) return {
			default: `sql\`${value}\``,
			options
		};
		return {
			default: value,
			options
		};
	}
};
const DateType = {
	is: (type) => type === "date" || type.startsWith("date("),
	drizzleImport: () => "date",
	defaultFromDrizzle: (value) => {
		if (value instanceof Date) return `('${value.toISOString().split("T")[0]}')`;
		return `('${String(value)}')`;
	},
	defaultFromIntrospect: Datetime.defaultFromIntrospect,
	toTs: Datetime.toTs
};
const Datetime2 = {
	is: (type) => type === "datetime2" || type.startsWith("datetime2("),
	drizzleImport: () => "datetime2",
	defaultFromDrizzle: Datetime.defaultFromDrizzle,
	defaultFromIntrospect: Datetime.defaultFromIntrospect,
	toTs: (type, value) => {
		const options = {
			mode: "string",
			precision: defaults.options.datetime2.precision
		};
		const param = require_grammar.parseParams(type)[0];
		if (param) options["precision"] = Number(param);
		if (!value) return {
			default: "",
			options
		};
		value = value.substring(1, value.length - 1);
		if (isNaN(Date.parse(value.substring(1, value.length - 1)))) return {
			default: `sql\`${value}\``,
			options
		};
		return {
			default: value,
			options
		};
	}
};
const Datetimeoffset = {
	is: (type) => type === "datetimeoffset" || type.startsWith("datetimeoffset("),
	drizzleImport: () => "datetimeoffset",
	defaultFromDrizzle: (value) => {
		if (value instanceof Date) return `('${value.toISOString()}')`;
		return `('${String(value)}')`;
	},
	defaultFromIntrospect: Datetime.defaultFromIntrospect,
	toTs: (type, value) => {
		const options = {
			mode: "string",
			precision: defaults.options.datetimeoffset.precision
		};
		const param = require_grammar.parseParams(type)[0];
		if (param) options["precision"] = Number(param);
		if (!value) return {
			default: "",
			options
		};
		if (value === "(getdate())") return {
			default: ".defaultGetDate()",
			options
		};
		value = value.substring(1, value.length - 1);
		if (isNaN(Date.parse(value.substring(1, value.length - 1)))) return {
			default: `sql\`${value}\``,
			options
		};
		return {
			default: value,
			options
		};
	}
};
const Time = {
	is: (type) => type === "time" || type.startsWith("time("),
	drizzleImport: () => "time",
	defaultFromDrizzle: (value) => {
		if (value instanceof Date) return `('${value.toISOString().split("T")[1].replace("Z", "")}')`;
		return `('${String(value)}')`;
	},
	defaultFromIntrospect: Datetime.defaultFromIntrospect,
	toTs: (type, value) => {
		const options = {
			mode: "string",
			precision: defaults.options.time.precision
		};
		const param = require_grammar.parseParams(type)[0];
		if (param) options["precision"] = Number(param);
		if (!value) return {
			default: "",
			options
		};
		value = value.substring(1, value.length - 1);
		if (isNaN(Date.parse(value.substring(1, value.length - 1)))) return {
			default: `sql\`${value}\``,
			options
		};
		return {
			default: value,
			options
		};
	}
};
const Binary = {
	is: (type) => type === "binary" || type.startsWith("binary("),
	drizzleImport: () => "binary",
	defaultFromDrizzle: (value) => {
		if (Buffer.isBuffer(value)) return `(${bufferToBinary(value)})`;
		throw Error("unexpected binary default");
	},
	defaultFromIntrospect: (value) => {
		return value;
	},
	toTs: (type, value) => {
		const optionsToSet = { length: defaults.options.binary.length };
		const param = require_grammar.parseParams(type)[0];
		if (param) optionsToSet["length"] = param === "max" ? "max" : Number(param);
		return {
			options: optionsToSet,
			default: value ? `sql\`${value.substring(1, value.length - 1)}\`` : ""
		};
	}
};
const Varbinary = {
	is: (type) => type === "varbinary" || type.startsWith("varbinary("),
	drizzleImport: () => "varbinary",
	defaultFromDrizzle: Binary.defaultFromDrizzle,
	defaultFromIntrospect: Binary.defaultFromIntrospect,
	toTs: Binary.toTs
};

//#endregion
//#region src/dialects/mssql/ddl.ts
const createDDLV1 = () => {
	return require_ddl.create({
		schemas: {},
		tables: { schema: "required" },
		columns: {
			schema: "required",
			table: "required",
			type: "string",
			notNull: "boolean",
			generated: {
				type: ["persisted", "virtual"],
				as: "string"
			},
			identity: {
				increment: "number",
				seed: "number"
			}
		},
		pks: {
			schema: "required",
			table: "required",
			nameExplicit: "boolean",
			columns: "string[]"
		},
		fks: {
			schema: "required",
			table: "required",
			columns: "string[]",
			nameExplicit: "boolean",
			schemaTo: "string",
			tableTo: "string",
			columnsTo: "string[]",
			onUpdate: [
				"NO ACTION",
				"CASCADE",
				"SET NULL",
				"SET DEFAULT"
			],
			onDelete: [
				"NO ACTION",
				"CASCADE",
				"SET NULL",
				"SET DEFAULT"
			]
		},
		indexes: {
			schema: "required",
			table: "required",
			columns: "string[]",
			isUnique: "boolean",
			where: "string?"
		},
		uniques: {
			schema: "required",
			table: "required",
			nameExplicit: "boolean",
			columns: "string[]"
		},
		checks: {
			schema: "required",
			table: "required",
			value: "string"
		},
		defaults: {
			schema: "required",
			table: "required",
			column: "string",
			nameExplicit: "boolean",
			default: "string?"
		},
		views: {
			schema: "required",
			definition: "string",
			encryption: "boolean?",
			schemaBinding: "boolean?",
			viewMetadata: "boolean?",
			checkOption: "boolean?"
		}
	});
};
const createDDL$1 = () => {
	return require_ddl.create({
		schemas: {},
		tables: { schema: "required" },
		columns: {
			schema: "required",
			table: "required",
			type: "string",
			notNull: "boolean",
			generated: {
				type: ["persisted", "virtual"],
				as: "string"
			},
			identity: {
				increment: "number",
				seed: "number"
			}
		},
		pks: {
			schema: "required",
			table: "required",
			nameExplicit: "boolean",
			columns: "string[]"
		},
		fks: {
			schema: "required",
			table: "required",
			columns: "string[]",
			nameExplicit: "boolean",
			schemaTo: "string",
			tableTo: "string",
			columnsTo: "string[]",
			onUpdate: [
				"NO ACTION",
				"CASCADE",
				"SET NULL",
				"SET DEFAULT"
			],
			onDelete: [
				"NO ACTION",
				"CASCADE",
				"SET NULL",
				"SET DEFAULT"
			]
		},
		indexes: {
			schema: "required",
			table: "required",
			columns: [{
				value: "string",
				isExpression: "boolean"
			}],
			isUnique: "boolean",
			where: "string?"
		},
		uniques: {
			schema: "required",
			table: "required",
			nameExplicit: "boolean",
			columns: "string[]"
		},
		checks: {
			schema: "required",
			table: "required",
			value: "string"
		},
		defaults: {
			schema: "required",
			table: "required",
			column: "string",
			nameExplicit: "boolean",
			default: "string?"
		},
		views: {
			schema: "required",
			definition: "string",
			encryption: "boolean?",
			schemaBinding: "boolean?",
			viewMetadata: "boolean?",
			checkOption: "boolean?"
		}
	});
};

//#endregion
//#region src/dialects/mssql/snapshot.ts
const ddlV1 = createDDLV1();
const snapshotValidatorV1 = require_snapshot.validator({
	version: ["1"],
	dialect: ["mssql"],
	id: "string",
	prevIds: require_snapshot.array((_) => true),
	ddl: require_snapshot.array((it) => ddlV1.entities.validate(it)),
	renames: require_snapshot.array((_) => true)
});
const ddl$1 = createDDL$1();
const snapshotValidator$1 = require_snapshot.validator({
	version: ["2"],
	dialect: ["mssql"],
	id: "string",
	prevIds: require_snapshot.array((_) => true),
	ddl: require_snapshot.array((it) => ddl$1.entities.validate(it)),
	renames: require_snapshot.array((_) => true)
});
const drySnapshot = snapshotValidator$1.strict({
	version: "2",
	dialect: "mssql",
	id: require_utils.originUUID,
	prevIds: [],
	ddl: [],
	renames: []
});

//#endregion
//#region src/dialects/sqlite/grammar.ts
const viewAsStatementRegex = new RegExp(`\\bAS\\b\\s+(WITH.+|SELECT.+)$`, "is");

//#endregion
//#region src/dialects/sqlite/ddl.ts
const createDDL = () => {
	return require_ddl.create({
		tables: {},
		columns: {
			table: "required",
			type: "string",
			notNull: "boolean",
			autoincrement: "boolean?",
			default: "string?",
			generated: {
				type: ["stored", "virtual"],
				as: "string"
			}
		},
		indexes: {
			table: "required",
			columns: [{
				value: "string",
				isExpression: "boolean"
			}],
			isUnique: "boolean",
			where: "string?",
			origin: ["manual", "auto"]
		},
		fks: {
			table: "required",
			columns: "string[]",
			tableTo: "string",
			columnsTo: "string[]",
			onUpdate: "string",
			onDelete: "string",
			nameExplicit: "boolean"
		},
		pks: {
			table: "required",
			columns: "string[]",
			nameExplicit: "boolean"
		},
		uniques: {
			table: "required",
			columns: "string[]",
			nameExplicit: "boolean"
		},
		checks: {
			table: "required",
			value: "string"
		},
		views: {
			definition: "string?",
			isExisting: "boolean",
			error: "string?"
		}
	});
};

//#endregion
//#region src/dialects/sqlite/snapshot.ts
const index = require_types.objectType({
	name: require_types.stringType(),
	columns: require_types.stringType().array(),
	where: require_types.stringType().optional(),
	isUnique: require_types.booleanType()
}).strict();
const fk = require_types.objectType({
	name: require_types.stringType(),
	tableFrom: require_types.stringType(),
	columnsFrom: require_types.stringType().array(),
	tableTo: require_types.stringType(),
	columnsTo: require_types.stringType().array(),
	onUpdate: require_types.stringType().optional(),
	onDelete: require_types.stringType().optional()
}).strict();
const compositePK = require_types.objectType({
	columns: require_types.stringType().array(),
	name: require_types.stringType().optional()
}).strict();
const column = require_types.objectType({
	name: require_types.stringType(),
	type: require_types.stringType(),
	typeSchema: require_types.stringType().optional(),
	primaryKey: require_types.booleanType(),
	notNull: require_types.booleanType(),
	autoincrement: require_types.booleanType().optional(),
	default: require_types.coerce.string().optional(),
	generated: require_types.objectType({
		type: require_types.enumType(["stored", "virtual"]),
		as: require_types.stringType()
	}).optional()
}).strict();
const uniqueConstraint = require_types.objectType({
	name: require_types.stringType(),
	columns: require_types.stringType().array()
}).strict();
const checkConstraint = require_types.objectType({
	name: require_types.stringType(),
	value: require_types.stringType()
}).strict();
const table = require_types.objectType({
	name: require_types.stringType(),
	columns: require_types.recordType(require_types.stringType(), column),
	indexes: require_types.recordType(require_types.stringType(), index),
	foreignKeys: require_types.recordType(require_types.stringType(), fk),
	compositePrimaryKeys: require_types.recordType(require_types.stringType(), compositePK),
	uniqueConstraints: require_types.recordType(require_types.stringType(), uniqueConstraint).default({}),
	checkConstraints: require_types.recordType(require_types.stringType(), checkConstraint).default({})
}).strict();
const view = require_types.objectType({
	name: require_types.stringType(),
	columns: require_types.recordType(require_types.stringType(), column),
	definition: require_types.stringType().optional(),
	isExisting: require_types.booleanType()
}).strict();
const dialect = require_types.enumType(["sqlite"]);
const schemaHash = require_types.objectType({
	id: require_types.stringType(),
	prevIds: require_types.arrayType(require_types.stringType())
}).strict();
const schemaHashV5 = require_types.objectType({
	id: require_types.stringType(),
	prevId: require_types.stringType()
}).strict();
const schemaInternalV5 = require_types.objectType({
	version: require_types.literalType("5"),
	dialect,
	tables: require_types.recordType(require_types.stringType(), table),
	enums: require_types.objectType({}),
	_meta: require_types.objectType({
		tables: require_types.recordType(require_types.stringType(), require_types.stringType()),
		columns: require_types.recordType(require_types.stringType(), require_types.stringType())
	})
}).strict();
const latestVersion = require_types.literalType("7");
const schemaInternalV6 = require_types.objectType({
	version: require_types.literalType("6"),
	dialect,
	tables: require_types.recordType(require_types.stringType(), table),
	views: require_types.recordType(require_types.stringType(), view).default({}),
	enums: require_types.objectType({}),
	_meta: require_types.objectType({
		tables: require_types.recordType(require_types.stringType(), require_types.stringType()),
		columns: require_types.recordType(require_types.stringType(), require_types.stringType())
	}),
	internal: require_types.anyType()
}).strict();
const schemaV5 = schemaInternalV5.merge(schemaHashV5).strict();
const schemaV6 = schemaInternalV6.merge(schemaHashV5).strict();
const schema = schemaInternalV6.merge(schemaHash).strict();
const tableSquashed = require_types.objectType({
	name: require_types.stringType(),
	schema: require_types.stringType().optional(),
	columns: require_types.recordType(require_types.stringType(), column),
	indexes: require_types.recordType(require_types.stringType(), require_types.stringType()),
	foreignKeys: require_types.recordType(require_types.stringType(), require_types.stringType()),
	compositePrimaryKeys: require_types.recordType(require_types.stringType(), require_types.stringType()),
	uniqueConstraints: require_types.recordType(require_types.stringType(), require_types.stringType()).default({}),
	checkConstraints: require_types.recordType(require_types.stringType(), require_types.stringType()).default({})
}).strict();
const schemaSquashed = require_types.objectType({
	version: latestVersion,
	dialect,
	tables: require_types.recordType(require_types.stringType(), tableSquashed),
	views: require_types.recordType(require_types.stringType(), view),
	enums: require_types.recordType(require_types.stringType(), require_types.objectType({
		name: require_types.stringType(),
		schema: require_types.stringType(),
		values: require_types.stringType().array()
	}).strict())
}).strict();
const ddl = createDDL();
const snapshotValidator = require_snapshot.validator({
	version: ["7"],
	dialect: ["sqlite"],
	id: "string",
	prevIds: require_snapshot.array((_) => true),
	ddl: require_snapshot.array((it) => ddl.entities.validate(it)),
	renames: require_snapshot.array((_) => true)
});
const drySqliteSnapshot = snapshotValidator.strict({
	version: "7",
	dialect: "sqlite",
	id: require_utils.originUUID,
	prevIds: [],
	ddl: [],
	renames: []
});

//#endregion
//#region src/utils/utils-node.ts
var import_glob = require_glob();
const normaliseSQLiteUrl = (it, type) => {
	if (type === "libsql") {
		if (it.startsWith("file:")) return it;
		try {
			if ((0, url.parse)(it).protocol === null) return `file:${it}`;
			return it;
		} catch {
			return `file:${it}`;
		}
	}
	if (type === "better-sqlite" || type === "@tursodatabase/database" || type === "bun") {
		if (it.startsWith("file:")) return it.substring(5);
		return it;
	}
	require_utils.assertUnreachable(type);
};
var InMemoryMutex = class {
	lockPromise = null;
	async withLock(fn) {
		while (this.lockPromise) await this.lockPromise;
		let resolveLock;
		this.lockPromise = new Promise((resolve$1) => {
			resolveLock = resolve$1;
		});
		try {
			return await fn();
		} finally {
			this.lockPromise = null;
			resolveLock();
		}
	}
};
const registerMutex = new InMemoryMutex();

//#endregion
Object.defineProperty(exports, 'normaliseSQLiteUrl', {
  enumerable: true,
  get: function () {
    return normaliseSQLiteUrl;
  }
});