{"version":3,"sources":["../../../../src/client/components/links.ts"],"sourcesContent":["import type { FlightRouterState } from '../../shared/lib/app-router-types'\nimport type { AppRouterInstance } from '../../shared/lib/app-router-context.shared-runtime'\nimport {\n  FetchStrategy,\n  type PrefetchTaskFetchStrategy,\n  PrefetchPriority,\n} from './segment-cache/types'\nimport { createCacheKey } from './segment-cache/cache-key'\nimport {\n  type PrefetchTask,\n  schedulePrefetchTask as scheduleSegmentPrefetchTask,\n  cancelPrefetchTask,\n  reschedulePrefetchTask,\n  isPrefetchTaskDirty,\n} from './segment-cache/scheduler'\nimport { startTransition } from 'react'\n\ntype LinkElement = HTMLAnchorElement | SVGAElement\n\ntype Element = LinkElement | HTMLFormElement\n\n// Properties that are shared between Link and Form instances. We use the same\n// shape for both to prevent a polymorphic de-opt in the VM.\ntype LinkOrFormInstanceShared = {\n  router: AppRouterInstance\n  fetchStrategy: PrefetchTaskFetchStrategy\n\n  isVisible: boolean\n\n  // The most recently initiated prefetch task. It may or may not have\n  // already completed. The same prefetch task object can be reused across\n  // multiple prefetches of the same link.\n  prefetchTask: PrefetchTask | null\n}\n\nexport type FormInstance = LinkOrFormInstanceShared & {\n  prefetchHref: string\n  setOptimisticLinkStatus: null\n}\n\ntype PrefetchableLinkInstance = LinkOrFormInstanceShared & {\n  prefetchHref: string\n  setOptimisticLinkStatus: (status: { pending: boolean }) => void\n}\n\ntype NonPrefetchableLinkInstance = LinkOrFormInstanceShared & {\n  prefetchHref: null\n  setOptimisticLinkStatus: (status: { pending: boolean }) => void\n}\n\ntype PrefetchableInstance = PrefetchableLinkInstance | FormInstance\n\nexport type LinkInstance =\n  | PrefetchableLinkInstance\n  | NonPrefetchableLinkInstance\n\n// Tracks the most recently navigated link instance. When null, indicates\n// the current navigation was not initiated by a link click.\nlet linkForMostRecentNavigation: LinkInstance | null = null\n\n// Status object indicating link is pending\nexport const PENDING_LINK_STATUS = { pending: true }\n\n// Status object indicating link is idle\nexport const IDLE_LINK_STATUS = { pending: false }\n\n// Updates the loading state when navigating between links\n// - Resets the previous link's loading state\n// - Sets the new link's loading state\n// - Updates tracking of current navigation\nexport function setLinkForCurrentNavigation(link: LinkInstance | null) {\n  startTransition(() => {\n    linkForMostRecentNavigation?.setOptimisticLinkStatus(IDLE_LINK_STATUS)\n    link?.setOptimisticLinkStatus(PENDING_LINK_STATUS)\n    linkForMostRecentNavigation = link\n  })\n}\n\n// Unmounts the current link instance from navigation tracking\nexport function unmountLinkForCurrentNavigation(link: LinkInstance) {\n  if (linkForMostRecentNavigation === link) {\n    linkForMostRecentNavigation = null\n  }\n}\n\n// Use a WeakMap to associate a Link instance with its DOM element. This is\n// used by the IntersectionObserver to track the link's visibility.\nconst prefetchable:\n  | WeakMap<Element, PrefetchableInstance>\n  | Map<Element, PrefetchableInstance> =\n  typeof WeakMap === 'function' ? new WeakMap() : new Map()\n\n// A Set of the currently visible links. We re-prefetch visible links after a\n// cache invalidation, or when the current URL changes. It's a separate data\n// structure from the WeakMap above because only the visible links need to\n// be enumerated.\nconst prefetchableAndVisible: Set<PrefetchableInstance> = new Set()\n\n// A single IntersectionObserver instance shared by all <Link> components.\nconst observer: IntersectionObserver | null =\n  typeof IntersectionObserver === 'function'\n    ? new IntersectionObserver(handleIntersect, {\n        rootMargin: '200px',\n      })\n    : null\n\nfunction observeVisibility(element: Element, instance: PrefetchableInstance) {\n  const existingInstance = prefetchable.get(element)\n  if (existingInstance !== undefined) {\n    // This shouldn't happen because each <Link> component should have its own\n    // anchor tag instance, but it's defensive coding to avoid a memory leak in\n    // case there's a logical error somewhere else.\n    unmountPrefetchableInstance(element)\n  }\n  // Only track prefetchable links that have a valid prefetch URL\n  prefetchable.set(element, instance)\n  if (observer !== null) {\n    observer.observe(element)\n  }\n}\n\nfunction coercePrefetchableUrl(href: string): URL | null {\n  if (typeof window !== 'undefined') {\n    const { createPrefetchURL } =\n      require('./app-router-utils') as typeof import('./app-router-utils')\n\n    try {\n      return createPrefetchURL(href)\n    } catch {\n      // createPrefetchURL sometimes throws an error if an invalid URL is\n      // provided, though I'm not sure if it's actually necessary.\n      // TODO: Consider removing the throw from the inner function, or change it\n      // to reportError. Or maybe the error isn't even necessary for automatic\n      // prefetches, just navigations.\n      const reportErrorFn =\n        typeof reportError === 'function' ? reportError : console.error\n      reportErrorFn(\n        `Cannot prefetch '${href}' because it cannot be converted to a URL.`\n      )\n      return null\n    }\n  } else {\n    return null\n  }\n}\n\nexport function mountLinkInstance(\n  element: LinkElement,\n  href: string,\n  router: AppRouterInstance,\n  fetchStrategy: PrefetchTaskFetchStrategy,\n  prefetchEnabled: boolean,\n  setOptimisticLinkStatus: (status: { pending: boolean }) => void\n): LinkInstance {\n  if (prefetchEnabled) {\n    const prefetchURL = coercePrefetchableUrl(href)\n    if (prefetchURL !== null) {\n      const instance: PrefetchableLinkInstance = {\n        router,\n        fetchStrategy,\n        isVisible: false,\n        prefetchTask: null,\n        prefetchHref: prefetchURL.href,\n        setOptimisticLinkStatus,\n      }\n      // We only observe the link's visibility if it's prefetchable. For\n      // example, this excludes links to external URLs.\n      observeVisibility(element, instance)\n      return instance\n    }\n  }\n  // If the link is not prefetchable, we still create an instance so we can\n  // track its optimistic state (i.e. useLinkStatus).\n  const instance: NonPrefetchableLinkInstance = {\n    router,\n    fetchStrategy,\n    isVisible: false,\n    prefetchTask: null,\n    prefetchHref: null,\n    setOptimisticLinkStatus,\n  }\n  return instance\n}\n\nexport function mountFormInstance(\n  element: HTMLFormElement,\n  href: string,\n  router: AppRouterInstance,\n  fetchStrategy: PrefetchTaskFetchStrategy\n): void {\n  const prefetchURL = coercePrefetchableUrl(href)\n  if (prefetchURL === null) {\n    // This href is not prefetchable, so we don't track it.\n    // TODO: We currently observe/unobserve a form every time its href changes.\n    // For Links, this isn't a big deal because the href doesn't usually change,\n    // but for forms it's extremely common. We should optimize this.\n    return\n  }\n  const instance: FormInstance = {\n    router,\n    fetchStrategy,\n    isVisible: false,\n    prefetchTask: null,\n    prefetchHref: prefetchURL.href,\n    setOptimisticLinkStatus: null,\n  }\n  observeVisibility(element, instance)\n}\n\nexport function unmountPrefetchableInstance(element: Element) {\n  const instance = prefetchable.get(element)\n  if (instance !== undefined) {\n    prefetchable.delete(element)\n    prefetchableAndVisible.delete(instance)\n    const prefetchTask = instance.prefetchTask\n    if (prefetchTask !== null) {\n      cancelPrefetchTask(prefetchTask)\n    }\n  }\n  if (observer !== null) {\n    observer.unobserve(element)\n  }\n}\n\nfunction handleIntersect(entries: Array<IntersectionObserverEntry>) {\n  for (const entry of entries) {\n    // Some extremely old browsers or polyfills don't reliably support\n    // isIntersecting so we check intersectionRatio instead. (Do we care? Not\n    // really. But whatever this is fine.)\n    const isVisible = entry.intersectionRatio > 0\n    onLinkVisibilityChanged(entry.target as HTMLAnchorElement, isVisible)\n  }\n}\n\nexport function onLinkVisibilityChanged(element: Element, isVisible: boolean) {\n  if (process.env.NODE_ENV !== 'production') {\n    // Prefetching on viewport is disabled in development for performance\n    // reasons, because it requires compiling the target page.\n    // TODO: Investigate re-enabling this.\n    return\n  }\n\n  const instance = prefetchable.get(element)\n  if (instance === undefined) {\n    return\n  }\n\n  instance.isVisible = isVisible\n  if (isVisible) {\n    prefetchableAndVisible.add(instance)\n  } else {\n    prefetchableAndVisible.delete(instance)\n  }\n  rescheduleLinkPrefetch(instance, PrefetchPriority.Default)\n}\n\nexport function onNavigationIntent(\n  element: HTMLAnchorElement | SVGAElement,\n  unstable_upgradeToDynamicPrefetch: boolean\n) {\n  const instance = prefetchable.get(element)\n  if (instance === undefined) {\n    return\n  }\n  // Prefetch the link on hover/touchstart.\n  if (instance !== undefined) {\n    if (\n      process.env.__NEXT_DYNAMIC_ON_HOVER &&\n      unstable_upgradeToDynamicPrefetch\n    ) {\n      // Switch to a full prefetch\n      instance.fetchStrategy = FetchStrategy.Full\n    }\n    rescheduleLinkPrefetch(instance, PrefetchPriority.Intent)\n  }\n}\n\nfunction rescheduleLinkPrefetch(\n  instance: PrefetchableInstance,\n  priority: PrefetchPriority.Default | PrefetchPriority.Intent\n) {\n  // Ensures that app-router-instance is not compiled in the server bundle\n  if (typeof window !== 'undefined') {\n    const existingPrefetchTask = instance.prefetchTask\n\n    if (!instance.isVisible) {\n      // Cancel any in-progress prefetch task. (If it already finished then this\n      // is a no-op.)\n      if (existingPrefetchTask !== null) {\n        cancelPrefetchTask(existingPrefetchTask)\n      }\n      // We don't need to reset the prefetchTask to null upon cancellation; an\n      // old task object can be rescheduled with reschedulePrefetchTask. This is a\n      // micro-optimization but also makes the code simpler (don't need to\n      // worry about whether an old task object is stale).\n      return\n    }\n\n    const { getCurrentAppRouterState } =\n      require('./app-router-instance') as typeof import('./app-router-instance')\n\n    const appRouterState = getCurrentAppRouterState()\n    if (appRouterState !== null) {\n      const treeAtTimeOfPrefetch = appRouterState.tree\n      if (existingPrefetchTask === null) {\n        // Initiate a prefetch task.\n        const nextUrl = appRouterState.nextUrl\n        const cacheKey = createCacheKey(instance.prefetchHref, nextUrl)\n        instance.prefetchTask = scheduleSegmentPrefetchTask(\n          cacheKey,\n          treeAtTimeOfPrefetch,\n          instance.fetchStrategy,\n          priority,\n          null\n        )\n      } else {\n        // We already have an old task object that we can reschedule. This is\n        // effectively the same as canceling the old task and creating a new one.\n        reschedulePrefetchTask(\n          existingPrefetchTask,\n          treeAtTimeOfPrefetch,\n          instance.fetchStrategy,\n          priority\n        )\n      }\n    }\n  }\n}\n\nexport function pingVisibleLinks(\n  nextUrl: string | null,\n  tree: FlightRouterState\n) {\n  // For each currently visible link, cancel the existing prefetch task (if it\n  // exists) and schedule a new one. This is effectively the same as if all the\n  // visible links left and then re-entered the viewport.\n  //\n  // This is called when the Next-Url or the base tree changes, since those\n  // may affect the result of a prefetch task. It's also called after a\n  // cache invalidation.\n  for (const instance of prefetchableAndVisible) {\n    const task = instance.prefetchTask\n    if (task !== null && !isPrefetchTaskDirty(task, nextUrl, tree)) {\n      // The cache has not been invalidated, and none of the inputs have\n      // changed. Bail out.\n      continue\n    }\n    // Something changed. Cancel the existing prefetch task and schedule a\n    // new one.\n    if (task !== null) {\n      cancelPrefetchTask(task)\n    }\n    const cacheKey = createCacheKey(instance.prefetchHref, nextUrl)\n    instance.prefetchTask = scheduleSegmentPrefetchTask(\n      cacheKey,\n      tree,\n      instance.fetchStrategy,\n      PrefetchPriority.Default,\n      null\n    )\n  }\n}\n"],"names":["FetchStrategy","PrefetchPriority","createCacheKey","schedulePrefetchTask","scheduleSegmentPrefetchTask","cancelPrefetchTask","reschedulePrefetchTask","isPrefetchTaskDirty","startTransition","linkForMostRecentNavigation","PENDING_LINK_STATUS","pending","IDLE_LINK_STATUS","setLinkForCurrentNavigation","link","setOptimisticLinkStatus","unmountLinkForCurrentNavigation","prefetchable","WeakMap","Map","prefetchableAndVisible","Set","observer","IntersectionObserver","handleIntersect","rootMargin","observeVisibility","element","instance","existingInstance","get","undefined","unmountPrefetchableInstance","set","observe","coercePrefetchableUrl","href","window","createPrefetchURL","require","reportErrorFn","reportError","console","error","mountLinkInstance","router","fetchStrategy","prefetchEnabled","prefetchURL","isVisible","prefetchTask","prefetchHref","mountFormInstance","delete","unobserve","entries","entry","intersectionRatio","onLinkVisibilityChanged","target","process","env","NODE_ENV","add","rescheduleLinkPrefetch","Default","onNavigationIntent","unstable_upgradeToDynamicPrefetch","__NEXT_DYNAMIC_ON_HOVER","Full","Intent","priority","existingPrefetchTask","getCurrentAppRouterState","appRouterState","treeAtTimeOfPrefetch","tree","nextUrl","cacheKey","pingVisibleLinks","task"],"mappings":"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","ignoreList":[0]}