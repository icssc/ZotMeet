{"version":3,"sources":["../../src/server/body-streams.ts"],"sourcesContent":["import type { IncomingMessage } from 'http'\nimport type { Readable } from 'stream'\nimport { PassThrough } from 'stream'\nimport bytes from 'next/dist/compiled/bytes'\n\nconst DEFAULT_BODY_CLONE_SIZE_LIMIT = 10 * 1024 * 1024 // 10MB\n\nexport function requestToBodyStream(\n  context: { ReadableStream: typeof ReadableStream },\n  KUint8Array: typeof Uint8Array,\n  stream: Readable\n) {\n  return new context.ReadableStream({\n    start: async (controller) => {\n      for await (const chunk of stream) {\n        controller.enqueue(new KUint8Array(chunk))\n      }\n      controller.close()\n    },\n  })\n}\n\nfunction replaceRequestBody<T extends IncomingMessage>(\n  base: T,\n  stream: Readable\n): T {\n  for (const key in stream) {\n    let v = stream[key as keyof Readable] as any\n    if (typeof v === 'function') {\n      v = v.bind(base)\n    }\n    base[key as keyof T] = v\n  }\n\n  return base\n}\n\nexport interface CloneableBody {\n  finalize(): Promise<void>\n  cloneBodyStream(): Readable\n}\n\nexport function getCloneableBody<T extends IncomingMessage>(\n  readable: T,\n  sizeLimit?: number\n): CloneableBody {\n  let buffered: Readable | null = null\n\n  const endPromise = new Promise<void | { error?: unknown }>(\n    (resolve, reject) => {\n      readable.on('end', resolve)\n      readable.on('error', reject)\n    }\n  ).catch((error) => {\n    return { error }\n  })\n\n  return {\n    /**\n     * Replaces the original request body if necessary.\n     * This is done because once we read the body from the original request,\n     * we can't read it again.\n     */\n    async finalize(): Promise<void> {\n      if (buffered) {\n        const res = await endPromise\n\n        if (res && typeof res === 'object' && res.error) {\n          throw res.error\n        }\n        replaceRequestBody(readable, buffered)\n        buffered = readable\n      }\n    },\n    /**\n     * Clones the body stream\n     * to pass into a middleware\n     */\n    cloneBodyStream() {\n      const input = buffered ?? readable\n      const p1 = new PassThrough()\n      const p2 = new PassThrough()\n\n      let bytesRead = 0\n      const bodySizeLimit = sizeLimit ?? DEFAULT_BODY_CLONE_SIZE_LIMIT\n      let limitExceeded = false\n\n      input.on('data', (chunk) => {\n        if (limitExceeded) return\n\n        bytesRead += chunk.length\n\n        if (bytesRead > bodySizeLimit) {\n          limitExceeded = true\n          const urlInfo = readable.url ? ` for ${readable.url}` : ''\n          console.warn(\n            // TODO(jiwon): Update this document link\n            `Request body exceeded ${bytes.format(bodySizeLimit)}${urlInfo}. Only the first ${bytes.format(bodySizeLimit)} will be available unless configured. See https://nextjs.org/docs/app/api-reference/config/next-config-js/middlewareClientMaxBodySize for more details.`\n          )\n          p1.push(null)\n          p2.push(null)\n          return\n        }\n\n        p1.push(chunk)\n        p2.push(chunk)\n      })\n      input.on('end', () => {\n        if (!limitExceeded) {\n          p1.push(null)\n          p2.push(null)\n        }\n      })\n      buffered = p2\n      return p1\n    },\n  }\n}\n"],"names":["getCloneableBody","requestToBodyStream","DEFAULT_BODY_CLONE_SIZE_LIMIT","context","KUint8Array","stream","ReadableStream","start","controller","chunk","enqueue","close","replaceRequestBody","base","key","v","bind","readable","sizeLimit","buffered","endPromise","Promise","resolve","reject","on","catch","error","finalize","res","cloneBodyStream","input","p1","PassThrough","p2","bytesRead","bodySizeLimit","limitExceeded","length","urlInfo","url","console","warn","bytes","format","push"],"mappings":";;;;;;;;;;;;;;;IA0CgBA,gBAAgB;eAAhBA;;IAnCAC,mBAAmB;eAAnBA;;;wBALY;8DACV;;;;;;AAElB,MAAMC,gCAAgC,KAAK,OAAO,KAAK,OAAO;;AAEvD,SAASD,oBACdE,OAAkD,EAClDC,WAA8B,EAC9BC,MAAgB;IAEhB,OAAO,IAAIF,QAAQG,cAAc,CAAC;QAChCC,OAAO,OAAOC;YACZ,WAAW,MAAMC,SAASJ,OAAQ;gBAChCG,WAAWE,OAAO,CAAC,IAAIN,YAAYK;YACrC;YACAD,WAAWG,KAAK;QAClB;IACF;AACF;AAEA,SAASC,mBACPC,IAAO,EACPR,MAAgB;IAEhB,IAAK,MAAMS,OAAOT,OAAQ;QACxB,IAAIU,IAAIV,MAAM,CAACS,IAAsB;QACrC,IAAI,OAAOC,MAAM,YAAY;YAC3BA,IAAIA,EAAEC,IAAI,CAACH;QACb;QACAA,IAAI,CAACC,IAAe,GAAGC;IACzB;IAEA,OAAOF;AACT;AAOO,SAASb,iBACdiB,QAAW,EACXC,SAAkB;IAElB,IAAIC,WAA4B;IAEhC,MAAMC,aAAa,IAAIC,QACrB,CAACC,SAASC;QACRN,SAASO,EAAE,CAAC,OAAOF;QACnBL,SAASO,EAAE,CAAC,SAASD;IACvB,GACAE,KAAK,CAAC,CAACC;QACP,OAAO;YAAEA;QAAM;IACjB;IAEA,OAAO;QACL;;;;KAIC,GACD,MAAMC;YACJ,IAAIR,UAAU;gBACZ,MAAMS,MAAM,MAAMR;gBAElB,IAAIQ,OAAO,OAAOA,QAAQ,YAAYA,IAAIF,KAAK,EAAE;oBAC/C,MAAME,IAAIF,KAAK;gBACjB;gBACAd,mBAAmBK,UAAUE;gBAC7BA,WAAWF;YACb;QACF;QACA;;;KAGC,GACDY;YACE,MAAMC,QAAQX,YAAYF;YAC1B,MAAMc,KAAK,IAAIC,mBAAW;YAC1B,MAAMC,KAAK,IAAID,mBAAW;YAE1B,IAAIE,YAAY;YAChB,MAAMC,gBAAgBjB,aAAahB;YACnC,IAAIkC,gBAAgB;YAEpBN,MAAMN,EAAE,CAAC,QAAQ,CAACf;gBAChB,IAAI2B,eAAe;gBAEnBF,aAAazB,MAAM4B,MAAM;gBAEzB,IAAIH,YAAYC,eAAe;oBAC7BC,gBAAgB;oBAChB,MAAME,UAAUrB,SAASsB,GAAG,GAAG,CAAC,KAAK,EAAEtB,SAASsB,GAAG,EAAE,GAAG;oBACxDC,QAAQC,IAAI,CACV,yCAAyC;oBACzC,CAAC,sBAAsB,EAAEC,cAAK,CAACC,MAAM,CAACR,iBAAiBG,QAAQ,iBAAiB,EAAEI,cAAK,CAACC,MAAM,CAACR,eAAe,uJAAuJ,CAAC;oBAExQJ,GAAGa,IAAI,CAAC;oBACRX,GAAGW,IAAI,CAAC;oBACR;gBACF;gBAEAb,GAAGa,IAAI,CAACnC;gBACRwB,GAAGW,IAAI,CAACnC;YACV;YACAqB,MAAMN,EAAE,CAAC,OAAO;gBACd,IAAI,CAACY,eAAe;oBAClBL,GAAGa,IAAI,CAAC;oBACRX,GAAGW,IAAI,CAAC;gBACV;YACF;YACAzB,WAAWc;YACX,OAAOF;QACT;IACF;AACF","ignoreList":[0]}