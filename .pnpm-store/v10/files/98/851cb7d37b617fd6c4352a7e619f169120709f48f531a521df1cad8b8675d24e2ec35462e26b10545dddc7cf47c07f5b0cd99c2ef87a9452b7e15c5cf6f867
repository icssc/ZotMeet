{"version":3,"file":"migrator.js","names":["migrationQueries: MigrationMeta[]","initialState: State","state"],"sources":["../../src/expo-sqlite/migrator.ts"],"sourcesContent":["import { useEffect, useReducer } from 'react';\nimport { formatToMillis } from '~/migrator.utils.ts';\nimport type { AnyRelations, EmptyRelations } from '~/relations.ts';\nimport type { MigrationMeta } from '../migrator.ts';\nimport type { ExpoSQLiteDatabase } from './driver.ts';\n\ninterface MigrationConfig {\n\tmigrations: Record<string, string>;\n}\n\nasync function readMigrationFiles({ migrations }: MigrationConfig): Promise<MigrationMeta[]> {\n\tconst migrationQueries: MigrationMeta[] = [];\n\n\tconst sortedMigrations = Object.keys(migrations).sort();\n\n\tfor (const key of sortedMigrations) {\n\t\tconst query = migrations[key];\n\t\tif (!query) {\n\t\t\tthrow new Error(`Missing migration: ${key}`);\n\t\t}\n\n\t\ttry {\n\t\t\tconst result = query.split('--> statement-breakpoint').map((it) => {\n\t\t\t\treturn it;\n\t\t\t});\n\n\t\t\tconst migrationDate = formatToMillis(key.slice(0, 14));\n\n\t\t\tmigrationQueries.push({\n\t\t\t\tsql: result,\n\t\t\t\tbps: true,\n\t\t\t\tfolderMillis: migrationDate,\n\t\t\t\thash: '',\n\t\t\t});\n\t\t} catch {\n\t\t\tthrow new Error(`Failed to parse migration: ${key}`);\n\t\t}\n\t}\n\n\treturn migrationQueries;\n}\n\nexport async function migrate<\n\tTSchema extends Record<string, unknown>,\n\tTRelations extends AnyRelations = EmptyRelations,\n>(\n\tdb: ExpoSQLiteDatabase<TSchema, TRelations>,\n\tconfig: MigrationConfig,\n) {\n\tconst migrations = await readMigrationFiles(config);\n\treturn db.dialect.migrate(migrations, db.session);\n}\n\ninterface State {\n\tsuccess: boolean;\n\terror?: Error;\n}\n\ntype Action =\n\t| { type: 'migrating' }\n\t| { type: 'migrated'; payload: true }\n\t| { type: 'error'; payload: Error };\n\nexport const useMigrations = (db: ExpoSQLiteDatabase<any, any>, migrations: {\n\tjournal: {\n\t\tentries: { idx: number; when: number; tag: string; breakpoints: boolean }[];\n\t};\n\tmigrations: Record<string, string>;\n}): State => {\n\tconst initialState: State = {\n\t\tsuccess: false,\n\t\terror: undefined,\n\t};\n\n\tconst fetchReducer = (state: State, action: Action): State => {\n\t\tswitch (action.type) {\n\t\t\tcase 'migrating': {\n\t\t\t\treturn { ...initialState };\n\t\t\t}\n\t\t\tcase 'migrated': {\n\t\t\t\treturn { ...initialState, success: action.payload };\n\t\t\t}\n\t\t\tcase 'error': {\n\t\t\t\treturn { ...initialState, error: action.payload };\n\t\t\t}\n\t\t\tdefault: {\n\t\t\t\treturn state;\n\t\t\t}\n\t\t}\n\t};\n\n\tconst [state, dispatch] = useReducer(fetchReducer, initialState);\n\n\tuseEffect(() => {\n\t\tdispatch({ type: 'migrating' });\n\t\tmigrate(db, migrations as any).then(() => {\n\t\t\tdispatch({ type: 'migrated', payload: true });\n\t\t}).catch((error) => {\n\t\t\tdispatch({ type: 'error', payload: error as Error });\n\t\t});\n\t}, []);\n\n\treturn state;\n};\n"],"mappings":";;;;AAUA,eAAe,mBAAmB,EAAE,cAAyD;CAC5F,MAAMA,mBAAoC,EAAE;CAE5C,MAAM,mBAAmB,OAAO,KAAK,WAAW,CAAC,MAAM;AAEvD,MAAK,MAAM,OAAO,kBAAkB;EACnC,MAAM,QAAQ,WAAW;AACzB,MAAI,CAAC,MACJ,OAAM,IAAI,MAAM,sBAAsB,MAAM;AAG7C,MAAI;GACH,MAAM,SAAS,MAAM,MAAM,2BAA2B,CAAC,KAAK,OAAO;AAClE,WAAO;KACN;GAEF,MAAM,gBAAgB,eAAe,IAAI,MAAM,GAAG,GAAG,CAAC;AAEtD,oBAAiB,KAAK;IACrB,KAAK;IACL,KAAK;IACL,cAAc;IACd,MAAM;IACN,CAAC;UACK;AACP,SAAM,IAAI,MAAM,8BAA8B,MAAM;;;AAItD,QAAO;;AAGR,eAAsB,QAIrB,IACA,QACC;CACD,MAAM,aAAa,MAAM,mBAAmB,OAAO;AACnD,QAAO,GAAG,QAAQ,QAAQ,YAAY,GAAG,QAAQ;;AAalD,MAAa,iBAAiB,IAAkC,eAKnD;CACZ,MAAMC,eAAsB;EAC3B,SAAS;EACT,OAAO;EACP;CAED,MAAM,gBAAgB,SAAc,WAA0B;AAC7D,UAAQ,OAAO,MAAf;GACC,KAAK,YACJ,QAAO,EAAE,GAAG,cAAc;GAE3B,KAAK,WACJ,QAAO;IAAE,GAAG;IAAc,SAAS,OAAO;IAAS;GAEpD,KAAK,QACJ,QAAO;IAAE,GAAG;IAAc,OAAO,OAAO;IAAS;GAElD,QACC,QAAOC;;;CAKV,MAAM,CAAC,OAAO,YAAY,WAAW,cAAc,aAAa;AAEhE,iBAAgB;AACf,WAAS,EAAE,MAAM,aAAa,CAAC;AAC/B,UAAQ,IAAI,WAAkB,CAAC,WAAW;AACzC,YAAS;IAAE,MAAM;IAAY,SAAS;IAAM,CAAC;IAC5C,CAAC,OAAO,UAAU;AACnB,YAAS;IAAE,MAAM;IAAS,SAAS;IAAgB,CAAC;IACnD;IACA,EAAE,CAAC;AAEN,QAAO"}