{"version":3,"sources":["../../../src/lib/worker.ts"],"sourcesContent":["import type { ChildProcess } from 'child_process'\nimport { Worker as JestWorker } from 'next/dist/compiled/jest-worker'\nimport { Transform } from 'stream'\nimport {\n  formatDebugAddress,\n  formatNodeOptions,\n  getNodeDebugType,\n  getParsedDebugAddress,\n  getParsedNodeOptions,\n  type DebugAddress,\n} from '../server/lib/utils'\n\ntype FarmOptions = NonNullable<ConstructorParameters<typeof JestWorker>[1]>\n\nconst RESTARTED = Symbol('restarted')\n\nconst cleanupWorkers = (worker: JestWorker) => {\n  for (const curWorker of ((worker as any)._workerPool?._workers || []) as {\n    _child?: ChildProcess\n  }[]) {\n    curWorker._child?.kill('SIGINT')\n  }\n}\n\nexport function getNextBuildDebuggerPortOffset(_: {\n  kind: 'export-page'\n}): number {\n  // 0: export worker\n  return 0\n}\n\nexport class Worker {\n  private _worker: JestWorker | undefined\n\n  private _onActivity: (() => void) | undefined\n  private _onActivityAbort: (() => void) | undefined\n\n  constructor(\n    workerPath: string,\n    options: Omit<FarmOptions, 'forkOptions'> & {\n      forkOptions?:\n        | (Omit<NonNullable<FarmOptions['forkOptions']>, 'env'> & {\n            env?: Partial<NodeJS.ProcessEnv> | undefined\n          })\n        | undefined\n      /**\n       * `-1` if not inspectable\n       */\n      debuggerPortOffset: number\n      enableSourceMaps?: boolean\n      /**\n       * True if `--max-old-space-size` should not be forwarded to the worker.\n       */\n      isolatedMemory: boolean\n      timeout?: number\n      onActivity?: () => void\n      onActivityAbort?: () => void\n      onRestart?: (method: string, args: any[], attempts: number) => void\n      logger?: Pick<typeof console, 'error' | 'info' | 'warn'>\n      exposedMethods: ReadonlyArray<string>\n      enableWorkerThreads?: boolean\n    }\n  ) {\n    let {\n      enableSourceMaps,\n      timeout,\n      onRestart,\n      logger = console,\n      debuggerPortOffset,\n      isolatedMemory,\n      onActivity,\n      onActivityAbort,\n      ...farmOptions\n    } = options\n\n    this._onActivity = onActivity\n    this._onActivityAbort = onActivityAbort\n\n    let restartPromise: Promise<typeof RESTARTED>\n    let resolveRestartPromise: (arg: typeof RESTARTED) => void\n    let activeTasks = 0\n\n    this._worker = undefined\n\n    // ensure we end workers if they weren't before exit\n    process.on('exit', () => {\n      this.close()\n    })\n\n    const nodeOptions = getParsedNodeOptions()\n    const originalOptions = { ...nodeOptions }\n    delete nodeOptions.inspect\n    delete nodeOptions['inspect-brk']\n    delete nodeOptions['inspect_brk']\n    if (debuggerPortOffset !== -1) {\n      const nodeDebugType = getNodeDebugType(originalOptions)\n      if (nodeDebugType) {\n        const debuggerAddress = getParsedDebugAddress(\n          originalOptions[nodeDebugType]\n        )\n        const address: DebugAddress = {\n          host: debuggerAddress.host,\n          // current process runs on `address.port`\n          port:\n            debuggerAddress.port === 0\n              ? 0\n              : debuggerAddress.port + 1 + debuggerPortOffset,\n        }\n        nodeOptions[nodeDebugType] = formatDebugAddress(address)\n      }\n    }\n\n    if (enableSourceMaps) {\n      nodeOptions['enable-source-maps'] = true\n    }\n\n    if (isolatedMemory) {\n      delete nodeOptions['max-old-space-size']\n      delete nodeOptions['max_old_space_size']\n    }\n\n    const createWorker = () => {\n      const workerEnv: NodeJS.ProcessEnv = {\n        ...process.env,\n        ...((farmOptions.forkOptions?.env || {}) as any),\n        IS_NEXT_WORKER: 'true',\n        NODE_OPTIONS: formatNodeOptions(nodeOptions),\n      }\n\n      if (workerEnv.FORCE_COLOR === undefined) {\n        // Mirror the enablement heuristic from picocolors (see https://github.com/vercel/next.js/blob/6a40da0345939fe4f7b1ae519b296a86dd103432/packages/next/src/lib/picocolors.ts#L21-L24).\n        // Picocolors snapshots `process.env`/`stdout.isTTY` at module load time, so when the worker\n        // process bootstraps with piped stdio its own check would disable colors. Re-evaluating the\n        // same conditions here lets us opt the worker into color output only when the parent would\n        // have seen colors, while still respecting explicit opt-outs like NO_COLOR.\n        const supportsColors =\n          !workerEnv.NO_COLOR &&\n          !workerEnv.CI &&\n          workerEnv.TERM !== 'dumb' &&\n          (process.stdout.isTTY || process.stderr?.isTTY)\n\n        if (supportsColors) {\n          workerEnv.FORCE_COLOR = '1'\n        }\n      }\n\n      this._worker = new JestWorker(workerPath, {\n        ...farmOptions,\n        forkOptions: {\n          ...farmOptions.forkOptions,\n          env: workerEnv,\n        },\n        maxRetries: 0,\n      }) as JestWorker\n      restartPromise = new Promise(\n        (resolve) => (resolveRestartPromise = resolve)\n      )\n\n      /**\n       * Jest Worker has two worker types, ChildProcessWorker (uses child_process) and NodeThreadWorker (uses worker_threads)\n       * Next.js uses ChildProcessWorker by default, but it can be switched to NodeThreadWorker with an experimental flag\n       *\n       * We only want to handle ChildProcessWorker's orphan process issue, so we access the private property \"_child\":\n       * https://github.com/facebook/jest/blob/b38d7d345a81d97d1dc3b68b8458b1837fbf19be/packages/jest-worker/src/workers/ChildProcessWorker.ts\n       *\n       * But this property is not available in NodeThreadWorker, so we need to check if we are using ChildProcessWorker\n       */\n      if (!farmOptions.enableWorkerThreads) {\n        for (const worker of ((this._worker as any)._workerPool?._workers ||\n          []) as {\n          _child?: ChildProcess\n        }[]) {\n          worker._child?.on('exit', (code, signal) => {\n            if ((code || (signal && signal !== 'SIGINT')) && this._worker) {\n              logger.error(\n                `Next.js build worker exited with code: ${code} and signal: ${signal}`\n              )\n\n              // if a child process doesn't exit gracefully, we want to bubble up the exit code to the parent process\n              process.exit(code ?? 1)\n            }\n          })\n\n          // if a child process emits a particular message, we track that as activity\n          // so the parent process can keep track of progress\n          worker._child?.on('message', ([, data]: [number, unknown]) => {\n            if (\n              data &&\n              typeof data === 'object' &&\n              'type' in data &&\n              data.type === 'activity'\n            ) {\n              onActivityImpl()\n            }\n          })\n        }\n      }\n\n      let aborted = false\n      const onActivityAbortImpl = () => {\n        if (!aborted) {\n          this._onActivityAbort?.()\n          aborted = true\n        }\n      }\n\n      // Listen to the worker's stdout and stderr, if there's any thing logged, abort the activity first\n      const abortActivityStreamOnLog = new Transform({\n        transform(_chunk, _encoding, callback) {\n          onActivityAbortImpl()\n          callback()\n        },\n      })\n      // Stop the activity if there's any output from the worker\n      this._worker.getStdout().pipe(abortActivityStreamOnLog)\n      this._worker.getStderr().pipe(abortActivityStreamOnLog)\n\n      // Pipe the worker's stdout and stderr to the parent process\n      this._worker.getStdout().pipe(process.stdout)\n      this._worker.getStderr().pipe(process.stderr)\n    }\n    createWorker()\n\n    const onHanging = () => {\n      const worker = this._worker\n      if (!worker) return\n      const resolve = resolveRestartPromise\n      createWorker()\n      logger.warn(\n        `Sending SIGTERM signal to static worker due to timeout${\n          timeout ? ` of ${timeout / 1000} seconds` : ''\n        }. Subsequent errors may be a result of the worker exiting.`\n      )\n      worker.end().then(() => {\n        resolve(RESTARTED)\n      })\n    }\n\n    let hangingTimer: NodeJS.Timeout | false = false\n\n    const onActivityImpl = () => {\n      if (hangingTimer) clearTimeout(hangingTimer)\n      if (this._onActivity) this._onActivity()\n\n      hangingTimer = activeTasks > 0 && setTimeout(onHanging, timeout)\n    }\n\n    for (const method of farmOptions.exposedMethods) {\n      if (method.startsWith('_')) continue\n      ;(this as any)[method] = timeout\n        ? // eslint-disable-next-line no-loop-func\n          async (...args: any[]) => {\n            activeTasks++\n            try {\n              let attempts = 0\n              for (;;) {\n                onActivityImpl()\n                const result = await Promise.race([\n                  (this._worker as any)[method](...args),\n                  restartPromise,\n                ])\n                if (result !== RESTARTED) return result\n                if (onRestart) onRestart(method, args, ++attempts)\n              }\n            } finally {\n              activeTasks--\n              onActivityImpl()\n            }\n          }\n        : (this._worker as any)[method].bind(this._worker)\n    }\n  }\n\n  setOnActivity(onActivity: (() => void) | undefined): void {\n    this._onActivity = onActivity\n  }\n  setOnActivityAbort(onActivityAbort: (() => void) | undefined): void {\n    this._onActivityAbort = onActivityAbort\n  }\n\n  end(): ReturnType<JestWorker['end']> {\n    const worker = this._worker\n    if (!worker) {\n      throw new Error('Farm is ended, no more calls can be done to it')\n    }\n    cleanupWorkers(worker)\n    this._worker = undefined\n    return worker.end()\n  }\n\n  /**\n   * Quietly end the worker if it exists\n   */\n  close(): void {\n    if (this._worker) {\n      cleanupWorkers(this._worker)\n      this._worker.end()\n    }\n  }\n}\n"],"names":["Worker","JestWorker","Transform","formatDebugAddress","formatNodeOptions","getNodeDebugType","getParsedDebugAddress","getParsedNodeOptions","RESTARTED","Symbol","cleanupWorkers","worker","curWorker","_workerPool","_workers","_child","kill","getNextBuildDebuggerPortOffset","_","constructor","workerPath","options","enableSourceMaps","timeout","onRestart","logger","console","debuggerPortOffset","isolatedMemory","onActivity","onActivityAbort","farmOptions","_onActivity","_onActivityAbort","restartPromise","resolveRestartPromise","activeTasks","_worker","undefined","process","on","close","nodeOptions","originalOptions","inspect","nodeDebugType","debuggerAddress","address","host","port","createWorker","workerEnv","env","forkOptions","IS_NEXT_WORKER","NODE_OPTIONS","FORCE_COLOR","supportsColors","NO_COLOR","CI","TERM","stdout","isTTY","stderr","maxRetries","Promise","resolve","enableWorkerThreads","code","signal","error","exit","data","type","onActivityImpl","aborted","onActivityAbortImpl","abortActivityStreamOnLog","transform","_chunk","_encoding","callback","getStdout","pipe","getStderr","onHanging","warn","end","then","hangingTimer","clearTimeout","setTimeout","method","exposedMethods","startsWith","args","attempts","result","race","bind","setOnActivity","setOnActivityAbort","Error"],"mappings":"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","ignoreList":[0]}