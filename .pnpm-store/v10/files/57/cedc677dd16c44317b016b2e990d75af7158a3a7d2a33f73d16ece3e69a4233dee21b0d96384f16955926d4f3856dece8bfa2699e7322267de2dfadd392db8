{"version":3,"sources":["../../../../src/build/segment-config/app/app-segments.ts"],"sourcesContent":["import type { Params } from '../../../server/request/params'\nimport type { AppPageRouteModule } from '../../../server/route-modules/app-page/module.compiled'\nimport type { AppRouteRouteModule } from '../../../server/route-modules/app-route/module.compiled'\nimport {\n  type AppSegmentConfig,\n  parseAppSegmentConfig,\n} from './app-segment-config'\n\nimport { InvariantError } from '../../../shared/lib/invariant-error'\nimport {\n  isAppRouteRouteModule,\n  isAppPageRouteModule,\n} from '../../../server/route-modules/checks'\nimport { isClientReference } from '../../../lib/client-and-server-references'\nimport { getSegmentParam } from '../../../shared/lib/router/utils/get-segment-param'\nimport {\n  getLayoutOrPageModule,\n  type LoaderTree,\n} from '../../../server/lib/app-dir-module'\nimport type { DynamicParamTypes } from '../../../shared/lib/app-router-types'\n\ntype GenerateStaticParams = (options: { params?: Params }) => Promise<Params[]>\n\n/**\n * Parses the app config and attaches it to the segment.\n */\nfunction attach(segment: AppSegment, userland: unknown, route: string) {\n  // If the userland is not an object, then we can't do anything with it.\n  if (typeof userland !== 'object' || userland === null) {\n    return\n  }\n\n  // Try to parse the application configuration.\n  const config = parseAppSegmentConfig(userland, route)\n\n  // If there was any keys on the config, then attach it to the segment.\n  if (Object.keys(config).length > 0) {\n    segment.config = config\n  }\n\n  if (\n    'generateStaticParams' in userland &&\n    typeof userland.generateStaticParams === 'function'\n  ) {\n    segment.generateStaticParams =\n      userland.generateStaticParams as GenerateStaticParams\n\n    // Validate that `generateStaticParams` makes sense in this context.\n    if (segment.config?.runtime === 'edge') {\n      throw new Error(\n        'Edge runtime is not supported with `generateStaticParams`.'\n      )\n    }\n  }\n}\n\nexport type AppSegment = {\n  name: string\n  paramName: string | undefined\n  paramType: DynamicParamTypes | undefined\n  filePath: string | undefined\n  config: AppSegmentConfig | undefined\n  generateStaticParams: GenerateStaticParams | undefined\n}\n\n/**\n * Walks the loader tree and collects the generate parameters for each segment.\n *\n * @param routeModule the app page route module\n * @returns the segments for the app page route module\n */\nasync function collectAppPageSegments(routeModule: AppPageRouteModule) {\n  // We keep track of unique segments, since with parallel routes, it's possible\n  // to see the same segment multiple times.\n  const segments: AppSegment[] = []\n\n  // Queue will store loader trees.\n  const queue: LoaderTree[] = [routeModule.userland.loaderTree]\n\n  while (queue.length > 0) {\n    const loaderTree = queue.shift()!\n    const [name, parallelRoutes] = loaderTree\n\n    // Process current node\n    const { mod: userland, filePath } = await getLayoutOrPageModule(loaderTree)\n    const isClientComponent = userland && isClientReference(userland)\n\n    const param = getSegmentParam(name)\n\n    const segment: AppSegment = {\n      name,\n      paramName: param?.paramName,\n      paramType: param?.paramType,\n      filePath,\n      config: undefined,\n      generateStaticParams: undefined,\n    }\n\n    // Only server components can have app segment configurations\n    if (!isClientComponent) {\n      attach(segment, userland, routeModule.definition.pathname)\n    }\n\n    // If this segment doesn't already exist, then add it to the segments array.\n    // The list of segments is short so we just use a list traversal to check\n    // for duplicates and spare us needing to maintain the string key.\n    if (\n      segments.every(\n        (s) =>\n          s.name !== segment.name ||\n          s.paramName !== segment.paramName ||\n          s.paramType !== segment.paramType ||\n          s.filePath !== segment.filePath\n      )\n    ) {\n      segments.push(segment)\n    }\n\n    // Add all parallel routes to the queue\n    for (const parallelRoute of Object.values(parallelRoutes)) {\n      queue.push(parallelRoute)\n    }\n  }\n\n  return segments\n}\n\n/**\n * Collects the segments for a given app route module.\n *\n * @param routeModule the app route module\n * @returns the segments for the app route module\n */\nfunction collectAppRouteSegments(\n  routeModule: AppRouteRouteModule\n): AppSegment[] {\n  // Get the pathname parts, slice off the first element (which is empty).\n  const parts = routeModule.definition.pathname.split('/').slice(1)\n  if (parts.length === 0) {\n    throw new InvariantError('Expected at least one segment')\n  }\n\n  // Generate all the segments.\n  const segments: AppSegment[] = parts.map((name) => {\n    const param = getSegmentParam(name)\n\n    return {\n      name,\n      paramName: param?.paramName,\n      paramType: param?.paramType,\n      filePath: undefined,\n      config: undefined,\n      generateStaticParams: undefined,\n    } satisfies AppSegment\n  })\n\n  // We know we have at least one, we verified this above. We should get the\n  // last segment which represents the root route module.\n  const segment = segments[segments.length - 1]\n\n  segment.filePath = routeModule.definition.filename\n\n  // Extract the segment config from the userland module.\n  attach(segment, routeModule.userland, routeModule.definition.pathname)\n\n  return segments\n}\n\n/**\n * Collects the segments for a given route module.\n *\n * @param components the loaded components\n * @returns the segments for the route module\n */\nexport function collectSegments(\n  routeModule: AppRouteRouteModule | AppPageRouteModule\n): Promise<AppSegment[]> | AppSegment[] {\n  if (isAppRouteRouteModule(routeModule)) {\n    return collectAppRouteSegments(routeModule)\n  }\n\n  if (isAppPageRouteModule(routeModule)) {\n    return collectAppPageSegments(routeModule)\n  }\n\n  throw new InvariantError(\n    'Expected a route module to be one of app route or page'\n  )\n}\n"],"names":["collectSegments","attach","segment","userland","route","config","parseAppSegmentConfig","Object","keys","length","generateStaticParams","runtime","Error","collectAppPageSegments","routeModule","segments","queue","loaderTree","shift","name","parallelRoutes","mod","filePath","getLayoutOrPageModule","isClientComponent","isClientReference","param","getSegmentParam","paramName","paramType","undefined","definition","pathname","every","s","push","parallelRoute","values","collectAppRouteSegments","parts","split","slice","InvariantError","map","filename","isAppRouteRouteModule","isAppPageRouteModule"],"mappings":"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","ignoreList":[0]}