{"version":3,"sources":["../../../../src/server/app-render/action-handler.ts"],"sourcesContent":["import type { IncomingHttpHeaders, OutgoingHttpHeaders } from 'node:http'\nimport type { SizeLimit } from '../../types'\nimport type { RequestStore } from '../app-render/work-unit-async-storage.external'\nimport type { AppRenderContext, GenerateFlight } from './app-render'\nimport type { AppPageModule } from '../route-modules/app-page/module'\nimport type { BaseNextRequest, BaseNextResponse } from '../base-http'\n\nimport {\n  RSC_HEADER,\n  RSC_CONTENT_TYPE_HEADER,\n  NEXT_ROUTER_STATE_TREE_HEADER,\n  ACTION_HEADER,\n  NEXT_ACTION_NOT_FOUND_HEADER,\n  NEXT_ROUTER_PREFETCH_HEADER,\n  NEXT_ROUTER_SEGMENT_PREFETCH_HEADER,\n  NEXT_URL,\n  NEXT_ACTION_REVALIDATED_HEADER,\n} from '../../client/components/app-router-headers'\nimport {\n  getAccessFallbackHTTPStatus,\n  isHTTPAccessFallbackError,\n} from '../../client/components/http-access-fallback/http-access-fallback'\nimport {\n  getRedirectTypeFromError,\n  getURLFromRedirectError,\n} from '../../client/components/redirect'\nimport {\n  isRedirectError,\n  type RedirectType,\n} from '../../client/components/redirect-error'\nimport RenderResult, {\n  type AppPageRenderResultMetadata,\n} from '../render-result'\nimport type { WorkStore } from '../app-render/work-async-storage.external'\nimport { FlightRenderResult } from './flight-render-result'\nimport {\n  filterReqHeaders,\n  actionsForbiddenHeaders,\n} from '../lib/server-ipc/utils'\nimport { getModifiedCookieValues } from '../web/spec-extension/adapters/request-cookies'\n\nimport {\n  JSON_CONTENT_TYPE_HEADER,\n  NEXT_CACHE_REVALIDATED_TAGS_HEADER,\n  NEXT_CACHE_REVALIDATE_TAG_TOKEN_HEADER,\n} from '../../lib/constants'\nimport { getServerActionRequestMetadata } from '../lib/server-action-request-meta'\nimport { isCsrfOriginAllowed } from './csrf-protection'\nimport { warn } from '../../build/output/log'\nimport { RequestCookies, ResponseCookies } from '../web/spec-extension/cookies'\nimport { HeadersAdapter } from '../web/spec-extension/adapters/headers'\nimport { fromNodeOutgoingHttpHeaders } from '../web/utils'\nimport {\n  selectWorkerForForwarding,\n  type ServerModuleMap,\n  getServerActionsManifest,\n  getServerModuleMap,\n} from './manifests-singleton'\nimport { isNodeNextRequest, isWebNextRequest } from '../base-http/helpers'\nimport { RedirectStatusCode } from '../../client/components/redirect-status-code'\nimport { synchronizeMutableCookies } from '../async-storage/request-store'\nimport type { TemporaryReferenceSet } from 'react-server-dom-webpack/server'\nimport { workUnitAsyncStorage } from '../app-render/work-unit-async-storage.external'\nimport { InvariantError } from '../../shared/lib/invariant-error'\nimport { executeRevalidates } from '../revalidation-utils'\nimport { getRequestMeta } from '../request-meta'\nimport { setCacheBustingSearchParam } from '../../client/components/router-reducer/set-cache-busting-search-param'\nimport {\n  ActionDidNotRevalidate,\n  ActionDidRevalidateStaticAndDynamic,\n} from '../../shared/lib/action-revalidation-kind'\n\n/**\n * Checks if the app has any server actions defined in any runtime.\n */\nfunction hasServerActions() {\n  const serverActionsManifest = getServerActionsManifest()\n\n  return (\n    Object.keys(serverActionsManifest.node).length > 0 ||\n    Object.keys(serverActionsManifest.edge).length > 0\n  )\n}\n\nfunction nodeHeadersToRecord(\n  headers: IncomingHttpHeaders | OutgoingHttpHeaders\n) {\n  const record: Record<string, string> = {}\n  for (const [key, value] of Object.entries(headers)) {\n    if (value !== undefined) {\n      record[key] = Array.isArray(value) ? value.join(', ') : `${value}`\n    }\n  }\n  return record\n}\n\nfunction getForwardedHeaders(\n  req: BaseNextRequest,\n  res: BaseNextResponse\n): Headers {\n  // Get request headers and cookies\n  const requestHeaders = req.headers\n  const requestCookies = new RequestCookies(HeadersAdapter.from(requestHeaders))\n\n  // Get response headers and cookies\n  const responseHeaders = res.getHeaders()\n  const responseCookies = new ResponseCookies(\n    fromNodeOutgoingHttpHeaders(responseHeaders)\n  )\n\n  // Merge request and response headers\n  const mergedHeaders = filterReqHeaders(\n    {\n      ...nodeHeadersToRecord(requestHeaders),\n      ...nodeHeadersToRecord(responseHeaders),\n    },\n    actionsForbiddenHeaders\n  ) as Record<string, string>\n\n  // Merge cookies into requestCookies, so responseCookies always take precedence\n  // and overwrite/delete those from requestCookies.\n  responseCookies.getAll().forEach((cookie) => {\n    if (typeof cookie.value === 'undefined') {\n      requestCookies.delete(cookie.name)\n    } else {\n      requestCookies.set(cookie)\n    }\n  })\n\n  // Update the 'cookie' header with the merged cookies\n  mergedHeaders['cookie'] = requestCookies.toString()\n\n  // Remove headers that should not be forwarded\n  delete mergedHeaders['transfer-encoding']\n\n  return new Headers(mergedHeaders)\n}\n\nfunction addRevalidationHeader(\n  res: BaseNextResponse,\n  {\n    workStore,\n    requestStore,\n  }: {\n    workStore: WorkStore\n    requestStore: RequestStore\n  }\n) {\n  // If a tag was revalidated, the client router needs to invalidate all the\n  // client router cache as they may be stale. And if a path was revalidated, the\n  // client needs to invalidate all subtrees below that path.\n\n  // TODO: Currently we don't send the specific tags or paths to the client,\n  // we just send a flag indicating that all the static data on the client\n  // should be invalidated. In the future, this will likely be a Bloom filter\n  // or bitmask of some kind.\n\n  // TODO-APP: Currently the prefetch cache doesn't have subtree information,\n  // so we need to invalidate the entire cache if a path was revalidated.\n  // TODO-APP: Currently paths are treated as tags, so the second element of the tuple\n  // is always empty.\n\n  const isTagRevalidated = workStore.pendingRevalidatedTags?.length ? 1 : 0\n  const isCookieRevalidated = getModifiedCookieValues(\n    requestStore.mutableCookies\n  ).length\n    ? 1\n    : 0\n\n  // First check if a tag, cookie, or path was revalidated.\n  if (isTagRevalidated || isCookieRevalidated) {\n    res.setHeader(\n      NEXT_ACTION_REVALIDATED_HEADER,\n      JSON.stringify(ActionDidRevalidateStaticAndDynamic)\n    )\n  } else if (\n    // Check for refresh() actions. This will invalidate only the dynamic data.\n    workStore.pathWasRevalidated !== undefined &&\n    workStore.pathWasRevalidated !== ActionDidNotRevalidate\n  ) {\n    res.setHeader(\n      NEXT_ACTION_REVALIDATED_HEADER,\n      JSON.stringify(workStore.pathWasRevalidated)\n    )\n  }\n}\n\n/**\n * Forwards a server action request to a separate worker. Used when the requested action is not available in the current worker.\n */\nasync function createForwardedActionResponse(\n  req: BaseNextRequest,\n  res: BaseNextResponse,\n  host: Host,\n  workerPathname: string,\n  basePath: string\n) {\n  if (!host) {\n    throw new Error(\n      'Invariant: Missing `host` header from a forwarded Server Actions request.'\n    )\n  }\n\n  const forwardedHeaders = getForwardedHeaders(req, res)\n\n  // indicate that this action request was forwarded from another worker\n  // we use this to skip rendering the flight tree so that we don't update the UI\n  // with the response from the forwarded worker\n  forwardedHeaders.set('x-action-forwarded', '1')\n\n  const proto =\n    getRequestMeta(req, 'initProtocol')?.replace(/:+$/, '') || 'https'\n\n  // For standalone or the serverful mode, use the internal origin directly\n  // other than the host headers from the request.\n  const origin = process.env.__NEXT_PRIVATE_ORIGIN || `${proto}://${host.value}`\n\n  const fetchUrl = new URL(`${origin}${basePath}${workerPathname}`)\n\n  try {\n    let body: BodyInit | ReadableStream<Uint8Array> | undefined\n    if (\n      // The type check here ensures that `req` is correctly typed, and the\n      // environment variable check provides dead code elimination.\n      process.env.NEXT_RUNTIME === 'edge' &&\n      isWebNextRequest(req)\n    ) {\n      if (!req.body) {\n        throw new Error('Invariant: missing request body.')\n      }\n\n      body = req.body\n    } else if (\n      // The type check here ensures that `req` is correctly typed, and the\n      // environment variable check provides dead code elimination.\n      process.env.NEXT_RUNTIME !== 'edge' &&\n      isNodeNextRequest(req)\n    ) {\n      body = req.stream()\n    } else {\n      throw new Error('Invariant: Unknown request type.')\n    }\n\n    // Forward the request to the new worker\n    const response = await fetch(fetchUrl, {\n      method: 'POST',\n      body,\n      duplex: 'half',\n      headers: forwardedHeaders,\n      redirect: 'manual',\n      next: {\n        // @ts-ignore\n        internal: 1,\n      },\n    })\n\n    if (\n      response.headers.get('content-type')?.startsWith(RSC_CONTENT_TYPE_HEADER)\n    ) {\n      // copy the headers from the redirect response to the response we're sending\n      for (const [key, value] of response.headers) {\n        if (!actionsForbiddenHeaders.includes(key)) {\n          res.setHeader(key, value)\n        }\n      }\n\n      return new FlightRenderResult(response.body!)\n    } else {\n      // Since we aren't consuming the response body, we cancel it to avoid memory leaks\n      response.body?.cancel()\n    }\n  } catch (err) {\n    // we couldn't stream the forwarded response, so we'll just return an empty response\n    console.error(`failed to forward action response`, err)\n  }\n\n  return RenderResult.fromStatic('{}', JSON_CONTENT_TYPE_HEADER)\n}\n\n/**\n * Returns the parsed redirect URL if we deem that it is hosted by us.\n *\n * We handle both relative and absolute redirect URLs.\n *\n * In case the redirect URL is not relative to the application we return `null`.\n */\nfunction getAppRelativeRedirectUrl(\n  basePath: string,\n  host: Host,\n  redirectUrl: string,\n  currentPathname?: string\n): URL | null {\n  if (redirectUrl.startsWith('/')) {\n    // Absolute path - just add basePath\n    return new URL(`${basePath}${redirectUrl}`, 'http://n')\n  } else if (redirectUrl.startsWith('.')) {\n    // Relative path - resolve relative to current pathname\n    let base = currentPathname || '/'\n    // Ensure the base path ends with a slash so relative resolution works correctly\n    // e.g., \"./subpage\" from \"/subdir\" should resolve to \"/subdir/subpage\"\n    // not \"/subpage\"\n    if (!base.endsWith('/')) {\n      base = base + '/'\n    }\n    const resolved = new URL(redirectUrl, `http://n${base}`)\n    // Include basePath in the final URL\n    return new URL(\n      `${basePath}${resolved.pathname}${resolved.search}${resolved.hash}`,\n      'http://n'\n    )\n  }\n\n  const parsedRedirectUrl = new URL(redirectUrl)\n\n  if (host?.value !== parsedRedirectUrl.host) {\n    return null\n  }\n\n  // At this point the hosts are the same, just confirm we\n  // are routing to a path underneath the `basePath`\n  return parsedRedirectUrl.pathname.startsWith(basePath)\n    ? parsedRedirectUrl\n    : null\n}\n\nasync function createRedirectRenderResult(\n  req: BaseNextRequest,\n  res: BaseNextResponse,\n  originalHost: Host,\n  redirectUrl: string,\n  redirectType: RedirectType,\n  basePath: string,\n  workStore: WorkStore,\n  currentPathname?: string\n) {\n  res.setHeader('x-action-redirect', `${redirectUrl};${redirectType}`)\n\n  // If we're redirecting to another route of this Next.js application, we'll\n  // try to stream the response from the other worker path. When that works,\n  // we can save an extra roundtrip and avoid a full page reload.\n  // When the redirect URL starts with a `/` or is to the same host, under the\n  // `basePath` we treat it as an app-relative redirect;\n  const appRelativeRedirectUrl = getAppRelativeRedirectUrl(\n    basePath,\n    originalHost,\n    redirectUrl,\n    currentPathname\n  )\n\n  if (appRelativeRedirectUrl) {\n    if (!originalHost) {\n      throw new Error(\n        'Invariant: Missing `host` header from a forwarded Server Actions request.'\n      )\n    }\n\n    const forwardedHeaders = getForwardedHeaders(req, res)\n    forwardedHeaders.set(RSC_HEADER, '1')\n\n    const proto =\n      getRequestMeta(req, 'initProtocol')?.replace(/:+$/, '') || 'https'\n\n    // For standalone or the serverful mode, use the internal origin directly\n    // other than the host headers from the request.\n    const origin =\n      process.env.__NEXT_PRIVATE_ORIGIN || `${proto}://${originalHost.value}`\n\n    const fetchUrl = new URL(\n      `${origin}${appRelativeRedirectUrl.pathname}${appRelativeRedirectUrl.search}`\n    )\n\n    if (workStore.pendingRevalidatedTags) {\n      forwardedHeaders.set(\n        NEXT_CACHE_REVALIDATED_TAGS_HEADER,\n        workStore.pendingRevalidatedTags.map((item) => item.tag).join(',')\n      )\n      forwardedHeaders.set(\n        NEXT_CACHE_REVALIDATE_TAG_TOKEN_HEADER,\n        workStore.incrementalCache?.prerenderManifest?.preview?.previewModeId ||\n          ''\n      )\n    }\n\n    // Ensures that when the path was revalidated we don't return a partial response on redirects\n    forwardedHeaders.delete(NEXT_ROUTER_STATE_TREE_HEADER)\n    // When an action follows a redirect, it's no longer handling an action: it's just a normal RSC request\n    // to the requested URL. We should remove the `next-action` header so that it's not treated as an action\n    forwardedHeaders.delete(ACTION_HEADER)\n\n    try {\n      setCacheBustingSearchParam(fetchUrl, {\n        [NEXT_ROUTER_PREFETCH_HEADER]: forwardedHeaders.get(\n          NEXT_ROUTER_PREFETCH_HEADER\n        )\n          ? ('1' as const)\n          : undefined,\n        [NEXT_ROUTER_SEGMENT_PREFETCH_HEADER]:\n          forwardedHeaders.get(NEXT_ROUTER_SEGMENT_PREFETCH_HEADER) ??\n          undefined,\n        [NEXT_ROUTER_STATE_TREE_HEADER]:\n          forwardedHeaders.get(NEXT_ROUTER_STATE_TREE_HEADER) ?? undefined,\n        [NEXT_URL]: forwardedHeaders.get(NEXT_URL) ?? undefined,\n      })\n\n      const response = await fetch(fetchUrl, {\n        method: 'GET',\n        headers: forwardedHeaders,\n        next: {\n          // @ts-ignore\n          internal: 1,\n        },\n      })\n\n      if (\n        response.headers\n          .get('content-type')\n          ?.startsWith(RSC_CONTENT_TYPE_HEADER)\n      ) {\n        // copy the headers from the redirect response to the response we're sending\n        for (const [key, value] of response.headers) {\n          if (!actionsForbiddenHeaders.includes(key)) {\n            res.setHeader(key, value)\n          }\n        }\n\n        return new FlightRenderResult(response.body!)\n      } else {\n        // Since we aren't consuming the response body, we cancel it to avoid memory leaks\n        response.body?.cancel()\n      }\n    } catch (err) {\n      // we couldn't stream the redirect response, so we'll just do a normal redirect\n      console.error(`failed to get redirect response`, err)\n    }\n  }\n\n  return RenderResult.EMPTY\n}\n\n// Used to compare Host header and Origin header.\nconst enum HostType {\n  XForwardedHost = 'x-forwarded-host',\n  Host = 'host',\n}\ntype Host =\n  | {\n      type: HostType.XForwardedHost\n      value: string\n    }\n  | {\n      type: HostType.Host\n      value: string\n    }\n  | undefined\n\n/**\n * Ensures the value of the header can't create long logs.\n */\nfunction limitUntrustedHeaderValueForLogs(value: string) {\n  return value.length > 100 ? value.slice(0, 100) + '...' : value\n}\n\nexport function parseHostHeader(\n  headers: IncomingHttpHeaders,\n  originDomain?: string\n) {\n  const forwardedHostHeader = headers['x-forwarded-host']\n  const forwardedHostHeaderValue =\n    forwardedHostHeader && Array.isArray(forwardedHostHeader)\n      ? forwardedHostHeader[0]\n      : forwardedHostHeader?.split(',')?.[0]?.trim()\n  const hostHeader = headers['host']\n\n  if (originDomain) {\n    return forwardedHostHeaderValue === originDomain\n      ? {\n          type: HostType.XForwardedHost,\n          value: forwardedHostHeaderValue,\n        }\n      : hostHeader === originDomain\n        ? {\n            type: HostType.Host,\n            value: hostHeader,\n          }\n        : undefined\n  }\n\n  return forwardedHostHeaderValue\n    ? {\n        type: HostType.XForwardedHost,\n        value: forwardedHostHeaderValue,\n      }\n    : hostHeader\n      ? {\n          type: HostType.Host,\n          value: hostHeader,\n        }\n      : undefined\n}\n\ntype ServerActionsConfig = {\n  bodySizeLimit?: SizeLimit\n  allowedOrigins?: string[]\n}\n\ntype HandleActionResult =\n  | {\n      /** An MPA action threw notFound(), and we need to render the appropriate HTML */\n      type: 'not-found'\n    }\n  | {\n      type: 'done'\n      result: RenderResult | undefined\n      formState?: any\n    }\n  /** The request turned out not to be a server action. */\n  | null\n\nexport async function handleAction({\n  req,\n  res,\n  ComponentMod,\n  generateFlight,\n  workStore,\n  requestStore,\n  serverActions,\n  ctx,\n  metadata,\n}: {\n  req: BaseNextRequest\n  res: BaseNextResponse\n  ComponentMod: AppPageModule\n  generateFlight: GenerateFlight\n  workStore: WorkStore\n  requestStore: RequestStore\n  serverActions?: ServerActionsConfig\n  ctx: AppRenderContext\n  metadata: AppPageRenderResultMetadata\n}): Promise<HandleActionResult> {\n  const contentType = req.headers['content-type']\n  const { page } = ctx.renderOpts\n  const serverModuleMap = getServerModuleMap()\n\n  const {\n    actionId,\n    isMultipartAction,\n    isFetchAction,\n    isURLEncodedAction,\n    isPossibleServerAction,\n  } = getServerActionRequestMetadata(req)\n\n  const handleUnrecognizedFetchAction = (err: unknown): HandleActionResult => {\n    // If the deployment doesn't have skew protection, this is expected to occasionally happen,\n    // so we use a warning instead of an error.\n    console.warn(err)\n\n    // Return an empty response with a header that the client router will interpret.\n    // We don't need to waste time encoding a flight response, and using a blank body + header\n    // means that unrecognized actions can also be handled at the infra level\n    // (i.e. without needing to invoke a lambda)\n    res.setHeader(NEXT_ACTION_NOT_FOUND_HEADER, '1')\n    res.setHeader('content-type', 'text/plain')\n    res.statusCode = 404\n    return {\n      type: 'done',\n      result: RenderResult.fromStatic('Server action not found.', 'text/plain'),\n    }\n  }\n\n  // If it can't be a Server Action, skip handling.\n  // Note that this can be a false positive -- any multipart/urlencoded POST can get us here,\n  // But won't know if it's an MPA action or not until we call `decodeAction` below.\n  if (!isPossibleServerAction) {\n    return null\n  }\n\n  // We don't currently support URL encoded actions, so we bail out early.\n  // Depending on if it's a fetch action or an MPA, we return a different response.\n  if (isURLEncodedAction) {\n    if (isFetchAction) {\n      return {\n        type: 'not-found',\n      }\n    } else {\n      // This is an MPA action, so we return null\n      return null\n    }\n  }\n\n  // If the app has no server actions at all, we can 404 early.\n  if (!hasServerActions()) {\n    return handleUnrecognizedFetchAction(getActionNotFoundError(actionId))\n  }\n\n  if (workStore.isStaticGeneration) {\n    throw new Error(\n      \"Invariant: server actions can't be handled during static rendering\"\n    )\n  }\n\n  let temporaryReferences: TemporaryReferenceSet | undefined\n\n  // When running actions the default is no-store, you can still `cache: 'force-cache'`\n  workStore.fetchCache = 'default-no-store'\n\n  const originHeader = req.headers['origin']\n  const originDomain =\n    typeof originHeader === 'string' && originHeader !== 'null'\n      ? new URL(originHeader).host\n      : undefined\n  const host = parseHostHeader(req.headers)\n\n  let warning: string | undefined = undefined\n\n  function warnBadServerActionRequest() {\n    if (warning) {\n      warn(warning)\n    }\n  }\n  // This is to prevent CSRF attacks. If `x-forwarded-host` is set, we need to\n  // ensure that the request is coming from the same host.\n  if (!originDomain) {\n    // This might be an old browser that doesn't send `host` header. We ignore\n    // this case.\n    warning = 'Missing `origin` header from a forwarded Server Actions request.'\n  } else if (!host || originDomain !== host.value) {\n    // If the customer sets a list of allowed origins, we'll allow the request.\n    // These are considered safe but might be different from forwarded host set\n    // by the infra (i.e. reverse proxies).\n    if (isCsrfOriginAllowed(originDomain, serverActions?.allowedOrigins)) {\n      // Ignore it\n    } else {\n      if (host) {\n        // This seems to be an CSRF attack. We should not proceed the action.\n        console.error(\n          `\\`${\n            host.type\n          }\\` header with value \\`${limitUntrustedHeaderValueForLogs(\n            host.value\n          )}\\` does not match \\`origin\\` header with value \\`${limitUntrustedHeaderValueForLogs(\n            originDomain\n          )}\\` from a forwarded Server Actions request. Aborting the action.`\n        )\n      } else {\n        // This is an attack. We should not proceed the action.\n        console.error(\n          `\\`x-forwarded-host\\` or \\`host\\` headers are not provided. One of these is needed to compare the \\`origin\\` header from a forwarded Server Actions request. Aborting the action.`\n        )\n      }\n\n      const error = new Error('Invalid Server Actions request.')\n\n      if (isFetchAction) {\n        res.statusCode = 500\n        metadata.statusCode = 500\n\n        const promise = Promise.reject(error)\n        try {\n          // we need to await the promise to trigger the rejection early\n          // so that it's already handled by the time we call\n          // the RSC runtime. Otherwise, it will throw an unhandled\n          // promise rejection error in the renderer.\n          await promise\n        } catch {\n          // swallow error, it's gonna be handled on the client\n        }\n\n        return {\n          type: 'done',\n          result: await generateFlight(req, ctx, requestStore, {\n            actionResult: promise,\n            // We didn't execute an action, so no revalidations could have\n            // occurred. We can skip rendering the page.\n            skipPageRendering: true,\n            temporaryReferences,\n          }),\n        }\n      }\n\n      throw error\n    }\n  }\n\n  // ensure we avoid caching server actions unexpectedly\n  res.setHeader(\n    'Cache-Control',\n    'no-cache, no-store, max-age=0, must-revalidate'\n  )\n\n  const { actionAsyncStorage } = ComponentMod\n\n  const actionWasForwarded = Boolean(req.headers['x-action-forwarded'])\n\n  if (actionId) {\n    const forwardedWorker = selectWorkerForForwarding(actionId, page)\n\n    // If forwardedWorker is truthy, it means there isn't a worker for the action\n    // in the current handler, so we forward the request to a worker that has the action.\n    if (forwardedWorker) {\n      return {\n        type: 'done',\n        result: await createForwardedActionResponse(\n          req,\n          res,\n          host,\n          forwardedWorker,\n          ctx.renderOpts.basePath\n        ),\n      }\n    }\n  }\n\n  try {\n    return await actionAsyncStorage.run(\n      { isAction: true },\n      async (): Promise<HandleActionResult> => {\n        // We only use these for fetch actions -- MPA actions handle them inside `decodeAction`.\n        let actionModId: string | number | undefined\n        let boundActionArguments: unknown[] = []\n\n        if (\n          // The type check here ensures that `req` is correctly typed, and the\n          // environment variable check provides dead code elimination.\n          process.env.NEXT_RUNTIME === 'edge' &&\n          isWebNextRequest(req)\n        ) {\n          if (!req.body) {\n            throw new Error('invariant: Missing request body.')\n          }\n\n          // TODO: add body limit\n\n          // Use react-server-dom-webpack/server\n          const {\n            createTemporaryReferenceSet,\n            decodeReply,\n            decodeAction,\n            decodeFormState,\n          } = ComponentMod\n\n          temporaryReferences = createTemporaryReferenceSet()\n\n          if (isMultipartAction) {\n            // TODO-APP: Add streaming support\n            const formData = await req.request.formData()\n            if (isFetchAction) {\n              // A fetch action with a multipart body.\n\n              try {\n                actionModId = getActionModIdOrError(actionId, serverModuleMap)\n              } catch (err) {\n                return handleUnrecognizedFetchAction(err)\n              }\n\n              boundActionArguments = await decodeReply(\n                formData,\n                serverModuleMap,\n                { temporaryReferences }\n              )\n            } else {\n              // Multipart POST, but not a fetch action.\n              // Potentially an MPA action, we have to try decoding it to check.\n              if (areAllActionIdsValid(formData, serverModuleMap) === false) {\n                // TODO: This can be from skew or manipulated input. We should handle this case\n                // more gracefully but this preserves the prior behavior where decodeAction would throw instead.\n                throw new Error(\n                  `Failed to find Server Action. This request might be from an older or newer deployment.\\nRead more: https://nextjs.org/docs/messages/failed-to-find-server-action`\n                )\n              }\n\n              const action = await decodeAction(formData, serverModuleMap)\n              if (typeof action === 'function') {\n                // an MPA action.\n\n                // Only warn if it's a server action, otherwise skip for other post requests\n                warnBadServerActionRequest()\n\n                const { actionResult } = await executeActionAndPrepareForRender(\n                  action as () => Promise<unknown>,\n                  [],\n                  workStore,\n                  requestStore,\n                  actionWasForwarded\n                )\n\n                const formState = await decodeFormState(\n                  actionResult,\n                  formData,\n                  serverModuleMap\n                )\n\n                // Skip the fetch path.\n                // We need to render a full HTML version of the page for the response, we'll handle that in app-render.\n                return {\n                  type: 'done',\n                  result: undefined,\n                  formState,\n                }\n              } else {\n                // We couldn't decode an action, so this POST request turned out not to be a server action request.\n                return null\n              }\n            }\n          } else {\n            // POST with non-multipart body.\n\n            // If it's not multipart AND not a fetch action,\n            // then it can't be an action request.\n            if (!isFetchAction) {\n              return null\n            }\n\n            try {\n              actionModId = getActionModIdOrError(actionId, serverModuleMap)\n            } catch (err) {\n              return handleUnrecognizedFetchAction(err)\n            }\n\n            // A fetch action with a non-multipart body.\n            // In practice, this happens if `encodeReply` returned a string instead of FormData,\n            // which can happen for very simple JSON-like values that don't need multiple flight rows.\n\n            const chunks: Buffer[] = []\n            const reader = req.body.getReader()\n            while (true) {\n              const { done, value } = await reader.read()\n              if (done) {\n                break\n              }\n\n              chunks.push(value)\n            }\n\n            const actionData = Buffer.concat(chunks).toString('utf-8')\n\n            boundActionArguments = await decodeReply(\n              actionData,\n              serverModuleMap,\n              { temporaryReferences }\n            )\n          }\n        } else if (\n          // The type check here ensures that `req` is correctly typed, and the\n          // environment variable check provides dead code elimination.\n          process.env.NEXT_RUNTIME !== 'edge' &&\n          isNodeNextRequest(req)\n        ) {\n          // Use react-server-dom-webpack/server.node which supports streaming\n          const {\n            createTemporaryReferenceSet,\n            decodeReply,\n            decodeReplyFromBusboy,\n            decodeAction,\n            decodeFormState,\n          } = require(\n            `./react-server.node`\n          ) as typeof import('./react-server.node')\n\n          temporaryReferences = createTemporaryReferenceSet()\n\n          const { PassThrough, Readable, Transform } =\n            require('node:stream') as typeof import('node:stream')\n          const { pipeline } =\n            require('node:stream/promises') as typeof import('node:stream/promises')\n\n          const defaultBodySizeLimit = '1 MB'\n          const bodySizeLimit =\n            serverActions?.bodySizeLimit ?? defaultBodySizeLimit\n          const bodySizeLimitBytes =\n            bodySizeLimit !== defaultBodySizeLimit\n              ? (\n                  require('next/dist/compiled/bytes') as typeof import('next/dist/compiled/bytes')\n                ).parse(bodySizeLimit)\n              : 1024 * 1024 // 1 MB\n\n          let size = 0\n          const sizeLimitTransform = new Transform({\n            transform(chunk, encoding, callback) {\n              size += Buffer.byteLength(chunk, encoding)\n              if (size > bodySizeLimitBytes) {\n                const { ApiError } =\n                  require('../api-utils') as typeof import('../api-utils')\n\n                callback(\n                  new ApiError(\n                    413,\n                    `Body exceeded ${bodySizeLimit} limit.\\n` +\n                      `To configure the body size limit for Server Actions, see: https://nextjs.org/docs/app/api-reference/next-config-js/serverActions#bodysizelimit`\n                  )\n                )\n                return\n              }\n\n              callback(null, chunk)\n            },\n          })\n\n          if (isMultipartAction) {\n            if (isFetchAction) {\n              // A fetch action with a multipart body.\n\n              try {\n                actionModId = getActionModIdOrError(actionId, serverModuleMap)\n              } catch (err) {\n                return handleUnrecognizedFetchAction(err)\n              }\n\n              const busboy = (\n                require('next/dist/compiled/busboy') as typeof import('next/dist/compiled/busboy')\n              )({\n                defParamCharset: 'utf8',\n                headers: req.headers,\n                limits: { fieldSize: bodySizeLimitBytes },\n              })\n\n              const abortController = new AbortController()\n              try {\n                ;[, boundActionArguments] = await Promise.all([\n                  pipeline(req.body, sizeLimitTransform, busboy, {\n                    signal: abortController.signal,\n                  }),\n                  decodeReplyFromBusboy(busboy, serverModuleMap, {\n                    temporaryReferences,\n                  }),\n                ])\n              } catch (err) {\n                abortController.abort()\n                throw err\n              }\n            } else {\n              // Multipart POST, but not a fetch action.\n              // Potentially an MPA action, we have to try decoding it to check.\n\n              const sizeLimitedBody = new PassThrough()\n\n              // React doesn't yet publish a busboy version of decodeAction\n              // so we polyfill the parsing of FormData.\n              const fakeRequest = new Request('http://localhost', {\n                method: 'POST',\n                // @ts-expect-error\n                headers: { 'Content-Type': contentType },\n                body: Readable.toWeb(\n                  sizeLimitedBody\n                ) as ReadableStream<Uint8Array>,\n                duplex: 'half',\n              })\n\n              let formData: FormData\n              const abortController = new AbortController()\n              try {\n                ;[, formData] = await Promise.all([\n                  pipeline(req.body, sizeLimitTransform, sizeLimitedBody, {\n                    signal: abortController.signal,\n                  }),\n                  fakeRequest.formData(),\n                ])\n              } catch (err) {\n                abortController.abort()\n                throw err\n              }\n\n              if (areAllActionIdsValid(formData, serverModuleMap) === false) {\n                // TODO: This can be from skew or manipulated input. We should handle this case\n                // more gracefully but this preserves the prior behavior where decodeAction would throw instead.\n                throw new Error(\n                  `Failed to find Server Action. This request might be from an older or newer deployment.\\nRead more: https://nextjs.org/docs/messages/failed-to-find-server-action`\n                )\n              }\n\n              // TODO: Refactor so it is harder to accidentally decode an action before you have validated that the\n              // action referred to is available.\n              const action = await decodeAction(formData, serverModuleMap)\n              if (typeof action === 'function') {\n                // an MPA action.\n\n                // Only warn if it's a server action, otherwise skip for other post requests\n                warnBadServerActionRequest()\n\n                const { actionResult } = await executeActionAndPrepareForRender(\n                  action as () => Promise<unknown>,\n                  [],\n                  workStore,\n                  requestStore,\n                  actionWasForwarded\n                )\n\n                const formState = await decodeFormState(\n                  actionResult,\n                  formData,\n                  serverModuleMap\n                )\n\n                // Skip the fetch path.\n                // We need to render a full HTML version of the page for the response, we'll handle that in app-render.\n                return {\n                  type: 'done',\n                  result: undefined,\n                  formState,\n                }\n              } else {\n                // We couldn't decode an action, so this POST request turned out not to be a server action request.\n                return null\n              }\n            }\n          } else {\n            // POST with non-multipart body.\n\n            // If it's not multipart AND not a fetch action,\n            // then it can't be an action request.\n            if (!isFetchAction) {\n              return null\n            }\n\n            try {\n              actionModId = getActionModIdOrError(actionId, serverModuleMap)\n            } catch (err) {\n              return handleUnrecognizedFetchAction(err)\n            }\n\n            // A fetch action with a non-multipart body.\n            // In practice, this happens if `encodeReply` returned a string instead of FormData,\n            // which can happen for very simple JSON-like values that don't need multiple flight rows.\n\n            const sizeLimitedBody = new PassThrough()\n\n            const chunks: Buffer[] = []\n            await Promise.all([\n              pipeline(req.body, sizeLimitTransform, sizeLimitedBody),\n              (async () => {\n                for await (const chunk of sizeLimitedBody) {\n                  chunks.push(Buffer.from(chunk))\n                }\n              })(),\n            ])\n\n            const actionData = Buffer.concat(chunks).toString('utf-8')\n\n            boundActionArguments = await decodeReply(\n              actionData,\n              serverModuleMap,\n              { temporaryReferences }\n            )\n          }\n        } else {\n          throw new Error('Invariant: Unknown request type.')\n        }\n\n        // actions.js\n        // app/page.js\n        //   action worker1\n        //     appRender1\n\n        // app/foo/page.js\n        //   action worker2\n        //     appRender\n\n        // / -> fire action -> POST / -> appRender1 -> modId for the action file\n        // /foo -> fire action -> POST /foo -> appRender2 -> modId for the action file\n\n        const actionMod = (await ComponentMod.__next_app__.require(\n          actionModId\n        )) as Record<string, (...args: unknown[]) => Promise<unknown>>\n        const actionHandler =\n          actionMod[\n            // `actionId` must exist if we got here, as otherwise we would have thrown an error above\n            actionId!\n          ]\n\n        const { actionResult, skipPageRendering } =\n          await executeActionAndPrepareForRender(\n            actionHandler,\n            boundActionArguments,\n            workStore,\n            requestStore,\n            actionWasForwarded\n          ).finally(() => {\n            addRevalidationHeader(res, { workStore, requestStore })\n          })\n\n        // For form actions, we need to continue rendering the page.\n        if (isFetchAction) {\n          return {\n            type: 'done',\n            result: await generateFlight(req, ctx, requestStore, {\n              actionResult: Promise.resolve(actionResult),\n              skipPageRendering,\n              temporaryReferences,\n              // If we skip page rendering, we need to ensure pending\n              // revalidates are awaited before closing the response. Otherwise,\n              // this will be done after rendering the page.\n              waitUntil: skipPageRendering\n                ? executeRevalidates(workStore)\n                : undefined,\n            }),\n          }\n        } else {\n          // TODO: this shouldn't be reachable, because all non-fetch codepaths return early.\n          // this will be handled in a follow-up refactor PR.\n          return null\n        }\n      }\n    )\n  } catch (err) {\n    if (isRedirectError(err)) {\n      const redirectUrl = getURLFromRedirectError(err)\n      const redirectType = getRedirectTypeFromError(err)\n\n      // if it's a fetch action, we'll set the status code for logging/debugging purposes\n      // but we won't set a Location header, as the redirect will be handled by the client router\n      res.statusCode = RedirectStatusCode.SeeOther\n      metadata.statusCode = RedirectStatusCode.SeeOther\n\n      if (isFetchAction) {\n        return {\n          type: 'done',\n          result: await createRedirectRenderResult(\n            req,\n            res,\n            host,\n            redirectUrl,\n            redirectType,\n            ctx.renderOpts.basePath,\n            workStore,\n            requestStore.url.pathname\n          ),\n        }\n      }\n\n      // For an MPA action, the redirect doesn't need a body, just a Location header.\n      res.setHeader('Location', redirectUrl)\n      return {\n        type: 'done',\n        result: RenderResult.EMPTY,\n      }\n    } else if (isHTTPAccessFallbackError(err)) {\n      res.statusCode = getAccessFallbackHTTPStatus(err)\n      metadata.statusCode = res.statusCode\n\n      if (isFetchAction) {\n        const promise = Promise.reject(err)\n        try {\n          // we need to await the promise to trigger the rejection early\n          // so that it's already handled by the time we call\n          // the RSC runtime. Otherwise, it will throw an unhandled\n          // promise rejection error in the renderer.\n          await promise\n        } catch {\n          // swallow error, it's gonna be handled on the client\n        }\n        return {\n          type: 'done',\n          result: await generateFlight(req, ctx, requestStore, {\n            skipPageRendering: false,\n            actionResult: promise,\n            temporaryReferences,\n          }),\n        }\n      }\n\n      // For an MPA action, we need to render a HTML response. We'll handle that in app-render.\n      return {\n        type: 'not-found',\n      }\n    }\n\n    // An error that didn't come from `redirect()` or `notFound()`, likely thrown from user code\n    // (but it could also be a bug in our code!)\n\n    if (isFetchAction) {\n      // TODO: consider checking if the error is an `ApiError` and change status code\n      // so that we can respond with a 413 to requests that break the body size limit\n      // (but if we do that, we also need to make sure that whatever handles the non-fetch error path below does the same)\n      res.statusCode = 500\n      metadata.statusCode = 500\n      const promise = Promise.reject(err)\n      try {\n        // we need to await the promise to trigger the rejection early\n        // so that it's already handled by the time we call\n        // the RSC runtime. Otherwise, it will throw an unhandled\n        // promise rejection error in the renderer.\n        await promise\n      } catch {\n        // swallow error, it's gonna be handled on the client\n      }\n\n      return {\n        type: 'done',\n        result: await generateFlight(req, ctx, requestStore, {\n          actionResult: promise,\n          // If the page was not revalidated, or if the action was forwarded\n          // from another worker, we can skip rendering the page.\n          skipPageRendering:\n            workStore.pathWasRevalidated === undefined ||\n            workStore.pathWasRevalidated === ActionDidNotRevalidate ||\n            actionWasForwarded,\n          temporaryReferences,\n        }),\n      }\n    }\n\n    // For an MPA action, we need to render a HTML response. We'll rethrow the error and let it be handled above.\n    throw err\n  }\n}\n\nasync function executeActionAndPrepareForRender<\n  TFn extends (...args: any[]) => Promise<any>,\n>(\n  action: TFn,\n  args: Parameters<TFn>,\n  workStore: WorkStore,\n  requestStore: RequestStore,\n  actionWasForwarded: boolean\n): Promise<{\n  actionResult: Awaited<ReturnType<TFn>>\n  skipPageRendering: boolean\n}> {\n  requestStore.phase = 'action'\n  let skipPageRendering = actionWasForwarded\n\n  try {\n    const actionResult = await workUnitAsyncStorage.run(requestStore, () =>\n      action.apply(null, args)\n    )\n\n    // If the page was not revalidated, or if the action was forwarded from\n    // another worker, we can skip rendering the page.\n    skipPageRendering ||=\n      workStore.pathWasRevalidated === undefined ||\n      workStore.pathWasRevalidated === ActionDidNotRevalidate\n\n    return { actionResult, skipPageRendering }\n  } finally {\n    if (!skipPageRendering) {\n      requestStore.phase = 'render'\n\n      // When we switch to the render phase, cookies() will return\n      // `workUnitStore.cookies` instead of\n      // `workUnitStore.userspaceMutableCookies`. We want the render to see any\n      // cookie writes that we performed during the action, so we need to update\n      // the immutable cookies to reflect the changes.\n      synchronizeMutableCookies(requestStore)\n\n      // The server action might have toggled draft mode, so we need to reflect\n      // that in the work store to be up-to-date for subsequent rendering.\n      workStore.isDraftMode = requestStore.draftMode.isEnabled\n\n      // If the action called revalidateTag/revalidatePath, then that might\n      // affect data used by the subsequent render, so we need to make sure all\n      // revalidations are applied before that.\n      await executeRevalidates(workStore)\n    }\n  }\n}\n\n/**\n * Attempts to find the module ID for the action from the module map. When this fails, it could be a deployment skew where\n * the action came from a different deployment. It could also simply be an invalid POST request that is not a server action.\n * In either case, we'll throw an error to be handled by the caller.\n */\nfunction getActionModIdOrError(\n  actionId: string | null,\n  serverModuleMap: ServerModuleMap\n): string | number {\n  // if we're missing the action ID header, we can't do any further processing\n  if (!actionId) {\n    throw new InvariantError(\"Missing 'next-action' header.\")\n  }\n\n  const actionModId = serverModuleMap[actionId]?.id\n\n  if (!actionModId) {\n    throw getActionNotFoundError(actionId)\n  }\n\n  return actionModId\n}\n\nfunction getActionNotFoundError(actionId: string | null): Error {\n  return new Error(\n    `Failed to find Server Action${actionId ? ` \"${actionId}\"` : ''}. This request might be from an older or newer deployment.\\nRead more: https://nextjs.org/docs/messages/failed-to-find-server-action`\n  )\n}\n\nconst $ACTION_ = '$ACTION_'\nconst $ACTION_REF_ = '$ACTION_REF_'\nconst $ACTION_ID_ = '$ACTION_ID_'\nconst ACTION_ID_EXPECTED_LENGTH = 42\n\n/**\n * This function mirrors logic inside React's decodeAction and should be kept in sync with that.\n * It pre-parses the FormData to ensure that any action IDs referred to are actual action IDs for\n * this Next.js application.\n */\nfunction areAllActionIdsValid(\n  mpaFormData: FormData,\n  serverModuleMap: ServerModuleMap\n): boolean {\n  let hasAtLeastOneAction = false\n  // Before we attempt to decode the payload for a possible MPA action, assert that all\n  // action IDs are valid IDs. If not we should disregard the payload\n  for (let key of mpaFormData.keys()) {\n    if (!key.startsWith($ACTION_)) {\n      // not a relevant field\n      continue\n    }\n\n    if (key.startsWith($ACTION_ID_)) {\n      // No Bound args case\n      if (isInvalidActionIdFieldName(key, serverModuleMap)) {\n        return false\n      }\n\n      hasAtLeastOneAction = true\n    } else if (key.startsWith($ACTION_REF_)) {\n      // Bound args case\n      const actionDescriptorField =\n        $ACTION_ + key.slice($ACTION_REF_.length) + ':0'\n      const actionFields = mpaFormData.getAll(actionDescriptorField)\n      if (actionFields.length !== 1) {\n        return false\n      }\n      const actionField = actionFields[0]\n      if (typeof actionField !== 'string') {\n        return false\n      }\n\n      if (isInvalidStringActionDescriptor(actionField, serverModuleMap)) {\n        return false\n      }\n      hasAtLeastOneAction = true\n    }\n  }\n  return hasAtLeastOneAction\n}\n\nconst ACTION_DESCRIPTOR_ID_PREFIX = '{\"id\":\"'\nfunction isInvalidStringActionDescriptor(\n  actionDescriptor: string,\n  serverModuleMap: ServerModuleMap\n): unknown {\n  if (actionDescriptor.startsWith(ACTION_DESCRIPTOR_ID_PREFIX) === false) {\n    return true\n  }\n\n  const from = ACTION_DESCRIPTOR_ID_PREFIX.length\n  const to = from + ACTION_ID_EXPECTED_LENGTH\n\n  // We expect actionDescriptor to be '{\"id\":\"<actionId>\",...}'\n  const actionId = actionDescriptor.slice(from, to)\n  if (\n    actionId.length !== ACTION_ID_EXPECTED_LENGTH ||\n    actionDescriptor[to] !== '\"'\n  ) {\n    return true\n  }\n\n  const entry = serverModuleMap[actionId]\n\n  if (entry == null) {\n    return true\n  }\n\n  return false\n}\n\nfunction isInvalidActionIdFieldName(\n  actionIdFieldName: string,\n  serverModuleMap: ServerModuleMap\n): boolean {\n  // The field name must always start with $ACTION_ID_ but since it is\n  // the id is extracted from the key of the field we have already validated\n  // this before entering this function\n  if (\n    actionIdFieldName.length !==\n    $ACTION_ID_.length + ACTION_ID_EXPECTED_LENGTH\n  ) {\n    // this field name has too few or too many characters\n    return true\n  }\n\n  const actionId = actionIdFieldName.slice($ACTION_ID_.length)\n  const entry = serverModuleMap[actionId]\n\n  if (entry == null) {\n    return true\n  }\n\n  return false\n}\n"],"names":["RSC_HEADER","RSC_CONTENT_TYPE_HEADER","NEXT_ROUTER_STATE_TREE_HEADER","ACTION_HEADER","NEXT_ACTION_NOT_FOUND_HEADER","NEXT_ROUTER_PREFETCH_HEADER","NEXT_ROUTER_SEGMENT_PREFETCH_HEADER","NEXT_URL","NEXT_ACTION_REVALIDATED_HEADER","getAccessFallbackHTTPStatus","isHTTPAccessFallbackError","getRedirectTypeFromError","getURLFromRedirectError","isRedirectError","RenderResult","FlightRenderResult","filterReqHeaders","actionsForbiddenHeaders","getModifiedCookieValues","JSON_CONTENT_TYPE_HEADER","NEXT_CACHE_REVALIDATED_TAGS_HEADER","NEXT_CACHE_REVALIDATE_TAG_TOKEN_HEADER","getServerActionRequestMetadata","isCsrfOriginAllowed","warn","RequestCookies","ResponseCookies","HeadersAdapter","fromNodeOutgoingHttpHeaders","selectWorkerForForwarding","getServerActionsManifest","getServerModuleMap","isNodeNextRequest","isWebNextRequest","RedirectStatusCode","synchronizeMutableCookies","workUnitAsyncStorage","InvariantError","executeRevalidates","getRequestMeta","setCacheBustingSearchParam","ActionDidNotRevalidate","ActionDidRevalidateStaticAndDynamic","hasServerActions","serverActionsManifest","Object","keys","node","length","edge","nodeHeadersToRecord","headers","record","key","value","entries","undefined","Array","isArray","join","getForwardedHeaders","req","res","requestHeaders","requestCookies","from","responseHeaders","getHeaders","responseCookies","mergedHeaders","getAll","forEach","cookie","delete","name","set","toString","Headers","addRevalidationHeader","workStore","requestStore","isTagRevalidated","pendingRevalidatedTags","isCookieRevalidated","mutableCookies","setHeader","JSON","stringify","pathWasRevalidated","createForwardedActionResponse","host","workerPathname","basePath","Error","forwardedHeaders","proto","replace","origin","process","env","__NEXT_PRIVATE_ORIGIN","fetchUrl","URL","response","body","NEXT_RUNTIME","stream","fetch","method","duplex","redirect","next","internal","get","startsWith","includes","cancel","err","console","error","fromStatic","getAppRelativeRedirectUrl","redirectUrl","currentPathname","base","endsWith","resolved","pathname","search","hash","parsedRedirectUrl","createRedirectRenderResult","originalHost","redirectType","appRelativeRedirectUrl","map","item","tag","incrementalCache","prerenderManifest","preview","previewModeId","EMPTY","limitUntrustedHeaderValueForLogs","slice","parseHostHeader","originDomain","forwardedHostHeader","forwardedHostHeaderValue","split","trim","hostHeader","type","handleAction","ComponentMod","generateFlight","serverActions","ctx","metadata","contentType","page","renderOpts","serverModuleMap","actionId","isMultipartAction","isFetchAction","isURLEncodedAction","isPossibleServerAction","handleUnrecognizedFetchAction","statusCode","result","getActionNotFoundError","isStaticGeneration","temporaryReferences","fetchCache","originHeader","warning","warnBadServerActionRequest","allowedOrigins","promise","Promise","reject","actionResult","skipPageRendering","actionAsyncStorage","actionWasForwarded","Boolean","forwardedWorker","run","isAction","actionModId","boundActionArguments","createTemporaryReferenceSet","decodeReply","decodeAction","decodeFormState","formData","request","getActionModIdOrError","areAllActionIdsValid","action","executeActionAndPrepareForRender","formState","chunks","reader","getReader","done","read","push","actionData","Buffer","concat","decodeReplyFromBusboy","require","PassThrough","Readable","Transform","pipeline","defaultBodySizeLimit","bodySizeLimit","bodySizeLimitBytes","parse","size","sizeLimitTransform","transform","chunk","encoding","callback","byteLength","ApiError","busboy","defParamCharset","limits","fieldSize","abortController","AbortController","all","signal","abort","sizeLimitedBody","fakeRequest","Request","toWeb","actionMod","__next_app__","actionHandler","finally","resolve","waitUntil","SeeOther","url","args","phase","apply","isDraftMode","draftMode","isEnabled","id","$ACTION_","$ACTION_REF_","$ACTION_ID_","ACTION_ID_EXPECTED_LENGTH","mpaFormData","hasAtLeastOneAction","isInvalidActionIdFieldName","actionDescriptorField","actionFields","actionField","isInvalidStringActionDescriptor","ACTION_DESCRIPTOR_ID_PREFIX","actionDescriptor","to","entry","actionIdFieldName"],"mappings":"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","ignoreList":[0]}