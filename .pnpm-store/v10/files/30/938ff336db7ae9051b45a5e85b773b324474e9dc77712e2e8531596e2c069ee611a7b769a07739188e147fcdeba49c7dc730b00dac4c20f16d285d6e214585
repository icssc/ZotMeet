{"version":3,"file":"column-builder.js","names":[],"sources":["../src/column-builder.ts"],"sourcesContent":["import { entityKind } from '~/entity.ts';\nimport type { CockroachColumn, ExtraConfigColumn as CockroachExtraConfigColumn } from './cockroach-core/index.ts';\nimport type { Column, ColumnBaseConfig } from './column.ts';\nimport type { GelColumn, GelExtraConfigColumn } from './gel-core/index.ts';\nimport type { MsSqlColumn } from './mssql-core/index.ts';\nimport type { MySqlColumn } from './mysql-core/index.ts';\nimport type { ExtraConfigColumn, PgColumn, PgSequenceOptions } from './pg-core/index.ts';\nimport type { SingleStoreColumn } from './singlestore-core/index.ts';\nimport type { SQL } from './sql/sql.ts';\nimport type { SQLiteColumn } from './sqlite-core/index.ts';\nimport type { Assume } from './utils.ts';\n\nexport type ColumnDataType =\n\t| 'array'\n\t| 'bigint'\n\t| 'boolean'\n\t| 'custom'\n\t| 'number'\n\t| 'object'\n\t| 'string';\n\nexport type ColumnDataArrayConstraint =\n\t| 'vector'\n\t| 'int64vector'\n\t| 'halfvector'\n\t| 'basecolumn'\n\t| 'point'\n\t| 'geometry'\n\t| 'line';\n\nexport type ColumnDataBigIntConstraint = 'int64' | 'uint64';\n\nexport type ColumnDataNumberConstraint =\n\t| 'double'\n\t| 'float'\n\t| 'int8'\n\t| 'int16'\n\t| 'int24'\n\t| 'int32'\n\t| 'int53'\n\t| 'udouble'\n\t| 'ufloat'\n\t| 'uint8'\n\t| 'uint16'\n\t| 'uint24'\n\t| 'uint32'\n\t| 'uint53'\n\t| 'unsigned'\n\t| 'year';\n\nexport type ColumnDataObjectConstraint =\n\t| 'buffer'\n\t| 'date'\n\t| 'geometry'\n\t| 'json'\n\t| 'line'\n\t| 'point'\n\t// Gel-specific\n\t| 'dateDuration'\n\t| 'duration'\n\t| 'localDate'\n\t| 'localDateTime'\n\t| 'localTime'\n\t| 'relDuration';\n\nexport type ColumnDataStringConstraint =\n\t| 'binary'\n\t| 'cidr'\n\t| 'date'\n\t| 'datetime'\n\t| 'enum'\n\t| 'inet'\n\t| 'int64'\n\t| 'interval'\n\t| 'macaddr'\n\t| 'macaddr8'\n\t| 'numeric'\n\t| 'sparsevec'\n\t| 'time'\n\t| 'timestamp'\n\t| 'uint64'\n\t| 'unumeric'\n\t| 'uuid';\n\nexport type ColumnDataConstraint =\n\t| ColumnDataArrayConstraint\n\t| ColumnDataBigIntConstraint\n\t| ColumnDataNumberConstraint\n\t| ColumnDataObjectConstraint\n\t| ColumnDataStringConstraint;\n\nexport type ColumnType =\n\t| ColumnDataType\n\t| `array ${ColumnDataArrayConstraint}`\n\t| `bigint ${ColumnDataBigIntConstraint}`\n\t| `number ${ColumnDataNumberConstraint}`\n\t| `object ${ColumnDataObjectConstraint}`\n\t| `string ${ColumnDataStringConstraint}`;\n\nexport interface ColumnTypeData<\n\tTType extends ColumnDataType = ColumnDataType,\n\tTConstraint extends ColumnDataConstraint | undefined = ColumnDataConstraint | undefined,\n> {\n\ttype: TType;\n\tconstraint: TConstraint;\n}\n\nexport type ExtractColumnTypeData<T extends ColumnType> = T extends\n\t`${infer Type extends ColumnDataType} ${infer Constraint extends ColumnDataConstraint}`\n\t? ColumnTypeData<Type, Constraint>\n\t: ColumnTypeData<Assume<T, ColumnDataType>, undefined>;\n\nexport function extractExtendedColumnType<TColumn extends Column>(\n\tcolumn: TColumn,\n): ExtractColumnTypeData<TColumn['_']['dataType']> {\n\tconst [type, constraint] = column.dataType.split(' ');\n\n\treturn { type, constraint } as any;\n}\n\nexport type Dialect = 'pg' | 'mysql' | 'sqlite' | 'singlestore' | 'mssql' | 'common' | 'gel' | 'cockroach';\n\n// TODO update description\n// 'virtual' | 'stored'  for postgres\n// 'stored' for mysql\n// 'virtual' | 'persisted' for mssql\n// We should remove this option from common Column and store it per dialect common\n// Was discussed with Andrew\nexport type GeneratedStorageMode = 'virtual' | 'stored' | 'persisted';\n\nexport type GeneratedType = 'always' | 'byDefault';\n\nexport interface GeneratedColumnConfig<TDataType> {\n\tas: TDataType | SQL | (() => SQL);\n\ttype?: GeneratedType;\n\tmode?: GeneratedStorageMode;\n}\n\nexport interface GeneratedIdentityConfig {\n\tsequenceName?: string;\n\tsequenceOptions?: PgSequenceOptions;\n\ttype: 'always' | 'byDefault';\n}\n\nexport interface ColumnBuilderBaseConfig<TDataType extends ColumnType> {\n\tdataType: TDataType;\n\tdata: unknown;\n\tdriverParam: unknown;\n\tnotNull?: boolean;\n\thasDefault?: boolean;\n}\n\nexport type MakeColumnConfig<\n\tT extends ColumnBuilderBaseConfig<ColumnType>,\n\tTTableName extends string,\n\tTDialect extends Dialect = 'common',\n\tTData = T extends { $type: infer U } ? U : T['data'],\n> = {\n\tname: string;\n\ttableName: TTableName;\n\tdataType: T['dataType'];\n\tdata: TData;\n\tdriverParam: T['driverParam'];\n\tnotNull: T['notNull'] extends true ? true : false;\n\thasDefault: T['hasDefault'] extends true ? true : false;\n\tisPrimaryKey: T extends { isPrimaryKey: true } ? true : false;\n\tisAutoincrement: T extends { isAutoincrement: true } ? true : false;\n\thasRuntimeDefault: T extends { hasRuntimeDefault: true } ? true : false;\n\tenumValues: T extends { enumValues: [string, ...string[]] } ? T['enumValues'] : undefined;\n\tbaseColumn: T extends { baseBuilder: infer U extends ColumnBuilderBase } ? BuildColumn<TTableName, U, TDialect>\n\t\t: never;\n\tidentity: T extends { identity: 'always' } ? 'always' : T extends { identity: 'byDefault' } ? 'byDefault' : undefined;\n\tgenerated: T extends { generated: infer G } ? unknown extends G ? undefined\n\t\t: G extends undefined ? undefined\n\t\t: G\n\t\t: undefined;\n} & {};\n\nexport interface ColumnBuilderRuntimeConfig<TData> {\n\tname: string;\n\tkeyAsName: boolean;\n\tnotNull: boolean;\n\tdefault: TData | SQL | undefined;\n\tdefaultFn: (() => TData | SQL) | undefined;\n\tonUpdateFn: (() => TData | SQL) | undefined;\n\thasDefault: boolean;\n\tprimaryKey: boolean;\n\tisUnique: boolean;\n\tuniqueName: string | undefined;\n\tuniqueType: string | undefined;\n\tdataType: string;\n\tcolumnType: string;\n\tgenerated: GeneratedColumnConfig<TData> | undefined;\n\tgeneratedIdentity: GeneratedIdentityConfig | undefined;\n}\n\nexport interface ColumnBuilderExtraConfig {\n\tprimaryKeyHasDefault?: boolean;\n}\n\nexport type NotNull<T> = T & {\n\t_: {\n\t\tnotNull: true;\n\t};\n};\n\nexport type HasDefault<T> = T & {\n\t_: {\n\t\thasDefault: true;\n\t};\n};\n\nexport type IsPrimaryKey<T> = T & {\n\t_: {\n\t\tisPrimaryKey: true;\n\t\tnotNull: true;\n\t};\n};\n\nexport type IsAutoincrement<T> = T & {\n\t_: {\n\t\tisAutoincrement: true;\n\t};\n};\n\nexport type HasRuntimeDefault<T> = T & {\n\t_: {\n\t\thasRuntimeDefault: true;\n\t};\n};\n\nexport type $Type<T, TType> = T & {\n\t_: {\n\t\t$type: TType;\n\t};\n};\n\nexport type HasGenerated<T, TGenerated = {}> = T & {\n\t_: {\n\t\thasDefault: true;\n\t\tgenerated: TGenerated;\n\t};\n};\n\nexport type IsIdentity<T, TType extends 'always' | 'byDefault'> = T & {\n\t_: {\n\t\tnotNull: true;\n\t\thasDefault: true;\n\t\tidentity: TType;\n\t};\n};\n\nexport interface ColumnBuilderBase<\n\tout T extends ColumnBuilderBaseConfig<ColumnType> = ColumnBuilderBaseConfig<ColumnType>,\n> {\n\t_: T;\n}\n\n// To understand how to use `ColumnBuilder` and `AnyColumnBuilder`, see `Column` and `AnyColumn` documentation.\nexport abstract class ColumnBuilder<\n\tout T extends ColumnBuilderBaseConfig<ColumnType>,\n\tTRuntimeConfig extends object = object,\n\tTExtraConfig extends ColumnBuilderExtraConfig = ColumnBuilderExtraConfig,\n> implements ColumnBuilderBase<T> {\n\tstatic readonly [entityKind]: string = 'ColumnBuilder';\n\n\tdeclare _: T;\n\n\t/** @internal */\n\tprotected config: ColumnBuilderRuntimeConfig<T['data']> & TRuntimeConfig;\n\n\tconstructor(name: string, dataType: ColumnType, columnType: string) {\n\t\tthis.config = {\n\t\t\tname,\n\t\t\tkeyAsName: name === '',\n\t\t\tnotNull: false,\n\t\t\tdefault: undefined,\n\t\t\thasDefault: false,\n\t\t\tprimaryKey: false,\n\t\t\tisUnique: false,\n\t\t\tuniqueName: undefined,\n\t\t\tuniqueType: undefined,\n\t\t\tdataType,\n\t\t\tcolumnType,\n\t\t\tgenerated: undefined,\n\t\t} as ColumnBuilderRuntimeConfig<T['data']> & TRuntimeConfig; // TODO: ??\n\t}\n\n\t/**\n\t * Changes the data type of the column. Commonly used with `json` columns. Also, useful for branded types.\n\t *\n\t * @example\n\t * ```ts\n\t * const users = pgTable('users', {\n\t * \tid: integer('id').$type<UserId>().primaryKey(),\n\t * \tdetails: json('details').$type<UserDetails>().notNull(),\n\t * });\n\t * ```\n\t */\n\t$type<TType>(): $Type<this, TType> {\n\t\treturn this as $Type<this, TType>;\n\t}\n\n\t/**\n\t * Adds a `not null` clause to the column definition.\n\t *\n\t * Affects the `select` model of the table - columns *without* `not null` will be nullable on select.\n\t */\n\tnotNull(): NotNull<this> {\n\t\tthis.config.notNull = true;\n\t\treturn this as NotNull<this>;\n\t}\n\n\t/**\n\t * Adds a `default <value>` clause to the column definition.\n\t *\n\t * Affects the `insert` model of the table - columns *with* `default` are optional on insert.\n\t *\n\t * If you need to set a dynamic default value, use {@link $defaultFn} instead.\n\t */\n\tdefault(value: (this['_'] extends { $type: infer U } ? U : this['_']['data']) | SQL): HasDefault<this> {\n\t\tthis.config.default = value;\n\t\tthis.config.hasDefault = true;\n\t\treturn this as HasDefault<this>;\n\t}\n\n\t/**\n\t * Adds a dynamic default value to the column.\n\t * The function will be called when the row is inserted, and the returned value will be used as the column value.\n\t *\n\t * **Note:** This value does not affect the `drizzle-kit` behavior, it is only used at runtime in `drizzle-orm`.\n\t */\n\t$defaultFn(\n\t\tfn: () => (this['_'] extends { $type: infer U } ? U : this['_']['data']) | SQL,\n\t): HasRuntimeDefault<HasDefault<this>> {\n\t\tthis.config.defaultFn = fn;\n\t\tthis.config.hasDefault = true;\n\t\treturn this as HasRuntimeDefault<HasDefault<this>>;\n\t}\n\n\t/**\n\t * Alias for {@link $defaultFn}.\n\t */\n\t$default = this.$defaultFn;\n\n\t/**\n\t * Adds a dynamic update value to the column.\n\t * The function will be called when the row is updated, and the returned value will be used as the column value if none is provided.\n\t * If no `default` (or `$defaultFn`) value is provided, the function will be called when the row is inserted as well, and the returned value will be used as the column value.\n\t *\n\t * **Note:** This value does not affect the `drizzle-kit` behavior, it is only used at runtime in `drizzle-orm`.\n\t */\n\t$onUpdateFn(\n\t\tfn: () => (this['_'] extends { $type: infer U } ? U : this['_']['data']) | SQL,\n\t): HasDefault<this> {\n\t\tthis.config.onUpdateFn = fn;\n\t\tthis.config.hasDefault = true;\n\t\treturn this as HasDefault<this>;\n\t}\n\n\t/**\n\t * Alias for {@link $onUpdateFn}.\n\t */\n\t$onUpdate = this.$onUpdateFn;\n\n\t/**\n\t * Adds a `primary key` clause to the column definition. This implicitly makes the column `not null`.\n\t *\n\t * In SQLite, `integer primary key` implicitly makes the column auto-incrementing.\n\t */\n\tprimaryKey(): TExtraConfig['primaryKeyHasDefault'] extends true ? IsPrimaryKey<HasDefault<this>>\n\t\t: IsPrimaryKey<this>\n\t{\n\t\tthis.config.primaryKey = true;\n\t\tthis.config.notNull = true;\n\t\treturn this as TExtraConfig['primaryKeyHasDefault'] extends true ? IsPrimaryKey<HasDefault<this>>\n\t\t\t: IsPrimaryKey<this>;\n\t}\n\n\tabstract generatedAlwaysAs(\n\t\tas: SQL | T['data'] | (() => SQL),\n\t\tconfig?: Partial<GeneratedColumnConfig<unknown>>,\n\t): HasGenerated<this, {\n\t\ttype: 'always';\n\t}>;\n\n\t/** @internal Sets the name of the column to the key within the table definition if a name was not given. */\n\tsetName(name: string) {\n\t\tif (this.config.name !== '') return;\n\t\tthis.config.name = name;\n\t}\n}\n\nexport type BuildColumn<\n\tTTableName extends string,\n\tTBuilder extends ColumnBuilderBase,\n\tTDialect extends Dialect,\n\tTBuiltConfig extends ColumnBaseConfig<ColumnType> = MakeColumnConfig<TBuilder['_'], TTableName, TDialect>,\n> =\n\t// TDialect extends 'pg' ? PgColumn<TBuiltConfig, {}>\n\tTDialect extends 'mysql' ? MySqlColumn<TBuiltConfig, {}>\n\t\t: TDialect extends 'mssql' ? MsSqlColumn<TBuiltConfig, {}>\n\t\t: TDialect extends 'sqlite' ? SQLiteColumn<TBuiltConfig, {}>\n\t\t: TDialect extends 'singlestore' ? SingleStoreColumn<TBuiltConfig, {}>\n\t\t: TDialect extends 'gel' ? GelColumn<TBuiltConfig, {}>\n\t\t: TDialect extends 'cockroach' ? CockroachColumn<TBuiltConfig, {}>\n\t\t: TDialect extends 'common' ? Column<TBuiltConfig, {}>\n\t\t: never;\n\nexport type BuildIndexColumn<\n\tTDialect extends Dialect,\n> = TDialect extends 'pg' ? ExtraConfigColumn\n\t: TDialect extends 'cockroach' ? CockroachExtraConfigColumn\n\t: TDialect extends 'gel' ? GelExtraConfigColumn\n\t: never;\n\n// TODO\n// try to make sql as well + indexRaw\n\n// optional after everything will be working as expected\n// also try to leave only needed methods for extraConfig\n// make an error if I pass .asc() to fk and so on\n\nexport type BuildColumns<\n\tTTableName extends string,\n\tTConfigMap extends Record<string, ColumnBuilderBase>,\n\tTDialect extends Dialect,\n> =\n\t& {\n\t\t[Key in keyof TConfigMap]: BuildColumn<\n\t\t\tTTableName,\n\t\t\tTConfigMap[Key],\n\t\t\tTDialect\n\t\t>;\n\t}\n\t& {};\n\nexport type BuildExtraConfigColumns<\n\t_TTableName extends string,\n\tTConfigMap extends Record<string, ColumnBuilderBase>,\n\tTDialect extends Dialect,\n> =\n\t& {\n\t\t[Key in keyof TConfigMap]: BuildIndexColumn<TDialect>;\n\t}\n\t& {};\n\nexport type ChangeColumnTableName<\n\tTColumn extends Column,\n\tTAlias extends string,\n\tTDialect extends Dialect,\n> =\n\t// TODO: optimise\n\tTDialect extends 'pg' ? PgColumn<\n\t\t\tTColumn['_']['dataType'],\n\t\t\tOmit<TColumn['_'], 'tableName'> & { tableName: TAlias; insertType: unknown }\n\t\t>\n\t\t: TDialect extends 'mysql' ? MySqlColumn<MakeColumnConfig<TColumn['_'], TAlias>>\n\t\t: TDialect extends 'singlestore' ? SingleStoreColumn<MakeColumnConfig<TColumn['_'], TAlias>>\n\t\t: TDialect extends 'sqlite' ? SQLiteColumn<MakeColumnConfig<TColumn['_'], TAlias>>\n\t\t: TDialect extends 'gel' ? GelColumn<MakeColumnConfig<TColumn['_'], TAlias>>\n\t\t: TDialect extends 'mssql' ? MsSqlColumn<MakeColumnConfig<TColumn['_'], TAlias>>\n\t\t: TDialect extends 'cockroach' ? CockroachColumn<MakeColumnConfig<TColumn['_'], TAlias>>\n\t\t: never;\n"],"mappings":";;;AAgHA,SAAgB,0BACf,QACkD;CAClD,MAAM,CAAC,MAAM,cAAc,OAAO,SAAS,MAAM,IAAI;AAErD,QAAO;EAAE;EAAM;EAAY;;AA8I5B,IAAsB,gBAAtB,MAIkC;CACjC,QAAiB,cAAsB;;CAKvC,AAAU;CAEV,YAAY,MAAc,UAAsB,YAAoB;AACnE,OAAK,SAAS;GACb;GACA,WAAW,SAAS;GACpB,SAAS;GACT,SAAS;GACT,YAAY;GACZ,YAAY;GACZ,UAAU;GACV,YAAY;GACZ,YAAY;GACZ;GACA;GACA,WAAW;GACX;;;;;;;;;;;;;CAcF,QAAmC;AAClC,SAAO;;;;;;;CAQR,UAAyB;AACxB,OAAK,OAAO,UAAU;AACtB,SAAO;;;;;;;;;CAUR,QAAQ,OAA+F;AACtG,OAAK,OAAO,UAAU;AACtB,OAAK,OAAO,aAAa;AACzB,SAAO;;;;;;;;CASR,WACC,IACsC;AACtC,OAAK,OAAO,YAAY;AACxB,OAAK,OAAO,aAAa;AACzB,SAAO;;;;;CAMR,WAAW,KAAK;;;;;;;;CAShB,YACC,IACmB;AACnB,OAAK,OAAO,aAAa;AACzB,OAAK,OAAO,aAAa;AACzB,SAAO;;;;;CAMR,YAAY,KAAK;;;;;;CAOjB,aAEA;AACC,OAAK,OAAO,aAAa;AACzB,OAAK,OAAO,UAAU;AACtB,SAAO;;;CAYR,QAAQ,MAAc;AACrB,MAAI,KAAK,OAAO,SAAS,GAAI;AAC7B,OAAK,OAAO,OAAO"}