{"version":3,"sources":["../../../../../src/server/route-modules/app-page/module.ts"],"sourcesContent":["import type { AppPageRouteDefinition } from '../../route-definitions/app-page-route-definition'\nimport type RenderResult from '../../render-result'\nimport type { RenderOpts } from '../../app-render/types'\nimport type { NextParsedUrlQuery } from '../../request-meta'\nimport type { LoaderTree } from '../../lib/app-dir-module'\nimport type { PrerenderManifest } from '../../../build'\n\nimport {\n  renderToHTMLOrFlight,\n  type AppSharedContext,\n} from '../../app-render/app-render'\nimport {\n  RouteModule,\n  type RouteModuleOptions,\n  type RouteModuleHandleContext,\n} from '../route-module'\nimport * as vendoredContexts from './vendored/contexts/entrypoints'\nimport type { BaseNextRequest, BaseNextResponse } from '../../base-http'\nimport type { ServerComponentsHmrCache } from '../../response-cache'\nimport type { OpaqueFallbackRouteParams } from '../../request/fallback-params'\nimport { PrerenderManifestMatcher } from './helpers/prerender-manifest-matcher'\nimport type { DeepReadonly } from '../../../shared/lib/deep-readonly'\nimport {\n  NEXT_ROUTER_PREFETCH_HEADER,\n  NEXT_ROUTER_SEGMENT_PREFETCH_HEADER,\n  NEXT_ROUTER_STATE_TREE_HEADER,\n  NEXT_URL,\n  RSC_HEADER,\n} from '../../../client/components/app-router-headers'\nimport { isInterceptionRouteAppPath } from '../../../shared/lib/router/utils/interception-routes'\n\nlet vendoredReactRSC\nlet vendoredReactSSR\n\n// the vendored Reacts are loaded from their original source in the edge runtime\nif (process.env.NEXT_RUNTIME !== 'edge') {\n  vendoredReactRSC =\n    require('./vendored/rsc/entrypoints') as typeof import('./vendored/rsc/entrypoints')\n  vendoredReactSSR =\n    require('./vendored/ssr/entrypoints') as typeof import('./vendored/ssr/entrypoints')\n\n  // In Node environments we need to access the correct React instance from external modules such\n  // as global patches. We register the loaded React instances here.\n  const { registerServerReact, registerClientReact } =\n    require('../../runtime-reacts.external') as typeof import('../../runtime-reacts.external')\n  registerServerReact(vendoredReactRSC.React)\n  registerClientReact(vendoredReactSSR.React)\n}\n\n/**\n * The AppPageModule is the type of the module exported by the bundled app page\n * module.\n */\nexport type AppPageModule = typeof import('../../../build/templates/app-page')\n\ntype AppPageUserlandModule = {\n  /**\n   * The tree created in next-app-loader that holds component segments and modules\n   */\n  loaderTree: LoaderTree\n}\n\nexport interface AppPageRouteHandlerContext extends RouteModuleHandleContext {\n  page: string\n  query: NextParsedUrlQuery\n  fallbackRouteParams: OpaqueFallbackRouteParams | null\n  renderOpts: RenderOpts\n  serverComponentsHmrCache?: ServerComponentsHmrCache\n  sharedContext: AppSharedContext\n}\n\nexport type AppPageRouteModuleOptions = RouteModuleOptions<\n  AppPageRouteDefinition,\n  AppPageUserlandModule\n>\n\nexport class AppPageRouteModule extends RouteModule<\n  AppPageRouteDefinition,\n  AppPageUserlandModule\n> {\n  private matchers = new WeakMap<\n    DeepReadonly<PrerenderManifest>,\n    PrerenderManifestMatcher\n  >()\n  public match(\n    pathname: string,\n    prerenderManifest: DeepReadonly<PrerenderManifest>\n  ) {\n    // Lazily create the matcher based on the provided prerender manifest.\n    let matcher = this.matchers.get(prerenderManifest)\n    if (!matcher) {\n      matcher = new PrerenderManifestMatcher(\n        this.definition.pathname,\n        prerenderManifest\n      )\n      this.matchers.set(prerenderManifest, matcher)\n    }\n\n    // Match the pathname to the dynamic route.\n    return matcher.match(pathname)\n  }\n\n  public render(\n    req: BaseNextRequest,\n    res: BaseNextResponse,\n    context: AppPageRouteHandlerContext\n  ): Promise<RenderResult> {\n    return renderToHTMLOrFlight(\n      req,\n      res,\n      context.page,\n      context.query,\n      context.fallbackRouteParams,\n      context.renderOpts,\n      context.serverComponentsHmrCache,\n      context.sharedContext\n    )\n  }\n\n  private pathCouldBeIntercepted(\n    resolvedPathname: string,\n    interceptionRoutePatterns: RegExp[]\n  ): boolean {\n    return (\n      isInterceptionRouteAppPath(resolvedPathname) ||\n      interceptionRoutePatterns.some((regexp) => {\n        return regexp.test(resolvedPathname)\n      })\n    )\n  }\n\n  public getVaryHeader(\n    resolvedPathname: string,\n    interceptionRoutePatterns: RegExp[]\n  ): string {\n    const baseVaryHeader = `${RSC_HEADER}, ${NEXT_ROUTER_STATE_TREE_HEADER}, ${NEXT_ROUTER_PREFETCH_HEADER}, ${NEXT_ROUTER_SEGMENT_PREFETCH_HEADER}`\n\n    if (\n      this.pathCouldBeIntercepted(resolvedPathname, interceptionRoutePatterns)\n    ) {\n      // Interception route responses can vary based on the `Next-URL` header.\n      // We use the Vary header to signal this behavior to the client to properly cache the response.\n      return `${baseVaryHeader}, ${NEXT_URL}`\n    } else {\n      // We don't need to include `Next-URL` in the Vary header for non-interception routes since it won't affect the response.\n      // We also set this header for pages to avoid caching issues when navigating between pages and app.\n      return baseVaryHeader\n    }\n  }\n}\n\nconst vendored = {\n  'react-rsc': vendoredReactRSC,\n  'react-ssr': vendoredReactSSR,\n  contexts: vendoredContexts,\n}\n\nexport { renderToHTMLOrFlight, vendored }\n\nexport default AppPageRouteModule\n"],"names":["renderToHTMLOrFlight","RouteModule","vendoredContexts","PrerenderManifestMatcher","NEXT_ROUTER_PREFETCH_HEADER","NEXT_ROUTER_SEGMENT_PREFETCH_HEADER","NEXT_ROUTER_STATE_TREE_HEADER","NEXT_URL","RSC_HEADER","isInterceptionRouteAppPath","vendoredReactRSC","vendoredReactSSR","process","env","NEXT_RUNTIME","require","registerServerReact","registerClientReact","React","AppPageRouteModule","match","pathname","prerenderManifest","matcher","matchers","get","definition","set","render","req","res","context","page","query","fallbackRouteParams","renderOpts","serverComponentsHmrCache","sharedContext","pathCouldBeIntercepted","resolvedPathname","interceptionRoutePatterns","some","regexp","test","getVaryHeader","baseVaryHeader","WeakMap","vendored","contexts"],"mappings":"AAOA,SACEA,oBAAoB,QAEf,8BAA6B;AACpC,SACEC,WAAW,QAGN,kBAAiB;AACxB,YAAYC,sBAAsB,kCAAiC;AAInE,SAASC,wBAAwB,QAAQ,uCAAsC;AAE/E,SACEC,2BAA2B,EAC3BC,mCAAmC,EACnCC,6BAA6B,EAC7BC,QAAQ,EACRC,UAAU,QACL,gDAA+C;AACtD,SAASC,0BAA0B,QAAQ,uDAAsD;AAEjG,IAAIC;AACJ,IAAIC;AAEJ,gFAAgF;AAChF,IAAIC,QAAQC,GAAG,CAACC,YAAY,KAAK,QAAQ;IACvCJ,mBACEK,QAAQ;IACVJ,mBACEI,QAAQ;IAEV,+FAA+F;IAC/F,kEAAkE;IAClE,MAAM,EAAEC,mBAAmB,EAAEC,mBAAmB,EAAE,GAChDF,QAAQ;IACVC,oBAAoBN,iBAAiBQ,KAAK;IAC1CD,oBAAoBN,iBAAiBO,KAAK;AAC5C;AA6BA,OAAO,MAAMC,2BAA2BlB;IAQ/BmB,MACLC,QAAgB,EAChBC,iBAAkD,EAClD;QACA,sEAAsE;QACtE,IAAIC,UAAU,IAAI,CAACC,QAAQ,CAACC,GAAG,CAACH;QAChC,IAAI,CAACC,SAAS;YACZA,UAAU,IAAIpB,yBACZ,IAAI,CAACuB,UAAU,CAACL,QAAQ,EACxBC;YAEF,IAAI,CAACE,QAAQ,CAACG,GAAG,CAACL,mBAAmBC;QACvC;QAEA,2CAA2C;QAC3C,OAAOA,QAAQH,KAAK,CAACC;IACvB;IAEOO,OACLC,GAAoB,EACpBC,GAAqB,EACrBC,OAAmC,EACZ;QACvB,OAAO/B,qBACL6B,KACAC,KACAC,QAAQC,IAAI,EACZD,QAAQE,KAAK,EACbF,QAAQG,mBAAmB,EAC3BH,QAAQI,UAAU,EAClBJ,QAAQK,wBAAwB,EAChCL,QAAQM,aAAa;IAEzB;IAEQC,uBACNC,gBAAwB,EACxBC,yBAAmC,EAC1B;QACT,OACE/B,2BAA2B8B,qBAC3BC,0BAA0BC,IAAI,CAAC,CAACC;YAC9B,OAAOA,OAAOC,IAAI,CAACJ;QACrB;IAEJ;IAEOK,cACLL,gBAAwB,EACxBC,yBAAmC,EAC3B;QACR,MAAMK,iBAAiB,GAAGrC,WAAW,EAAE,EAAEF,8BAA8B,EAAE,EAAEF,4BAA4B,EAAE,EAAEC,qCAAqC;QAEhJ,IACE,IAAI,CAACiC,sBAAsB,CAACC,kBAAkBC,4BAC9C;YACA,wEAAwE;YACxE,+FAA+F;YAC/F,OAAO,GAAGK,eAAe,EAAE,EAAEtC,UAAU;QACzC,OAAO;YACL,yHAAyH;YACzH,mGAAmG;YACnG,OAAOsC;QACT;IACF;;QAxEK,qBAIGrB,WAAW,IAAIsB;;AAqEzB;AAEA,MAAMC,WAAW;IACf,aAAarC;IACb,aAAaC;IACbqC,UAAU9C;AACZ;AAEA,SAASF,oBAAoB,EAAE+C,QAAQ,GAAE;AAEzC,eAAe5B,mBAAkB","ignoreList":[0]}