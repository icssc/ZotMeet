{"version":3,"sources":["../../../../src/server/node-environment-extensions/unhandled-rejection.tsx"],"sourcesContent":["/**\n * Manages unhandled rejection listeners to intelligently filter rejections\n * from aborted prerenders when cache components are enabled.\n *\n * THE PROBLEM:\n * When we abort prerenders we expect to find numerous unhandled promise rejections due to\n * things like awaiting Request data like `headers()`. The rejections are fine and should\n * not be construed as problematic so we need to avoid the appearance of a problem by\n * omitting them from the logged output.\n *\n * THE STRATEGY:\n * 1. Install a filtering unhandled rejection handler\n * 2. Intercept process event methods to capture new handlers in our internal queue\n * 3. For each rejection, check if it comes from an aborted prerender context\n * 4. If yes, suppress it. If no, delegate to all handlers in our queue\n * 5. This provides precise filtering without time-based windows\n *\n * This ensures we suppress noisy prerender-related rejections while preserving\n * normal error logging for genuine unhandled rejections.\n */\n\nimport { workUnitAsyncStorage } from '../app-render/work-unit-async-storage.external'\n\nconst MODE:\n  | 'enabled'\n  | 'debug'\n  | 'silent'\n  | 'true'\n  | 'false'\n  | '1'\n  | '0'\n  | ''\n  | string\n  | undefined = process.env.NEXT_UNHANDLED_REJECTION_FILTER\n\nlet ENABLE_UHR_FILTER = true\nlet UHR_FILTER_LOG_LEVEL: 'debug' | 'warn' | 'silent' = 'warn'\n\nswitch (MODE) {\n  case 'silent':\n    UHR_FILTER_LOG_LEVEL = 'silent'\n    break\n  case 'debug':\n    UHR_FILTER_LOG_LEVEL = 'debug'\n    break\n  case 'false':\n  case 'disabled':\n  case '0':\n    ENABLE_UHR_FILTER = false\n    break\n  case '':\n  case undefined:\n  case 'enabled':\n  case 'true':\n  case '1':\n    break\n  default:\n    if (typeof MODE === 'string') {\n      console.error(\n        `NEXT_UNHANDLED_REJECTION_FILTER has an unrecognized value: ${JSON.stringify(MODE)}. Use \"enabled\", \"disabled\", \"silent\", or \"debug\", or omit the environment variable altogether`\n      )\n    }\n}\n\nlet debug: typeof console.debug | undefined\nlet debugWithTrace: typeof console.debug | undefined\nlet warn: typeof console.warn | undefined\nlet warnWithTrace: typeof console.warn | undefined\n\nswitch (UHR_FILTER_LOG_LEVEL) {\n  case 'debug':\n    debug = (message: string) =>\n      console.log('[Next.js Unhandled Rejection Filter]: ' + message)\n    debugWithTrace = (message: string) => {\n      console.log(new DebugWithStack(message))\n    }\n  // Intentional fallthrough\n  case 'warn':\n    warn = (message: string) => {\n      console.warn('[Next.js Unhandled Rejection Filter]: ' + message)\n    }\n    warnWithTrace = (message: string) => {\n      console.warn(new WarnWithStack(message))\n    }\n    break\n  case 'silent':\n  default:\n}\n\nclass DebugWithStack extends Error {\n  constructor(message: string) {\n    super(message)\n    this.name = '[Next.js Unhandled Rejection Filter]'\n  }\n}\n\nclass WarnWithStack extends Error {\n  constructor(message: string) {\n    super(message)\n    this.name = '[Next.js Unhandled Rejection Filter]'\n  }\n}\n\nlet didWarnUninstalled = false\nconst warnUninstalledOnce = warn\n  ? function warnUninstalledOnce(...args: any[]) {\n      if (!didWarnUninstalled) {\n        didWarnUninstalled = true\n        warn(...args)\n      }\n    }\n  : undefined\n\ntype ListenerMetadata = {\n  listener: NodeJS.UnhandledRejectionListener\n  once: boolean\n}\n\nlet filterInstalled = false\n\n// We store the proxied listeners for unhandled rejections here.\nlet underlyingListeners: Array<NodeJS.UnhandledRejectionListener> = []\n// We store a unique pointer to each event listener registration to track\n// details like whether the listener is a once listener.\nlet listenerMetadata: Array<ListenerMetadata> = []\n\n// These methods are used to restore the original implementations when uninstalling the patch\nlet originalProcessAddListener: typeof process.addListener\nlet originalProcessRemoveListener: typeof process.removeListener\nlet originalProcessOn: typeof process.on\nlet originalProcessOff: typeof process.off\nlet originalProcessPrependListener: typeof process.prependListener\nlet originalProcessOnce: typeof process.once\nlet originalProcessPrependOnceListener: typeof process.prependOnceListener\nlet originalProcessRemoveAllListeners: typeof process.removeAllListeners\nlet originalProcessListeners: typeof process.listeners\n\ntype UnderlyingMethod =\n  | typeof originalProcessAddListener\n  | typeof originalProcessRemoveListener\n  | typeof originalProcessOn\n  | typeof originalProcessOff\n  | typeof originalProcessPrependListener\n  | typeof originalProcessOnce\n  | typeof originalProcessPrependOnceListener\n  | typeof originalProcessRemoveAllListeners\n  | typeof originalProcessListeners\n\n// Some of these base methods call others and we don't want them to call the patched version so we\n// need a way to synchronously disable the patch temporarily.\nlet bypassPatch = false\n\n// This patch ensures that if any patched methods end up calling other methods internally they will\n// bypass the patch during their execution. This is important for removeAllListeners in particular\n// because it calls removeListener internally and we want to ensure it actually clears the listeners\n// from the process queue and not our private queue.\nfunction patchWithoutReentrancy<T extends UnderlyingMethod>(\n  original: T,\n  patchedImpl: T\n): T {\n  // Produce a function which has the correct name\n  const patched = {\n    [original.name]: function (...args: Parameters<T>) {\n      if (bypassPatch) {\n        return Reflect.apply(original, process, args)\n      }\n\n      const previousBypassPatch = bypassPatch\n      bypassPatch = true\n      try {\n        return Reflect.apply(patchedImpl, process, args)\n      } finally {\n        bypassPatch = previousBypassPatch\n      }\n    } as any,\n  }[original.name]\n\n  // Preserve the original toString behavior\n  Object.defineProperty(patched, 'toString', {\n    value: original.toString.bind(original),\n    writable: true,\n    configurable: true,\n  })\n\n  return patched\n}\n\nconst MACGUFFIN_EVENT = 'Next.UnhandledRejectionFilter.MacguffinEvent'\n\n/**\n * Installs a filtering unhandled rejection handler that intelligently suppresses\n * rejections from aborted prerender contexts.\n *\n * This should be called once during server startup to install the global filter.\n */\nfunction installUnhandledRejectionFilter(): void {\n  if (filterInstalled) {\n    warnWithTrace?.(\n      'Unexpected subsequent filter installation. This is a bug in Next.js'\n    )\n    return\n  }\n\n  debug?.('Installing Filter')\n\n  // Capture existing handlers\n  underlyingListeners = Array.from(process.listeners('unhandledRejection'))\n  // We assume all existing handlers are not \"once\"\n  listenerMetadata = underlyingListeners.map((l) => ({\n    listener: l,\n    once: false,\n  }))\n\n  // Remove all existing handlers\n  process.removeAllListeners('unhandledRejection')\n\n  // Install our filtering handler\n  process.addListener('unhandledRejection', filteringUnhandledRejectionHandler)\n\n  // Store the original process methods\n  originalProcessAddListener = process.addListener\n  originalProcessRemoveListener = process.removeListener\n  originalProcessOn = process.on\n  originalProcessOff = process.off\n  originalProcessPrependListener = process.prependListener\n  originalProcessOnce = process.once\n  originalProcessPrependOnceListener = process.prependOnceListener\n  originalProcessRemoveAllListeners = process.removeAllListeners\n  originalProcessListeners = process.listeners\n\n  process.addListener = patchWithoutReentrancy(\n    originalProcessAddListener,\n    function (event: string | symbol, listener: (...args: any[]) => void) {\n      if (event === 'unhandledRejection') {\n        debugWithTrace?.(\n          `Appending 'unhandledRejection' listener with name \\`${listener.name}\\`.`\n        )\n        // We add the listener to a dummy event in case it throws. We don't catch it intentionally\n        try {\n          originalProcessAddListener.call(\n            process,\n            MACGUFFIN_EVENT as any,\n            listener\n          )\n        } finally {\n          // We clean up the added event\n          originalProcessRemoveAllListeners.call(process, MACGUFFIN_EVENT)\n        }\n        // Add new handlers to our internal queue instead of the process\n        underlyingListeners.push(listener as NodeJS.UnhandledRejectionListener)\n        listenerMetadata.push({ listener, once: false })\n        return process\n      }\n      // For other events, use the original method\n      return originalProcessAddListener.call(process, event as any, listener)\n    } as typeof process.addListener\n  )\n\n  // Intercept process.removeListener (alias for process.off)\n  process.removeListener = patchWithoutReentrancy(\n    originalProcessRemoveListener,\n    function (event: string | symbol, listener: (...args: any[]) => void) {\n      if (event === 'unhandledRejection') {\n        // Check if they're trying to remove our filtering handler\n        if (listener === filteringUnhandledRejectionHandler) {\n          warnUninstalledOnce?.(\n            `Uninstalling filter because \\`process.removeListener('unhandledRejection', listener)\\` was called with the filter listener. Uninstalling this filter is not recommended and will cause you to observe 'unhandledRejection' events related to intentionally aborted prerenders.\n\nYou can silence warnings related to this behavior by running Next.js with \\`NEXT_UNHANDLED_REJECTION_FILTER=silent\\` environment variable.\n\nYou can debug event listener operations by running Next.js with \\`NEXT_UNHANDLED_REJECTION_FILTER=debug\\` environment variable.`\n          )\n          uninstallUnhandledRejectionFilter()\n          return process\n        }\n\n        debugWithTrace?.(\n          `Removing 'unhandledRejection' listener with name \\`${listener.name}\\`.`\n        )\n        // We remove the listener on a dummy event in case it throws. We don't catch it intentionally\n        originalProcessRemoveListener.call(\n          process,\n          MACGUFFIN_EVENT as any,\n          listener\n        )\n        const index = underlyingListeners.lastIndexOf(listener)\n        if (index > -1) {\n          debug?.(`listener found index ${index} and removed.`)\n          underlyingListeners.splice(index, 1)\n          listenerMetadata.splice(index, 1)\n        } else {\n          debug?.(`listener not found.`)\n        }\n        return process\n      }\n      // For other events, use the original method\n      return originalProcessRemoveListener.call(process, event, listener)\n    } as typeof process.removeListener\n  )\n\n  // If the process.on is referentially process.addListener then share the patched version as well\n  if (originalProcessOn === originalProcessAddListener) {\n    process.on = process.addListener\n  } else {\n    process.on = patchWithoutReentrancy(originalProcessOn, function (\n      event: string | symbol,\n      listener: (...args: any[]) => void\n    ) {\n      if (event === 'unhandledRejection') {\n        debugWithTrace?.(\n          `Appending 'unhandledRejection' listener with name \\`${listener.name}\\`.`\n        )\n        // We add the listener to a dummy event in case it throws. We don't catch it intentionally\n        try {\n          originalProcessOn.call(process, MACGUFFIN_EVENT as any, listener)\n        } finally {\n          // We clean up the added event\n          originalProcessRemoveAllListeners.call(process, MACGUFFIN_EVENT)\n        }\n        // Add new handlers to our internal queue instead of the process\n        underlyingListeners.push(listener as NodeJS.UnhandledRejectionListener)\n        listenerMetadata.push({ listener, once: false })\n        return process\n      }\n      // For other events, use the original method\n      return originalProcessOn.call(process, event, listener)\n    } as typeof process.on)\n  }\n\n  // If the process.off is referentially process.addListener then share the patched version as well\n  if (originalProcessOff === originalProcessRemoveListener) {\n    process.off = process.removeListener\n  } else {\n    process.off = patchWithoutReentrancy(originalProcessOff, function (\n      event: string | symbol,\n      listener: (...args: any[]) => void\n    ) {\n      if (event === 'unhandledRejection') {\n        // Check if they're trying to remove our filtering handler\n        if (listener === filteringUnhandledRejectionHandler) {\n          warnUninstalledOnce?.(\n            `Uninstalling filter because \\`process.off('unhandledRejection', listener)\\` was called with the filter listener. Uninstalling this filter is not recommended and will cause you to observe 'unhandledRejection' events related to intentionally aborted prerenders.\n\nYou can silence warnings related to this behavior by running Next.js with \\`NEXT_UNHANDLED_REJECTION_FILTER=silent\\` environment variable.\n\nYou can debug event listener operations by running Next.js with \\`NEXT_UNHANDLED_REJECTION_FILTER=debug\\` environment variable.`\n          )\n          uninstallUnhandledRejectionFilter()\n          return process\n        }\n\n        debugWithTrace?.(\n          `Removing 'unhandledRejection' listener with name \\`${listener.name}\\`.`\n        )\n        // We remove the listener on a dummy event in case it throws. We don't catch it intentionally\n        originalProcessOff.call(process, MACGUFFIN_EVENT as any, listener)\n        const index = underlyingListeners.lastIndexOf(listener)\n        if (index > -1) {\n          debug?.(`listener found index ${index} and removed.`)\n          underlyingListeners.splice(index, 1)\n          listenerMetadata.splice(index, 1)\n        } else {\n          debug?.(`listener not found.`)\n        }\n        return process\n      }\n      // For other events, use the original method\n      return originalProcessOff.call(process, event, listener)\n    } as typeof process.off)\n  }\n\n  // Intercept process.prependListener for handlers that should go first\n  process.prependListener = patchWithoutReentrancy(\n    originalProcessPrependListener,\n    function (event: string | symbol, listener: (...args: any[]) => void) {\n      if (event === 'unhandledRejection') {\n        debugWithTrace?.(\n          `(Prepending) Inserting 'unhandledRejection' listener with name \\`${listener.name}\\` immediately following the Next.js 'unhandledRejection' filter listener.`\n        )\n        // We add the listener to a dummy event in case it throws. We don't catch it intentionally\n        try {\n          originalProcessPrependListener.call(\n            process,\n            MACGUFFIN_EVENT as any,\n            listener\n          )\n        } finally {\n          // We clean up the added event\n          originalProcessRemoveAllListeners.call(process, MACGUFFIN_EVENT)\n        }\n\n        // Add new handlers to the beginning of our internal queue\n        underlyingListeners.unshift(\n          listener as NodeJS.UnhandledRejectionListener\n        )\n        listenerMetadata.unshift({ listener, once: false })\n        return process\n      }\n      // For other events, use the original method\n      return originalProcessPrependListener.call(\n        process,\n        event as any,\n        listener\n      )\n    } as typeof process.prependListener\n  )\n\n  // Intercept process.once for one-time handlers\n  process.once = patchWithoutReentrancy(originalProcessOnce, function (\n    event: string | symbol,\n    listener: (...args: any[]) => void\n  ) {\n    if (event === 'unhandledRejection') {\n      debugWithTrace?.(\n        `Appending 'unhandledRejection' once-listener with name \\`${listener.name}\\`.`\n      )\n      // We add the listener to a dummy event in case it throws. We don't catch it intentionally\n      try {\n        originalProcessOnce.call(process, MACGUFFIN_EVENT as any, listener)\n      } finally {\n        // We clean up the added event\n        originalProcessRemoveAllListeners.call(process, MACGUFFIN_EVENT)\n      }\n      underlyingListeners.push(listener as NodeJS.UnhandledRejectionListener)\n      listenerMetadata.push({\n        listener: listener as NodeJS.UnhandledRejectionListener,\n        once: true,\n      })\n      return process\n    }\n    // For other events, use the original method\n    return originalProcessOnce.call(process, event, listener)\n  } as typeof process.once)\n\n  // Intercept process.prependOnceListener for one-time handlers that should go first\n  process.prependOnceListener = patchWithoutReentrancy(\n    originalProcessPrependOnceListener,\n    function (event: string | symbol, listener: (...args: any[]) => void) {\n      if (event === 'unhandledRejection') {\n        debugWithTrace?.(\n          `(Prepending) Inserting 'unhandledRejection' once-listener with name \\`${listener.name}\\` immediately following the Next.js 'unhandledRejection' filter listener.`\n        )\n        // We add the listener to a dummy event in case it throws. We don't catch it intentionally\n        try {\n          originalProcessPrependOnceListener.call(\n            process,\n            MACGUFFIN_EVENT as any,\n            listener\n          )\n        } finally {\n          // We clean up the added event\n          originalProcessRemoveAllListeners.call(process, MACGUFFIN_EVENT)\n        }\n\n        // Add to the beginning of our internal queue\n        underlyingListeners.unshift(\n          listener as NodeJS.UnhandledRejectionListener\n        )\n        listenerMetadata.unshift({\n          listener: listener as NodeJS.UnhandledRejectionListener,\n          once: true,\n        })\n        return process\n      }\n      // For other events, use the original method\n      return originalProcessPrependOnceListener.call(\n        process,\n        event as any,\n        listener\n      )\n    } as typeof process.prependOnceListener\n  )\n\n  // Intercept process.removeAllListeners\n  process.removeAllListeners = patchWithoutReentrancy(\n    originalProcessRemoveAllListeners,\n    function (event?: string | symbol) {\n      if (event === 'unhandledRejection') {\n        // TODO add warning for this case once we stop importing this in test scopes automatically. Currently\n        // we pull this file in whenever build/utils.tsx is imported which is not the right layering.\n        // The extensions should be loaded from entrypoints like build/index or next-server\n        //         warnRemoveAllOnce?.(\n        //           `\\`process.removeAllListeners('unhandledRejection')\\` was called. Next.js maintains the first 'unhandledRejection' listener to filter out unnecessary rejection warnings caused by aborting prerenders early. It is not recommended that you uninstall this behavior, but if you want to you must you can acquire the listener with \\`process.listeners('unhandledRejection')[0]\\` and remove it with \\`process.removeListener('unhandledRejection', listener)\\`.\n\n        // You can silence warnings related to this behavior by running Next.js with \\`NEXT_UNHANDLED_REJECTION_FILTER=silent\\` environment variable.\n\n        // You can debug event listener operations by running Next.js with \\`NEXT_UNHANDLED_REJECTION_FILTER=debug\\` environment variable.`\n        //         )\n        debugWithTrace?.(\n          `Removing all 'unhandledRejection' listeners except for the Next.js filter.`\n        )\n\n        underlyingListeners.length = 0\n        listenerMetadata.length = 0\n        return process\n      }\n\n      // For other specific events, use the original method\n      if (event !== undefined) {\n        return originalProcessRemoveAllListeners.call(process, event)\n      }\n\n      // If no event specified (removeAllListeners()), uninstall our patch completely\n      warnUninstalledOnce?.(\n        `Uninstalling filter because \\`process.removeAllListeners()\\` was called. Uninstalling this filter is not recommended and will cause you to observe 'unhandledRejection' events related to intentionally aborted prerenders.\n\nYou can silence warnings related to this behavior by running Next.js with \\`NEXT_UNHANDLED_REJECTION_FILTER=silent\\` environment variable.\n\nYou can debug event listener operations by running Next.js with \\`NEXT_UNHANDLED_REJECTION_FILTER=debug\\` environment variable.`\n      )\n      uninstallUnhandledRejectionFilter()\n      return originalProcessRemoveAllListeners.call(process)\n    } as typeof process.removeAllListeners\n  )\n\n  // Intercept process.listeners to return our internal handlers for unhandled rejection\n  process.listeners = patchWithoutReentrancy(\n    originalProcessListeners,\n    function (event: string | symbol) {\n      if (event === 'unhandledRejection') {\n        debugWithTrace?.(`Retrieving all 'unhandledRejection' listeners.`)\n        return [filteringUnhandledRejectionHandler, ...underlyingListeners]\n      }\n      return originalProcessListeners.call(process, event as any)\n    } as typeof process.listeners\n  )\n\n  filterInstalled = true\n}\n\n/**\n * Uninstalls the unhandled rejection filter and restores original process methods.\n * This is called when someone explicitly removes our filtering handler.\n * @internal\n */\nfunction uninstallUnhandledRejectionFilter(): void {\n  if (!filterInstalled) {\n    warnWithTrace?.(\n      'Unexpected subsequent filter uninstallation. This is a bug in Next.js'\n    )\n    return\n  }\n\n  debug?.('Uninstalling Filter')\n\n  // Restore original process methods\n  process.on = originalProcessOn\n  process.addListener = originalProcessAddListener\n  process.once = originalProcessOnce\n  process.prependListener = originalProcessPrependListener\n  process.prependOnceListener = originalProcessPrependOnceListener\n  process.removeListener = originalProcessRemoveListener\n  process.off = originalProcessOff\n  process.removeAllListeners = originalProcessRemoveAllListeners\n  process.listeners = originalProcessListeners\n\n  // Remove our filtering handler\n  process.removeListener(\n    'unhandledRejection',\n    filteringUnhandledRejectionHandler\n  )\n\n  // Re-register all the handlers that were in our internal queue\n  for (const meta of listenerMetadata) {\n    if (meta.once) {\n      process.once('unhandledRejection', meta.listener)\n    } else {\n      process.addListener('unhandledRejection', meta.listener)\n    }\n  }\n\n  // Reset state\n  filterInstalled = false\n  underlyingListeners.length = 0\n  listenerMetadata.length = 0\n}\n\n/**\n * The filtering handler that decides whether to suppress or delegate unhandled rejections.\n */\nfunction filteringUnhandledRejectionHandler(\n  reason: any,\n  promise: Promise<any>\n): void {\n  const capturedListenerMetadata = Array.from(listenerMetadata)\n\n  const workUnitStore = workUnitAsyncStorage.getStore()\n\n  if (workUnitStore) {\n    switch (workUnitStore.type) {\n      case 'prerender':\n      case 'prerender-client':\n      case 'prerender-runtime': {\n        const signal = workUnitStore.renderSignal\n        if (signal.aborted) {\n          // This unhandledRejection is from async work spawned in a now\n          // aborted prerender. We don't need to report this.\n          return\n        }\n        break\n      }\n      case 'prerender-ppr':\n      case 'prerender-legacy':\n      case 'request':\n      case 'cache':\n      case 'private-cache':\n      case 'unstable-cache':\n        break\n      default:\n        workUnitStore satisfies never\n    }\n  }\n\n  // Not from an aborted prerender, delegate to original handlers\n  if (capturedListenerMetadata.length === 0) {\n    // We need to log something because the default behavior when there is\n    // no event handler installed is to trigger an Unhandled Exception.\n    // We don't do that here b/c we don't want to rely on this implicit default\n    // to kill the process since it can be disabled by installing a userland listener\n    // and you may also choose to run Next.js with args such that unhandled rejections\n    // do not automatically terminate the process.\n    console.error('Unhandled Rejection:', reason)\n  } else {\n    try {\n      for (const meta of capturedListenerMetadata) {\n        if (meta.once) {\n          // This is a once listener. we remove it from our set before we call it\n          const index = listenerMetadata.indexOf(meta)\n          if (index !== -1) {\n            underlyingListeners.splice(index, 1)\n            listenerMetadata.splice(index, 1)\n          }\n        }\n        const listener = meta.listener\n        listener(reason, promise)\n      }\n    } catch (error) {\n      // If any handlers error we produce an Uncaught Exception\n      setImmediate(() => {\n        throw error\n      })\n    }\n  }\n}\n\n// Install the filter when this module is imported\nif (ENABLE_UHR_FILTER) {\n  installUnhandledRejectionFilter()\n}\n"],"names":["workUnitAsyncStorage","MODE","process","env","NEXT_UNHANDLED_REJECTION_FILTER","ENABLE_UHR_FILTER","UHR_FILTER_LOG_LEVEL","undefined","console","error","JSON","stringify","debug","debugWithTrace","warn","warnWithTrace","message","log","DebugWithStack","WarnWithStack","Error","constructor","name","didWarnUninstalled","warnUninstalledOnce","args","filterInstalled","underlyingListeners","listenerMetadata","originalProcessAddListener","originalProcessRemoveListener","originalProcessOn","originalProcessOff","originalProcessPrependListener","originalProcessOnce","originalProcessPrependOnceListener","originalProcessRemoveAllListeners","originalProcessListeners","bypassPatch","patchWithoutReentrancy","original","patchedImpl","patched","Reflect","apply","previousBypassPatch","Object","defineProperty","value","toString","bind","writable","configurable","MACGUFFIN_EVENT","installUnhandledRejectionFilter","Array","from","listeners","map","l","listener","once","removeAllListeners","addListener","filteringUnhandledRejectionHandler","removeListener","on","off","prependListener","prependOnceListener","event","call","push","uninstallUnhandledRejectionFilter","index","lastIndexOf","splice","unshift","length","meta","reason","promise","capturedListenerMetadata","workUnitStore","getStore","type","signal","renderSignal","aborted","indexOf","setImmediate"],"mappings":"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","ignoreList":[0]}