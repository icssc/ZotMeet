{"version":3,"sources":["../../../../../../src/server/mcp/tools/utils/format-errors.ts"],"sourcesContent":["import type { OverlayState } from '../../../../next-devtools/dev-overlay/shared'\nimport type { SupportedErrorEvent } from '../../../../next-devtools/dev-overlay/container/runtime-error/render-error'\nimport { getErrorSource } from '../../../../shared/lib/error-source'\nimport type {\n  OriginalStackFramesRequest,\n  OriginalStackFramesResponse,\n} from '../../../../next-devtools/server/shared'\n\ntype StackFrameForFormatting = {\n  file: string | null\n  methodName: string\n  line1: number | null\n  column1: number | null\n}\n\ntype StackFrameResolver = (\n  request: OriginalStackFramesRequest\n) => Promise<OriginalStackFramesResponse>\n\n// Dependency injection for stack frame resolver\nlet stackFrameResolver: StackFrameResolver | undefined\n\nexport function setStackFrameResolver(fn: StackFrameResolver) {\n  stackFrameResolver = fn\n}\n\nasync function resolveStackFrames(\n  request: OriginalStackFramesRequest\n): Promise<OriginalStackFramesResponse> {\n  if (!stackFrameResolver) {\n    throw new Error(\n      'Stack frame resolver not initialized. This is a bug in Next.js.'\n    )\n  }\n  return stackFrameResolver(request)\n}\n\nconst formatStackFrame = (frame: StackFrameForFormatting): string => {\n  const file = frame.file || '<unknown>'\n  const method = frame.methodName || '<anonymous>'\n  const { line1: line, column1: column } = frame\n  return line && column\n    ? `  at ${method} (${file}:${line}:${column})`\n    : line\n      ? `  at ${method} (${file}:${line})`\n      : `  at ${method} (${file})`\n}\n\nconst formatErrorFrames = async (\n  frames: readonly StackFrameForFormatting[],\n  context: {\n    isServer: boolean\n    isEdgeServer: boolean\n    isAppDirectory: boolean\n  }\n): Promise<string> => {\n  try {\n    const resolvedFrames = await resolveStackFrames({\n      frames: frames.map((frame) => ({\n        file: frame.file || null,\n        methodName: frame.methodName || '<anonymous>',\n        arguments: [],\n        line1: frame.line1 || null,\n        column1: frame.column1 || null,\n      })),\n      isServer: context.isServer,\n      isEdgeServer: context.isEdgeServer,\n      isAppDirectory: context.isAppDirectory,\n    })\n\n    return (\n      resolvedFrames\n        .filter(\n          (resolvedFrame) =>\n            !(\n              resolvedFrame.status === 'fulfilled' &&\n              resolvedFrame.value.originalStackFrame?.ignored\n            )\n        )\n        .map((resolvedFrame, j) =>\n          resolvedFrame.status === 'fulfilled' &&\n          resolvedFrame.value.originalStackFrame\n            ? formatStackFrame(resolvedFrame.value.originalStackFrame)\n            : formatStackFrame(frames[j])\n        )\n        .join('\\n') + '\\n'\n    )\n  } catch {\n    return frames.map(formatStackFrame).join('\\n') + '\\n'\n  }\n}\n\nasync function formatRuntimeError(\n  errors: readonly SupportedErrorEvent[],\n  isAppDirectory: boolean\n): Promise<string> {\n  const formatError = async (\n    error: SupportedErrorEvent,\n    index: number\n  ): Promise<string> => {\n    const errorHeader = `\\n#### Error ${index + 1} (Type: ${error.type})\\n\\n`\n    const errorName = error.error?.name || 'Error'\n    const errorMsg = error.error?.message || 'Unknown error'\n    const errorMessage = `**${errorName}**: ${errorMsg}\\n\\n`\n\n    if (!error.frames?.length) {\n      const stack = error.error?.stack || ''\n      return (\n        errorHeader + errorMessage + (stack ? `\\`\\`\\`\\n${stack}\\n\\`\\`\\`\\n` : '')\n      )\n    }\n\n    const errorSource = getErrorSource(error.error)\n    const frames = await formatErrorFrames(error.frames, {\n      isServer: errorSource === 'server',\n      isEdgeServer: errorSource === 'edge-server',\n      isAppDirectory,\n    })\n\n    return errorHeader + errorMessage + `\\`\\`\\`\\n${frames}\\`\\`\\`\\n`\n  }\n\n  const formattedErrors = await Promise.all(errors.map(formatError))\n  return '### Runtime Errors\\n' + formattedErrors.join('\\n---\\n')\n}\n\nexport async function formatErrors(\n  errorsByUrl: Map<string, OverlayState>,\n  nextInstanceErrors: { nextConfig: unknown[] } = { nextConfig: [] }\n): Promise<string> {\n  let output = ''\n\n  // Format Next.js instance errors first (e.g., next.config.js errors)\n  if (nextInstanceErrors.nextConfig.length > 0) {\n    output += `# Next.js Configuration Errors\\n\\n`\n    output += `**${nextInstanceErrors.nextConfig.length} error(s) found in next.config**\\n\\n`\n\n    nextInstanceErrors.nextConfig.forEach((error, index) => {\n      output += `## Error ${index + 1}\\n\\n`\n      output += '```\\n'\n      if (error instanceof Error) {\n        output += `${error.name}: ${error.message}\\n`\n        if (error.stack) {\n          output += error.stack\n        }\n      } else {\n        output += String(error)\n      }\n      output += '\\n```\\n\\n'\n    })\n\n    output += '---\\n\\n'\n  }\n\n  // Format browser session errors\n  if (errorsByUrl.size > 0) {\n    output += `# Found errors in ${errorsByUrl.size} browser session(s)\\n\\n`\n\n    for (const [url, overlayState] of errorsByUrl) {\n      const totalErrorCount =\n        overlayState.errors.length + (overlayState.buildError ? 1 : 0)\n\n      if (totalErrorCount === 0) continue\n\n      let displayUrl = url\n      try {\n        const urlObj = new URL(url)\n        displayUrl = urlObj.pathname + urlObj.search + urlObj.hash\n      } catch {\n        // If URL parsing fails, use the original URL\n      }\n\n      output += `## Session: ${displayUrl}\\n\\n`\n      output += `**${totalErrorCount} error(s) found**\\n\\n`\n\n      // Build errors\n      if (overlayState.buildError) {\n        output += '### Build Error\\n\\n'\n        output += '```\\n'\n        output += overlayState.buildError\n        output += '\\n```\\n\\n'\n      }\n\n      // Runtime errors with source-mapped stack traces\n      if (overlayState.errors.length > 0) {\n        const runtimeErrors = await formatRuntimeError(\n          overlayState.errors,\n          overlayState.routerType === 'app'\n        )\n        output += runtimeErrors\n        output += '\\n'\n      }\n\n      output += '---\\n\\n'\n    }\n  }\n\n  return output.trim()\n}\n"],"names":["getErrorSource","stackFrameResolver","setStackFrameResolver","fn","resolveStackFrames","request","Error","formatStackFrame","frame","file","method","methodName","line1","line","column1","column","formatErrorFrames","frames","context","resolvedFrames","map","arguments","isServer","isEdgeServer","isAppDirectory","filter","resolvedFrame","status","value","originalStackFrame","ignored","j","join","formatRuntimeError","errors","formatError","error","index","errorHeader","type","errorName","name","errorMsg","message","errorMessage","length","stack","errorSource","formattedErrors","Promise","all","formatErrors","errorsByUrl","nextInstanceErrors","nextConfig","output","forEach","String","size","url","overlayState","totalErrorCount","buildError","displayUrl","urlObj","URL","pathname","search","hash","runtimeErrors","routerType","trim"],"mappings":"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","ignoreList":[0]}