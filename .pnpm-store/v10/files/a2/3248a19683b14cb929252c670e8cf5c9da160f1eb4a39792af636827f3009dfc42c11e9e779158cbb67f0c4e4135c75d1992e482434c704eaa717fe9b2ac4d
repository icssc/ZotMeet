{"version":3,"file":"schema-object.mjs","sources":["../../src/transform/schema-object.ts"],"sourcesContent":["import { parseRef } from \"@redocly/openapi-core/lib/ref-utils.js\";\nimport ts from \"typescript\";\nimport {\n  BOOLEAN,\n  NEVER,\n  NULL,\n  NUMBER,\n  QUESTION_TOKEN,\n  STRING,\n  UNDEFINED,\n  UNKNOWN,\n  addJSDocComment,\n  oapiRef,\n  tsArrayLiteralExpression,\n  tsEnum,\n  tsIntersection,\n  tsIsPrimitive,\n  tsLiteral,\n  tsModifiers,\n  tsNullable,\n  tsOmit,\n  tsPropertyIndex,\n  tsRecord,\n  tsUnion,\n  tsWithRequired,\n} from \"../lib/ts.js\";\nimport { createDiscriminatorProperty, createRef, getEntries } from \"../lib/utils.js\";\nimport type { ReferenceObject, SchemaObject, TransformNodeOptions } from \"../types.js\";\n\n/**\n * Transform SchemaObject nodes (4.8.24)\n * @see https://spec.openapis.org/oas/v3.1.0#schema-object\n */\nexport default function transformSchemaObject(\n  schemaObject: SchemaObject | ReferenceObject,\n  options: TransformNodeOptions,\n): ts.TypeNode {\n  const type = transformSchemaObjectWithComposition(schemaObject, options);\n  if (typeof options.ctx.postTransform === \"function\") {\n    const postTransformResult = options.ctx.postTransform(type, options);\n    if (postTransformResult) {\n      return postTransformResult;\n    }\n  }\n  return type;\n}\n\n/**\n * Transform SchemaObjects\n */\nexport function transformSchemaObjectWithComposition(\n  schemaObject: SchemaObject | ReferenceObject,\n  options: TransformNodeOptions,\n): ts.TypeNode {\n  /**\n   * Unexpected types & edge cases\n   */\n\n  // missing/falsy type returns `never`\n  if (!schemaObject) {\n    return NEVER;\n  }\n  // `true` returns `unknown` (this exists, but is untyped)\n  if ((schemaObject as unknown) === true) {\n    return UNKNOWN;\n  }\n  // for any other unexpected type, throw error\n  if (Array.isArray(schemaObject) || typeof schemaObject !== \"object\") {\n    throw new Error(\n      `Expected SchemaObject, received ${Array.isArray(schemaObject) ? \"Array\" : typeof schemaObject} at ${options.path}`,\n    );\n  }\n\n  /**\n   * ReferenceObject\n   */\n  if (\"$ref\" in schemaObject) {\n    return oapiRef(schemaObject.$ref);\n  }\n\n  /**\n   * const (valid for any type)\n   */\n  if (schemaObject.const !== null && schemaObject.const !== undefined) {\n    return tsLiteral(schemaObject.const);\n  }\n\n  /**\n   * enum (non-objects)\n   * note: enum is valid for any type, but for objects, handle in oneOf below\n   */\n  if (\n    Array.isArray(schemaObject.enum) &&\n    (!(\"type\" in schemaObject) || schemaObject.type !== \"object\") &&\n    !(\"properties\" in schemaObject) &&\n    !(\"additionalProperties\" in schemaObject)\n  ) {\n    // hoist enum to top level if string/number enum and option is enabled\n    if (\n      options.ctx.enum &&\n      schemaObject.enum.every((v) => typeof v === \"string\" || typeof v === \"number\" || v === null)\n    ) {\n      let enumName = parseRef(options.path ?? \"\").pointer.join(\"/\");\n      // allow #/components/schemas to have simpler names\n      enumName = enumName.replace(\"components/schemas\", \"\");\n      const metadata = schemaObject.enum.map((_, i) => ({\n        name: schemaObject[\"x-enum-varnames\"]?.[i] ?? schemaObject[\"x-enumNames\"]?.[i],\n        description: schemaObject[\"x-enum-descriptions\"]?.[i] ?? schemaObject[\"x-enumDescriptions\"]?.[i],\n      }));\n\n      // enums can contain null values, but dont want to output them\n      let hasNull = false;\n      const validSchemaEnums = schemaObject.enum.filter((enumValue) => {\n        if (enumValue === null) {\n          hasNull = true;\n          return false;\n        }\n\n        return true;\n      });\n      const enumType = tsEnum(enumName, validSchemaEnums as (string | number)[], metadata, {\n        shouldCache: options.ctx.dedupeEnums,\n        export: true,\n        // readonly: TS enum do not support the readonly modifier\n      });\n      if (!options.ctx.injectFooter.includes(enumType)) {\n        options.ctx.injectFooter.push(enumType);\n      }\n      const ref = ts.factory.createTypeReferenceNode(enumType.name);\n      return hasNull ? tsUnion([ref, NULL]) : ref;\n    }\n    const enumType = schemaObject.enum.map(tsLiteral);\n    if ((Array.isArray(schemaObject.type) && schemaObject.type.includes(\"null\")) || schemaObject.nullable) {\n      enumType.push(NULL);\n    }\n\n    const unionType = tsUnion(enumType);\n\n    // hoist array with valid enum values to top level if string/number enum and option is enabled\n    if (options.ctx.enumValues && schemaObject.enum.every((v) => typeof v === \"string\" || typeof v === \"number\")) {\n      let enumValuesVariableName = parseRef(options.path ?? \"\").pointer.join(\"/\");\n      // allow #/components/schemas to have simpler names\n      enumValuesVariableName = enumValuesVariableName.replace(\"components/schemas\", \"\");\n      enumValuesVariableName = `${enumValuesVariableName}Values`;\n\n      const enumValuesArray = tsArrayLiteralExpression(\n        enumValuesVariableName,\n        oapiRef(options.path ?? \"\"),\n        schemaObject.enum as (string | number)[],\n        {\n          export: true,\n          readonly: true,\n          injectFooter: options.ctx.injectFooter,\n        },\n      );\n\n      options.ctx.injectFooter.push(enumValuesArray);\n    }\n\n    return unionType;\n  }\n\n  /**\n   * Object + composition (anyOf/allOf/oneOf) types\n   */\n\n  /** Collect oneOf/anyOf */\n  function collectUnionCompositions(items: (SchemaObject | ReferenceObject)[]) {\n    const output: ts.TypeNode[] = [];\n    for (const item of items) {\n      output.push(transformSchemaObject(item, options));\n    }\n\n    return output;\n  }\n\n  /** Collect allOf with Omit<> for discriminators */\n  function collectAllOfCompositions(items: (SchemaObject | ReferenceObject)[], required?: string[]): ts.TypeNode[] {\n    const output: ts.TypeNode[] = [];\n    for (const item of items) {\n      let itemType: ts.TypeNode;\n      // if this is a $ref, use WithRequired<X, Y> if parent specifies required properties\n      // (but only for valid keys)\n      if (\"$ref\" in item) {\n        itemType = transformSchemaObject(item, options);\n\n        const resolved = options.ctx.resolve<SchemaObject>(item.$ref);\n\n        // make keys required, if necessary\n        if (\n          resolved &&\n          typeof resolved === \"object\" &&\n          \"properties\" in resolved &&\n          // we have already handled this item (discriminator property was already added as required)\n          !options.ctx.discriminators.refsHandled.includes(item.$ref)\n        ) {\n          // add WithRequired<X, Y> if necessary\n          const validRequired = (required ?? []).filter((key) => !!resolved.properties?.[key]);\n          if (validRequired.length) {\n            itemType = tsWithRequired(itemType, validRequired, options.ctx.injectFooter);\n          }\n        }\n      }\n      // otherwise, if this is a schema object, combine parent `required[]` with its own, if any\n      else {\n        const itemRequired = [...(required ?? [])];\n        if (typeof item === \"object\" && Array.isArray(item.required)) {\n          itemRequired.push(...item.required);\n        }\n        itemType = transformSchemaObject({ ...item, required: itemRequired }, options);\n      }\n\n      const discriminator =\n        (\"$ref\" in item && options.ctx.discriminators.objects[item.$ref]) || (item as any).discriminator;\n      if (discriminator) {\n        output.push(tsOmit(itemType, [discriminator.propertyName]));\n      } else {\n        output.push(itemType);\n      }\n    }\n    return output;\n  }\n\n  // compile final type\n  let finalType: ts.TypeNode | undefined = undefined;\n\n  // core + allOf: intersect\n  const coreObjectType = transformSchemaObjectCore(schemaObject, options);\n  const allOfType = collectAllOfCompositions(schemaObject.allOf ?? [], schemaObject.required);\n  if (coreObjectType || allOfType.length) {\n    const allOf: ts.TypeNode | undefined = allOfType.length ? tsIntersection(allOfType) : undefined;\n    finalType = tsIntersection([...(coreObjectType ? [coreObjectType] : []), ...(allOf ? [allOf] : [])]);\n  }\n  // anyOf: union\n  // (note: this may seem counterintuitive, but as TypeScript’s unions are not true XORs, they mimic behavior closer to anyOf than oneOf)\n  const anyOfType = collectUnionCompositions(schemaObject.anyOf ?? []);\n  if (anyOfType.length) {\n    finalType = tsUnion([...(finalType ? [finalType] : []), ...anyOfType]);\n  }\n  // oneOf: union (within intersection with other types, if any)\n  const oneOfType = collectUnionCompositions(\n    schemaObject.oneOf ||\n      (\"type\" in schemaObject &&\n        schemaObject.type === \"object\" &&\n        (schemaObject.enum as (SchemaObject | ReferenceObject)[])) ||\n      [],\n  );\n  if (oneOfType.length) {\n    // note: oneOf is the only type that may include primitives\n    if (oneOfType.every(tsIsPrimitive)) {\n      finalType = tsUnion([...(finalType ? [finalType] : []), ...oneOfType]);\n    } else {\n      finalType = tsIntersection([...(finalType ? [finalType] : []), tsUnion(oneOfType)]);\n    }\n  }\n\n  // When no final type can be generated, fall back to unknown type (or related variants)\n  if (!finalType) {\n    if (\"type\" in schemaObject) {\n      finalType = tsRecord(STRING, options.ctx.emptyObjectsUnknown ? UNKNOWN : NEVER);\n    } else {\n      finalType = UNKNOWN;\n    }\n  }\n\n  if (finalType !== UNKNOWN && schemaObject.nullable) {\n    finalType = tsNullable([finalType]);\n  }\n\n  return finalType;\n}\n\n/**\n * Handle SchemaObject minus composition (anyOf/allOf/oneOf)\n */\nfunction transformSchemaObjectCore(schemaObject: SchemaObject, options: TransformNodeOptions): ts.TypeNode | undefined {\n  if (\"type\" in schemaObject && schemaObject.type) {\n    if (typeof options.ctx.transform === \"function\") {\n      const result = options.ctx.transform(schemaObject, options);\n      if (result && typeof result === \"object\") {\n        if (\"schema\" in result) {\n          if (result.questionToken) {\n            return ts.factory.createUnionTypeNode([result.schema, UNDEFINED]);\n          } else {\n            return result.schema;\n          }\n        } else {\n          return result;\n        }\n      }\n    }\n\n    // primitives\n    // type: null\n    if (schemaObject.type === \"null\") {\n      return NULL;\n    }\n    // type: string\n    if (schemaObject.type === \"string\") {\n      return STRING;\n    }\n    // type: number / type: integer\n    if (schemaObject.type === \"number\" || schemaObject.type === \"integer\") {\n      return NUMBER;\n    }\n    // type: boolean\n    if (schemaObject.type === \"boolean\") {\n      return BOOLEAN;\n    }\n\n    // type: array (with support for tuples)\n    if (schemaObject.type === \"array\") {\n      // default to `unknown[]`\n      let itemType: ts.TypeNode = UNKNOWN;\n      // tuple type\n      if (schemaObject.prefixItems || Array.isArray(schemaObject.items)) {\n        const prefixItems = schemaObject.prefixItems ?? (schemaObject.items as (SchemaObject | ReferenceObject)[]);\n        itemType = ts.factory.createTupleTypeNode(prefixItems.map((item) => transformSchemaObject(item, options)));\n      }\n      // standard array type\n      else if (schemaObject.items) {\n        if (hasKey(schemaObject.items, \"type\") && schemaObject.items.type === \"array\") {\n          itemType = ts.factory.createArrayTypeNode(transformSchemaObject(schemaObject.items, options));\n        } else {\n          itemType = transformSchemaObject(schemaObject.items, options);\n        }\n      }\n\n      const min: number =\n        typeof schemaObject.minItems === \"number\" && schemaObject.minItems >= 0 ? schemaObject.minItems : 0;\n      const max: number | undefined =\n        typeof schemaObject.maxItems === \"number\" && schemaObject.maxItems >= 0 && min <= schemaObject.maxItems\n          ? schemaObject.maxItems\n          : undefined;\n      const estimateCodeSize = typeof max !== \"number\" ? min : (max * (max + 1) - min * (min - 1)) / 2;\n      if (\n        options.ctx.arrayLength &&\n        (min !== 0 || max !== undefined) &&\n        estimateCodeSize < 30 // \"30\" is an arbitrary number but roughly around when TS starts to struggle with tuple inference in practice\n      ) {\n        if (min === max) {\n          const elements: ts.TypeNode[] = [];\n          for (let i = 0; i < min; i++) {\n            elements.push(itemType);\n          }\n          return tsUnion([ts.factory.createTupleTypeNode(elements)]);\n        } else if ((schemaObject.maxItems as number) > 0) {\n          // if maxItems is set, then return a union of all permutations of possible tuple types\n          const members: ts.TypeNode[] = [];\n          // populate 1 short of min …\n          for (let i = 0; i <= (max ?? 0) - min; i++) {\n            const elements: ts.TypeNode[] = [];\n            for (let j = min; j < i + min; j++) {\n              elements.push(itemType);\n            }\n            members.push(ts.factory.createTupleTypeNode(elements));\n          }\n          return tsUnion(members);\n        }\n        // if maxItems not set, then return a simple tuple type the length of `min`\n        else {\n          const elements: ts.TypeNode[] = [];\n          for (let i = 0; i < min; i++) {\n            elements.push(itemType);\n          }\n          elements.push(ts.factory.createRestTypeNode(ts.factory.createArrayTypeNode(itemType)));\n          return ts.factory.createTupleTypeNode(elements);\n        }\n      }\n\n      const finalType =\n        ts.isTupleTypeNode(itemType) || ts.isArrayTypeNode(itemType)\n          ? itemType\n          : ts.factory.createArrayTypeNode(itemType); // wrap itemType in array type, but only if not a tuple or array already\n\n      return options.ctx.immutable\n        ? ts.factory.createTypeOperatorNode(ts.SyntaxKind.ReadonlyKeyword, finalType)\n        : finalType;\n    }\n\n    // polymorphic, or 3.1 nullable\n    if (Array.isArray(schemaObject.type) && !Array.isArray(schemaObject)) {\n      // skip any primitive types that appear in oneOf as well\n      const uniqueTypes: ts.TypeNode[] = [];\n      if (Array.isArray(schemaObject.oneOf)) {\n        for (const t of schemaObject.type) {\n          if (\n            (t === \"boolean\" || t === \"string\" || t === \"number\" || t === \"integer\" || t === \"null\") &&\n            schemaObject.oneOf.find((o) => typeof o === \"object\" && \"type\" in o && o.type === t)\n          ) {\n            continue;\n          }\n          uniqueTypes.push(\n            t === \"null\" || t === null\n              ? NULL\n              : transformSchemaObject(\n                  { ...schemaObject, type: t, oneOf: undefined } as SchemaObject, // don’t stack oneOf transforms\n                  options,\n                ),\n          );\n        }\n      } else {\n        for (const t of schemaObject.type) {\n          if (t === \"null\" || t === null) {\n            uniqueTypes.push(NULL);\n          } else {\n            uniqueTypes.push(transformSchemaObject({ ...schemaObject, type: t } as SchemaObject, options));\n          }\n        }\n      }\n      return tsUnion(uniqueTypes);\n    }\n  }\n\n  // type: object\n  const coreObjectType: ts.TypeElement[] = [];\n\n  // discriminators: explicit mapping on schema object\n  for (const k of [\"allOf\", \"anyOf\"] as const) {\n    if (!schemaObject[k]) {\n      continue;\n    }\n    // for all magic inheritance, we will have already gathered it into\n    // ctx.discriminators. But stop objects from referencing their own\n    // discriminator meant for children (!schemaObject.discriminator)\n    // and don't add discriminator properties if we already added/patched\n    // them (options.ctx.discriminators.refsHandled.includes(options.path!).\n    const discriminator =\n      !schemaObject.discriminator &&\n      !options.ctx.discriminators.refsHandled.includes(options.path ?? \"\") &&\n      options.ctx.discriminators.objects[options.path ?? \"\"];\n    if (discriminator) {\n      coreObjectType.unshift(\n        createDiscriminatorProperty(discriminator, {\n          path: options.path ?? \"\",\n          readonly: options.ctx.immutable,\n        }),\n      );\n      break;\n    }\n  }\n\n  if (\n    (\"properties\" in schemaObject && schemaObject.properties && Object.keys(schemaObject.properties).length) ||\n    (\"additionalProperties\" in schemaObject && schemaObject.additionalProperties) ||\n    (\"$defs\" in schemaObject && schemaObject.$defs)\n  ) {\n    // properties\n    if (Object.keys(schemaObject.properties ?? {}).length) {\n      for (const [k, v] of getEntries(schemaObject.properties ?? {}, options.ctx)) {\n        if ((typeof v !== \"object\" && typeof v !== \"boolean\") || Array.isArray(v)) {\n          throw new Error(\n            `${options.path}: invalid property ${k}. Expected Schema Object or boolean, got ${\n              Array.isArray(v) ? \"Array\" : typeof v\n            }`,\n          );\n        }\n\n        const { $ref, readOnly, hasDefault } =\n          typeof v === \"object\"\n            ? {\n                $ref: \"$ref\" in v && v.$ref,\n                readOnly: \"readOnly\" in v && v.readOnly,\n                hasDefault: \"default\" in v && v.default !== undefined,\n              }\n            : {};\n\n        // handle excludeDeprecated option\n        if (options.ctx.excludeDeprecated) {\n          const resolved = $ref ? options.ctx.resolve<SchemaObject>($ref) : v;\n          if ((resolved as SchemaObject)?.deprecated) {\n            continue;\n          }\n        }\n        let optional =\n          schemaObject.required?.includes(k) ||\n          (schemaObject.required === undefined && options.ctx.propertiesRequiredByDefault) ||\n          (hasDefault &&\n            options.ctx.defaultNonNullable &&\n            !options.path?.includes(\"parameters\") &&\n            !options.path?.includes(\"requestBody\") &&\n            !options.path?.includes(\"requestBodies\")) // can’t be required, even with defaults\n            ? undefined\n            : QUESTION_TOKEN;\n        let type = $ref\n          ? oapiRef($ref)\n          : transformSchemaObject(v, {\n              ...options,\n              path: createRef([options.path, k]),\n            });\n\n        if (typeof options.ctx.transform === \"function\") {\n          const result = options.ctx.transform(v as SchemaObject, options);\n          if (result && typeof result === \"object\") {\n            if (\"schema\" in result) {\n              type = result.schema;\n              optional = result.questionToken ? QUESTION_TOKEN : optional;\n            } else {\n              type = result;\n            }\n          }\n        }\n\n        const property = ts.factory.createPropertySignature(\n          /* modifiers     */ tsModifiers({\n            readonly: options.ctx.immutable || readOnly,\n          }),\n          /* name          */ tsPropertyIndex(k),\n          /* questionToken */ optional,\n          /* type          */ type,\n        );\n        addJSDocComment(v, property);\n        coreObjectType.push(property);\n      }\n    }\n\n    // $defs\n    if (schemaObject.$defs && typeof schemaObject.$defs === \"object\" && Object.keys(schemaObject.$defs).length) {\n      const defKeys: ts.TypeElement[] = [];\n      for (const [k, v] of Object.entries(schemaObject.$defs)) {\n        const property = ts.factory.createPropertySignature(\n          /* modifiers    */ tsModifiers({\n            readonly: options.ctx.immutable || (\"readonly\" in v && !!v.readOnly),\n          }),\n          /* name          */ tsPropertyIndex(k),\n          /* questionToken */ undefined,\n          /* type          */ transformSchemaObject(v, {\n            ...options,\n            path: createRef([options.path, \"$defs\", k]),\n          }),\n        );\n        addJSDocComment(v, property);\n        defKeys.push(property);\n      }\n      coreObjectType.push(\n        ts.factory.createPropertySignature(\n          /* modifiers     */ undefined,\n          /* name          */ tsPropertyIndex(\"$defs\"),\n          /* questionToken */ undefined,\n          /* type          */ ts.factory.createTypeLiteralNode(defKeys),\n        ),\n      );\n    }\n\n    // additionalProperties\n    if (schemaObject.additionalProperties || options.ctx.additionalProperties) {\n      const hasExplicitAdditionalProperties =\n        typeof schemaObject.additionalProperties === \"object\" && Object.keys(schemaObject.additionalProperties).length;\n      const addlType = hasExplicitAdditionalProperties\n        ? transformSchemaObject(schemaObject.additionalProperties as SchemaObject, options)\n        : UNKNOWN;\n      return tsIntersection([\n        ...(coreObjectType.length ? [ts.factory.createTypeLiteralNode(coreObjectType)] : []),\n        ts.factory.createTypeLiteralNode([\n          ts.factory.createIndexSignature(\n            /* modifiers  */ tsModifiers({\n              readonly: options.ctx.immutable,\n            }),\n            /* parameters */ [\n              ts.factory.createParameterDeclaration(\n                /* modifiers      */ undefined,\n                /* dotDotDotToken */ undefined,\n                /* name           */ ts.factory.createIdentifier(\"key\"),\n                /* questionToken  */ undefined,\n                /* type           */ STRING,\n              ),\n            ],\n            /* type       */ addlType,\n          ),\n        ]),\n      ]);\n    }\n  }\n\n  return coreObjectType.length ? ts.factory.createTypeLiteralNode(coreObjectType) : undefined;\n}\n\n/**\n * Check if an object has a key\n * @param possibleObject - The object to check\n * @param key - The key to check for\n * @returns True if the object has the key, false otherwise\n */\nfunction hasKey<K extends string>(possibleObject: unknown, key: K): possibleObject is { [key in K]: unknown } {\n  return typeof possibleObject === \"object\" && possibleObject !== null && key in possibleObject;\n}\n"],"names":["enumType"],"mappings":"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"}