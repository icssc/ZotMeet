{"version":3,"file":"utils.js","names":["nullifyMap: Record<string, string | false>","decoder: DriverValueDecoder<unknown, unknown>","result","entries: [string, UpdateSet[string]][]"],"sources":["../src/utils.ts"],"sourcesContent":["import type { Cache } from './cache/core/cache.ts';\nimport type { AnyColumn } from './column.ts';\nimport { Column } from './column.ts';\nimport { is } from './entity.ts';\nimport type { Logger } from './logger.ts';\nimport type { SelectedFieldsOrdered } from './operations.ts';\nimport type { TableLike } from './query-builders/select.types.ts';\nimport type { AnyRelations, EmptyRelations } from './relations.ts';\nimport { Param, SQL, View } from './sql/sql.ts';\nimport type { DriverValueDecoder } from './sql/sql.ts';\nimport { Subquery } from './subquery.ts';\nimport { getTableName, Table } from './table.ts';\nimport { ViewBaseConfig } from './view-common.ts';\n\n/** @internal */\nexport function mapResultRow<TResult>(\n\tcolumns: SelectedFieldsOrdered<AnyColumn>,\n\trow: unknown[],\n\tjoinsNotNullableMap: Record<string, boolean> | undefined,\n): TResult {\n\t// Key -> nested object key, value -> table name if all fields in the nested object are from the same table, false otherwise\n\tconst nullifyMap: Record<string, string | false> = {};\n\n\tconst result = columns.reduce<Record<string, any>>(\n\t\t(result, { path, field }, columnIndex) => {\n\t\t\tlet decoder: DriverValueDecoder<unknown, unknown>;\n\t\t\tif (is(field, Column)) {\n\t\t\t\tdecoder = field;\n\t\t\t} else if (is(field, SQL)) {\n\t\t\t\tdecoder = field.decoder;\n\t\t\t} else if (is(field, Subquery)) {\n\t\t\t\tdecoder = field._.sql.decoder;\n\t\t\t} else {\n\t\t\t\tdecoder = field.sql.decoder;\n\t\t\t}\n\t\t\tlet node = result;\n\t\t\tfor (const [pathChunkIndex, pathChunk] of path.entries()) {\n\t\t\t\tif (pathChunkIndex < path.length - 1) {\n\t\t\t\t\tif (!(pathChunk in node)) {\n\t\t\t\t\t\tnode[pathChunk] = {};\n\t\t\t\t\t}\n\t\t\t\t\tnode = node[pathChunk];\n\t\t\t\t} else {\n\t\t\t\t\tconst rawValue = row[columnIndex]!;\n\t\t\t\t\tconst value = node[pathChunk] = rawValue === null ? null : decoder.mapFromDriverValue(rawValue);\n\n\t\t\t\t\tif (joinsNotNullableMap && is(field, Column) && path.length === 2) {\n\t\t\t\t\t\tconst objectName = path[0]!;\n\t\t\t\t\t\tif (!(objectName in nullifyMap)) {\n\t\t\t\t\t\t\tnullifyMap[objectName] = value === null ? getTableName(field.table) : false;\n\t\t\t\t\t\t} else if (\n\t\t\t\t\t\t\ttypeof nullifyMap[objectName] === 'string' && nullifyMap[objectName] !== getTableName(field.table)\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tnullifyMap[objectName] = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn result;\n\t\t},\n\t\t{},\n\t);\n\n\t// Nullify all nested objects from nullifyMap that are nullable\n\tif (joinsNotNullableMap && Object.keys(nullifyMap).length > 0) {\n\t\tfor (const [objectName, tableName] of Object.entries(nullifyMap)) {\n\t\t\tif (typeof tableName === 'string' && !joinsNotNullableMap[tableName]) {\n\t\t\t\tresult[objectName] = null;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn result as TResult;\n}\n\n/** @internal */\nexport function orderSelectedFields<TColumn extends AnyColumn>(\n\tfields: Record<string, unknown>,\n\tpathPrefix?: string[],\n): SelectedFieldsOrdered<TColumn> {\n\treturn Object.entries(fields).reduce<SelectedFieldsOrdered<AnyColumn>>((result, [name, field]) => {\n\t\tif (typeof name !== 'string') {\n\t\t\treturn result;\n\t\t}\n\n\t\tconst newPath = pathPrefix ? [...pathPrefix, name] : [name];\n\t\tif (is(field, Column) || is(field, SQL) || is(field, SQL.Aliased) || is(field, Subquery)) {\n\t\t\tresult.push({ path: newPath, field });\n\t\t} else if (is(field, Table)) {\n\t\t\tresult.push(...orderSelectedFields(field[Table.Symbol.Columns], newPath));\n\t\t} else {\n\t\t\tresult.push(...orderSelectedFields(field as Record<string, unknown>, newPath));\n\t\t}\n\t\treturn result;\n\t}, []) as SelectedFieldsOrdered<TColumn>;\n}\n\nexport function haveSameKeys(left: Record<string, unknown>, right: Record<string, unknown>) {\n\tconst leftKeys = Object.keys(left);\n\tconst rightKeys = Object.keys(right);\n\n\tif (leftKeys.length !== rightKeys.length) {\n\t\treturn false;\n\t}\n\n\tfor (const [index, key] of leftKeys.entries()) {\n\t\tif (key !== rightKeys[index]) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\n/** @internal */\nexport function mapUpdateSet(table: Table, values: Record<string, unknown>): UpdateSet {\n\tconst entries: [string, UpdateSet[string]][] = Object.entries(values)\n\t\t.filter(([, value]) => value !== undefined)\n\t\t.map(([key, value]) => {\n\t\t\t// eslint-disable-next-line unicorn/prefer-ternary\n\t\t\tif (is(value, SQL) || is(value, Column)) {\n\t\t\t\treturn [key, value];\n\t\t\t} else {\n\t\t\t\treturn [key, new Param(value, table[Table.Symbol.Columns][key])];\n\t\t\t}\n\t\t});\n\n\tif (entries.length === 0) {\n\t\tthrow new Error('No values to set');\n\t}\n\n\treturn Object.fromEntries(entries);\n}\n\nexport type UpdateSet = Record<string, SQL | Param | AnyColumn | null | undefined>;\n\nexport type OneOrMany<T> = T | T[];\n\nexport type Update<T, TUpdate> =\n\t& {\n\t\t[K in Exclude<keyof T, keyof TUpdate>]: T[K];\n\t}\n\t& TUpdate;\n\nexport type Simplify<T> =\n\t& {\n\t\t// @ts-ignore - \"Type parameter 'K' has a circular constraint\", not sure why\n\t\t[K in keyof T]: T[K];\n\t}\n\t& {};\n\nexport type Not<T extends boolean> = T extends true ? false : true;\n\nexport type IsNever<T> = [T] extends [never] ? true : false;\n\nexport type IsUnion<T, U extends T = T> = (T extends any ? (U extends T ? false : true) : never) extends false ? false\n\t: true;\n\nexport type SingleKeyObject<T, TError extends string, K = keyof T> = IsNever<K> extends true ? never\n\t: IsUnion<K> extends true ? DrizzleTypeError<TError>\n\t: T;\n\nexport type FromSingleKeyObject<T, Result, TError extends string, K = keyof T> = IsNever<K> extends true ? never\n\t: IsUnion<K> extends true ? DrizzleTypeError<TError>\n\t: Result;\n\nexport type SimplifyMappedType<T> = [T] extends [unknown] ? T : never;\n\nexport type ShallowRecord<K extends keyof any, T> = SimplifyMappedType<{ [P in K]: T }>;\n\nexport type Assume<T, U> = T extends U ? T : U;\n\nexport type Equal<X, Y> = (<T>() => T extends X ? 1 : 2) extends (<T>() => T extends Y ? 1 : 2) ? true : false;\n\nexport interface DrizzleTypeError<T extends string> {\n\t$drizzleTypeError: T;\n}\n\nexport type ValueOrArray<T> = T | T[];\n\n/** @internal */\nexport function applyMixins(baseClass: any, extendedClasses: any[]) {\n\tfor (const extendedClass of extendedClasses) {\n\t\tfor (const name of Object.getOwnPropertyNames(extendedClass.prototype)) {\n\t\t\tif (name === 'constructor') continue;\n\n\t\t\tObject.defineProperty(\n\t\t\t\tbaseClass.prototype,\n\t\t\t\tname,\n\t\t\t\tObject.getOwnPropertyDescriptor(extendedClass.prototype, name) || Object.create(null),\n\t\t\t);\n\t\t}\n\t}\n}\n\nexport type Or<T1, T2> = T1 extends true ? true : T2 extends true ? true : false;\n\nexport type IfThenElse<If, Then, Else> = If extends true ? Then : Else;\n\nexport type PromiseOf<T> = T extends Promise<infer U> ? U : T;\n\nexport type Writable<T> = {\n\t-readonly [P in keyof T]: T[P];\n};\n\nexport type NonArray<T> = T extends any[] ? never : T;\n\n/**\n * @deprecated\n * Use `getColumns` instead\n */\nexport function getTableColumns<T extends Table>(table: T): T['_']['columns'] {\n\treturn table[Table.Symbol.Columns];\n}\n\nexport function getViewSelectedFields<T extends View>(view: T): T['_']['selectedFields'] {\n\treturn view[ViewBaseConfig].selectedFields;\n}\n\nexport function getColumns<T extends Table | View | Subquery>(\n\ttable: T,\n): T extends Table ? T['_']['columns']\n\t: T extends View ? T['_']['selectedFields']\n\t: T extends Subquery ? T['_']['selectedFields']\n\t: never\n{\n\treturn (is(table, Table)\n\t\t? table[Table.Symbol.Columns]\n\t\t: is(table, View)\n\t\t? table[ViewBaseConfig].selectedFields\n\t\t: table._.selectedFields) as any;\n}\n\n/** @internal */\nexport function getTableLikeName(table: TableLike): string | undefined {\n\treturn is(table, Subquery)\n\t\t? table._.alias\n\t\t: is(table, View)\n\t\t? table[ViewBaseConfig].name\n\t\t: is(table, SQL)\n\t\t? undefined\n\t\t: table[Table.Symbol.IsAlias]\n\t\t? table[Table.Symbol.Name]\n\t\t: table[Table.Symbol.BaseName];\n}\n\nexport type ColumnsWithTable<\n\tTTableName extends string,\n\tTForeignTableName extends string,\n\tTColumns extends AnyColumn<{ tableName: TTableName }>[],\n> = { [Key in keyof TColumns]: AnyColumn<{ tableName: TForeignTableName }> };\n\nexport type Casing = 'snake_case' | 'camelCase';\n\nexport interface DrizzleConfig<\n\tTSchema extends Record<string, unknown> = Record<string, never>,\n\tTRelationConfigs extends AnyRelations = EmptyRelations,\n> {\n\tlogger?: boolean | Logger | undefined;\n\tschema?: TSchema | undefined;\n\tcasing?: Casing | undefined;\n\trelations?: TRelationConfigs | undefined;\n\tcache?: Cache | undefined;\n}\nexport type ValidateShape<T, ValidShape, TResult = T> = T extends ValidShape\n\t? Exclude<keyof T, keyof ValidShape> extends never ? TResult\n\t: DrizzleTypeError<\n\t\t`Invalid key(s): ${Exclude<(keyof T) & (string | number | bigint | boolean | null | undefined), keyof ValidShape>}`\n\t>\n\t: never;\n\nexport type KnownKeysOnly<T, U> = {\n\t[K in keyof T]: K extends keyof U ? T[K] : never;\n};\n\nexport type IsAny<T> = 0 extends (1 & T) ? true : false;\n\n/** @internal */\nexport function getColumnNameAndConfig<\n\tTConfig extends Record<string, any> | undefined,\n>(a: string | TConfig | undefined, b: TConfig | undefined) {\n\treturn {\n\t\tname: typeof a === 'string' && a.length > 0 ? a : '' as string,\n\t\tconfig: typeof a === 'object' ? a : b as TConfig,\n\t};\n}\n\nexport type IfNotImported<T, Y, N> = unknown extends T ? Y : N;\n\nexport type ImportTypeError<TPackageName extends string> =\n\t`Please install \\`${TPackageName}\\` to allow Drizzle ORM to connect to the database`;\n\nexport type RequireAtLeastOne<T, Keys extends keyof T = keyof T> = Keys extends any\n\t? Required<Pick<T, Keys>> & Partial<Omit<T, Keys>>\n\t: never;\n\ntype ExpectedConfigShape = {\n\tlogger?: boolean | {\n\t\tlogQuery(query: string, params: unknown[]): void;\n\t} | undefined;\n\tschema?: Record<string, never> | undefined;\n\trelations?: AnyRelations | undefined;\n\tcasing?: 'snake_case' | 'camelCase' | undefined;\n};\n\n// If this errors, you must update config shape checker function with new config specs\nconst _: DrizzleConfig<any, any> = {} as ExpectedConfigShape;\nconst __: ExpectedConfigShape = {} as DrizzleConfig;\n\nexport function isConfig(data: any): boolean {\n\tif (typeof data !== 'object' || data === null) return false;\n\n\tif (data.constructor.name !== 'Object') return false;\n\n\tif ('logger' in data) {\n\t\tconst type = typeof data['logger'];\n\t\tif (\n\t\t\ttype !== 'boolean' && (type !== 'object' || typeof data['logger']['logQuery'] !== 'function')\n\t\t\t&& type !== 'undefined'\n\t\t) return false;\n\n\t\treturn true;\n\t}\n\n\tif ('schema' in data) {\n\t\tconst type = typeof data['schema'];\n\t\tif (type !== 'object' && type !== 'undefined') return false;\n\n\t\treturn true;\n\t}\n\n\tif ('relations' in data) {\n\t\tconst type = typeof data['relations'];\n\t\tif (type !== 'object' && type !== 'undefined') return false;\n\n\t\treturn true;\n\t}\n\n\tif ('casing' in data) {\n\t\tconst type = typeof data['casing'];\n\t\tif (type !== 'string' && type !== 'undefined') return false;\n\n\t\treturn true;\n\t}\n\n\tif ('mode' in data) {\n\t\tif (data['mode'] !== 'default' || data['mode'] !== 'planetscale' || data['mode'] !== undefined) return false;\n\n\t\treturn true;\n\t}\n\n\tif ('connection' in data) {\n\t\tconst type = typeof data['connection'];\n\t\tif (type !== 'string' && type !== 'object' && type !== 'undefined') return false;\n\n\t\treturn true;\n\t}\n\n\tif ('client' in data) {\n\t\tconst type = typeof data['client'];\n\t\tif (type !== 'object' && type !== 'function' && type !== 'undefined') return false;\n\n\t\treturn true;\n\t}\n\n\tif (Object.keys(data).length === 0) return true;\n\n\treturn false;\n}\n\nexport type NeonAuthToken = string | (() => string | Promise<string>);\n\nexport const textDecoder = typeof TextDecoder === 'undefined' ? null : new TextDecoder();\n\nexport function assertUnreachable(_x: never | undefined): never {\n\tthrow new Error(\"Didn't expect to get here\");\n}\n"],"mappings":"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"}