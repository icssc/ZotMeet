import { PgBasePreparedQuery, PgSession } from "../session.js";
import { PgEffectDatabase } from "./db.js";
import { entityKind, is } from "../../entity.js";
import { assertUnreachable } from "../../utils.js";
import { sql } from "../../sql/sql.js";
import { NoopCache, strategyFor } from "../../cache/core/cache.js";
import { Effect } from "effect";
import { TaggedDrizzleQueryError, TaggedTransactionRollbackError } from "../../effect-core/errors.js";

//#region src/pg-core/effect/session.ts
var PgEffectPreparedQuery = class extends PgBasePreparedQuery {
	static [entityKind] = "PgEffectPreparedQuery";
	constructor(query, cache, queryMetadata, cacheConfig) {
		super(query);
		this.cache = cache;
		this.queryMetadata = queryMetadata;
		this.cacheConfig = cacheConfig;
		if (cache && cache.strategy() === "all" && cacheConfig === void 0) this.cacheConfig = {
			enabled: true,
			autoInvalidate: true
		};
		if (!this.cacheConfig?.enabled) this.cacheConfig = void 0;
	}
	queryWithCache(queryString, params, query) {
		const { cache, cacheConfig, queryMetadata } = this;
		return Effect.gen(function* () {
			const cacheStrat = cache && !is(cache.wrapped, NoopCache) ? yield* Effect.tryPromise(() => strategyFor(queryString, params, queryMetadata, cacheConfig)) : { type: "skip" };
			if (cacheStrat.type === "skip") return yield* query;
			if (cacheStrat.type === "invalidate") {
				const result = yield* query;
				yield* cache.onMutate({ tables: cacheStrat.tables });
				return result;
			}
			if (cacheStrat.type === "try") {
				const { tables, key, isTag, autoInvalidate, config } = cacheStrat;
				const fromCache = yield* cache.get(key, tables, isTag, autoInvalidate);
				if (typeof fromCache !== "undefined") return fromCache;
				const result = yield* query;
				yield* cache.put(key, result, autoInvalidate ? tables : [], isTag, config);
				return result;
			}
			assertUnreachable(cacheStrat);
		}).pipe(Effect.catchAll((e) => {
			return Effect.fail(new TaggedDrizzleQueryError(queryString, params, e instanceof Error ? e : void 0));
		}));
	}
};
var PgEffectSession = class extends PgSession {
	static [entityKind] = "PgEffectSession";
	constructor(dialect) {
		super(dialect);
	}
	execute(query) {
		const { sql: sql$1, params } = this.dialect.sqlToQuery(query);
		return this.prepareQuery({
			sql: sql$1,
			params
		}, void 0, void 0, false).execute();
	}
	all(query) {
		const { sql: sql$1, params } = this.dialect.sqlToQuery(query);
		return this.prepareQuery({
			sql: sql$1,
			params
		}, void 0, void 0, false).all();
	}
};
var PgEffectTransaction = class extends PgEffectDatabase {
	static [entityKind] = "PgEffectTransaction";
	constructor(dialect, session, relations, schema, nestedIndex = 0, parseRqbJson) {
		super(dialect, session, relations, schema, parseRqbJson);
		this.relations = relations;
		this.schema = schema;
		this.nestedIndex = nestedIndex;
	}
	rollback() {
		return Effect.fail(new TaggedTransactionRollbackError());
	}
	/** @internal */
	getTransactionConfigSQL(config) {
		const chunks = [];
		if (config.isolationLevel) chunks.push(`isolation level ${config.isolationLevel}`);
		if (config.accessMode) chunks.push(config.accessMode);
		if (typeof config.deferrable === "boolean") chunks.push(config.deferrable ? "deferrable" : "not deferrable");
		return sql.raw(chunks.join(" "));
	}
	setTransaction(config) {
		return this.session.execute(sql`set transaction ${this.getTransactionConfigSQL(config)}`);
	}
};
function migrate(migrations, session, config) {
	return Effect.gen(function* () {
		const migrationsTable = typeof config === "string" ? "__drizzle_migrations" : config.migrationsTable ?? "__drizzle_migrations";
		const migrationsSchema = typeof config === "string" ? "drizzle" : config.migrationsSchema ?? "drizzle";
		const migrationTableCreate = sql`
			CREATE TABLE IF NOT EXISTS ${sql.identifier(migrationsSchema)}.${sql.identifier(migrationsTable)} (
				id SERIAL PRIMARY KEY,
				hash text NOT NULL,
				created_at bigint
			)
		`;
		yield* session.execute(sql`CREATE SCHEMA IF NOT EXISTS ${sql.identifier(migrationsSchema)}`);
		yield* session.execute(migrationTableCreate);
		const dbMigrations = yield* session.all(sql`select id, hash, created_at from ${sql.identifier(migrationsSchema)}.${sql.identifier(migrationsTable)} order by created_at desc limit 1`);
		if (typeof config === "object" && config.init) {
			if (dbMigrations.length) return { exitCode: "databaseMigrations" };
			if (migrations.length > 1) return { exitCode: "localMigrations" };
			const [migration] = migrations;
			if (!migration) return;
			yield* session.execute(sql`insert into ${sql.identifier(migrationsSchema)}.${sql.identifier(migrationsTable)} ("hash", "created_at") values(${migration.hash}, ${migration.folderMillis})`);
			return;
		}
		const lastDbMigration = dbMigrations[0];
		yield* session.transaction((tx) => Effect.gen(function* () {
			for (const migration of migrations) if (!lastDbMigration || Number(lastDbMigration.created_at) < migration.folderMillis) {
				for (const stmt of migration.sql) yield* tx.execute(sql.raw(stmt));
				yield* tx.execute(sql`insert into ${sql.identifier(migrationsSchema)}.${sql.identifier(migrationsTable)} ("hash", "created_at") values(${migration.hash}, ${migration.folderMillis})`);
			}
		}));
	});
}

//#endregion
export { PgEffectPreparedQuery, PgEffectSession, PgEffectTransaction, migrate };
//# sourceMappingURL=session.js.map