{"version":3,"file":"select.cjs","names":["entityKind","fields: SelectedFields","Subquery","SQL","TypedQueryBuilder","extractUsedTable","Table","SelectionProxyHandler","usedTables: string[]","QueryPromise"],"sources":["../../../src/singlestore-core/query-builders/select.ts"],"sourcesContent":["import type { CacheConfig, WithCacheConfig } from '~/cache/core/types.ts';\nimport { entityKind, is } from '~/entity.ts';\nimport { TypedQueryBuilder } from '~/query-builders/query-builder.ts';\nimport type {\n\tBuildSubquerySelection,\n\tGetSelectTableName,\n\tGetSelectTableSelection,\n\tJoinNullability,\n\tJoinType,\n\tSelectMode,\n\tSelectResult,\n\tSetOperator,\n} from '~/query-builders/select.types.ts';\nimport { QueryPromise } from '~/query-promise.ts';\nimport { SelectionProxyHandler } from '~/selection-proxy.ts';\nimport type { SingleStoreColumn } from '~/singlestore-core/columns/index.ts';\nimport type { SingleStoreDialect } from '~/singlestore-core/dialect.ts';\nimport type {\n\tPreparedQueryHKTBase,\n\tSingleStorePreparedQueryConfig,\n\tSingleStoreSession,\n} from '~/singlestore-core/session.ts';\nimport type { SubqueryWithSelection } from '~/singlestore-core/subquery.ts';\nimport type { SingleStoreTable } from '~/singlestore-core/table.ts';\nimport type { ColumnsSelection, Query } from '~/sql/sql.ts';\nimport { SQL } from '~/sql/sql.ts';\nimport { Subquery } from '~/subquery.ts';\nimport { Table } from '~/table.ts';\nimport {\n\tapplyMixins,\n\tgetTableColumns,\n\tgetTableLikeName,\n\thaveSameKeys,\n\torderSelectedFields,\n\ttype ValueOrArray,\n} from '~/utils.ts';\nimport { extractUsedTable } from '../utils.ts';\nimport type {\n\tAnySingleStoreSelect,\n\tCreateSingleStoreSelectFromBuilderMode,\n\tGetSingleStoreSetOperators,\n\tLockConfig,\n\tLockStrength,\n\tSelectedFields,\n\tSetOperatorRightSelect,\n\tSingleStoreCreateSetOperatorFn,\n\tSingleStoreCrossJoinFn,\n\tSingleStoreJoinFn,\n\tSingleStoreSelectConfig,\n\tSingleStoreSelectDynamic,\n\tSingleStoreSelectHKT,\n\tSingleStoreSelectHKTBase,\n\tSingleStoreSelectPrepare,\n\tSingleStoreSelectWithout,\n\tSingleStoreSetOperatorExcludedMethods,\n\tSingleStoreSetOperatorWithResult,\n} from './select.types.ts';\n\nexport class SingleStoreSelectBuilder<\n\tTSelection extends SelectedFields | undefined,\n\tTPreparedQueryHKT extends PreparedQueryHKTBase,\n\tTBuilderMode extends 'db' | 'qb' = 'db',\n> {\n\tstatic readonly [entityKind]: string = 'SingleStoreSelectBuilder';\n\n\tprivate fields: TSelection;\n\tprivate session: SingleStoreSession | undefined;\n\tprivate dialect: SingleStoreDialect;\n\tprivate withList: Subquery[] = [];\n\tprivate distinct: boolean | undefined;\n\n\tconstructor(\n\t\tconfig: {\n\t\t\tfields: TSelection;\n\t\t\tsession: SingleStoreSession | undefined;\n\t\t\tdialect: SingleStoreDialect;\n\t\t\twithList?: Subquery[];\n\t\t\tdistinct?: boolean;\n\t\t},\n\t) {\n\t\tthis.fields = config.fields;\n\t\tthis.session = config.session;\n\t\tthis.dialect = config.dialect;\n\t\tif (config.withList) {\n\t\t\tthis.withList = config.withList;\n\t\t}\n\t\tthis.distinct = config.distinct;\n\t}\n\n\tfrom<TFrom extends SingleStoreTable | Subquery | SQL>( // | SingleStoreViewBase\n\t\tsource: TFrom,\n\t): CreateSingleStoreSelectFromBuilderMode<\n\t\tTBuilderMode,\n\t\tGetSelectTableName<TFrom>,\n\t\tTSelection extends undefined ? GetSelectTableSelection<TFrom> : TSelection,\n\t\tTSelection extends undefined ? 'single' : 'partial',\n\t\tTPreparedQueryHKT\n\t> {\n\t\tconst isPartialSelect = !!this.fields;\n\n\t\tlet fields: SelectedFields;\n\t\tif (this.fields) {\n\t\t\tfields = this.fields;\n\t\t} else if (is(source, Subquery)) {\n\t\t\t// This is required to use the proxy handler to get the correct field values from the subquery\n\t\t\tfields = Object.fromEntries(\n\t\t\t\tObject.keys(source._.selectedFields).map((\n\t\t\t\t\tkey,\n\t\t\t\t) => [key, source[key as unknown as keyof typeof source] as unknown as SelectedFields[string]]),\n\t\t\t);\n\t\t\t/* } else if (is(source, SingleStoreViewBase)) {\n\t\t\tfields = source[ViewBaseConfig].selectedFields as SelectedFields; */\n\t\t} else if (is(source, SQL)) {\n\t\t\tfields = {};\n\t\t} else {\n\t\t\tfields = getTableColumns<SingleStoreTable>(source);\n\t\t}\n\n\t\treturn new SingleStoreSelectBase(\n\t\t\t{\n\t\t\t\ttable: source,\n\t\t\t\tfields,\n\t\t\t\tisPartialSelect,\n\t\t\t\tsession: this.session,\n\t\t\t\tdialect: this.dialect,\n\t\t\t\twithList: this.withList,\n\t\t\t\tdistinct: this.distinct,\n\t\t\t},\n\t\t) as any;\n\t}\n}\n\nexport abstract class SingleStoreSelectQueryBuilderBase<\n\tTHKT extends SingleStoreSelectHKTBase,\n\tTTableName extends string | undefined,\n\tTSelection extends ColumnsSelection,\n\tTSelectMode extends SelectMode,\n\tTPreparedQueryHKT extends PreparedQueryHKTBase,\n\tTNullabilityMap extends Record<string, JoinNullability> = TTableName extends string ? Record<TTableName, 'not-null'>\n\t\t: {},\n\tTDynamic extends boolean = false,\n\tTExcludedMethods extends string = never,\n\tTResult extends any[] = SelectResult<TSelection, TSelectMode, TNullabilityMap>[],\n\tTSelectedFields extends ColumnsSelection = BuildSubquerySelection<TSelection, TNullabilityMap>,\n> extends TypedQueryBuilder<TSelectedFields, TResult> {\n\tstatic override readonly [entityKind]: string = 'SingleStoreSelectQueryBuilder';\n\n\toverride readonly _: {\n\t\treadonly hkt: THKT;\n\t\treadonly tableName: TTableName;\n\t\treadonly selection: TSelection;\n\t\treadonly selectMode: TSelectMode;\n\t\treadonly preparedQueryHKT: TPreparedQueryHKT;\n\t\treadonly nullabilityMap: TNullabilityMap;\n\t\treadonly dynamic: TDynamic;\n\t\treadonly excludedMethods: TExcludedMethods;\n\t\treadonly result: TResult;\n\t\treadonly selectedFields: TSelectedFields;\n\t\treadonly config: SingleStoreSelectConfig;\n\t};\n\n\tprotected config: SingleStoreSelectConfig;\n\tprotected joinsNotNullableMap: Record<string, boolean>;\n\tprivate tableName: string | undefined;\n\tprivate isPartialSelect: boolean;\n\t/** @internal */\n\treadonly session: SingleStoreSession | undefined;\n\tprotected dialect: SingleStoreDialect;\n\tprotected cacheConfig?: WithCacheConfig = undefined;\n\tprotected usedTables: Set<string> = new Set();\n\n\tconstructor(\n\t\t{ table, fields, isPartialSelect, session, dialect, withList, distinct }: {\n\t\t\ttable: SingleStoreSelectConfig['table'];\n\t\t\tfields: SingleStoreSelectConfig['fields'];\n\t\t\tisPartialSelect: boolean;\n\t\t\tsession: SingleStoreSession | undefined;\n\t\t\tdialect: SingleStoreDialect;\n\t\t\twithList: Subquery[];\n\t\t\tdistinct: boolean | undefined;\n\t\t},\n\t) {\n\t\tsuper();\n\t\tthis.config = {\n\t\t\twithList,\n\t\t\ttable,\n\t\t\tfields: { ...fields },\n\t\t\tdistinct,\n\t\t\tsetOperators: [],\n\t\t};\n\t\tthis.isPartialSelect = isPartialSelect;\n\t\tthis.session = session;\n\t\tthis.dialect = dialect;\n\t\tthis._ = {\n\t\t\tselectedFields: fields as TSelectedFields,\n\t\t\tconfig: this.config,\n\t\t} as this['_'];\n\t\tthis.tableName = getTableLikeName(table);\n\t\tthis.joinsNotNullableMap = typeof this.tableName === 'string' ? { [this.tableName]: true } : {};\n\t\tfor (const item of extractUsedTable(table)) this.usedTables.add(item);\n\t}\n\n\t/** @internal */\n\tgetUsedTables() {\n\t\treturn [...this.usedTables];\n\t}\n\n\tprivate createJoin<\n\t\tTJoinType extends JoinType,\n\t\tTIsLateral extends (TJoinType extends 'full' | 'right' ? false : boolean),\n\t>(\n\t\tjoinType: TJoinType,\n\t\tlateral: TIsLateral,\n\t): 'cross' extends TJoinType ? SingleStoreCrossJoinFn<this, TDynamic, TIsLateral>\n\t\t: SingleStoreJoinFn<this, TDynamic, TJoinType, TIsLateral>\n\t{\n\t\treturn (\n\t\t\ttable: SingleStoreTable | Subquery | SQL, // | SingleStoreViewBase\n\t\t\ton?: ((aliases: TSelection) => SQL | undefined) | SQL | undefined,\n\t\t) => {\n\t\t\tconst baseTableName = this.tableName;\n\t\t\tconst tableName = getTableLikeName(table);\n\n\t\t\t// store all tables used in a query\n\t\t\tfor (const item of extractUsedTable(table)) this.usedTables.add(item);\n\n\t\t\tif (typeof tableName === 'string' && this.config.joins?.some((join) => join.alias === tableName)) {\n\t\t\t\tthrow new Error(`Alias \"${tableName}\" is already used in this query`);\n\t\t\t}\n\n\t\t\tif (!this.isPartialSelect) {\n\t\t\t\t// If this is the first join and this is not a partial select and we're not selecting from raw SQL, \"move\" the fields from the main table to the nested object\n\t\t\t\tif (Object.keys(this.joinsNotNullableMap).length === 1 && typeof baseTableName === 'string') {\n\t\t\t\t\tthis.config.fields = {\n\t\t\t\t\t\t[baseTableName]: this.config.fields,\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\tif (typeof tableName === 'string' && !is(table, SQL)) {\n\t\t\t\t\tconst selection = is(table, Subquery)\n\t\t\t\t\t\t? table._.selectedFields\n\t\t\t\t\t\t/* : is(table, View)\n\t\t\t\t\t\t? table[ViewBaseConfig].selectedFields */\n\t\t\t\t\t\t: table[Table.Symbol.Columns];\n\t\t\t\t\tthis.config.fields[tableName] = selection;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (typeof on === 'function') {\n\t\t\t\ton = on(\n\t\t\t\t\tnew Proxy(\n\t\t\t\t\t\tthis.config.fields,\n\t\t\t\t\t\tnew SelectionProxyHandler({ sqlAliasedBehavior: 'sql', sqlBehavior: 'sql' }),\n\t\t\t\t\t) as TSelection,\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tif (!this.config.joins) {\n\t\t\t\tthis.config.joins = [];\n\t\t\t}\n\n\t\t\tthis.config.joins.push({ on, table, joinType, alias: tableName, lateral });\n\n\t\t\tif (typeof tableName === 'string') {\n\t\t\t\tswitch (joinType) {\n\t\t\t\t\tcase 'left': {\n\t\t\t\t\t\tthis.joinsNotNullableMap[tableName] = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcase 'right': {\n\t\t\t\t\t\tthis.joinsNotNullableMap = Object.fromEntries(\n\t\t\t\t\t\t\tObject.entries(this.joinsNotNullableMap).map(([key]) => [key, false]),\n\t\t\t\t\t\t);\n\t\t\t\t\t\tthis.joinsNotNullableMap[tableName] = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcase 'cross':\n\t\t\t\t\tcase 'inner': {\n\t\t\t\t\t\tthis.joinsNotNullableMap[tableName] = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcase 'full': {\n\t\t\t\t\t\tthis.joinsNotNullableMap = Object.fromEntries(\n\t\t\t\t\t\t\tObject.entries(this.joinsNotNullableMap).map(([key]) => [key, false]),\n\t\t\t\t\t\t);\n\t\t\t\t\t\tthis.joinsNotNullableMap[tableName] = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn this as any;\n\t\t};\n\t}\n\n\t/**\n\t * Executes a `left join` operation by adding another table to the current query.\n\t *\n\t * Calling this method associates each row of the table with the corresponding row from the joined table, if a match is found. If no matching row exists, it sets all columns of the joined table to null.\n\t *\n\t * See docs: {@link https://orm.drizzle.team/docs/joins#left-join}\n\t *\n\t * @param table the table to join.\n\t * @param on the `on` clause.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * // Select all users and their pets\n\t * const usersWithPets: { user: User; pets: Pet | null; }[] = await db.select()\n\t *   .from(users)\n\t *   .leftJoin(pets, eq(users.id, pets.ownerId))\n\t *\n\t * // Select userId and petId\n\t * const usersIdsAndPetIds: { userId: number; petId: number | null; }[] = await db.select({\n\t *   userId: users.id,\n\t *   petId: pets.id,\n\t * })\n\t *   .from(users)\n\t *   .leftJoin(pets, eq(users.id, pets.ownerId))\n\t * ```\n\t */\n\tleftJoin = this.createJoin('left', false);\n\n\t/**\n\t * Executes a `left join lateral` operation by adding subquery to the current query.\n\t *\n\t * A `lateral` join allows the right-hand expression to refer to columns from the left-hand side.\n\t *\n\t * Calling this method associates each row of the table with the corresponding row from the joined table, if a match is found. If no matching row exists, it sets all columns of the joined table to null.\n\t *\n\t * See docs: {@link https://orm.drizzle.team/docs/joins#left-join-lateral}\n\t *\n\t * @param table the subquery to join.\n\t * @param on the `on` clause.\n\t */\n\tleftJoinLateral = this.createJoin('left', true);\n\n\t/**\n\t * Executes a `right join` operation by adding another table to the current query.\n\t *\n\t * Calling this method associates each row of the joined table with the corresponding row from the main table, if a match is found. If no matching row exists, it sets all columns of the main table to null.\n\t *\n\t * See docs: {@link https://orm.drizzle.team/docs/joins#right-join}\n\t *\n\t * @param table the table to join.\n\t * @param on the `on` clause.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * // Select all users and their pets\n\t * const usersWithPets: { user: User | null; pets: Pet; }[] = await db.select()\n\t *   .from(users)\n\t *   .rightJoin(pets, eq(users.id, pets.ownerId))\n\t *\n\t * // Select userId and petId\n\t * const usersIdsAndPetIds: { userId: number | null; petId: number; }[] = await db.select({\n\t *   userId: users.id,\n\t *   petId: pets.id,\n\t * })\n\t *   .from(users)\n\t *   .rightJoin(pets, eq(users.id, pets.ownerId))\n\t * ```\n\t */\n\trightJoin = this.createJoin('right', false);\n\n\t/**\n\t * Executes an `inner join` operation, creating a new table by combining rows from two tables that have matching values.\n\t *\n\t * Calling this method retrieves rows that have corresponding entries in both joined tables. Rows without matching entries in either table are excluded, resulting in a table that includes only matching pairs.\n\t *\n\t * See docs: {@link https://orm.drizzle.team/docs/joins#inner-join}\n\t *\n\t * @param table the table to join.\n\t * @param on the `on` clause.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * // Select all users and their pets\n\t * const usersWithPets: { user: User; pets: Pet; }[] = await db.select()\n\t *   .from(users)\n\t *   .innerJoin(pets, eq(users.id, pets.ownerId))\n\t *\n\t * // Select userId and petId\n\t * const usersIdsAndPetIds: { userId: number; petId: number; }[] = await db.select({\n\t *   userId: users.id,\n\t *   petId: pets.id,\n\t * })\n\t *   .from(users)\n\t *   .innerJoin(pets, eq(users.id, pets.ownerId))\n\t * ```\n\t */\n\tinnerJoin = this.createJoin('inner', false);\n\n\t/**\n\t * Executes an `inner join lateral` operation, creating a new table by combining rows from two queries that have matching values.\n\t *\n\t * A `lateral` join allows the right-hand expression to refer to columns from the left-hand side.\n\t *\n\t * Calling this method retrieves rows that have corresponding entries in both joined tables. Rows without matching entries in either table are excluded, resulting in a table that includes only matching pairs.\n\t *\n\t * See docs: {@link https://orm.drizzle.team/docs/joins#inner-join-lateral}\n\t *\n\t * @param table the subquery to join.\n\t * @param on the `on` clause.\n\t */\n\tinnerJoinLateral = this.createJoin('inner', true);\n\n\t/**\n\t * Executes a `full join` operation by combining rows from two tables into a new table.\n\t *\n\t * Calling this method retrieves all rows from both main and joined tables, merging rows with matching values and filling in `null` for non-matching columns.\n\t *\n\t * See docs: {@link https://orm.drizzle.team/docs/joins#full-join}\n\t *\n\t * @param table the table to join.\n\t * @param on the `on` clause.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * // Select all users and their pets\n\t * const usersWithPets: { user: User | null; pets: Pet | null; }[] = await db.select()\n\t *   .from(users)\n\t *   .fullJoin(pets, eq(users.id, pets.ownerId))\n\t *\n\t * // Select userId and petId\n\t * const usersIdsAndPetIds: { userId: number | null; petId: number | null; }[] = await db.select({\n\t *   userId: users.id,\n\t *   petId: pets.id,\n\t * })\n\t *   .from(users)\n\t *   .fullJoin(pets, eq(users.id, pets.ownerId))\n\t * ```\n\t */\n\tfullJoin = this.createJoin('full', false);\n\n\t/**\n\t * Executes a `cross join` operation by combining rows from two tables into a new table.\n\t *\n\t * Calling this method retrieves all rows from both main and joined tables, merging all rows from each table.\n\t *\n\t * See docs: {@link https://orm.drizzle.team/docs/joins#cross-join}\n\t *\n\t * @param table the table to join.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * // Select all users, each user with every pet\n\t * const usersWithPets: { user: User; pets: Pet; }[] = await db.select()\n\t *   .from(users)\n\t *   .crossJoin(pets)\n\t *\n\t * // Select userId and petId\n\t * const usersIdsAndPetIds: { userId: number; petId: number; }[] = await db.select({\n\t *   userId: users.id,\n\t *   petId: pets.id,\n\t * })\n\t *   .from(users)\n\t *   .crossJoin(pets)\n\t * ```\n\t */\n\tcrossJoin = this.createJoin('cross', false);\n\n\t/**\n\t * Executes a `cross join lateral` operation by combining rows from two queries into a new table.\n\t *\n\t * A `lateral` join allows the right-hand expression to refer to columns from the left-hand side.\n\t *\n\t * Calling this method retrieves all rows from both main and joined queries, merging all rows from each query.\n\t *\n\t * See docs: {@link https://orm.drizzle.team/docs/joins#cross-join-lateral}\n\t *\n\t * @param table the query to join.\n\t */\n\tcrossJoinLateral = this.createJoin('cross', true);\n\n\tprivate createSetOperator(\n\t\ttype: SetOperator,\n\t\tisAll: boolean,\n\t): <TValue extends SingleStoreSetOperatorWithResult<TResult>>(\n\t\trightSelection:\n\t\t\t| ((setOperators: GetSingleStoreSetOperators) => SetOperatorRightSelect<TValue, TResult>)\n\t\t\t| SetOperatorRightSelect<TValue, TResult>,\n\t) => SingleStoreSelectWithout<\n\t\tthis,\n\t\tTDynamic,\n\t\tSingleStoreSetOperatorExcludedMethods,\n\t\ttrue\n\t> {\n\t\treturn (rightSelection) => {\n\t\t\tconst rightSelect = (typeof rightSelection === 'function'\n\t\t\t\t? rightSelection(getSingleStoreSetOperators())\n\t\t\t\t: rightSelection) as TypedQueryBuilder<\n\t\t\t\t\tany,\n\t\t\t\t\tTResult\n\t\t\t\t>;\n\n\t\t\tif (!haveSameKeys(this.getSelectedFields(), rightSelect.getSelectedFields())) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t'Set operator error (union / intersect / except): selected fields are not the same or are in a different order',\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tthis.config.setOperators.push({ type, isAll, rightSelect });\n\t\t\treturn this as any;\n\t\t};\n\t}\n\n\t/**\n\t * Adds `union` set operator to the query.\n\t *\n\t * Calling this method will combine the result sets of the `select` statements and remove any duplicate rows that appear across them.\n\t *\n\t * See docs: {@link https://orm.drizzle.team/docs/set-operations#union}\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * // Select all unique names from customers and users tables\n\t * await db.select({ name: users.name })\n\t *   .from(users)\n\t *   .union(\n\t *     db.select({ name: customers.name }).from(customers)\n\t *   );\n\t * // or\n\t * import { union } from 'drizzle-orm/singlestore-core'\n\t *\n\t * await union(\n\t *   db.select({ name: users.name }).from(users),\n\t *   db.select({ name: customers.name }).from(customers)\n\t * );\n\t * ```\n\t */\n\tunion = this.createSetOperator('union', false);\n\n\t/**\n\t * Adds `union all` set operator to the query.\n\t *\n\t * Calling this method will combine the result-set of the `select` statements and keep all duplicate rows that appear across them.\n\t *\n\t * See docs: {@link https://orm.drizzle.team/docs/set-operations#union-all}\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * // Select all transaction ids from both online and in-store sales\n\t * await db.select({ transaction: onlineSales.transactionId })\n\t *   .from(onlineSales)\n\t *   .unionAll(\n\t *     db.select({ transaction: inStoreSales.transactionId }).from(inStoreSales)\n\t *   );\n\t * // or\n\t * import { unionAll } from 'drizzle-orm/singlestore-core'\n\t *\n\t * await unionAll(\n\t *   db.select({ transaction: onlineSales.transactionId }).from(onlineSales),\n\t *   db.select({ transaction: inStoreSales.transactionId }).from(inStoreSales)\n\t * );\n\t * ```\n\t */\n\tunionAll = this.createSetOperator('union', true);\n\n\t/**\n\t * Adds `intersect` set operator to the query.\n\t *\n\t * Calling this method will retain only the rows that are present in both result sets and eliminate duplicates.\n\t *\n\t * See docs: {@link https://orm.drizzle.team/docs/set-operations#intersect}\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * // Select course names that are offered in both departments A and B\n\t * await db.select({ courseName: depA.courseName })\n\t *   .from(depA)\n\t *   .intersect(\n\t *     db.select({ courseName: depB.courseName }).from(depB)\n\t *   );\n\t * // or\n\t * import { intersect } from 'drizzle-orm/singlestore-core'\n\t *\n\t * await intersect(\n\t *   db.select({ courseName: depA.courseName }).from(depA),\n\t *   db.select({ courseName: depB.courseName }).from(depB)\n\t * );\n\t * ```\n\t */\n\tintersect = this.createSetOperator('intersect', false);\n\n\t/**\n\t * Adds `except` set operator to the query.\n\t *\n\t * Calling this method will retrieve all unique rows from the left query, except for the rows that are present in the result set of the right query.\n\t *\n\t * See docs: {@link https://orm.drizzle.team/docs/set-operations#except}\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * // Select all courses offered in department A but not in department B\n\t * await db.select({ courseName: depA.courseName })\n\t *   .from(depA)\n\t *   .except(\n\t *     db.select({ courseName: depB.courseName }).from(depB)\n\t *   );\n\t * // or\n\t * import { except } from 'drizzle-orm/singlestore-core'\n\t *\n\t * await except(\n\t *   db.select({ courseName: depA.courseName }).from(depA),\n\t *   db.select({ courseName: depB.courseName }).from(depB)\n\t * );\n\t * ```\n\t */\n\texcept = this.createSetOperator('except', false);\n\n\t/**\n\t * Adds `minus` set operator to the query.\n\t *\n\t * This is an alias of `except` supported by SingleStore.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * // Select all courses offered in department A but not in department B\n\t * await db.select({ courseName: depA.courseName })\n\t *   .from(depA)\n\t *   .minus(\n\t *     db.select({ courseName: depB.courseName }).from(depB)\n\t *   );\n\t * // or\n\t * import { minus } from 'drizzle-orm/singlestore-core'\n\t *\n\t * await minus(\n\t *   db.select({ courseName: depA.courseName }).from(depA),\n\t *   db.select({ courseName: depB.courseName }).from(depB)\n\t * );\n\t * ```\n\t */\n\tminus = this.createSetOperator('except', false);\n\n\t/** @internal */\n\taddSetOperators(setOperators: SingleStoreSelectConfig['setOperators']): SingleStoreSelectWithout<\n\t\tthis,\n\t\tTDynamic,\n\t\tSingleStoreSetOperatorExcludedMethods,\n\t\ttrue\n\t> {\n\t\tthis.config.setOperators.push(...setOperators);\n\t\treturn this as any;\n\t}\n\n\t/**\n\t * Adds a `where` clause to the query.\n\t *\n\t * Calling this method will select only those rows that fulfill a specified condition.\n\t *\n\t * See docs: {@link https://orm.drizzle.team/docs/select#filtering}\n\t *\n\t * @param where the `where` clause.\n\t *\n\t * @example\n\t * You can use conditional operators and `sql function` to filter the rows to be selected.\n\t *\n\t * ```ts\n\t * // Select all cars with green color\n\t * await db.select().from(cars).where(eq(cars.color, 'green'));\n\t * // or\n\t * await db.select().from(cars).where(sql`${cars.color} = 'green'`)\n\t * ```\n\t *\n\t * You can logically combine conditional operators with `and()` and `or()` operators:\n\t *\n\t * ```ts\n\t * // Select all BMW cars with a green color\n\t * await db.select().from(cars).where(and(eq(cars.color, 'green'), eq(cars.brand, 'BMW')));\n\t *\n\t * // Select all cars with the green or blue color\n\t * await db.select().from(cars).where(or(eq(cars.color, 'green'), eq(cars.color, 'blue')));\n\t * ```\n\t */\n\twhere(\n\t\twhere: ((aliases: this['_']['selection']) => SQL | undefined) | SQL | undefined,\n\t): SingleStoreSelectWithout<this, TDynamic, 'where'> {\n\t\tif (typeof where === 'function') {\n\t\t\twhere = where(\n\t\t\t\tnew Proxy(\n\t\t\t\t\tthis.config.fields,\n\t\t\t\t\tnew SelectionProxyHandler({ sqlAliasedBehavior: 'sql', sqlBehavior: 'sql' }),\n\t\t\t\t) as TSelection,\n\t\t\t);\n\t\t}\n\t\tthis.config.where = where;\n\t\treturn this as any;\n\t}\n\n\t/**\n\t * Adds a `having` clause to the query.\n\t *\n\t * Calling this method will select only those rows that fulfill a specified condition. It is typically used with aggregate functions to filter the aggregated data based on a specified condition.\n\t *\n\t * See docs: {@link https://orm.drizzle.team/docs/select#aggregations}\n\t *\n\t * @param having the `having` clause.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * // Select all brands with more than one car\n\t * await db.select({\n\t * \tbrand: cars.brand,\n\t * \tcount: sql<number>`cast(count(${cars.id}) as int)`,\n\t * })\n\t *   .from(cars)\n\t *   .groupBy(cars.brand)\n\t *   .having(({ count }) => gt(count, 1));\n\t * ```\n\t */\n\thaving(\n\t\thaving: ((aliases: this['_']['selection']) => SQL | undefined) | SQL | undefined,\n\t): SingleStoreSelectWithout<this, TDynamic, 'having'> {\n\t\tif (typeof having === 'function') {\n\t\t\thaving = having(\n\t\t\t\tnew Proxy(\n\t\t\t\t\tthis.config.fields,\n\t\t\t\t\tnew SelectionProxyHandler({ sqlAliasedBehavior: 'sql', sqlBehavior: 'sql' }),\n\t\t\t\t) as TSelection,\n\t\t\t);\n\t\t}\n\t\tthis.config.having = having;\n\t\treturn this as any;\n\t}\n\n\t/**\n\t * Adds a `group by` clause to the query.\n\t *\n\t * Calling this method will group rows that have the same values into summary rows, often used for aggregation purposes.\n\t *\n\t * See docs: {@link https://orm.drizzle.team/docs/select#aggregations}\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * // Group and count people by their last names\n\t * await db.select({\n\t *    lastName: people.lastName,\n\t *    count: sql<number>`cast(count(*) as int)`\n\t * })\n\t *   .from(people)\n\t *   .groupBy(people.lastName);\n\t * ```\n\t */\n\tgroupBy(\n\t\tbuilder: (aliases: this['_']['selection']) => ValueOrArray<SingleStoreColumn | SQL | SQL.Aliased>,\n\t): SingleStoreSelectWithout<this, TDynamic, 'groupBy'>;\n\tgroupBy(...columns: (SingleStoreColumn | SQL | SQL.Aliased)[]): SingleStoreSelectWithout<this, TDynamic, 'groupBy'>;\n\tgroupBy(\n\t\t...columns:\n\t\t\t| [(aliases: this['_']['selection']) => ValueOrArray<SingleStoreColumn | SQL | SQL.Aliased>]\n\t\t\t| (SingleStoreColumn | SQL | SQL.Aliased)[]\n\t): SingleStoreSelectWithout<this, TDynamic, 'groupBy'> {\n\t\tif (typeof columns[0] === 'function') {\n\t\t\tconst groupBy = columns[0](\n\t\t\t\tnew Proxy(\n\t\t\t\t\tthis.config.fields,\n\t\t\t\t\tnew SelectionProxyHandler({ sqlAliasedBehavior: 'alias', sqlBehavior: 'sql' }),\n\t\t\t\t) as TSelection,\n\t\t\t);\n\t\t\tthis.config.groupBy = Array.isArray(groupBy) ? groupBy : [groupBy];\n\t\t} else {\n\t\t\tthis.config.groupBy = columns as (SingleStoreColumn | SQL | SQL.Aliased)[];\n\t\t}\n\t\treturn this as any;\n\t}\n\n\t/**\n\t * Adds an `order by` clause to the query.\n\t *\n\t * Calling this method will sort the result-set in ascending or descending order. By default, the sort order is ascending.\n\t *\n\t * See docs: {@link https://orm.drizzle.team/docs/select#order-by}\n\t *\n\t * @example\n\t *\n\t * ```\n\t * // Select cars ordered by year\n\t * await db.select().from(cars).orderBy(cars.year);\n\t * ```\n\t *\n\t * You can specify whether results are in ascending or descending order with the `asc()` and `desc()` operators.\n\t *\n\t * ```ts\n\t * // Select cars ordered by year in descending order\n\t * await db.select().from(cars).orderBy(desc(cars.year));\n\t *\n\t * // Select cars ordered by year and price\n\t * await db.select().from(cars).orderBy(asc(cars.year), desc(cars.price));\n\t * ```\n\t */\n\torderBy(\n\t\tbuilder: (aliases: this['_']['selection']) => ValueOrArray<SingleStoreColumn | SQL | SQL.Aliased>,\n\t): SingleStoreSelectWithout<this, TDynamic, 'orderBy'>;\n\torderBy(...columns: (SingleStoreColumn | SQL | SQL.Aliased)[]): SingleStoreSelectWithout<this, TDynamic, 'orderBy'>;\n\torderBy(\n\t\t...columns:\n\t\t\t| [(aliases: this['_']['selection']) => ValueOrArray<SingleStoreColumn | SQL | SQL.Aliased>]\n\t\t\t| (SingleStoreColumn | SQL | SQL.Aliased)[]\n\t): SingleStoreSelectWithout<this, TDynamic, 'orderBy'> {\n\t\tif (typeof columns[0] === 'function') {\n\t\t\tconst orderBy = columns[0](\n\t\t\t\tnew Proxy(\n\t\t\t\t\tthis.config.fields,\n\t\t\t\t\tnew SelectionProxyHandler({ sqlAliasedBehavior: 'alias', sqlBehavior: 'sql' }),\n\t\t\t\t) as TSelection,\n\t\t\t);\n\n\t\t\tconst orderByArray = Array.isArray(orderBy) ? orderBy : [orderBy];\n\n\t\t\tif (this.config.setOperators.length > 0) {\n\t\t\t\tthis.config.setOperators.at(-1)!.orderBy = orderByArray;\n\t\t\t} else {\n\t\t\t\tthis.config.orderBy = orderByArray;\n\t\t\t}\n\t\t} else {\n\t\t\tconst orderByArray = columns as (SingleStoreColumn | SQL | SQL.Aliased)[];\n\n\t\t\tif (this.config.setOperators.length > 0) {\n\t\t\t\tthis.config.setOperators.at(-1)!.orderBy = orderByArray;\n\t\t\t} else {\n\t\t\t\tthis.config.orderBy = orderByArray;\n\t\t\t}\n\t\t}\n\t\treturn this as any;\n\t}\n\n\t/**\n\t * Adds a `limit` clause to the query.\n\t *\n\t * Calling this method will set the maximum number of rows that will be returned by this query.\n\t *\n\t * See docs: {@link https://orm.drizzle.team/docs/select#limit--offset}\n\t *\n\t * @param limit the `limit` clause.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * // Get the first 10 people from this query.\n\t * await db.select().from(people).limit(10);\n\t * ```\n\t */\n\tlimit(limit: number): SingleStoreSelectWithout<this, TDynamic, 'limit'> {\n\t\tif (this.config.setOperators.length > 0) {\n\t\t\tthis.config.setOperators.at(-1)!.limit = limit;\n\t\t} else {\n\t\t\tthis.config.limit = limit;\n\t\t}\n\t\treturn this as any;\n\t}\n\n\t/**\n\t * Adds an `offset` clause to the query.\n\t *\n\t * Calling this method will skip a number of rows when returning results from this query.\n\t *\n\t * See docs: {@link https://orm.drizzle.team/docs/select#limit--offset}\n\t *\n\t * @param offset the `offset` clause.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * // Get the 10th-20th people from this query.\n\t * await db.select().from(people).offset(10).limit(10);\n\t * ```\n\t */\n\toffset(offset: number): SingleStoreSelectWithout<this, TDynamic, 'offset'> {\n\t\tif (this.config.setOperators.length > 0) {\n\t\t\tthis.config.setOperators.at(-1)!.offset = offset;\n\t\t} else {\n\t\t\tthis.config.offset = offset;\n\t\t}\n\t\treturn this as any;\n\t}\n\n\t/**\n\t * Adds a `for` clause to the query.\n\t *\n\t * Calling this method will specify a lock strength for this query that controls how strictly it acquires exclusive access to the rows being queried.\n\t *\n\t * @param strength the lock strength.\n\t * @param config the lock configuration.\n\t */\n\tfor(strength: LockStrength, config: LockConfig = {}): SingleStoreSelectWithout<this, TDynamic, 'for'> {\n\t\tthis.config.lockingClause = { strength, config };\n\t\treturn this as any;\n\t}\n\n\t/** @internal */\n\tgetSQL(): SQL {\n\t\treturn this.dialect.buildSelectQuery(this.config);\n\t}\n\n\ttoSQL(): Query {\n\t\tconst { typings: _typings, ...rest } = this.dialect.sqlToQuery(this.getSQL());\n\t\treturn rest;\n\t}\n\n\tas<TAlias extends string>(\n\t\talias: TAlias,\n\t): SubqueryWithSelection<this['_']['selectedFields'], TAlias> {\n\t\tconst usedTables: string[] = [];\n\t\tusedTables.push(...extractUsedTable(this.config.table));\n\t\tif (this.config.joins) { for (const it of this.config.joins) usedTables.push(...extractUsedTable(it.table)); }\n\n\t\treturn new Proxy(\n\t\t\tnew Subquery(this.getSQL(), this.config.fields, alias, false, [...new Set(usedTables)]),\n\t\t\tnew SelectionProxyHandler({ alias, sqlAliasedBehavior: 'alias', sqlBehavior: 'error' }),\n\t\t) as SubqueryWithSelection<this['_']['selectedFields'], TAlias>;\n\t}\n\n\t/** @internal */\n\toverride getSelectedFields(): this['_']['selectedFields'] {\n\t\treturn new Proxy(\n\t\t\tthis.config.fields,\n\t\t\tnew SelectionProxyHandler({ alias: this.tableName, sqlAliasedBehavior: 'alias', sqlBehavior: 'error' }),\n\t\t) as this['_']['selectedFields'];\n\t}\n\n\t$dynamic(): SingleStoreSelectDynamic<this> {\n\t\treturn this as any;\n\t}\n}\n\nexport interface SingleStoreSelectBase<\n\tTTableName extends string | undefined,\n\tTSelection extends ColumnsSelection,\n\tTSelectMode extends SelectMode,\n\tTPreparedQueryHKT extends PreparedQueryHKTBase,\n\tTNullabilityMap extends Record<string, JoinNullability> = TTableName extends string ? Record<TTableName, 'not-null'>\n\t\t: {},\n\tTDynamic extends boolean = false,\n\tTExcludedMethods extends string = never,\n\tTResult extends any[] = SelectResult<TSelection, TSelectMode, TNullabilityMap>[],\n\tTSelectedFields extends ColumnsSelection = BuildSubquerySelection<TSelection, TNullabilityMap>,\n> extends\n\tSingleStoreSelectQueryBuilderBase<\n\t\tSingleStoreSelectHKT,\n\t\tTTableName,\n\t\tTSelection,\n\t\tTSelectMode,\n\t\tTPreparedQueryHKT,\n\t\tTNullabilityMap,\n\t\tTDynamic,\n\t\tTExcludedMethods,\n\t\tTResult,\n\t\tTSelectedFields\n\t>,\n\tQueryPromise<TResult>\n{}\n\nexport class SingleStoreSelectBase<\n\tTTableName extends string | undefined,\n\tTSelection,\n\tTSelectMode extends SelectMode,\n\tTPreparedQueryHKT extends PreparedQueryHKTBase,\n\tTNullabilityMap extends Record<string, JoinNullability> = TTableName extends string ? Record<TTableName, 'not-null'>\n\t\t: {},\n\tTDynamic extends boolean = false,\n\tTExcludedMethods extends string = never,\n\tTResult = SelectResult<TSelection, TSelectMode, TNullabilityMap>[],\n\tTSelectedFields = BuildSubquerySelection<TSelection, TNullabilityMap>,\n> extends SingleStoreSelectQueryBuilderBase<\n\tSingleStoreSelectHKT,\n\tTTableName,\n\tTSelection,\n\tTSelectMode,\n\tTPreparedQueryHKT,\n\tTNullabilityMap,\n\tTDynamic,\n\tTExcludedMethods,\n\tTResult,\n\tTSelectedFields\n> {\n\tstatic override readonly [entityKind]: string = 'SingleStoreSelect';\n\n\tprepare(): SingleStoreSelectPrepare<this> {\n\t\tif (!this.session) {\n\t\t\tthrow new Error('Cannot execute a query on a query builder. Please use a database instance instead.');\n\t\t}\n\t\tconst fieldsList = orderSelectedFields<SingleStoreColumn>(this.config.fields);\n\t\tconst query = this.session.prepareQuery<\n\t\t\tSingleStorePreparedQueryConfig & { execute: SelectResult<TSelection, TSelectMode, TNullabilityMap>[] },\n\t\t\tTPreparedQueryHKT\n\t\t>(this.dialect.sqlToQuery(this.getSQL()), fieldsList, undefined, undefined, undefined, {\n\t\t\ttype: 'select',\n\t\t\ttables: [...this.usedTables],\n\t\t}, this.cacheConfig);\n\t\tquery.joinsNotNullableMap = this.joinsNotNullableMap;\n\t\treturn query as SingleStoreSelectPrepare<this>;\n\t}\n\n\t$withCache(config?: { config?: CacheConfig; tag?: string; autoInvalidate?: boolean } | false) {\n\t\tthis.cacheConfig = config === undefined\n\t\t\t? { config: {}, enabled: true, autoInvalidate: true }\n\t\t\t: config === false\n\t\t\t? { enabled: false }\n\t\t\t: { enabled: true, autoInvalidate: true, ...config };\n\t\treturn this;\n\t}\n\n\texecute = ((placeholderValues) => {\n\t\treturn this.prepare().execute(placeholderValues);\n\t}) as ReturnType<this['prepare']>['execute'];\n\n\tprivate createIterator = (): ReturnType<this['prepare']>['iterator'] => {\n\t\tconst self = this;\n\t\treturn async function*(placeholderValues) {\n\t\t\tyield* self.prepare().iterator(placeholderValues);\n\t\t};\n\t};\n\n\titerator = this.createIterator();\n}\n\napplyMixins(SingleStoreSelectBase, [QueryPromise]);\n\nfunction createSetOperator(type: SetOperator, isAll: boolean): SingleStoreCreateSetOperatorFn {\n\treturn (leftSelect, rightSelect, ...restSelects) => {\n\t\tconst setOperators = [rightSelect, ...restSelects].map((select) => ({\n\t\t\ttype,\n\t\t\tisAll,\n\t\t\trightSelect: select as AnySingleStoreSelect,\n\t\t}));\n\n\t\tfor (const setOperator of setOperators) {\n\t\t\tif (!haveSameKeys((leftSelect as any).getSelectedFields(), setOperator.rightSelect.getSelectedFields())) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t'Set operator error (union / intersect / except): selected fields are not the same or are in a different order',\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\treturn (leftSelect as AnySingleStoreSelect).addSetOperators(setOperators) as any;\n\t};\n}\n\nconst getSingleStoreSetOperators = () => ({\n\tunion,\n\tunionAll,\n\tintersect,\n\texcept,\n\tminus,\n});\n\n/**\n * Adds `union` set operator to the query.\n *\n * Calling this method will combine the result sets of the `select` statements and remove any duplicate rows that appear across them.\n *\n * See docs: {@link https://orm.drizzle.team/docs/set-operations#union}\n *\n * @example\n *\n * ```ts\n * // Select all unique names from customers and users tables\n * import { union } from 'drizzle-orm/singlestore-core'\n *\n * await union(\n *   db.select({ name: users.name }).from(users),\n *   db.select({ name: customers.name }).from(customers)\n * );\n * // or\n * await db.select({ name: users.name })\n *   .from(users)\n *   .union(\n *     db.select({ name: customers.name }).from(customers)\n *   );\n * ```\n */\nexport const union = createSetOperator('union', false);\n\n/**\n * Adds `union all` set operator to the query.\n *\n * Calling this method will combine the result-set of the `select` statements and keep all duplicate rows that appear across them.\n *\n * See docs: {@link https://orm.drizzle.team/docs/set-operations#union-all}\n *\n * @example\n *\n * ```ts\n * // Select all transaction ids from both online and in-store sales\n * import { unionAll } from 'drizzle-orm/singlestore-core'\n *\n * await unionAll(\n *   db.select({ transaction: onlineSales.transactionId }).from(onlineSales),\n *   db.select({ transaction: inStoreSales.transactionId }).from(inStoreSales)\n * );\n * // or\n * await db.select({ transaction: onlineSales.transactionId })\n *   .from(onlineSales)\n *   .unionAll(\n *     db.select({ transaction: inStoreSales.transactionId }).from(inStoreSales)\n *   );\n * ```\n */\nexport const unionAll = createSetOperator('union', true);\n\n/**\n * Adds `intersect` set operator to the query.\n *\n * Calling this method will retain only the rows that are present in both result sets and eliminate duplicates.\n *\n * See docs: {@link https://orm.drizzle.team/docs/set-operations#intersect}\n *\n * @example\n *\n * ```ts\n * // Select course names that are offered in both departments A and B\n * import { intersect } from 'drizzle-orm/singlestore-core'\n *\n * await intersect(\n *   db.select({ courseName: depA.courseName }).from(depA),\n *   db.select({ courseName: depB.courseName }).from(depB)\n * );\n * // or\n * await db.select({ courseName: depA.courseName })\n *   .from(depA)\n *   .intersect(\n *     db.select({ courseName: depB.courseName }).from(depB)\n *   );\n * ```\n */\nexport const intersect = createSetOperator('intersect', false);\n\n/**\n * Adds `except` set operator to the query.\n *\n * Calling this method will retrieve all unique rows from the left query, except for the rows that are present in the result set of the right query.\n *\n * See docs: {@link https://orm.drizzle.team/docs/set-operations#except}\n *\n * @example\n *\n * ```ts\n * // Select all courses offered in department A but not in department B\n * import { except } from 'drizzle-orm/singlestore-core'\n *\n * await except(\n *   db.select({ courseName: depA.courseName }).from(depA),\n *   db.select({ courseName: depB.courseName }).from(depB)\n * );\n * // or\n * await db.select({ courseName: depA.courseName })\n *   .from(depA)\n *   .except(\n *     db.select({ courseName: depB.courseName }).from(depB)\n *   );\n * ```\n */\nexport const except = createSetOperator('except', false);\n\n/**\n * Adds `minus` set operator to the query.\n *\n * This is an alias of `except` supported by SingleStore.\n *\n * @example\n *\n * ```ts\n * // Select all courses offered in department A but not in department B\n * import { minus } from 'drizzle-orm/singlestore-core'\n *\n * await minus(\n *   db.select({ courseName: depA.courseName }).from(depA),\n *   db.select({ courseName: depB.courseName }).from(depB)\n * );\n * // or\n * await db.select({ courseName: depA.courseName })\n *   .from(depA)\n *   .minus(\n *     db.select({ courseName: depB.courseName }).from(depB)\n *   );\n * ```\n */\nexport const minus = createSetOperator('except', true);\n"],"mappings":"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"}