{"version":3,"sources":["../../../src/build/templates/edge-wrapper.js"],"sourcesContent":["// The wrapped module could be an async module, we handle that with the proxy\n// here. The comma expression makes sure we don't call the function with the\n// module as the \"this\" arg.\n// Turn exports into functions that are also a thenable. This way you can await the whole object\n// or  exports (e.g. for Components) or call them directly as though they are async functions\n// (e.g. edge functions/middleware, this is what the Edge Runtime does).\n// Catch promise to prevent UnhandledPromiseRejectionWarning, this will be propagated through\n// the awaited export(s) anyway.\nself._ENTRIES ||= {}\nconst modProm = import('MODULE')\nmodProm.catch(() => {})\nself._ENTRIES['VAR_ENTRY_NAME'] = new Proxy(modProm, {\n  get(innerModProm, name) {\n    if (name === 'then') {\n      return (res, rej) => innerModProm.then(res, rej)\n    }\n    let result = (...args) =>\n      innerModProm.then((mod) => (0, mod[name])(...args))\n    result.then = (res, rej) =>\n      innerModProm.then((mod) => mod[name]).then(res, rej)\n    return result\n  },\n})\n"],"names":["self","_ENTRIES","modProm","catch","Proxy","get","innerModProm","name","res","rej","then","result","args","mod"],"mappings":"AAAA,6EAA6E;AAC7E,4EAA4E;AAC5E,4BAA4B;AAC5B,gGAAgG;AAChG,6FAA6F;AAC7F,wEAAwE;AACxE,6FAA6F;AAC7F,gCAAgC;;AAChCA,KAAKC,QAAQ,KAAK,CAAC;AACnB,MAAMC,UAAU,MAAM,CAAC;AACvBA,QAAQC,KAAK,CAAC,KAAO;AACrBH,KAAKC,QAAQ,CAAC,iBAAiB,GAAG,IAAIG,MAAMF,SAAS;IACnDG,KAAIC,YAAY,EAAEC,IAAI;QACpB,IAAIA,SAAS,QAAQ;YACnB,OAAO,CAACC,KAAKC,MAAQH,aAAaI,IAAI,CAACF,KAAKC;QAC9C;QACA,IAAIE,SAAS,CAAC,GAAGC,OACfN,aAAaI,IAAI,CAAC,CAACG,MAAQ,AAAC,CAAA,GAAGA,GAAG,CAACN,KAAK,AAAD,KAAMK;QAC/CD,OAAOD,IAAI,GAAG,CAACF,KAAKC,MAClBH,aAAaI,IAAI,CAAC,CAACG,MAAQA,GAAG,CAACN,KAAK,EAAEG,IAAI,CAACF,KAAKC;QAClD,OAAOE;IACT;AACF","ignoreList":[0]}