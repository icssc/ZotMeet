{"version":3,"sources":["../../../src/server/node-environment-extensions/utils.tsx"],"sourcesContent":["import { workAsyncStorage } from '../app-render/work-async-storage.external'\nimport { workUnitAsyncStorage } from '../app-render/work-unit-async-storage.external'\nimport { abortOnSynchronousPlatformIOAccess } from '../app-render/dynamic-rendering'\nimport { InvariantError } from '../../shared/lib/invariant-error'\nimport { RenderStage } from '../app-render/staged-rendering'\n\nimport { getServerReact, getClientReact } from '../runtime-reacts.external'\n\ntype ApiType = 'time' | 'random' | 'crypto'\n\nexport function io(expression: string, type: ApiType) {\n  const workUnitStore = workUnitAsyncStorage.getStore()\n  const workStore = workAsyncStorage.getStore()\n\n  if (!workUnitStore || !workStore) {\n    return\n  }\n\n  switch (workUnitStore.type) {\n    case 'prerender':\n    case 'prerender-runtime': {\n      const prerenderSignal = workUnitStore.controller.signal\n\n      if (prerenderSignal.aborted === false) {\n        // If the prerender signal is already aborted we don't need to construct\n        // any stacks because something else actually terminated the prerender.\n        let message: string\n        switch (type) {\n          case 'time':\n            message = `Route \"${workStore.route}\" used ${expression} before accessing either uncached data (e.g. \\`fetch()\\`) or Request data (e.g. \\`cookies()\\`, \\`headers()\\`, \\`connection()\\`, and \\`searchParams\\`). Accessing the current time in a Server Component requires reading one of these data sources first. Alternatively, consider moving this expression into a Client Component or Cache Component. See more info here: https://nextjs.org/docs/messages/next-prerender-current-time`\n            break\n          case 'random':\n            message = `Route \"${workStore.route}\" used ${expression} before accessing either uncached data (e.g. \\`fetch()\\`) or Request data (e.g. \\`cookies()\\`, \\`headers()\\`, \\`connection()\\`, and \\`searchParams\\`). Accessing random values synchronously in a Server Component requires reading one of these data sources first. Alternatively, consider moving this expression into a Client Component or Cache Component. See more info here: https://nextjs.org/docs/messages/next-prerender-random`\n            break\n          case 'crypto':\n            message = `Route \"${workStore.route}\" used ${expression} before accessing either uncached data (e.g. \\`fetch()\\`) or Request data (e.g. \\`cookies()\\`, \\`headers()\\`, \\`connection()\\`, and \\`searchParams\\`). Accessing random cryptographic values synchronously in a Server Component requires reading one of these data sources first. Alternatively, consider moving this expression into a Client Component or Cache Component. See more info here: https://nextjs.org/docs/messages/next-prerender-crypto`\n            break\n          default:\n            throw new InvariantError(\n              'Unknown expression type in abortOnSynchronousPlatformIOAccess.'\n            )\n        }\n\n        abortOnSynchronousPlatformIOAccess(\n          workStore.route,\n          expression,\n          applyOwnerStack(new Error(message)),\n          workUnitStore\n        )\n      }\n      break\n    }\n    case 'prerender-client': {\n      const prerenderSignal = workUnitStore.controller.signal\n\n      if (prerenderSignal.aborted === false) {\n        // If the prerender signal is already aborted we don't need to construct\n        // any stacks because something else actually terminated the prerender.\n        let message: string\n        switch (type) {\n          case 'time':\n            message = `Route \"${workStore.route}\" used ${expression} inside a Client Component without a Suspense boundary above it. See more info here: https://nextjs.org/docs/messages/next-prerender-current-time-client`\n            break\n          case 'random':\n            message = `Route \"${workStore.route}\" used ${expression} inside a Client Component without a Suspense boundary above it. See more info here: https://nextjs.org/docs/messages/next-prerender-random-client`\n            break\n          case 'crypto':\n            message = `Route \"${workStore.route}\" used ${expression} inside a Client Component without a Suspense boundary above it. See more info here: https://nextjs.org/docs/messages/next-prerender-crypto-client`\n            break\n          default:\n            throw new InvariantError(\n              'Unknown expression type in abortOnSynchronousPlatformIOAccess.'\n            )\n        }\n\n        abortOnSynchronousPlatformIOAccess(\n          workStore.route,\n          expression,\n          applyOwnerStack(new Error(message)),\n          workUnitStore\n        )\n      }\n      break\n    }\n    case 'request':\n      if (process.env.NODE_ENV === 'development') {\n        const stageController = workUnitStore.stagedRendering\n        if (stageController && stageController.canSyncInterrupt()) {\n          let message: string\n          if (stageController.currentStage === RenderStage.Static) {\n            switch (type) {\n              case 'time':\n                message = `Route \"${workStore.route}\" used ${expression} before accessing either uncached data (e.g. \\`fetch()\\`) or Request data (e.g. \\`cookies()\\`, \\`headers()\\`, \\`connection()\\`, and \\`searchParams\\`). Accessing the current time in a Server Component requires reading one of these data sources first. Alternatively, consider moving this expression into a Client Component or Cache Component. See more info here: https://nextjs.org/docs/messages/next-prerender-current-time`\n                break\n              case 'random':\n                message = `Route \"${workStore.route}\" used ${expression} before accessing either uncached data (e.g. \\`fetch()\\`) or Request data (e.g. \\`cookies()\\`, \\`headers()\\`, \\`connection()\\`, and \\`searchParams\\`). Accessing random values synchronously in a Server Component requires reading one of these data sources first. Alternatively, consider moving this expression into a Client Component or Cache Component. See more info here: https://nextjs.org/docs/messages/next-prerender-random`\n                break\n              case 'crypto':\n                message = `Route \"${workStore.route}\" used ${expression} before accessing either uncached data (e.g. \\`fetch()\\`) or Request data (e.g. \\`cookies()\\`, \\`headers()\\`, \\`connection()\\`, and \\`searchParams\\`). Accessing random cryptographic values synchronously in a Server Component requires reading one of these data sources first. Alternatively, consider moving this expression into a Client Component or Cache Component. See more info here: https://nextjs.org/docs/messages/next-prerender-crypto`\n                break\n              default:\n                throw new InvariantError(\n                  'Unknown expression type in abortOnSynchronousPlatformIOAccess.'\n                )\n            }\n          } else {\n            // We're in the Runtime stage.\n            // We only error for Sync IO in the Runtime stage if the route has a runtime prefetch config.\n            // This check is implemented in `stageController.canSyncInterrupt()` --\n            // if runtime prefetching isn't enabled, then we won't get here.\n\n            let accessStatement: string\n            let additionalInfoLink: string\n\n            switch (type) {\n              case 'time':\n                accessStatement = 'the current time'\n                additionalInfoLink =\n                  'https://nextjs.org/docs/messages/next-prerender-runtime-current-time'\n                break\n              case 'random':\n                accessStatement = 'random values synchronously'\n                additionalInfoLink =\n                  'https://nextjs.org/docs/messages/next-prerender-runtime-random'\n                break\n              case 'crypto':\n                accessStatement = 'random cryptographic values synchronously'\n                additionalInfoLink =\n                  'https://nextjs.org/docs/messages/next-prerender-runtime-crypto'\n                break\n              default:\n                throw new InvariantError(\n                  'Unknown expression type in abortOnSynchronousPlatformIOAccess.'\n                )\n            }\n\n            message = `Route \"${workStore.route}\" used ${expression} before accessing either uncached data (e.g. \\`fetch()\\`) or awaiting \\`connection()\\`. When configured for Runtime prefetching, accessing ${accessStatement} in a Server Component requires reading one of these data sources first. Alternatively, consider moving this expression into a Client Component or Cache Component. See more info here: ${additionalInfoLink}`\n          }\n\n          const syncIOError = applyOwnerStack(new Error(message))\n          stageController.syncInterruptCurrentStageWithReason(syncIOError)\n        }\n      }\n      break\n    case 'prerender-ppr':\n    case 'prerender-legacy':\n    case 'cache':\n    case 'private-cache':\n    case 'unstable-cache':\n      break\n    default:\n      workUnitStore satisfies never\n  }\n}\n\nfunction applyOwnerStack(error: Error) {\n  // TODO: Instead of stitching the stacks here, we should log the original\n  // error as-is when it occurs, and let `patchErrorInspect` handle adding the\n  // owner stack, instead of logging it deferred in the `LogSafely` component\n  // via `throwIfDisallowedDynamic`.\n  if (process.env.NODE_ENV !== 'production') {\n    const ownerStack =\n      getClientReact()?.captureOwnerStack?.() ??\n      getServerReact()?.captureOwnerStack?.()\n\n    if (ownerStack) {\n      let stack = ownerStack\n\n      if (error.stack) {\n        const frames: string[] = []\n\n        for (const frame of error.stack.split('\\n').slice(1)) {\n          if (frame.includes('react_stack_bottom_frame')) {\n            break\n          }\n\n          frames.push(frame)\n        }\n\n        stack = '\\n' + frames.join('\\n') + stack\n      }\n\n      error.stack = error.name + ': ' + error.message + stack\n    }\n  }\n\n  return error\n}\n"],"names":["io","expression","type","workUnitStore","workUnitAsyncStorage","getStore","workStore","workAsyncStorage","prerenderSignal","controller","signal","aborted","message","route","InvariantError","abortOnSynchronousPlatformIOAccess","applyOwnerStack","Error","process","env","NODE_ENV","stageController","stagedRendering","canSyncInterrupt","currentStage","RenderStage","Static","accessStatement","additionalInfoLink","syncIOError","syncInterruptCurrentStageWithReason","error","getClientReact","getServerReact","ownerStack","captureOwnerStack","stack","frames","frame","split","slice","includes","push","join","name"],"mappings":"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","ignoreList":[0]}