{"version":3,"sources":["../../../src/lib/typescript/runTypeCheck.ts"],"sourcesContent":["import path from 'path'\nimport { getFormattedDiagnostic } from './diagnosticFormatter'\nimport { getTypeScriptConfiguration } from './getTypeScriptConfiguration'\nimport { getRequiredConfiguration } from './writeConfigurationDefaults'\nimport { getDevTypesPath } from './type-paths'\n\nimport { CompileError } from '../compile-error'\nimport { warn } from '../../build/output/log'\nimport { defaultConfig } from '../../server/config-shared'\n\nexport interface TypeCheckResult {\n  hasWarnings: boolean\n  warnings?: string[]\n  inputFilesCount: number\n  totalFilesCount: number\n  incremental: boolean\n}\n\nexport interface TypeCheckDirs {\n  app?: string\n  pages?: string\n}\n\nexport interface DebugBuildPaths {\n  app?: string[]\n  pages?: string[]\n}\n\n/**\n * Check if a file path matches any of the debug build paths.\n * Both filePath and debugPaths are resolved file paths from glob.\n */\nfunction fileMatchesDebugPaths(\n  filePath: string,\n  debugPaths: string[]\n): boolean {\n  return debugPaths.includes(filePath)\n}\n\nexport async function runTypeCheck(\n  typescript: typeof import('typescript'),\n  baseDir: string,\n  distDir: string,\n  tsConfigPath: string,\n  cacheDir?: string,\n  isAppDirEnabled?: boolean,\n  isolatedDevBuild?: boolean,\n  dirs?: TypeCheckDirs,\n  debugBuildPaths?: DebugBuildPaths\n): Promise<TypeCheckResult> {\n  const effectiveConfiguration = await getTypeScriptConfiguration(\n    typescript,\n    tsConfigPath\n  )\n\n  // When isolatedDevBuild is enabled, tsconfig includes both .next/types and\n  // .next/dev/types to avoid config churn between dev/build modes. During build,\n  // we filter out .next/dev/types files to prevent stale dev types from causing\n  // errors when routes have been deleted since the last dev session.\n  let fileNames = effectiveConfiguration.fileNames\n  const resolvedIsolatedDevBuild =\n    isolatedDevBuild === undefined\n      ? defaultConfig.experimental.isolatedDevBuild\n      : isolatedDevBuild\n\n  // Get the dev types path to filter (null if not applicable)\n  const devTypesDir = getDevTypesPath(\n    baseDir,\n    distDir,\n    resolvedIsolatedDevBuild\n  )\n  if (devTypesDir) {\n    fileNames = fileNames.filter(\n      (fileName) => !fileName.startsWith(devTypesDir)\n    )\n  }\n\n  // Apply debug build paths filter if specified\n  if (dirs && debugBuildPaths) {\n    const { app: appDir, pages: pagesDir } = dirs\n    const { app: debugAppPaths, pages: debugPagePaths } = debugBuildPaths\n\n    fileNames = fileNames.filter((fileName) => {\n      // Check if file is in app directory\n      if (appDir && fileName.startsWith(appDir + path.sep)) {\n        // If debugAppPaths is undefined, include all app files\n        if (debugAppPaths === undefined) {\n          return true\n        }\n        // If debugAppPaths is empty array, exclude all app files\n        if (debugAppPaths.length === 0) {\n          return false\n        }\n        // Check if file matches any of the debug paths\n        const relativeToApp = fileName.slice(appDir.length)\n        return fileMatchesDebugPaths(relativeToApp, debugAppPaths)\n      }\n\n      // Check if file is in pages directory\n      if (pagesDir && fileName.startsWith(pagesDir + path.sep)) {\n        // If debugPagePaths is undefined, include all pages files\n        if (debugPagePaths === undefined) {\n          return true\n        }\n        // If debugPagePaths is empty array, exclude all pages files\n        if (debugPagePaths.length === 0) {\n          return false\n        }\n        // Check if file matches any of the debug paths\n        const relativeToPages = fileName.slice(pagesDir.length)\n        return fileMatchesDebugPaths(relativeToPages, debugPagePaths)\n      }\n\n      // Keep files outside app/pages directories (shared code, etc.)\n      return true\n    })\n  }\n\n  if (fileNames.length < 1) {\n    return {\n      hasWarnings: false,\n      inputFilesCount: 0,\n      totalFilesCount: 0,\n      incremental: false,\n    }\n  }\n  const requiredConfig = getRequiredConfiguration(typescript)\n\n  const options = {\n    ...requiredConfig,\n    ...effectiveConfiguration.options,\n    declarationMap: false,\n    emitDeclarationOnly: false,\n    noEmit: true,\n  }\n\n  let program:\n    | import('typescript').Program\n    | import('typescript').BuilderProgram\n  let incremental = false\n  if ((options.incremental || options.composite) && cacheDir) {\n    if (options.composite) {\n      warn(\n        'TypeScript project references are not fully supported. Attempting to build in incremental mode.'\n      )\n    }\n    incremental = true\n    program = typescript.createIncrementalProgram({\n      rootNames: fileNames,\n      options: {\n        ...options,\n        composite: false,\n        incremental: true,\n        tsBuildInfoFile: path.join(cacheDir, '.tsbuildinfo'),\n      },\n    })\n  } else {\n    program = typescript.createProgram(fileNames, options)\n  }\n\n  const result = program.emit()\n\n  const ignoreRegex = [\n    // matches **/__(tests|mocks)__/**\n    /[\\\\/]__(?:tests|mocks)__[\\\\/]/,\n    // matches **/*.(spec|test).*\n    /(?<=[\\\\/.])(?:spec|test)\\.[^\\\\/]+$/,\n  ]\n  const regexIgnoredFile = new RegExp(\n    ignoreRegex.map((r) => r.source).join('|')\n  )\n\n  const allDiagnostics = typescript\n    .getPreEmitDiagnostics(program as import('typescript').Program)\n    .concat(result.diagnostics)\n    .filter((d) => !(d.file && regexIgnoredFile.test(d.file.fileName)))\n\n  const firstError =\n    allDiagnostics.find(\n      (d) =>\n        d.category === typescript.DiagnosticCategory.Error && Boolean(d.file)\n    ) ??\n    allDiagnostics.find(\n      (d) => d.category === typescript.DiagnosticCategory.Error\n    )\n\n  // In test mode, we want to check all diagnostics, not just the first one.\n  if (process.env.__NEXT_TEST_MODE) {\n    if (firstError) {\n      const allErrors = allDiagnostics\n        .filter((d) => d.category === typescript.DiagnosticCategory.Error)\n        .map(\n          (d) =>\n            '[Test Mode] ' +\n            getFormattedDiagnostic(\n              typescript,\n              baseDir,\n              distDir,\n              d,\n              isAppDirEnabled\n            )\n        )\n\n      console.error(\n        '\\n\\n===== TS errors =====\\n\\n' +\n          allErrors.join('\\n\\n') +\n          '\\n\\n===== TS errors =====\\n\\n'\n      )\n\n      // Make sure all stdout is flushed before we exit.\n      await new Promise((resolve) => setTimeout(resolve, 100))\n    }\n  }\n\n  if (firstError) {\n    throw new CompileError(\n      getFormattedDiagnostic(\n        typescript,\n        baseDir,\n        distDir,\n        firstError,\n        isAppDirEnabled\n      )\n    )\n  }\n\n  const warnings = allDiagnostics\n    .filter((d) => d.category === typescript.DiagnosticCategory.Warning)\n    .map((d) =>\n      getFormattedDiagnostic(typescript, baseDir, distDir, d, isAppDirEnabled)\n    )\n\n  return {\n    hasWarnings: true,\n    warnings,\n    inputFilesCount: fileNames.length,\n    totalFilesCount: program.getSourceFiles().length,\n    incremental,\n  }\n}\n"],"names":["runTypeCheck","fileMatchesDebugPaths","filePath","debugPaths","includes","typescript","baseDir","distDir","tsConfigPath","cacheDir","isAppDirEnabled","isolatedDevBuild","dirs","debugBuildPaths","effectiveConfiguration","getTypeScriptConfiguration","fileNames","resolvedIsolatedDevBuild","undefined","defaultConfig","experimental","devTypesDir","getDevTypesPath","filter","fileName","startsWith","app","appDir","pages","pagesDir","debugAppPaths","debugPagePaths","path","sep","length","relativeToApp","slice","relativeToPages","hasWarnings","inputFilesCount","totalFilesCount","incremental","requiredConfig","getRequiredConfiguration","options","declarationMap","emitDeclarationOnly","noEmit","program","composite","warn","createIncrementalProgram","rootNames","tsBuildInfoFile","join","createProgram","result","emit","ignoreRegex","regexIgnoredFile","RegExp","map","r","source","allDiagnostics","getPreEmitDiagnostics","concat","diagnostics","d","file","test","firstError","find","category","DiagnosticCategory","Error","Boolean","process","env","__NEXT_TEST_MODE","allErrors","getFormattedDiagnostic","console","error","Promise","resolve","setTimeout","CompileError","warnings","Warning","getSourceFiles"],"mappings":"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","ignoreList":[0]}