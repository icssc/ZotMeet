{"version":3,"sources":["../../../../src/client/components/segment-cache/navigation.ts"],"sourcesContent":["import type {\n  CacheNodeSeedData,\n  FlightRouterState,\n  FlightSegmentPath,\n} from '../../../shared/lib/app-router-types'\nimport type { CacheNode } from '../../../shared/lib/app-router-types'\nimport type {\n  HeadData,\n  LoadingModuleData,\n} from '../../../shared/lib/app-router-types'\nimport type { NormalizedFlightData } from '../../flight-data-helpers'\nimport { fetchServerResponse } from '../router-reducer/fetch-server-response'\nimport {\n  startPPRNavigation,\n  spawnDynamicRequests,\n  FreshnessPolicy,\n  type NavigationTask,\n  type NavigationRequestAccumulation,\n} from '../router-reducer/ppr-navigations'\nimport { createHrefFromUrl } from '../router-reducer/create-href-from-url'\nimport {\n  EntryStatus,\n  readRouteCacheEntry,\n  readSegmentCacheEntry,\n  waitForSegmentCacheEntry,\n  requestOptimisticRouteCacheEntry,\n  type RouteTree,\n  type FulfilledRouteCacheEntry,\n} from './cache'\nimport { createCacheKey } from './cache-key'\nimport { addSearchParamsIfPageSegment } from '../../../shared/lib/segment'\nimport { NavigationResultTag } from './types'\n\ntype MPANavigationResult = {\n  tag: NavigationResultTag.MPA\n  data: string\n}\n\ntype SuccessfulNavigationResult = {\n  tag: NavigationResultTag.Success\n  data: {\n    flightRouterState: FlightRouterState\n    cacheNode: CacheNode\n    canonicalUrl: string\n    renderedSearch: string\n    scrollableSegments: Array<FlightSegmentPath> | null\n    shouldScroll: boolean\n    hash: string\n  }\n}\n\ntype AsyncNavigationResult = {\n  tag: NavigationResultTag.Async\n  data: Promise<MPANavigationResult | SuccessfulNavigationResult>\n}\n\nexport type NavigationResult =\n  | MPANavigationResult\n  | SuccessfulNavigationResult\n  | AsyncNavigationResult\n\n/**\n * Navigate to a new URL, using the Segment Cache to construct a response.\n *\n * To allow for synchronous navigations whenever possible, this is not an async\n * function. It returns a promise only if there's no matching prefetch in\n * the cache. Otherwise it returns an immediate result and uses Suspense/RSC to\n * stream in any missing data.\n */\nexport function navigate(\n  url: URL,\n  currentUrl: URL,\n  currentCacheNode: CacheNode | null,\n  currentFlightRouterState: FlightRouterState,\n  nextUrl: string | null,\n  freshnessPolicy: FreshnessPolicy,\n  shouldScroll: boolean,\n  accumulation: { collectedDebugInfo?: Array<unknown> }\n): NavigationResult {\n  const now = Date.now()\n  const href = url.href\n\n  // We special case navigations to the exact same URL as the current location.\n  // It's a common UI pattern for apps to refresh when you click a link to the\n  // current page. So when this happens, we refresh the dynamic data in the page\n  // segments.\n  //\n  // Note that this does not apply if the any part of the hash or search query\n  // has changed. This might feel a bit weird but it makes more sense when you\n  // consider that the way to trigger this behavior is to click the same link\n  // multiple times.\n  //\n  // TODO: We should probably refresh the *entire* route when this case occurs,\n  // not just the page segments. Essentially treating it the same as a refresh()\n  // triggered by an action, which is the more explicit way of modeling the UI\n  // pattern described above.\n  //\n  // Also note that this only refreshes the dynamic data, not static/ cached\n  // data. If the page segment is fully static and prefetched, the request is\n  // skipped. (This is also how refresh() works.)\n  const isSamePageNavigation = href === currentUrl.href\n\n  const cacheKey = createCacheKey(href, nextUrl)\n  const route = readRouteCacheEntry(now, cacheKey)\n  if (route !== null && route.status === EntryStatus.Fulfilled) {\n    // We have a matching prefetch.\n    const snapshot = readRenderSnapshotFromCache(now, route, route.tree)\n    const prefetchFlightRouterState = snapshot.flightRouterState\n    const prefetchSeedData = snapshot.seedData\n    const headSnapshot = readHeadSnapshotFromCache(now, route)\n    const prefetchHead = headSnapshot.rsc\n    const isPrefetchHeadPartial = headSnapshot.isPartial\n    // TODO: The \"canonicalUrl\" stored in the cache doesn't include the hash,\n    // because hash entries do not vary by hash fragment. However, the one\n    // we set in the router state *does* include the hash, and it's used to\n    // sync with the actual browser location. To make this less of a refactor\n    // hazard, we should always track the hash separately from the rest of\n    // the URL.\n    const newCanonicalUrl = route.canonicalUrl + url.hash\n    const renderedSearch = route.renderedSearch\n    return navigateUsingPrefetchedRouteTree(\n      now,\n      url,\n      currentUrl,\n      nextUrl,\n      isSamePageNavigation,\n      currentCacheNode,\n      currentFlightRouterState,\n      prefetchFlightRouterState,\n      prefetchSeedData,\n      prefetchHead,\n      isPrefetchHeadPartial,\n      newCanonicalUrl,\n      renderedSearch,\n      freshnessPolicy,\n      shouldScroll\n    )\n  }\n\n  // There was no matching route tree in the cache. Let's see if we can\n  // construct an \"optimistic\" route tree.\n  //\n  // Do not construct an optimistic route tree if there was a cache hit, but\n  // the entry has a rejected status, since it may have been rejected due to a\n  // rewrite or redirect based on the search params.\n  //\n  // TODO: There are multiple reasons a prefetch might be rejected; we should\n  // track them explicitly and choose what to do here based on that.\n  if (route === null || route.status !== EntryStatus.Rejected) {\n    const optimisticRoute = requestOptimisticRouteCacheEntry(now, url, nextUrl)\n    if (optimisticRoute !== null) {\n      // We have an optimistic route tree. Proceed with the normal flow.\n      const snapshot = readRenderSnapshotFromCache(\n        now,\n        optimisticRoute,\n        optimisticRoute.tree\n      )\n      const prefetchFlightRouterState = snapshot.flightRouterState\n      const prefetchSeedData = snapshot.seedData\n      const headSnapshot = readHeadSnapshotFromCache(now, optimisticRoute)\n      const prefetchHead = headSnapshot.rsc\n      const isPrefetchHeadPartial = headSnapshot.isPartial\n      const newCanonicalUrl = optimisticRoute.canonicalUrl + url.hash\n      const newRenderedSearch = optimisticRoute.renderedSearch\n      return navigateUsingPrefetchedRouteTree(\n        now,\n        url,\n        currentUrl,\n        nextUrl,\n        isSamePageNavigation,\n        currentCacheNode,\n        currentFlightRouterState,\n        prefetchFlightRouterState,\n        prefetchSeedData,\n        prefetchHead,\n        isPrefetchHeadPartial,\n        newCanonicalUrl,\n        newRenderedSearch,\n        freshnessPolicy,\n        shouldScroll\n      )\n    }\n  }\n\n  // There's no matching prefetch for this route in the cache.\n  let collectedDebugInfo = accumulation.collectedDebugInfo ?? []\n  if (accumulation.collectedDebugInfo === undefined) {\n    collectedDebugInfo = accumulation.collectedDebugInfo = []\n  }\n  return {\n    tag: NavigationResultTag.Async,\n    data: navigateDynamicallyWithNoPrefetch(\n      now,\n      url,\n      currentUrl,\n      nextUrl,\n      currentCacheNode,\n      currentFlightRouterState,\n      freshnessPolicy,\n      shouldScroll,\n      collectedDebugInfo\n    ),\n  }\n}\n\nexport function navigateToSeededRoute(\n  now: number,\n  url: URL,\n  canonicalUrl: string,\n  navigationSeed: NavigationSeed,\n  currentUrl: URL,\n  currentCacheNode: CacheNode | null,\n  currentFlightRouterState: FlightRouterState,\n  freshnessPolicy: FreshnessPolicy,\n  nextUrl: string | null,\n  shouldScroll: boolean\n): SuccessfulNavigationResult | MPANavigationResult {\n  // A version of navigate() that accepts the target route tree as an argument\n  // rather than reading it from the prefetch cache.\n  const accumulation: NavigationRequestAccumulation = {\n    scrollableSegments: null,\n    separateRefreshUrls: null,\n  }\n  const isSamePageNavigation = url.href === currentUrl.href\n  const task = startPPRNavigation(\n    now,\n    currentUrl,\n    currentCacheNode,\n    currentFlightRouterState,\n    navigationSeed.tree,\n    freshnessPolicy,\n    navigationSeed.data,\n    navigationSeed.head,\n    null,\n    null,\n    false,\n    isSamePageNavigation,\n    accumulation\n  )\n  if (task !== null) {\n    spawnDynamicRequests(task, url, nextUrl, freshnessPolicy, accumulation)\n    return navigationTaskToResult(\n      task,\n      canonicalUrl,\n      navigationSeed.renderedSearch,\n      accumulation.scrollableSegments,\n      shouldScroll,\n      url.hash\n    )\n  }\n  // Could not perform a SPA navigation. Revert to a full-page (MPA) navigation.\n  return {\n    tag: NavigationResultTag.MPA,\n    data: canonicalUrl,\n  }\n}\n\nfunction navigateUsingPrefetchedRouteTree(\n  now: number,\n  url: URL,\n  currentUrl: URL,\n  nextUrl: string | null,\n  isSamePageNavigation: boolean,\n  currentCacheNode: CacheNode | null,\n  currentFlightRouterState: FlightRouterState,\n  prefetchFlightRouterState: FlightRouterState,\n  prefetchSeedData: CacheNodeSeedData | null,\n  prefetchHead: HeadData | null,\n  isPrefetchHeadPartial: boolean,\n  canonicalUrl: string,\n  renderedSearch: string,\n  freshnessPolicy: FreshnessPolicy,\n  shouldScroll: boolean\n): SuccessfulNavigationResult | MPANavigationResult {\n  // Recursively construct a prefetch tree by reading from the Segment Cache. To\n  // maintain compatibility, we output the same data structures as the old\n  // prefetching implementation: FlightRouterState and CacheNodeSeedData.\n  // TODO: Eventually updateCacheNodeOnNavigation (or the equivalent) should\n  // read from the Segment Cache directly. It's only structured this way for now\n  // so we can share code with the old prefetching implementation.\n  const accumulation: NavigationRequestAccumulation = {\n    scrollableSegments: null,\n    separateRefreshUrls: null,\n  }\n  const seedData = null\n  const seedHead = null\n  const task = startPPRNavigation(\n    now,\n    currentUrl,\n    currentCacheNode,\n    currentFlightRouterState,\n    prefetchFlightRouterState,\n    freshnessPolicy,\n    seedData,\n    seedHead,\n    prefetchSeedData,\n    prefetchHead,\n    isPrefetchHeadPartial,\n    isSamePageNavigation,\n    accumulation\n  )\n  if (task !== null) {\n    spawnDynamicRequests(task, url, nextUrl, freshnessPolicy, accumulation)\n    return navigationTaskToResult(\n      task,\n      canonicalUrl,\n      renderedSearch,\n      accumulation.scrollableSegments,\n      shouldScroll,\n      url.hash\n    )\n  }\n  // Could not perform a SPA navigation. Revert to a full-page (MPA) navigation.\n  return {\n    tag: NavigationResultTag.MPA,\n    data: canonicalUrl,\n  }\n}\n\nfunction navigationTaskToResult(\n  task: NavigationTask,\n  canonicalUrl: string,\n  renderedSearch: string,\n  scrollableSegments: Array<FlightSegmentPath> | null,\n  shouldScroll: boolean,\n  hash: string\n): SuccessfulNavigationResult | MPANavigationResult {\n  return {\n    tag: NavigationResultTag.Success,\n    data: {\n      flightRouterState: task.route,\n      cacheNode: task.node,\n      canonicalUrl,\n      renderedSearch,\n      scrollableSegments,\n      shouldScroll,\n      hash,\n    },\n  }\n}\n\nfunction readRenderSnapshotFromCache(\n  now: number,\n  route: FulfilledRouteCacheEntry,\n  tree: RouteTree\n): { flightRouterState: FlightRouterState; seedData: CacheNodeSeedData } {\n  let childRouterStates: { [parallelRouteKey: string]: FlightRouterState } = {}\n  let childSeedDatas: {\n    [parallelRouteKey: string]: CacheNodeSeedData | null\n  } = {}\n  const slots = tree.slots\n  if (slots !== null) {\n    for (const parallelRouteKey in slots) {\n      const childTree = slots[parallelRouteKey]\n      const childResult = readRenderSnapshotFromCache(now, route, childTree)\n      childRouterStates[parallelRouteKey] = childResult.flightRouterState\n      childSeedDatas[parallelRouteKey] = childResult.seedData\n    }\n  }\n\n  let rsc: React.ReactNode | null = null\n  let loading: LoadingModuleData | Promise<LoadingModuleData> = null\n  let isPartial: boolean = true\n\n  const segmentEntry = readSegmentCacheEntry(now, tree.varyPath)\n  if (segmentEntry !== null) {\n    switch (segmentEntry.status) {\n      case EntryStatus.Fulfilled: {\n        // Happy path: a cache hit\n        rsc = segmentEntry.rsc\n        loading = segmentEntry.loading\n        isPartial = segmentEntry.isPartial\n        break\n      }\n      case EntryStatus.Pending: {\n        // We haven't received data for this segment yet, but there's already\n        // an in-progress request. Since it's extremely likely to arrive\n        // before the dynamic data response, we might as well use it.\n        const promiseForFulfilledEntry = waitForSegmentCacheEntry(segmentEntry)\n        rsc = promiseForFulfilledEntry.then((entry) =>\n          entry !== null ? entry.rsc : null\n        )\n        loading = promiseForFulfilledEntry.then((entry) =>\n          entry !== null ? entry.loading : null\n        )\n        // Because the request is still pending, we typically don't know yet\n        // whether the response will be partial. We shouldn't skip this segment\n        // during the dynamic navigation request. Otherwise, we might need to\n        // do yet another request to fill in the remaining data, creating\n        // a waterfall.\n        //\n        // The one exception is if this segment is being fetched with via\n        // prefetch={true} (i.e. the \"force stale\" or \"full\" strategy). If so,\n        // we can assume the response will be full. This field is set to `false`\n        // for such segments.\n        isPartial = segmentEntry.isPartial\n        break\n      }\n      case EntryStatus.Empty:\n      case EntryStatus.Rejected:\n        break\n      default:\n        segmentEntry satisfies never\n    }\n  }\n\n  // The navigation implementation expects the search params to be\n  // included in the segment. However, the Segment Cache tracks search\n  // params separately from the rest of the segment key. So we need to\n  // add them back here.\n  //\n  // See corresponding comment in convertFlightRouterStateToTree.\n  //\n  // TODO: What we should do instead is update the navigation diffing\n  // logic to compare search params explicitly. This is a temporary\n  // solution until more of the Segment Cache implementation has settled.\n  const segment = addSearchParamsIfPageSegment(\n    tree.segment,\n    Object.fromEntries(new URLSearchParams(route.renderedSearch))\n  )\n\n  // We don't need this information in a render snapshot, so this can just be a placeholder.\n  const hasRuntimePrefetch = false\n\n  return {\n    flightRouterState: [\n      segment,\n      childRouterStates,\n      null,\n      null,\n      tree.isRootLayout,\n    ],\n    seedData: [rsc, childSeedDatas, loading, isPartial, hasRuntimePrefetch],\n  }\n}\n\nfunction readHeadSnapshotFromCache(\n  now: number,\n  route: FulfilledRouteCacheEntry\n): { rsc: HeadData; isPartial: boolean } {\n  // Same as readRenderSnapshotFromCache, but for the head\n  let rsc: React.ReactNode | null = null\n  let isPartial: boolean = true\n  const segmentEntry = readSegmentCacheEntry(now, route.metadata.varyPath)\n  if (segmentEntry !== null) {\n    switch (segmentEntry.status) {\n      case EntryStatus.Fulfilled: {\n        rsc = segmentEntry.rsc\n        isPartial = segmentEntry.isPartial\n        break\n      }\n      case EntryStatus.Pending: {\n        const promiseForFulfilledEntry = waitForSegmentCacheEntry(segmentEntry)\n        rsc = promiseForFulfilledEntry.then((entry) =>\n          entry !== null ? entry.rsc : null\n        )\n        isPartial = segmentEntry.isPartial\n        break\n      }\n      case EntryStatus.Empty:\n      case EntryStatus.Rejected:\n        break\n      default:\n        segmentEntry satisfies never\n    }\n  }\n  return { rsc, isPartial }\n}\n\n// Used to request all the dynamic data for a route, rather than just a subset,\n// e.g. during a refresh or a revalidation. Typically this gets constructed\n// during the normal flow when diffing the route tree, but for an unprefetched\n// navigation, where we don't know the structure of the target route, we use\n// this instead.\nconst DynamicRequestTreeForEntireRoute: FlightRouterState = [\n  '',\n  {},\n  null,\n  'refetch',\n]\n\nasync function navigateDynamicallyWithNoPrefetch(\n  now: number,\n  url: URL,\n  currentUrl: URL,\n  nextUrl: string | null,\n  currentCacheNode: CacheNode | null,\n  currentFlightRouterState: FlightRouterState,\n  freshnessPolicy: FreshnessPolicy,\n  shouldScroll: boolean,\n  collectedDebugInfo: Array<unknown>\n): Promise<MPANavigationResult | SuccessfulNavigationResult> {\n  // Runs when a navigation happens but there's no cached prefetch we can use.\n  // Don't bother to wait for a prefetch response; go straight to a full\n  // navigation that contains both static and dynamic data in a single stream.\n  // (This is unlike the old navigation implementation, which instead blocks\n  // the dynamic request until a prefetch request is received.)\n  //\n  // To avoid duplication of logic, we're going to pretend that the tree\n  // returned by the dynamic request is, in fact, a prefetch tree. Then we can\n  // use the same server response to write the actual data into the CacheNode\n  // tree. So it's the same flow as the \"happy path\" (prefetch, then\n  // navigation), except we use a single server response for both stages.\n\n  let dynamicRequestTree: FlightRouterState\n  switch (freshnessPolicy) {\n    case FreshnessPolicy.Default:\n    case FreshnessPolicy.HistoryTraversal:\n      dynamicRequestTree = currentFlightRouterState\n      break\n    case FreshnessPolicy.Hydration: // <- shouldn't happen during client nav\n    case FreshnessPolicy.RefreshAll:\n    case FreshnessPolicy.HMRRefresh:\n      dynamicRequestTree = DynamicRequestTreeForEntireRoute\n      break\n    default:\n      freshnessPolicy satisfies never\n      dynamicRequestTree = currentFlightRouterState\n      break\n  }\n\n  const promiseForDynamicServerResponse = fetchServerResponse(url, {\n    flightRouterState: dynamicRequestTree,\n    nextUrl,\n  })\n  const result = await promiseForDynamicServerResponse\n  if (typeof result === 'string') {\n    // This is an MPA navigation.\n    const newUrl = result\n    return {\n      tag: NavigationResultTag.MPA,\n      data: newUrl,\n    }\n  }\n\n  const {\n    flightData,\n    canonicalUrl,\n    renderedSearch,\n    debugInfo: debugInfoFromResponse,\n  } = result\n  if (debugInfoFromResponse !== null) {\n    collectedDebugInfo.push(...debugInfoFromResponse)\n  }\n\n  // Since the response format of dynamic requests and prefetches is slightly\n  // different, we'll need to massage the data a bit. Create FlightRouterState\n  // tree that simulates what we'd receive as the result of a prefetch.\n  const navigationSeed = convertServerPatchToFullTree(\n    currentFlightRouterState,\n    flightData,\n    renderedSearch\n  )\n\n  return navigateToSeededRoute(\n    now,\n    url,\n    createHrefFromUrl(canonicalUrl),\n    navigationSeed,\n    currentUrl,\n    currentCacheNode,\n    currentFlightRouterState,\n    freshnessPolicy,\n    nextUrl,\n    shouldScroll\n  )\n}\n\nexport type NavigationSeed = {\n  tree: FlightRouterState\n  renderedSearch: string\n  data: CacheNodeSeedData | null\n  head: HeadData | null\n}\n\nexport function convertServerPatchToFullTree(\n  currentTree: FlightRouterState,\n  flightData: Array<NormalizedFlightData>,\n  renderedSearch: string\n): NavigationSeed {\n  // During a client navigation or prefetch, the server sends back only a patch\n  // for the parts of the tree that have changed.\n  //\n  // This applies the patch to the base tree to create a full representation of\n  // the resulting tree.\n  //\n  // The return type includes a full FlightRouterState tree and a full\n  // CacheNodeSeedData tree. (Conceptually these are the same tree, and should\n  // eventually be unified, but there's still lots of existing code that\n  // operates on FlightRouterState trees alone without the CacheNodeSeedData.)\n  //\n  // TODO: This similar to what apply-router-state-patch-to-tree does. It\n  // will eventually fully replace it. We should get rid of all the remaining\n  // places where we iterate over the server patch format. This should also\n  // eventually replace normalizeFlightData.\n\n  let baseTree: FlightRouterState = currentTree\n  let baseData: CacheNodeSeedData | null = null\n  let head: HeadData | null = null\n  for (const {\n    segmentPath,\n    tree: treePatch,\n    seedData: dataPatch,\n    head: headPatch,\n  } of flightData) {\n    const result = convertServerPatchToFullTreeImpl(\n      baseTree,\n      baseData,\n      treePatch,\n      dataPatch,\n      segmentPath,\n      0\n    )\n    baseTree = result.tree\n    baseData = result.data\n    // This is the same for all patches per response, so just pick an\n    // arbitrary one\n    head = headPatch\n  }\n\n  return {\n    tree: baseTree,\n    data: baseData,\n    renderedSearch,\n    head,\n  }\n}\n\nfunction convertServerPatchToFullTreeImpl(\n  baseRouterState: FlightRouterState,\n  baseData: CacheNodeSeedData | null,\n  treePatch: FlightRouterState,\n  dataPatch: CacheNodeSeedData | null,\n  segmentPath: FlightSegmentPath,\n  index: number\n): { tree: FlightRouterState; data: CacheNodeSeedData | null } {\n  if (index === segmentPath.length) {\n    // We reached the part of the tree that we need to patch.\n    return {\n      tree: treePatch,\n      data: dataPatch,\n    }\n  }\n\n  // segmentPath represents the parent path of subtree. It's a repeating\n  // pattern of parallel route key and segment:\n  //\n  //   [string, Segment, string, Segment, string, Segment, ...]\n  //\n  // This path tells us which part of the base tree to apply the tree patch.\n  //\n  // NOTE: We receive the FlightRouterState patch in the same request as the\n  // seed data patch. Therefore we don't need to worry about diffing the segment\n  // values; we can assume the server sent us a correct result.\n  const updatedParallelRouteKey: string = segmentPath[index]\n  // const segment: Segment = segmentPath[index + 1] <-- Not used, see note above\n\n  const baseTreeChildren = baseRouterState[1]\n  const baseSeedDataChildren = baseData !== null ? baseData[1] : null\n  const newTreeChildren: Record<string, FlightRouterState> = {}\n  const newSeedDataChildren: Record<string, CacheNodeSeedData | null> = {}\n  for (const parallelRouteKey in baseTreeChildren) {\n    const childBaseRouterState = baseTreeChildren[parallelRouteKey]\n    const childBaseSeedData =\n      baseSeedDataChildren !== null\n        ? (baseSeedDataChildren[parallelRouteKey] ?? null)\n        : null\n    if (parallelRouteKey === updatedParallelRouteKey) {\n      const result = convertServerPatchToFullTreeImpl(\n        childBaseRouterState,\n        childBaseSeedData,\n        treePatch,\n        dataPatch,\n        segmentPath,\n        // Advance the index by two and keep cloning until we reach\n        // the end of the segment path.\n        index + 2\n      )\n\n      newTreeChildren[parallelRouteKey] = result.tree\n      newSeedDataChildren[parallelRouteKey] = result.data\n    } else {\n      // This child is not being patched. Copy it over as-is.\n      newTreeChildren[parallelRouteKey] = childBaseRouterState\n      newSeedDataChildren[parallelRouteKey] = childBaseSeedData\n    }\n  }\n\n  let clonedTree: FlightRouterState\n  let clonedSeedData: CacheNodeSeedData\n  // Clone all the fields except the children.\n\n  // Clone the FlightRouterState tree. Based on equivalent logic in\n  // apply-router-state-patch-to-tree, but should confirm whether we need to\n  // copy all of these fields. Not sure the server ever sends, e.g. the\n  // refetch marker.\n  clonedTree = [baseRouterState[0], newTreeChildren]\n  if (2 in baseRouterState) {\n    clonedTree[2] = baseRouterState[2]\n  }\n  if (3 in baseRouterState) {\n    clonedTree[3] = baseRouterState[3]\n  }\n  if (4 in baseRouterState) {\n    clonedTree[4] = baseRouterState[4]\n  }\n\n  // Clone the CacheNodeSeedData tree.\n  const isEmptySeedDataPartial = true\n  clonedSeedData = [\n    null,\n    newSeedDataChildren,\n    null,\n    isEmptySeedDataPartial,\n    false,\n  ]\n\n  return {\n    tree: clonedTree,\n    data: clonedSeedData,\n  }\n}\n"],"names":["convertServerPatchToFullTree","navigate","navigateToSeededRoute","url","currentUrl","currentCacheNode","currentFlightRouterState","nextUrl","freshnessPolicy","shouldScroll","accumulation","now","Date","href","isSamePageNavigation","cacheKey","createCacheKey","route","readRouteCacheEntry","status","EntryStatus","Fulfilled","snapshot","readRenderSnapshotFromCache","tree","prefetchFlightRouterState","flightRouterState","prefetchSeedData","seedData","headSnapshot","readHeadSnapshotFromCache","prefetchHead","rsc","isPrefetchHeadPartial","isPartial","newCanonicalUrl","canonicalUrl","hash","renderedSearch","navigateUsingPrefetchedRouteTree","Rejected","optimisticRoute","requestOptimisticRouteCacheEntry","newRenderedSearch","collectedDebugInfo","undefined","tag","NavigationResultTag","Async","data","navigateDynamicallyWithNoPrefetch","navigationSeed","scrollableSegments","separateRefreshUrls","task","startPPRNavigation","head","spawnDynamicRequests","navigationTaskToResult","MPA","seedHead","Success","cacheNode","node","childRouterStates","childSeedDatas","slots","parallelRouteKey","childTree","childResult","loading","segmentEntry","readSegmentCacheEntry","varyPath","Pending","promiseForFulfilledEntry","waitForSegmentCacheEntry","then","entry","Empty","segment","addSearchParamsIfPageSegment","Object","fromEntries","URLSearchParams","hasRuntimePrefetch","isRootLayout","metadata","DynamicRequestTreeForEntireRoute","dynamicRequestTree","FreshnessPolicy","Default","HistoryTraversal","Hydration","RefreshAll","HMRRefresh","promiseForDynamicServerResponse","fetchServerResponse","result","newUrl","flightData","debugInfo","debugInfoFromResponse","push","createHrefFromUrl","currentTree","baseTree","baseData","segmentPath","treePatch","dataPatch","headPatch","convertServerPatchToFullTreeImpl","baseRouterState","index","length","updatedParallelRouteKey","baseTreeChildren","baseSeedDataChildren","newTreeChildren","newSeedDataChildren","childBaseRouterState","childBaseSeedData","clonedTree","clonedSeedData","isEmptySeedDataPartial"],"mappings":"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","ignoreList":[0]}