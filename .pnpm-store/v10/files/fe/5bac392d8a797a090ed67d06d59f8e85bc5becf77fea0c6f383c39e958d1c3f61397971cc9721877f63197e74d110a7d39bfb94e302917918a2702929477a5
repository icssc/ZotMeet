{"version":3,"file":"session.cjs","names":["entityKind","cache?: Cache","queryMetadata?: {\n\t\t\ttype: 'select' | 'update' | 'delete' | 'insert';\n\t\t\ttables: string[];\n\t\t} | undefined","cacheConfig?: WithCacheConfig","NoopCache","DrizzleQueryError","dialect: SingleStoreDialect","sql","parts: string[]","SingleStoreDatabase","relations: TRelations","schema: V1.RelationalSchemaConfig<TSchema> | undefined","nestedIndex: number","TransactionRollbackError"],"sources":["../../src/singlestore-core/session.ts"],"sourcesContent":["import type * as V1 from '~/_relations.ts';\nimport { type Cache, hashQuery, NoopCache } from '~/cache/core/cache.ts';\nimport type { WithCacheConfig } from '~/cache/core/types.ts';\nimport { entityKind, is } from '~/entity.ts';\nimport { DrizzleQueryError, TransactionRollbackError } from '~/errors.ts';\nimport type { AnyRelations, EmptyRelations } from '~/relations.ts';\nimport { type Query, type SQL, sql } from '~/sql/sql.ts';\nimport type { Assume, Equal } from '~/utils.ts';\nimport { SingleStoreDatabase } from './db.ts';\nimport type { SingleStoreDialect } from './dialect.ts';\nimport type { SelectedFieldsOrdered } from './query-builders/select.types.ts';\n\nexport interface SingleStoreQueryResultHKT {\n\treadonly $brand: 'SingleStoreQueryResultHKT';\n\treadonly row: unknown;\n\treadonly type: unknown;\n}\n\nexport interface AnySingleStoreQueryResultHKT extends SingleStoreQueryResultHKT {\n\treadonly type: any;\n}\n\nexport type SingleStoreQueryResultKind<TKind extends SingleStoreQueryResultHKT, TRow> = (TKind & {\n\treadonly row: TRow;\n})['type'];\n\nexport interface SingleStorePreparedQueryConfig {\n\texecute: unknown;\n\titerator: unknown;\n}\n\nexport interface SingleStorePreparedQueryHKT {\n\treadonly $brand: 'SingleStorePreparedQueryHKT';\n\treadonly config: unknown;\n\treadonly type: unknown;\n}\n\nexport type PreparedQueryKind<\n\tTKind extends SingleStorePreparedQueryHKT,\n\tTConfig extends SingleStorePreparedQueryConfig,\n\tTAssume extends boolean = false,\n> = Equal<TAssume, true> extends true\n\t? Assume<(TKind & { readonly config: TConfig })['type'], SingleStorePreparedQuery<TConfig>>\n\t: (TKind & { readonly config: TConfig })['type'];\n\nexport abstract class SingleStorePreparedQuery<T extends SingleStorePreparedQueryConfig> {\n\tstatic readonly [entityKind]: string = 'SingleStorePreparedQuery';\n\n\tconstructor(\n\t\tprivate cache?: Cache,\n\t\t// per query related metadata\n\t\tprivate queryMetadata?: {\n\t\t\ttype: 'select' | 'update' | 'delete' | 'insert';\n\t\t\ttables: string[];\n\t\t} | undefined,\n\t\t// config that was passed through $withCache\n\t\tprivate cacheConfig?: WithCacheConfig,\n\t) {\n\t\t// it means that no $withCache options were passed and it should be just enabled\n\t\tif (cache && cache.strategy() === 'all' && cacheConfig === undefined) {\n\t\t\tthis.cacheConfig = { enabled: true, autoInvalidate: true };\n\t\t}\n\t\tif (!this.cacheConfig?.enabled) {\n\t\t\tthis.cacheConfig = undefined;\n\t\t}\n\t}\n\n\t/** @internal */\n\tprotected async queryWithCache<T>(\n\t\tqueryString: string,\n\t\tparams: any[],\n\t\tquery: () => Promise<T>,\n\t): Promise<T> {\n\t\tif (this.cache === undefined || is(this.cache, NoopCache) || this.queryMetadata === undefined) {\n\t\t\ttry {\n\t\t\t\treturn await query();\n\t\t\t} catch (e) {\n\t\t\t\tthrow new DrizzleQueryError(queryString, params, e as Error);\n\t\t\t}\n\t\t}\n\n\t\t// don't do any mutations, if globally is false\n\t\tif (this.cacheConfig && !this.cacheConfig.enabled) {\n\t\t\ttry {\n\t\t\t\treturn await query();\n\t\t\t} catch (e) {\n\t\t\t\tthrow new DrizzleQueryError(queryString, params, e as Error);\n\t\t\t}\n\t\t}\n\n\t\t// For mutate queries, we should query the database, wait for a response, and then perform invalidation\n\t\tif (\n\t\t\t(\n\t\t\t\tthis.queryMetadata.type === 'insert' || this.queryMetadata.type === 'update'\n\t\t\t\t|| this.queryMetadata.type === 'delete'\n\t\t\t) && this.queryMetadata.tables.length > 0\n\t\t) {\n\t\t\ttry {\n\t\t\t\tconst [res] = await Promise.all([\n\t\t\t\t\tquery(),\n\t\t\t\t\tthis.cache.onMutate({ tables: this.queryMetadata.tables }),\n\t\t\t\t]);\n\t\t\t\treturn res;\n\t\t\t} catch (e) {\n\t\t\t\tthrow new DrizzleQueryError(queryString, params, e as Error);\n\t\t\t}\n\t\t}\n\n\t\t// don't do any reads if globally disabled\n\t\tif (!this.cacheConfig) {\n\t\t\ttry {\n\t\t\t\treturn await query();\n\t\t\t} catch (e) {\n\t\t\t\tthrow new DrizzleQueryError(queryString, params, e as Error);\n\t\t\t}\n\t\t}\n\n\t\tif (this.queryMetadata.type === 'select') {\n\t\t\tconst fromCache = await this.cache.get(\n\t\t\t\tthis.cacheConfig.tag ?? await hashQuery(queryString, params),\n\t\t\t\tthis.queryMetadata.tables,\n\t\t\t\tthis.cacheConfig.tag !== undefined,\n\t\t\t\tthis.cacheConfig.autoInvalidate,\n\t\t\t);\n\t\t\tif (fromCache === undefined) {\n\t\t\t\tlet result;\n\t\t\t\ttry {\n\t\t\t\t\tresult = await query();\n\t\t\t\t} catch (e) {\n\t\t\t\t\tthrow new DrizzleQueryError(queryString, params, e as Error);\n\t\t\t\t}\n\n\t\t\t\t// put actual key\n\t\t\t\tawait this.cache.put(\n\t\t\t\t\tthis.cacheConfig.tag ?? await hashQuery(queryString, params),\n\t\t\t\t\tresult,\n\t\t\t\t\t// make sure we send tables that were used in a query only if user wants to invalidate it on each write\n\t\t\t\t\tthis.cacheConfig.autoInvalidate ? this.queryMetadata.tables : [],\n\t\t\t\t\tthis.cacheConfig.tag !== undefined,\n\t\t\t\t\tthis.cacheConfig.config,\n\t\t\t\t);\n\t\t\t\t// put flag if we should invalidate or not\n\t\t\t\treturn result;\n\t\t\t}\n\n\t\t\treturn fromCache as unknown as T;\n\t\t}\n\t\ttry {\n\t\t\treturn await query();\n\t\t} catch (e) {\n\t\t\tthrow new DrizzleQueryError(queryString, params, e as Error);\n\t\t}\n\t}\n\n\t/** @internal */\n\tjoinsNotNullableMap?: Record<string, boolean>;\n\n\tabstract execute(placeholderValues?: Record<string, unknown>): Promise<T['execute']>;\n\n\tabstract iterator(placeholderValues?: Record<string, unknown>): AsyncGenerator<T['iterator']>;\n}\n\nexport interface SingleStoreTransactionConfig {\n\twithConsistentSnapshot?: boolean;\n\taccessMode?: 'read only' | 'read write';\n\tisolationLevel: 'read committed'; // SingleStore only supports read committed isolation level (https://docs.singlestore.com/db/v8.7/introduction/faqs/durability/)\n}\n\nexport abstract class SingleStoreSession<\n\tTQueryResult extends SingleStoreQueryResultHKT = SingleStoreQueryResultHKT,\n\tTPreparedQueryHKT extends PreparedQueryHKTBase = PreparedQueryHKTBase,\n\tTFullSchema extends Record<string, unknown> = Record<string, never>,\n\tTRelations extends AnyRelations = EmptyRelations,\n\tTSchema extends V1.TablesRelationalConfig = Record<string, never>,\n> {\n\tstatic readonly [entityKind]: string = 'SingleStoreSession';\n\n\tconstructor(protected dialect: SingleStoreDialect) {}\n\n\tabstract prepareQuery<\n\t\tT extends SingleStorePreparedQueryConfig,\n\t\tTPreparedQueryHKT extends SingleStorePreparedQueryHKT,\n\t>(\n\t\tquery: Query,\n\t\tfields: SelectedFieldsOrdered | undefined,\n\t\tcustomResultMapper?: (rows: unknown[][]) => T['execute'],\n\t\tgeneratedIds?: Record<string, unknown>[],\n\t\treturningIds?: SelectedFieldsOrdered,\n\t\tqueryMetadata?: {\n\t\t\ttype: 'select' | 'update' | 'delete' | 'insert';\n\t\t\ttables: string[];\n\t\t},\n\t\tcacheConfig?: WithCacheConfig,\n\t): PreparedQueryKind<TPreparedQueryHKT, T>;\n\n\tabstract prepareRelationalQuery<\n\t\tT extends SingleStorePreparedQueryConfig,\n\t\tTPreparedQueryHKT extends SingleStorePreparedQueryHKT,\n\t>(\n\t\tquery: Query,\n\t\tfields: SelectedFieldsOrdered | undefined,\n\t\tcustomResultMapper: (rows: Record<string, unknown>[]) => T['execute'],\n\t\tgeneratedIds?: Record<string, unknown>[],\n\t\treturningIds?: SelectedFieldsOrdered,\n\t): PreparedQueryKind<TPreparedQueryHKT, T>;\n\n\texecute<T>(query: SQL): Promise<T> {\n\t\treturn this.prepareQuery<SingleStorePreparedQueryConfig & { execute: T }, PreparedQueryHKTBase>(\n\t\t\tthis.dialect.sqlToQuery(query),\n\t\t\tundefined,\n\t\t).execute();\n\t}\n\n\tabstract all<T = unknown>(query: SQL): Promise<T[]>;\n\n\tasync count(sql: SQL): Promise<number> {\n\t\tconst res = await this.execute<[[{ count: string }]]>(sql);\n\n\t\treturn Number(\n\t\t\tres[0][0]['count'],\n\t\t);\n\t}\n\n\tabstract transaction<T>(\n\t\ttransaction: (\n\t\t\ttx: SingleStoreTransaction<TQueryResult, TPreparedQueryHKT, TFullSchema, TRelations, TSchema>,\n\t\t) => Promise<T>,\n\t\tconfig?: SingleStoreTransactionConfig,\n\t): Promise<T>;\n\n\tprotected getSetTransactionSQL(config: SingleStoreTransactionConfig): SQL | undefined {\n\t\tconst parts: string[] = [];\n\n\t\tif (config.isolationLevel) {\n\t\t\tparts.push(`isolation level ${config.isolationLevel}`);\n\t\t}\n\n\t\treturn parts.length ? sql`set transaction ${sql.raw(parts.join(' '))}` : undefined;\n\t}\n\n\tprotected getStartTransactionSQL(config: SingleStoreTransactionConfig): SQL | undefined {\n\t\tconst parts: string[] = [];\n\n\t\tif (config.withConsistentSnapshot) {\n\t\t\tparts.push('with consistent snapshot');\n\t\t}\n\n\t\tif (config.accessMode) {\n\t\t\tparts.push(config.accessMode);\n\t\t}\n\n\t\treturn parts.length ? sql`start transaction ${sql.raw(parts.join(' '))}` : undefined;\n\t}\n}\n\nexport abstract class SingleStoreTransaction<\n\tTQueryResult extends SingleStoreQueryResultHKT,\n\tTPreparedQueryHKT extends PreparedQueryHKTBase,\n\tTFullSchema extends Record<string, unknown> = Record<string, never>,\n\tTRelations extends AnyRelations = EmptyRelations,\n\tTSchema extends V1.TablesRelationalConfig = Record<string, never>,\n> extends SingleStoreDatabase<TQueryResult, TPreparedQueryHKT, TFullSchema, TRelations, TSchema> {\n\tstatic override readonly [entityKind]: string = 'SingleStoreTransaction';\n\n\tconstructor(\n\t\tdialect: SingleStoreDialect,\n\t\tsession: SingleStoreSession,\n\t\tprotected relations: TRelations,\n\t\tprotected schema: V1.RelationalSchemaConfig<TSchema> | undefined,\n\t\tprotected readonly nestedIndex: number,\n\t) {\n\t\tsuper(dialect, session, relations, schema);\n\t}\n\n\trollback(): never {\n\t\tthrow new TransactionRollbackError();\n\t}\n\n\t/** Nested transactions (aka savepoints) only work with InnoDB engine. */\n\tabstract override transaction<T>(\n\t\ttransaction: (\n\t\t\ttx: SingleStoreTransaction<TQueryResult, TPreparedQueryHKT, TFullSchema, TRelations, TSchema>,\n\t\t) => Promise<T>,\n\t): Promise<T>;\n}\n\nexport interface PreparedQueryHKTBase extends SingleStorePreparedQueryHKT {\n\ttype: SingleStorePreparedQuery<Assume<this['config'], SingleStorePreparedQueryConfig>>;\n}\n"],"mappings":"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"}