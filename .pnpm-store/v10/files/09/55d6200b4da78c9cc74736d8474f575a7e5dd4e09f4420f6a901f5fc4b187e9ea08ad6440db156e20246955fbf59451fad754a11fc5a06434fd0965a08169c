{"version":3,"sources":["../../../../../src/client/components/segment-cache/lru.ts"],"sourcesContent":["import { deleteMapEntry } from './cache-map'\nimport type { UnknownMapEntry } from './cache-map'\n\n// We use an LRU for memory management. We must update this whenever we add or\n// remove a new cache entry, or when an entry changes size.\n\nlet head: UnknownMapEntry | null = null\nlet didScheduleCleanup: boolean = false\nlet lruSize: number = 0\n\n// TODO: I chose the max size somewhat arbitrarily. Consider setting this based\n// on navigator.deviceMemory, or some other heuristic. We should make this\n// customizable via the Next.js config, too.\nconst maxLruSize = 50 * 1024 * 1024 // 50 MB\n\nexport function lruPut(node: UnknownMapEntry) {\n  if (head === node) {\n    // Already at the head\n    return\n  }\n  const prev = node.prev\n  const next = node.next\n  if (next === null || prev === null) {\n    // This is an insertion\n    lruSize += node.size\n    // Whenever we add an entry, we need to check if we've exceeded the\n    // max size. We don't evict entries immediately; they're evicted later in\n    // an asynchronous task.\n    ensureCleanupIsScheduled()\n  } else {\n    // This is a move. Remove from its current position.\n    prev.next = next\n    next.prev = prev\n  }\n\n  // Move to the front of the list\n  if (head === null) {\n    // This is the first entry\n    node.prev = node\n    node.next = node\n  } else {\n    // Add to the front of the list\n    const tail = head.prev\n    node.prev = tail\n    // In practice, this is never null, but that isn't encoded in the type\n    if (tail !== null) {\n      tail.next = node\n    }\n    node.next = head\n    head.prev = node\n  }\n  head = node\n}\n\nexport function updateLruSize(node: UnknownMapEntry, newNodeSize: number) {\n  // This is a separate function from `put` so that we can resize the entry\n  // regardless of whether it's currently being tracked by the LRU.\n  const prevNodeSize = node.size\n  node.size = newNodeSize\n  if (node.next === null) {\n    // This entry is not currently being tracked by the LRU.\n    return\n  }\n  // Update the total LRU size\n  lruSize = lruSize - prevNodeSize + newNodeSize\n  ensureCleanupIsScheduled()\n}\n\nexport function deleteFromLru(deleted: UnknownMapEntry) {\n  const next = deleted.next\n  const prev = deleted.prev\n  if (next !== null && prev !== null) {\n    lruSize -= deleted.size\n\n    deleted.next = null\n    deleted.prev = null\n\n    // Remove from the list\n    if (head === deleted) {\n      // Update the head\n      if (next === head) {\n        // This was the last entry\n        head = null\n      } else {\n        head = next\n      }\n    } else {\n      prev.next = next\n      next.prev = prev\n    }\n  } else {\n    // Already deleted\n  }\n}\n\nfunction ensureCleanupIsScheduled() {\n  if (didScheduleCleanup || lruSize <= maxLruSize) {\n    return\n  }\n  didScheduleCleanup = true\n  requestCleanupCallback(cleanup)\n}\n\nfunction cleanup() {\n  didScheduleCleanup = false\n\n  // Evict entries until we're at 90% capacity. We can assume this won't\n  // infinite loop because even if `maxLruSize` were 0, eventually\n  // `deleteFromLru` sets `head` to `null` when we run out entries.\n  const ninetyPercentMax = maxLruSize * 0.9\n  while (lruSize > ninetyPercentMax && head !== null) {\n    const tail = head.prev\n    // In practice, this is never null, but that isn't encoded in the type\n    if (tail !== null) {\n      // Delete the entry from the map. In turn, this will remove it from\n      // the LRU.\n      deleteMapEntry(tail)\n    }\n  }\n}\n\nconst requestCleanupCallback =\n  typeof requestIdleCallback === 'function'\n    ? requestIdleCallback\n    : (cb: () => void) => setTimeout(cb, 0)\n"],"names":["deleteMapEntry","head","didScheduleCleanup","lruSize","maxLruSize","lruPut","node","prev","next","size","ensureCleanupIsScheduled","tail","updateLruSize","newNodeSize","prevNodeSize","deleteFromLru","deleted","requestCleanupCallback","cleanup","ninetyPercentMax","requestIdleCallback","cb","setTimeout"],"mappings":"AAAA,SAASA,cAAc,QAAQ,cAAa;AAG5C,8EAA8E;AAC9E,2DAA2D;AAE3D,IAAIC,OAA+B;AACnC,IAAIC,qBAA8B;AAClC,IAAIC,UAAkB;AAEtB,+EAA+E;AAC/E,0EAA0E;AAC1E,4CAA4C;AAC5C,MAAMC,aAAa,KAAK,OAAO,KAAK,QAAQ;;AAE5C,OAAO,SAASC,OAAOC,IAAqB;IAC1C,IAAIL,SAASK,MAAM;QACjB,sBAAsB;QACtB;IACF;IACA,MAAMC,OAAOD,KAAKC,IAAI;IACtB,MAAMC,OAAOF,KAAKE,IAAI;IACtB,IAAIA,SAAS,QAAQD,SAAS,MAAM;QAClC,uBAAuB;QACvBJ,WAAWG,KAAKG,IAAI;QACpB,mEAAmE;QACnE,yEAAyE;QACzE,wBAAwB;QACxBC;IACF,OAAO;QACL,oDAAoD;QACpDH,KAAKC,IAAI,GAAGA;QACZA,KAAKD,IAAI,GAAGA;IACd;IAEA,gCAAgC;IAChC,IAAIN,SAAS,MAAM;QACjB,0BAA0B;QAC1BK,KAAKC,IAAI,GAAGD;QACZA,KAAKE,IAAI,GAAGF;IACd,OAAO;QACL,+BAA+B;QAC/B,MAAMK,OAAOV,KAAKM,IAAI;QACtBD,KAAKC,IAAI,GAAGI;QACZ,sEAAsE;QACtE,IAAIA,SAAS,MAAM;YACjBA,KAAKH,IAAI,GAAGF;QACd;QACAA,KAAKE,IAAI,GAAGP;QACZA,KAAKM,IAAI,GAAGD;IACd;IACAL,OAAOK;AACT;AAEA,OAAO,SAASM,cAAcN,IAAqB,EAAEO,WAAmB;IACtE,yEAAyE;IACzE,iEAAiE;IACjE,MAAMC,eAAeR,KAAKG,IAAI;IAC9BH,KAAKG,IAAI,GAAGI;IACZ,IAAIP,KAAKE,IAAI,KAAK,MAAM;QACtB,wDAAwD;QACxD;IACF;IACA,4BAA4B;IAC5BL,UAAUA,UAAUW,eAAeD;IACnCH;AACF;AAEA,OAAO,SAASK,cAAcC,OAAwB;IACpD,MAAMR,OAAOQ,QAAQR,IAAI;IACzB,MAAMD,OAAOS,QAAQT,IAAI;IACzB,IAAIC,SAAS,QAAQD,SAAS,MAAM;QAClCJ,WAAWa,QAAQP,IAAI;QAEvBO,QAAQR,IAAI,GAAG;QACfQ,QAAQT,IAAI,GAAG;QAEf,uBAAuB;QACvB,IAAIN,SAASe,SAAS;YACpB,kBAAkB;YAClB,IAAIR,SAASP,MAAM;gBACjB,0BAA0B;gBAC1BA,OAAO;YACT,OAAO;gBACLA,OAAOO;YACT;QACF,OAAO;YACLD,KAAKC,IAAI,GAAGA;YACZA,KAAKD,IAAI,GAAGA;QACd;IACF,OAAO;IACL,kBAAkB;IACpB;AACF;AAEA,SAASG;IACP,IAAIR,sBAAsBC,WAAWC,YAAY;QAC/C;IACF;IACAF,qBAAqB;IACrBe,uBAAuBC;AACzB;AAEA,SAASA;IACPhB,qBAAqB;IAErB,sEAAsE;IACtE,gEAAgE;IAChE,iEAAiE;IACjE,MAAMiB,mBAAmBf,aAAa;IACtC,MAAOD,UAAUgB,oBAAoBlB,SAAS,KAAM;QAClD,MAAMU,OAAOV,KAAKM,IAAI;QACtB,sEAAsE;QACtE,IAAII,SAAS,MAAM;YACjB,mEAAmE;YACnE,WAAW;YACXX,eAAeW;QACjB;IACF;AACF;AAEA,MAAMM,yBACJ,OAAOG,wBAAwB,aAC3BA,sBACA,CAACC,KAAmBC,WAAWD,IAAI","ignoreList":[0]}