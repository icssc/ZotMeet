{"version":3,"file":"session.js","names":["client: RemoteCallback","relations: TRelations","schema: V1.RelationalSchemaConfig<TSchema> | undefined","SingleStoreTransaction","PreparedQueryBase","queryString: string","params: unknown[]","logger: Logger","fields: SelectedFieldsOrdered | undefined","customResultMapper?: (\n\t\t\trows: TIsRqbV2 extends true ? Record<string, unknown>[] : unknown[][],\n\t\t) => T['execute']","generatedIds?: Record<string, unknown>[]","returningIds?: SelectedFieldsOrdered","isRqbV2Query?: TIsRqbV2"],"sources":["../../src/singlestore-proxy/session.ts"],"sourcesContent":["import type { FieldPacket, ResultSetHeader } from 'mysql2/promise';\nimport type * as V1 from '~/_relations.ts';\nimport { Column } from '~/column.ts';\nimport { entityKind, is } from '~/entity.ts';\nimport type { Logger } from '~/logger.ts';\nimport { NoopLogger } from '~/logger.ts';\nimport type { AnyRelations } from '~/relations.ts';\nimport type { SingleStoreDialect } from '~/singlestore-core/dialect.ts';\nimport { SingleStoreTransaction } from '~/singlestore-core/index.ts';\nimport type { SelectedFieldsOrdered } from '~/singlestore-core/query-builders/select.types.ts';\nimport type {\n\tPreparedQueryKind,\n\tSingleStorePreparedQueryConfig,\n\tSingleStorePreparedQueryHKT,\n\tSingleStoreQueryResultHKT,\n\tSingleStoreTransactionConfig,\n} from '~/singlestore-core/session.ts';\nimport { SingleStorePreparedQuery as PreparedQueryBase, SingleStoreSession } from '~/singlestore-core/session.ts';\nimport type { Query, SQL } from '~/sql/sql.ts';\nimport { fillPlaceholders } from '~/sql/sql.ts';\nimport { type Assume, mapResultRow } from '~/utils.ts';\nimport type { RemoteCallback } from './driver.ts';\n\nexport type SingleStoreRawQueryResult = [ResultSetHeader, FieldPacket[]];\n\nexport interface SingleStoreRemoteSessionOptions {\n\tlogger?: Logger;\n}\n\nexport class SingleStoreRemoteSession<\n\tTFullSchema extends Record<string, unknown>,\n\tTRelations extends AnyRelations,\n\tTSchema extends V1.TablesRelationalConfig,\n> extends SingleStoreSession<\n\tSingleStoreRemoteQueryResultHKT,\n\tSingleStoreRemotePreparedQueryHKT,\n\tTFullSchema,\n\tTRelations,\n\tTSchema\n> {\n\tstatic override readonly [entityKind]: string = 'SingleStoreRemoteSession';\n\n\tprivate logger: Logger;\n\n\tconstructor(\n\t\tprivate client: RemoteCallback,\n\t\tdialect: SingleStoreDialect,\n\t\tprivate relations: TRelations,\n\t\tprivate schema: V1.RelationalSchemaConfig<TSchema> | undefined,\n\t\toptions: SingleStoreRemoteSessionOptions,\n\t) {\n\t\tsuper(dialect);\n\t\tthis.logger = options.logger ?? new NoopLogger();\n\t}\n\n\tprepareQuery<T extends SingleStorePreparedQueryConfig>(\n\t\tquery: Query,\n\t\tfields: SelectedFieldsOrdered | undefined,\n\t\tcustomResultMapper?: (rows: unknown[][]) => T['execute'],\n\t\tgeneratedIds?: Record<string, unknown>[],\n\t\treturningIds?: SelectedFieldsOrdered,\n\t): PreparedQueryKind<SingleStoreRemotePreparedQueryHKT, T> {\n\t\treturn new PreparedQuery(\n\t\t\tthis.client,\n\t\t\tquery.sql,\n\t\t\tquery.params,\n\t\t\tthis.logger,\n\t\t\tfields,\n\t\t\tcustomResultMapper,\n\t\t\tgeneratedIds,\n\t\t\treturningIds,\n\t\t) as PreparedQueryKind<SingleStoreRemotePreparedQueryHKT, T>;\n\t}\n\n\tprepareRelationalQuery<T extends SingleStorePreparedQueryConfig>(\n\t\tquery: Query,\n\t\tfields: SelectedFieldsOrdered | undefined,\n\t\tcustomResultMapper: (rows: Record<string, unknown>[]) => T['execute'],\n\t\tgeneratedIds?: Record<string, unknown>[],\n\t\treturningIds?: SelectedFieldsOrdered,\n\t): PreparedQueryKind<SingleStoreRemotePreparedQueryHKT, T> {\n\t\treturn new PreparedQuery(\n\t\t\tthis.client,\n\t\t\tquery.sql,\n\t\t\tquery.params,\n\t\t\tthis.logger,\n\t\t\tfields,\n\t\t\tcustomResultMapper,\n\t\t\tgeneratedIds,\n\t\t\treturningIds,\n\t\t\ttrue,\n\t\t) as any;\n\t}\n\n\toverride all<T = unknown>(query: SQL): Promise<T[]> {\n\t\tconst querySql = this.dialect.sqlToQuery(query);\n\t\tthis.logger.logQuery(querySql.sql, querySql.params);\n\t\treturn this.client(querySql.sql, querySql.params, 'all').then(({ rows }) => rows) as Promise<T[]>;\n\t}\n\n\toverride async transaction<T>(\n\t\t_transaction: (tx: SingleStoreProxyTransaction<TFullSchema, TRelations, TSchema>) => Promise<T>,\n\t\t_config?: SingleStoreTransactionConfig,\n\t): Promise<T> {\n\t\tthrow new Error('Transactions are not supported by the SingleStore Proxy driver');\n\t}\n}\n\nexport class SingleStoreProxyTransaction<\n\tTFullSchema extends Record<string, unknown>,\n\tTRelations extends AnyRelations,\n\tTSchema extends V1.TablesRelationalConfig,\n> extends SingleStoreTransaction<\n\tSingleStoreRemoteQueryResultHKT,\n\tSingleStoreRemotePreparedQueryHKT,\n\tTFullSchema,\n\tTRelations,\n\tTSchema\n> {\n\tstatic override readonly [entityKind]: string = 'SingleStoreProxyTransaction';\n\n\toverride async transaction<T>(\n\t\t_transaction: (tx: SingleStoreProxyTransaction<TFullSchema, TRelations, TSchema>) => Promise<T>,\n\t): Promise<T> {\n\t\tthrow new Error('Transactions are not supported by the SingleStore Proxy driver');\n\t}\n}\n\nexport class PreparedQuery<T extends SingleStorePreparedQueryConfig, TIsRqbV2 extends boolean = false>\n\textends PreparedQueryBase<T>\n{\n\tstatic override readonly [entityKind]: string = 'SingleStoreProxyPreparedQuery';\n\n\tconstructor(\n\t\tprivate client: RemoteCallback,\n\t\tprivate queryString: string,\n\t\tprivate params: unknown[],\n\t\tprivate logger: Logger,\n\t\tprivate fields: SelectedFieldsOrdered | undefined,\n\t\tprivate customResultMapper?: (\n\t\t\trows: TIsRqbV2 extends true ? Record<string, unknown>[] : unknown[][],\n\t\t) => T['execute'],\n\t\t// Keys that were used in $default and the value that was generated for them\n\t\tprivate generatedIds?: Record<string, unknown>[],\n\t\t// Keys that should be returned, it has the column with all properries + key from object\n\t\tprivate returningIds?: SelectedFieldsOrdered,\n\t\tprivate isRqbV2Query?: TIsRqbV2,\n\t) {\n\t\tsuper();\n\t}\n\n\tasync execute(placeholderValues: Record<string, unknown> | undefined = {}): Promise<T['execute']> {\n\t\tif (this.isRqbV2Query) return this.executeRqbV2(placeholderValues);\n\n\t\tconst params = fillPlaceholders(this.params, placeholderValues);\n\n\t\tconst { fields, client, queryString, logger, joinsNotNullableMap, customResultMapper, returningIds, generatedIds } =\n\t\t\tthis;\n\n\t\tlogger.logQuery(queryString, params);\n\n\t\tif (!fields && !customResultMapper) {\n\t\t\tconst { rows: data } = await client(queryString, params, 'execute');\n\n\t\t\tconst insertId = data[0].insertId as number;\n\t\t\tconst affectedRows = data[0].affectedRows;\n\n\t\t\tif (returningIds) {\n\t\t\t\tconst returningResponse = [];\n\t\t\t\tlet j = 0;\n\t\t\t\tfor (let i = insertId; i < insertId + affectedRows; i++) {\n\t\t\t\t\tfor (const column of returningIds) {\n\t\t\t\t\t\tconst key = returningIds[0]!.path[0]!;\n\t\t\t\t\t\tif (is(column.field, Column)) {\n\t\t\t\t\t\t\t// @ts-ignore\n\t\t\t\t\t\t\tif (column.field.primary && column.field.autoIncrement) {\n\t\t\t\t\t\t\t\treturningResponse.push({ [key]: i });\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (column.field.defaultFn && generatedIds) {\n\t\t\t\t\t\t\t\t// generatedIds[rowIdx][key]\n\t\t\t\t\t\t\t\treturningResponse.push({ [key]: generatedIds[j]![key] });\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tj++;\n\t\t\t\t}\n\n\t\t\t\treturn returningResponse;\n\t\t\t}\n\n\t\t\treturn data;\n\t\t}\n\n\t\tconst { rows } = await client(queryString, params, 'all');\n\n\t\tif (customResultMapper) {\n\t\t\treturn customResultMapper(rows);\n\t\t}\n\n\t\treturn rows.map((row) => mapResultRow<T['execute']>(fields!, row, joinsNotNullableMap));\n\t}\n\n\tprivate async executeRqbV2(placeholderValues: Record<string, unknown> | undefined = {}): Promise<T['execute']> {\n\t\tconst params = fillPlaceholders(this.params, placeholderValues);\n\n\t\tconst { client, queryString, logger, customResultMapper } = this;\n\n\t\tlogger.logQuery(queryString, params);\n\n\t\tconst { rows: res } = await client(queryString, params, 'execute');\n\t\tconst rows = res[0];\n\n\t\treturn customResultMapper!(rows);\n\t}\n\n\toverride iterator(\n\t\t_placeholderValues: Record<string, unknown> = {},\n\t): AsyncGenerator<T['iterator']> {\n\t\tthrow new Error('Streaming is not supported by the SingleStore Proxy driver');\n\t}\n}\n\nexport interface SingleStoreRemoteQueryResultHKT extends SingleStoreQueryResultHKT {\n\ttype: SingleStoreRawQueryResult;\n}\n\nexport interface SingleStoreRemotePreparedQueryHKT extends SingleStorePreparedQueryHKT {\n\ttype: PreparedQuery<Assume<this['config'], SingleStorePreparedQueryConfig>>;\n}\n"],"mappings":"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"}