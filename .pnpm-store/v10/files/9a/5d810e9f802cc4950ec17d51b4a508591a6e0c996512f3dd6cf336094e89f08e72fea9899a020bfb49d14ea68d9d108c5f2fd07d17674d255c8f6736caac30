{"version":3,"file":"session.js","names":["client: NodeMsSqlClient","params: unknown[]","logger: Logger","fields: SelectedFieldsOrdered | undefined","customResultMapper?: (rows: unknown[][]) => T['execute']","schema: V1.RelationalSchemaConfig<TSchema> | undefined","options: NodeMsSqlSessionOptions","isolationLevelMap: Record<\n\tMsSqlTransactionConfig['isolationLevel'],\n\t(typeof mssql.ISOLATION_LEVEL)[keyof (typeof mssql)['ISOLATION_LEVEL']]\n>"],"sources":["../../src/node-mssql/session.ts"],"sourcesContent":["import type { ConnectionPool, IResult, Request } from 'mssql';\nimport mssql from 'mssql';\nimport { once } from 'node:events';\nimport type * as V1 from '~/_relations.ts';\nimport { entityKind, is } from '~/entity.ts';\nimport type { Logger } from '~/logger.ts';\nimport { NoopLogger } from '~/logger.ts';\nimport type { MsSqlDialect } from '~/mssql-core/dialect.ts';\nimport type { SelectedFieldsOrdered } from '~/mssql-core/query-builders/select.types.ts';\nimport {\n\tMsSqlSession,\n\tMsSqlTransaction,\n\ttype MsSqlTransactionConfig,\n\tPreparedQuery,\n\ttype PreparedQueryConfig,\n\ttype PreparedQueryHKT,\n\ttype PreparedQueryKind,\n\ttype QueryResultHKT,\n} from '~/mssql-core/session.ts';\nimport { fillPlaceholders, type Query, type SQL, sql } from '~/sql/sql.ts';\nimport { type Assume, mapResultRow } from '~/utils.ts';\nimport { AutoPool } from './pool.ts';\n\nexport type NodeMsSqlClient = Pick<ConnectionPool, 'request'> | AutoPool;\n\nexport type MsSqlQueryResult<T extends unknown | unknown[] = any> = IResult<T>;\n\nexport class NodeMsSqlPreparedQuery<\n\tT extends PreparedQueryConfig,\n> extends PreparedQuery<T> {\n\tstatic override readonly [entityKind]: string = 'NodeMsSqlPreparedQuery';\n\n\tprivate rawQuery: {\n\t\tsql: string;\n\t\tparameters: unknown[];\n\t};\n\n\tconstructor(\n\t\tprivate client: NodeMsSqlClient,\n\t\tqueryString: string,\n\t\tprivate params: unknown[],\n\t\tprivate logger: Logger,\n\t\tprivate fields: SelectedFieldsOrdered | undefined,\n\t\tprivate customResultMapper?: (rows: unknown[][]) => T['execute'],\n\t) {\n\t\tsuper();\n\t\tthis.rawQuery = {\n\t\t\tsql: queryString,\n\t\t\tparameters: params,\n\t\t};\n\t}\n\n\tasync execute(\n\t\tplaceholderValues: Record<string, unknown> = {},\n\t): Promise<T['execute']> {\n\t\tconst params = fillPlaceholders(this.params, placeholderValues);\n\n\t\tthis.logger.logQuery(this.rawQuery.sql, params);\n\n\t\tconst {\n\t\t\tfields,\n\t\t\tclient,\n\t\t\trawQuery,\n\t\t\tjoinsNotNullableMap,\n\t\t\tcustomResultMapper,\n\t\t} = this;\n\t\tlet queryClient = client as ConnectionPool;\n\t\tif (is(client, AutoPool)) {\n\t\t\tqueryClient = await client.$instance();\n\t\t}\n\t\tconst request = queryClient.request() as Request & { arrayRowMode: boolean };\n\t\tfor (const [index, param] of params.entries()) {\n\t\t\trequest.input(`par${index}`, param);\n\t\t}\n\n\t\tif (!fields && !customResultMapper) {\n\t\t\treturn request.query(rawQuery.sql) as Promise<T['execute']>;\n\t\t}\n\n\t\trequest.arrayRowMode = true;\n\t\tconst rows = await request.query<any[]>(rawQuery.sql);\n\n\t\tif (customResultMapper) {\n\t\t\treturn customResultMapper(rows.recordset);\n\t\t}\n\n\t\treturn rows.recordset.map((row) => mapResultRow<T['execute']>(fields!, row, joinsNotNullableMap));\n\t}\n\n\tasync *iterator(\n\t\tplaceholderValues: Record<string, unknown> = {},\n\t): AsyncGenerator<\n\t\tT['execute'] extends any[] ? T['execute'][number] : T['execute']\n\t> {\n\t\tconst params = fillPlaceholders(this.params, placeholderValues);\n\n\t\tconst {\n\t\t\tfields,\n\t\t\trawQuery,\n\t\t\tjoinsNotNullableMap,\n\t\t\tclient,\n\t\t\tcustomResultMapper,\n\t\t} = this;\n\t\tlet queryClient = client as ConnectionPool;\n\t\tif (is(client, AutoPool)) {\n\t\t\tqueryClient = await client.$instance();\n\t\t}\n\t\tconst request = queryClient.request() as Request & { arrayRowMode: boolean };\n\t\trequest.stream = true;\n\t\tconst hasRowsMapper = Boolean(fields || customResultMapper);\n\n\t\tif (hasRowsMapper) {\n\t\t\trequest.arrayRowMode = true;\n\t\t}\n\n\t\tfor (const [index, param] of params.entries()) {\n\t\t\trequest.input(`par${index}`, param);\n\t\t}\n\n\t\tconst stream = request.toReadableStream();\n\n\t\trequest.query(rawQuery.sql);\n\n\t\tfunction dataListener() {\n\t\t\tstream.pause();\n\t\t}\n\n\t\tstream.on('data', dataListener);\n\n\t\ttry {\n\t\t\tconst onEnd = once(stream, 'end');\n\t\t\tconst onError = once(stream, 'error');\n\n\t\t\twhile (true) {\n\t\t\t\tstream.resume();\n\t\t\t\tconst row = await Promise.race([\n\t\t\t\t\tonEnd,\n\t\t\t\t\tonError,\n\t\t\t\t\tnew Promise((resolve) => stream.once('data', resolve)),\n\t\t\t\t]);\n\t\t\t\tif (row === undefined || (Array.isArray(row) && row.length === 0)) {\n\t\t\t\t\tbreak;\n\t\t\t\t\t// oxlint-disable-next-line drizzle-internal/no-instanceof\n\t\t\t\t} else if (row instanceof Error) {\n\t\t\t\t\tthrow row;\n\t\t\t\t} else {\n\t\t\t\t\tif (hasRowsMapper) {\n\t\t\t\t\t\tif (customResultMapper) {\n\t\t\t\t\t\t\tconst mappedRow = customResultMapper([row as unknown[]]);\n\t\t\t\t\t\t\tyield Array.isArray(mappedRow) ? mappedRow[0] : mappedRow;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tyield mapResultRow(\n\t\t\t\t\t\t\t\tfields!,\n\t\t\t\t\t\t\t\trow as unknown[],\n\t\t\t\t\t\t\t\tjoinsNotNullableMap,\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tyield row as T['execute'];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} finally {\n\t\t\tstream.off('data', dataListener);\n\t\t\trequest.cancel();\n\t\t}\n\t}\n}\n\nexport interface NodeMsSqlSessionOptions {\n\tlogger?: Logger;\n}\n\nexport class NodeMsSqlSession<\n\tTFullSchema extends Record<string, unknown>,\n\tTSchema extends V1.TablesRelationalConfig,\n> extends MsSqlSession<\n\tNodeMsSqlQueryResultHKT,\n\tNodeMsSqlPreparedQueryHKT,\n\tTFullSchema,\n\tTSchema\n> {\n\tstatic override readonly [entityKind]: string = 'NodeMsSqlSession';\n\n\tprivate logger: Logger;\n\n\tconstructor(\n\t\tprivate client: NodeMsSqlClient,\n\t\tdialect: MsSqlDialect,\n\t\tprivate schema: V1.RelationalSchemaConfig<TSchema> | undefined,\n\t\tprivate options: NodeMsSqlSessionOptions,\n\t) {\n\t\tsuper(dialect);\n\t\tthis.logger = options.logger ?? new NoopLogger();\n\t}\n\n\tprepareQuery<T extends PreparedQueryConfig>(\n\t\tquery: Query,\n\t\tfields: SelectedFieldsOrdered | undefined,\n\t\tcustomResultMapper?: (rows: unknown[][]) => T['execute'],\n\t): PreparedQueryKind<NodeMsSqlPreparedQueryHKT, T> {\n\t\treturn new NodeMsSqlPreparedQuery(\n\t\t\tthis.client,\n\t\t\tquery.sql,\n\t\t\tquery.params,\n\t\t\tthis.logger,\n\t\t\tfields,\n\t\t\tcustomResultMapper,\n\t\t) as PreparedQueryKind<NodeMsSqlPreparedQueryHKT, T>;\n\t}\n\n\t/**\n\t * @internal\n\t * What is its purpose?\n\t */\n\tasync query(query: string, params: unknown[]): Promise<MsSqlQueryResult> {\n\t\tthis.logger.logQuery(query, params);\n\n\t\tlet queryClient = this.client as ConnectionPool;\n\t\tif (is(this.client, AutoPool)) {\n\t\t\tqueryClient = await this.client.$instance();\n\t\t}\n\t\tconst request = queryClient.request() as Request & {\n\t\t\tarrayRowMode: boolean;\n\t\t};\n\t\trequest.arrayRowMode = true;\n\n\t\tfor (const [index, param] of params.entries()) {\n\t\t\trequest.input(`par${index}`, param);\n\t\t}\n\n\t\treturn request.query(query);\n\t}\n\n\toverride async all<T = unknown>(query: SQL): Promise<T[]> {\n\t\tconst querySql = this.dialect.sqlToQuery(query);\n\t\tthis.logger.logQuery(querySql.sql, querySql.params);\n\t\treturn await this.query(querySql.sql, querySql.params).then(\n\t\t\t(result) => result.recordset,\n\t\t);\n\t}\n\n\toverride async transaction<T>(\n\t\ttransaction: (tx: NodeMsSqlTransaction<TFullSchema, TSchema>) => Promise<T>,\n\t\tconfig?: MsSqlTransactionConfig,\n\t): Promise<T> {\n\t\tconst mssqlTransaction = (this.client as ConnectionPool).transaction();\n\t\tconst session = new NodeMsSqlSession(\n\t\t\tmssqlTransaction,\n\t\t\tthis.dialect,\n\t\t\tthis.schema,\n\t\t\tthis.options,\n\t\t);\n\t\tconst tx = new NodeMsSqlTransaction(\n\t\t\tthis.dialect,\n\t\t\tsession as MsSqlSession<any, any, any, any>,\n\t\t\tthis.schema,\n\t\t\t0,\n\t\t);\n\n\t\tawait mssqlTransaction.begin(\n\t\t\tconfig?.isolationLevel\n\t\t\t\t? isolationLevelMap[config.isolationLevel]\n\t\t\t\t: undefined,\n\t\t);\n\n\t\ttry {\n\t\t\tconst result = await transaction(tx);\n\t\t\tawait mssqlTransaction.commit();\n\t\t\treturn result;\n\t\t} catch (err) {\n\t\t\tawait mssqlTransaction.rollback();\n\t\t\tthrow err;\n\t\t}\n\t}\n}\n\nexport class NodeMsSqlTransaction<\n\tTFullSchema extends Record<string, unknown>,\n\tTSchema extends V1.TablesRelationalConfig,\n> extends MsSqlTransaction<\n\tNodeMsSqlQueryResultHKT,\n\tNodeMsSqlPreparedQueryHKT,\n\tTFullSchema,\n\tTSchema\n> {\n\tstatic override readonly [entityKind]: string = 'NodeMsSqlTransaction';\n\n\toverride async transaction<T>(\n\t\ttransaction: (tx: NodeMsSqlTransaction<TFullSchema, TSchema>) => Promise<T>,\n\t): Promise<T> {\n\t\tconst savepointName = `sp${this.nestedIndex + 1}`;\n\t\tconst tx = new NodeMsSqlTransaction(\n\t\t\tthis.dialect,\n\t\t\tthis.session,\n\t\t\tthis.schema,\n\t\t\tthis.nestedIndex + 1,\n\t\t);\n\n\t\tawait tx.execute(sql.raw(`save transaction ${savepointName}`));\n\t\ttry {\n\t\t\tconst result = await transaction(tx);\n\t\t\treturn result;\n\t\t} catch (err) {\n\t\t\tawait tx.execute(sql.raw(`rollback transaction ${savepointName}`));\n\t\t\tthrow err;\n\t\t}\n\t}\n}\n\nconst isolationLevelMap: Record<\n\tMsSqlTransactionConfig['isolationLevel'],\n\t(typeof mssql.ISOLATION_LEVEL)[keyof (typeof mssql)['ISOLATION_LEVEL']]\n> = {\n\t'read uncommitted': mssql.ISOLATION_LEVEL.READ_UNCOMMITTED,\n\t'read committed': mssql.ISOLATION_LEVEL.READ_COMMITTED,\n\t'repeatable read': mssql.ISOLATION_LEVEL.REPEATABLE_READ,\n\tserializable: mssql.ISOLATION_LEVEL.SERIALIZABLE,\n\tsnapshot: mssql.ISOLATION_LEVEL.SNAPSHOT,\n};\n\nexport interface NodeMsSqlQueryResultHKT extends QueryResultHKT {\n\ttype: MsSqlQueryResult<this['row']>;\n}\n\nexport interface NodeMsSqlPreparedQueryHKT extends PreparedQueryHKT {\n\ttype: NodeMsSqlPreparedQuery<Assume<this['config'], PreparedQueryConfig>>;\n}\n"],"mappings":"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"}