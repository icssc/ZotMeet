{"version":3,"sources":["../../../src/build/next-config-ts/transpile-config.ts"],"sourcesContent":["import type { Options as SWCOptions } from '@swc/core'\nimport type { CompilerOptions } from 'typescript'\n\nimport { resolve } from 'node:path'\nimport { readFile } from 'node:fs/promises'\nimport { pathToFileURL } from 'node:url'\nimport { deregisterHook, registerHook, requireFromString } from './require-hook'\nimport { warn, warnOnce } from '../output/log'\nimport { installDependencies } from '../../lib/install-dependencies'\nimport { getNodeOptionsArgs } from '../../server/lib/utils'\n\nfunction resolveSWCOptions(\n  cwd: string,\n  compilerOptions: CompilerOptions\n): SWCOptions {\n  return {\n    jsc: {\n      parser: {\n        syntax: 'typescript',\n      },\n      ...(compilerOptions.paths ? { paths: compilerOptions.paths } : {}),\n      ...(compilerOptions.baseUrl\n        ? // Needs to be an absolute path.\n          { baseUrl: resolve(cwd, compilerOptions.baseUrl) }\n        : compilerOptions.paths\n          ? // If paths is given, baseUrl is required.\n            { baseUrl: cwd }\n          : {}),\n    },\n    module: {\n      type: 'commonjs',\n    },\n    isModule: 'unknown',\n    env: {\n      targets: {\n        // Setting the Node.js version can reduce unnecessary code generation.\n        node: process?.versions?.node ?? '20.19.0',\n      },\n    },\n  } satisfies SWCOptions\n}\n\n// Ported from next/src/lib/verify-typescript-setup.ts\n// Although this overlaps with the later `verifyTypeScriptSetup`,\n// it is acceptable since the time difference in the worst case is trivial,\n// as we are only preparing to install the dependencies once more.\nasync function verifyTypeScriptSetup(cwd: string, configFileName: string) {\n  try {\n    // Quick module check.\n    require.resolve('typescript', { paths: [cwd] })\n  } catch (error) {\n    if (\n      error &&\n      typeof error === 'object' &&\n      'code' in error &&\n      error.code === 'MODULE_NOT_FOUND'\n    ) {\n      warn(\n        `Installing TypeScript as it was not found while loading \"${configFileName}\".`\n      )\n\n      await installDependencies(cwd, [{ pkg: 'typescript' }], true).catch(\n        (err) => {\n          if (err && typeof err === 'object' && 'command' in err) {\n            console.error(\n              `Failed to install TypeScript, please install it manually to continue:\\n` +\n                (err as any).command +\n                '\\n'\n            )\n          }\n          throw err\n        }\n      )\n    }\n  }\n}\n\nasync function getTsConfig(cwd: string): Promise<CompilerOptions> {\n  const ts: typeof import('typescript') = require(\n    require.resolve('typescript', { paths: [cwd] })\n  )\n\n  // NOTE: This doesn't fully cover the edge case for setting\n  // \"typescript.tsconfigPath\" in next config which is currently\n  // a restriction.\n  const tsConfigPath = ts.findConfigFile(\n    cwd,\n    ts.sys.fileExists,\n    'tsconfig.json'\n  )\n\n  if (!tsConfigPath) {\n    // It is ok to not return ts.getDefaultCompilerOptions() because\n    // we are only looking for paths and baseUrl from tsConfig.\n    return {}\n  }\n\n  const configFile = ts.readConfigFile(tsConfigPath, ts.sys.readFile)\n  const parsedCommandLine = ts.parseJsonConfigFileContent(\n    configFile.config,\n    ts.sys,\n    cwd\n  )\n\n  return parsedCommandLine.options\n}\n\nexport async function transpileConfig({\n  nextConfigPath,\n  configFileName,\n  cwd,\n}: {\n  nextConfigPath: string\n  configFileName: string\n  cwd: string\n}) {\n  try {\n    // envs are passed to the workers and preserve the flag\n    if (process.env.__NEXT_NODE_NATIVE_TS_LOADER_ENABLED === 'true') {\n      try {\n        // Node.js v22.10.0+\n        // Value is 'strip' or 'transform' based on how the feature is enabled.\n        // https://nodejs.org/api/process.html#processfeaturestypescript\n        // TODO: Remove `as any` once we bump @types/node to v22.10.0+\n        if ((process.features as any).typescript) {\n          // Run import() here to catch errors and fallback to legacy resolution.\n          return (await import(pathToFileURL(nextConfigPath).href)).default\n        }\n\n        if (\n          getNodeOptionsArgs().includes('--no-experimental-strip-types') ||\n          process.execArgv.includes('--no-experimental-strip-types')\n        ) {\n          warnOnce(\n            `Skipped resolving \"${configFileName}\" using Node.js native TypeScript resolution because it was disabled by the \"--no-experimental-strip-types\" flag.` +\n              ' Falling back to legacy resolution.' +\n              ' Learn more: https://nextjs.org/docs/app/api-reference/config/typescript#using-nodejs-native-typescript-resolver-for-nextconfigts'\n          )\n        }\n\n        // Feature is not enabled, fallback to legacy resolution for current session.\n        process.env.__NEXT_NODE_NATIVE_TS_LOADER_ENABLED = 'false'\n      } catch (cause) {\n        warnOnce(\n          `Failed to import \"${configFileName}\" using Node.js native TypeScript resolution.` +\n            ' Falling back to legacy resolution.' +\n            ' Learn more: https://nextjs.org/docs/app/api-reference/config/typescript#using-nodejs-native-typescript-resolver-for-nextconfigts',\n          { cause }\n        )\n        // Once failed, fallback to legacy resolution for current session.\n        process.env.__NEXT_NODE_NATIVE_TS_LOADER_ENABLED = 'false'\n      }\n    }\n\n    // Ensure TypeScript is installed to use the API.\n    await verifyTypeScriptSetup(cwd, configFileName)\n    const compilerOptions = await getTsConfig(cwd)\n\n    return handleCJS({ cwd, nextConfigPath, compilerOptions })\n  } catch (cause) {\n    throw new Error(`Failed to transpile \"${configFileName}\".`, { cause })\n  }\n}\n\nasync function handleCJS({\n  cwd,\n  nextConfigPath,\n  compilerOptions,\n}: {\n  cwd: string\n  nextConfigPath: string\n  compilerOptions: CompilerOptions\n}) {\n  const swcOptions = resolveSWCOptions(cwd, compilerOptions)\n  let hasRequire = false\n  try {\n    const nextConfigString = await readFile(nextConfigPath, 'utf8')\n    // lazy require swc since it loads React before even setting NODE_ENV\n    // resulting loading Development React on Production\n    const { loadBindings } = require('../swc') as typeof import('../swc')\n    const bindings = await loadBindings()\n    const { code } = await bindings.transform(nextConfigString, swcOptions)\n\n    // register require hook only if require exists\n    if (code.includes('require(')) {\n      registerHook(swcOptions)\n      hasRequire = true\n    }\n\n    // filename & extension don't matter here\n    const config = requireFromString(\n      code,\n      resolve(cwd, 'next.config.compiled.js')\n    )\n    // At this point we have already loaded the bindings without this configuration setting due to the `transform` call above.\n    // Possibly we fell back to wasm in which case, it all works out but if not we need to warn\n    // that the configuration was ignored.\n    if (config?.experimental?.useWasmBinary && !bindings.isWasm) {\n      warn(\n        'Using a next.config.ts file is incompatible with `experimental.useWasmBinary` unless ' +\n          '`--experimental-next-config-strip-types` is also passed.\\nSetting `useWasmBinary` to `false'\n      )\n      config.experimental.useWasmBinary = false\n    }\n    return config\n  } catch (error) {\n    throw error\n  } finally {\n    if (hasRequire) {\n      deregisterHook()\n    }\n  }\n}\n"],"names":["transpileConfig","resolveSWCOptions","cwd","compilerOptions","process","jsc","parser","syntax","paths","baseUrl","resolve","module","type","isModule","env","targets","node","versions","verifyTypeScriptSetup","configFileName","require","error","code","warn","installDependencies","pkg","catch","err","console","command","getTsConfig","ts","tsConfigPath","findConfigFile","sys","fileExists","configFile","readConfigFile","readFile","parsedCommandLine","parseJsonConfigFileContent","config","options","nextConfigPath","__NEXT_NODE_NATIVE_TS_LOADER_ENABLED","features","typescript","pathToFileURL","href","default","getNodeOptionsArgs","includes","execArgv","warnOnce","cause","handleCJS","Error","swcOptions","hasRequire","nextConfigString","loadBindings","bindings","transform","registerHook","requireFromString","experimental","useWasmBinary","isWasm","deregisterHook"],"mappings":"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","ignoreList":[0]}