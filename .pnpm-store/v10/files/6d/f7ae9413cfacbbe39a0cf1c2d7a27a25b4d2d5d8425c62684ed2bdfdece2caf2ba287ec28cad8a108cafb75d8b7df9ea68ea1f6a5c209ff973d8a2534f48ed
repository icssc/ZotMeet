{"version":3,"sources":["../../../../../src/shared/lib/router/routes/app.ts"],"sourcesContent":["import { InvariantError } from '../../invariant-error'\nimport { getSegmentParam, type SegmentParam } from '../utils/get-segment-param'\nimport {\n  INTERCEPTION_ROUTE_MARKERS,\n  type InterceptionMarker,\n} from '../utils/interception-routes'\n\nexport type RouteGroupAppRouteSegment = {\n  type: 'route-group'\n  name: string\n\n  /**\n   * If present, this segment has an interception marker prefixing it.\n   */\n  interceptionMarker?: InterceptionMarker\n}\n\nexport type ParallelRouteAppRouteSegment = {\n  type: 'parallel-route'\n  name: string\n\n  /**\n   * If present, this segment has an interception marker prefixing it.\n   */\n  interceptionMarker?: InterceptionMarker\n}\n\nexport type StaticAppRouteSegment = {\n  type: 'static'\n  name: string\n\n  /**\n   * If present, this segment has an interception marker prefixing it.\n   */\n  interceptionMarker?: InterceptionMarker\n}\n\nexport type DynamicAppRouteSegment = {\n  type: 'dynamic'\n  name: string\n  param: SegmentParam\n\n  /**\n   * If present, this segment has an interception marker prefixing it.\n   */\n  interceptionMarker?: InterceptionMarker\n}\n\n/**\n * Represents a single segment in a route path.\n * Can be either static (e.g., \"blog\") or dynamic (e.g., \"[slug]\").\n */\nexport type AppRouteSegment =\n  | StaticAppRouteSegment\n  | DynamicAppRouteSegment\n  | RouteGroupAppRouteSegment\n  | ParallelRouteAppRouteSegment\n\nexport type NormalizedAppRouteSegment =\n  | StaticAppRouteSegment\n  | DynamicAppRouteSegment\n\nexport function parseAppRouteSegment(segment: string): AppRouteSegment | null {\n  if (segment === '') {\n    return null\n  }\n\n  // Check if the segment starts with an interception marker\n  const interceptionMarker = INTERCEPTION_ROUTE_MARKERS.find((m) =>\n    segment.startsWith(m)\n  )\n\n  const param = getSegmentParam(segment)\n  if (param) {\n    return {\n      type: 'dynamic',\n      name: segment,\n      param,\n      interceptionMarker,\n    }\n  } else if (segment.startsWith('(') && segment.endsWith(')')) {\n    return {\n      type: 'route-group',\n      name: segment,\n      interceptionMarker,\n    }\n  } else if (segment.startsWith('@')) {\n    return {\n      type: 'parallel-route',\n      name: segment,\n      interceptionMarker,\n    }\n  } else {\n    return {\n      type: 'static',\n      name: segment,\n      interceptionMarker,\n    }\n  }\n}\n\nexport type AppRoute = {\n  normalized: boolean\n  pathname: string\n  segments: AppRouteSegment[]\n  dynamicSegments: DynamicAppRouteSegment[]\n  interceptionMarker: InterceptionMarker | undefined\n  interceptingRoute: AppRoute | undefined\n  interceptedRoute: AppRoute | undefined\n}\n\nexport type NormalizedAppRoute = Omit<AppRoute, 'normalized' | 'segments'> & {\n  normalized: true\n  segments: NormalizedAppRouteSegment[]\n}\n\nexport function isNormalizedAppRoute(\n  route: InterceptionAppRoute\n): route is NormalizedInterceptionAppRoute\nexport function isNormalizedAppRoute(\n  route: AppRoute | InterceptionAppRoute\n): route is NormalizedAppRoute {\n  return route.normalized\n}\n\nexport type InterceptionAppRoute = Omit<\n  AppRoute,\n  'interceptionMarker' | 'interceptingRoute' | 'interceptedRoute'\n> & {\n  interceptionMarker: InterceptionMarker\n  interceptingRoute: AppRoute\n  interceptedRoute: AppRoute\n}\n\nexport type NormalizedInterceptionAppRoute = Omit<\n  InterceptionAppRoute,\n  | 'normalized'\n  | 'segments'\n  | 'interceptionMarker'\n  | 'interceptingRoute'\n  | 'interceptedRoute'\n> & {\n  normalized: true\n  segments: NormalizedAppRouteSegment[]\n  interceptionMarker: InterceptionMarker\n  interceptingRoute: NormalizedAppRoute\n  interceptedRoute: NormalizedAppRoute\n}\n\nexport function isInterceptionAppRoute(\n  route: NormalizedAppRoute\n): route is NormalizedInterceptionAppRoute\nexport function isInterceptionAppRoute(\n  route: AppRoute\n): route is InterceptionAppRoute {\n  return (\n    route.interceptionMarker !== undefined &&\n    route.interceptingRoute !== undefined &&\n    route.interceptedRoute !== undefined\n  )\n}\n\nexport function parseAppRoute(\n  pathname: string,\n  normalized: true\n): NormalizedAppRoute\nexport function parseAppRoute(pathname: string, normalized: false): AppRoute\nexport function parseAppRoute(\n  pathname: string,\n  normalized: boolean\n): AppRoute | NormalizedAppRoute {\n  const pathnameSegments = pathname.split('/').filter(Boolean)\n\n  // Build segments array with static and dynamic segments\n  const segments: AppRouteSegment[] = []\n\n  // Parse if this is an interception route.\n  let interceptionMarker: InterceptionMarker | undefined\n  let interceptingRoute: AppRoute | NormalizedAppRoute | undefined\n  let interceptedRoute: AppRoute | NormalizedAppRoute | undefined\n\n  for (const segment of pathnameSegments) {\n    // Parse the segment into an AppSegment.\n    const appSegment = parseAppRouteSegment(segment)\n    if (!appSegment) {\n      continue\n    }\n\n    if (\n      normalized &&\n      (appSegment.type === 'route-group' ||\n        appSegment.type === 'parallel-route')\n    ) {\n      throw new InvariantError(\n        `${pathname} is being parsed as a normalized route, but it has a route group or parallel route segment.`\n      )\n    }\n\n    segments.push(appSegment)\n\n    if (appSegment.interceptionMarker) {\n      const parts = pathname.split(appSegment.interceptionMarker)\n      if (parts.length !== 2) {\n        throw new Error(`Invalid interception route: ${pathname}`)\n      }\n\n      interceptingRoute = normalized\n        ? parseAppRoute(parts[0], true)\n        : parseAppRoute(parts[0], false)\n      interceptedRoute = normalized\n        ? parseAppRoute(parts[1], true)\n        : parseAppRoute(parts[1], false)\n      interceptionMarker = appSegment.interceptionMarker\n    }\n  }\n\n  const dynamicSegments = segments.filter(\n    (segment) => segment.type === 'dynamic'\n  )\n\n  return {\n    normalized,\n    pathname,\n    segments,\n    dynamicSegments,\n    interceptionMarker,\n    interceptingRoute,\n    interceptedRoute,\n  }\n}\n"],"names":["isInterceptionAppRoute","isNormalizedAppRoute","parseAppRoute","parseAppRouteSegment","segment","interceptionMarker","INTERCEPTION_ROUTE_MARKERS","find","m","startsWith","param","getSegmentParam","type","name","endsWith","route","normalized","undefined","interceptingRoute","interceptedRoute","pathname","pathnameSegments","split","filter","Boolean","segments","appSegment","InvariantError","push","parts","length","Error","dynamicSegments"],"mappings":";;;;;;;;;;;;;;;;;IAwJgBA,sBAAsB;eAAtBA;;IAjCAC,oBAAoB;eAApBA;;IAgDAC,aAAa;eAAbA;;IAzGAC,oBAAoB;eAApBA;;;gCA9De;iCACoB;oCAI5C;AAyDA,SAASA,qBAAqBC,OAAe;IAClD,IAAIA,YAAY,IAAI;QAClB,OAAO;IACT;IAEA,0DAA0D;IAC1D,MAAMC,qBAAqBC,8CAA0B,CAACC,IAAI,CAAC,CAACC,IAC1DJ,QAAQK,UAAU,CAACD;IAGrB,MAAME,QAAQC,IAAAA,gCAAe,EAACP;IAC9B,IAAIM,OAAO;QACT,OAAO;YACLE,MAAM;YACNC,MAAMT;YACNM;YACAL;QACF;IACF,OAAO,IAAID,QAAQK,UAAU,CAAC,QAAQL,QAAQU,QAAQ,CAAC,MAAM;QAC3D,OAAO;YACLF,MAAM;YACNC,MAAMT;YACNC;QACF;IACF,OAAO,IAAID,QAAQK,UAAU,CAAC,MAAM;QAClC,OAAO;YACLG,MAAM;YACNC,MAAMT;YACNC;QACF;IACF,OAAO;QACL,OAAO;YACLO,MAAM;YACNC,MAAMT;YACNC;QACF;IACF;AACF;AAoBO,SAASJ,qBACdc,KAAsC;IAEtC,OAAOA,MAAMC,UAAU;AACzB;AA6BO,SAAShB,uBACde,KAAe;IAEf,OACEA,MAAMV,kBAAkB,KAAKY,aAC7BF,MAAMG,iBAAiB,KAAKD,aAC5BF,MAAMI,gBAAgB,KAAKF;AAE/B;AAOO,SAASf,cACdkB,QAAgB,EAChBJ,UAAmB;IAEnB,MAAMK,mBAAmBD,SAASE,KAAK,CAAC,KAAKC,MAAM,CAACC;IAEpD,wDAAwD;IACxD,MAAMC,WAA8B,EAAE;IAEtC,0CAA0C;IAC1C,IAAIpB;IACJ,IAAIa;IACJ,IAAIC;IAEJ,KAAK,MAAMf,WAAWiB,iBAAkB;QACtC,wCAAwC;QACxC,MAAMK,aAAavB,qBAAqBC;QACxC,IAAI,CAACsB,YAAY;YACf;QACF;QAEA,IACEV,cACCU,CAAAA,WAAWd,IAAI,KAAK,iBACnBc,WAAWd,IAAI,KAAK,gBAAe,GACrC;YACA,MAAM,qBAEL,CAFK,IAAIe,8BAAc,CACtB,GAAGP,SAAS,2FAA2F,CAAC,GADpG,qBAAA;uBAAA;4BAAA;8BAAA;YAEN;QACF;QAEAK,SAASG,IAAI,CAACF;QAEd,IAAIA,WAAWrB,kBAAkB,EAAE;YACjC,MAAMwB,QAAQT,SAASE,KAAK,CAACI,WAAWrB,kBAAkB;YAC1D,IAAIwB,MAAMC,MAAM,KAAK,GAAG;gBACtB,MAAM,qBAAoD,CAApD,IAAIC,MAAM,CAAC,4BAA4B,EAAEX,UAAU,GAAnD,qBAAA;2BAAA;gCAAA;kCAAA;gBAAmD;YAC3D;YAEAF,oBAAoBF,aAChBd,cAAc2B,KAAK,CAAC,EAAE,EAAE,QACxB3B,cAAc2B,KAAK,CAAC,EAAE,EAAE;YAC5BV,mBAAmBH,aACfd,cAAc2B,KAAK,CAAC,EAAE,EAAE,QACxB3B,cAAc2B,KAAK,CAAC,EAAE,EAAE;YAC5BxB,qBAAqBqB,WAAWrB,kBAAkB;QACpD;IACF;IAEA,MAAM2B,kBAAkBP,SAASF,MAAM,CACrC,CAACnB,UAAYA,QAAQQ,IAAI,KAAK;IAGhC,OAAO;QACLI;QACAI;QACAK;QACAO;QACA3B;QACAa;QACAC;IACF;AACF","ignoreList":[0]}