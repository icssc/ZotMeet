const require_chunk = require('./chunk-CdAKIUsw.js');
require('./ddl-SsGc2gVn.js');
const require_utils = require('./utils-D2E5ChQ0.js');
const require_grammar = require('./grammar-B2XVJ90y.js');
const require_views = require('./views-BA7qJeG7.js');
require('./snapshot-BG6vPgbm.js');
require('./brace-expansion-BfFnz-Zg.js');
const require_utils_node = require('./utils-node-C6Uy_GN3.js');
const require_dist_cjs = require('./dist-cjs-BRrAwDG_.js');
let node_https = require("node:https");
node_https = require_chunk.__toESM(node_https);
let net = require("net");
net = require_chunk.__toESM(net);
let node_http = require("node:http");
node_http = require_chunk.__toESM(node_http);
let node_zlib = require("node:zlib");
node_zlib = require_chunk.__toESM(node_zlib);
let node_stream = require("node:stream");
node_stream = require_chunk.__toESM(node_stream);
let node_buffer = require("node:buffer");
let node_util = require("node:util");
let node_url = require("node:url");
let node_net = require("node:net");

//#region ../node_modules/.pnpm/data-uri-to-buffer@4.0.1/node_modules/data-uri-to-buffer/dist/index.js
/**
* Returns a `Buffer` instance from the given data URI `uri`.
*
* @param {String} uri Data URI to turn into a Buffer instance
* @returns {Buffer} Buffer instance from Data URI
* @api public
*/
function dataUriToBuffer(uri) {
	if (!/^data:/i.test(uri)) throw new TypeError("`uri` does not appear to be a Data URI (must begin with \"data:\")");
	uri = uri.replace(/\r?\n/g, "");
	const firstComma = uri.indexOf(",");
	if (firstComma === -1 || firstComma <= 4) throw new TypeError("malformed data: URI");
	const meta = uri.substring(5, firstComma).split(";");
	let charset = "";
	let base64 = false;
	const type = meta[0] || "text/plain";
	let typeFull = type;
	for (let i = 1; i < meta.length; i++) if (meta[i] === "base64") base64 = true;
	else if (meta[i]) {
		typeFull += `;${meta[i]}`;
		if (meta[i].indexOf("charset=") === 0) charset = meta[i].substring(8);
	}
	if (!meta[0] && !charset.length) {
		typeFull += ";charset=US-ASCII";
		charset = "US-ASCII";
	}
	const encoding = base64 ? "base64" : "ascii";
	const data = unescape(uri.substring(firstComma + 1));
	const buffer = Buffer.from(data, encoding);
	buffer.type = type;
	buffer.typeFull = typeFull;
	buffer.charset = charset;
	return buffer;
}
var dist_default = dataUriToBuffer;

//#endregion
//#region ../node_modules/.pnpm/node-fetch@3.3.2/node_modules/node-fetch/src/errors/base.js
var FetchBaseError = class extends Error {
	constructor(message, type) {
		super(message);
		Error.captureStackTrace(this, this.constructor);
		this.type = type;
	}
	get name() {
		return this.constructor.name;
	}
	get [Symbol.toStringTag]() {
		return this.constructor.name;
	}
};

//#endregion
//#region ../node_modules/.pnpm/node-fetch@3.3.2/node_modules/node-fetch/src/errors/fetch-error.js
/**
* @typedef {{ address?: string, code: string, dest?: string, errno: number, info?: object, message: string, path?: string, port?: number, syscall: string}} SystemError
*/
/**
* FetchError interface for operational errors
*/
var FetchError = class extends FetchBaseError {
	/**
	* @param  {string} message -      Error message for human
	* @param  {string} [type] -        Error type for machine
	* @param  {SystemError} [systemError] - For Node.js system error
	*/
	constructor(message, type, systemError) {
		super(message, type);
		if (systemError) {
			this.code = this.errno = systemError.code;
			this.erroredSysCall = systemError.syscall;
		}
	}
};

//#endregion
//#region ../node_modules/.pnpm/node-fetch@3.3.2/node_modules/node-fetch/src/utils/is.js
/**
* Is.js
*
* Object type checks.
*/
const NAME = Symbol.toStringTag;
/**
* Check if `obj` is a URLSearchParams object
* ref: https://github.com/node-fetch/node-fetch/issues/296#issuecomment-307598143
* @param {*} object - Object to check for
* @return {boolean}
*/
const isURLSearchParameters = (object) => {
	return typeof object === "object" && typeof object.append === "function" && typeof object.delete === "function" && typeof object.get === "function" && typeof object.getAll === "function" && typeof object.has === "function" && typeof object.set === "function" && typeof object.sort === "function" && object[NAME] === "URLSearchParams";
};
/**
* Check if `object` is a W3C `Blob` object (which `File` inherits from)
* @param {*} object - Object to check for
* @return {boolean}
*/
const isBlob = (object) => {
	return object && typeof object === "object" && typeof object.arrayBuffer === "function" && typeof object.type === "string" && typeof object.stream === "function" && typeof object.constructor === "function" && /^(Blob|File)$/.test(object[NAME]);
};
/**
* Check if `obj` is an instance of AbortSignal.
* @param {*} object - Object to check for
* @return {boolean}
*/
const isAbortSignal = (object) => {
	return typeof object === "object" && (object[NAME] === "AbortSignal" || object[NAME] === "EventTarget");
};
/**
* isDomainOrSubdomain reports whether sub is a subdomain (or exact match) of
* the parent domain.
*
* Both domains must already be in canonical form.
* @param {string|URL} original
* @param {string|URL} destination
*/
const isDomainOrSubdomain = (destination, original) => {
	const orig = new URL(original).hostname;
	const dest = new URL(destination).hostname;
	return orig === dest || orig.endsWith(`.${dest}`);
};
/**
* isSameProtocol reports whether the two provided URLs use the same protocol.
*
* Both domains must already be in canonical form.
* @param {string|URL} original
* @param {string|URL} destination
*/
const isSameProtocol = (destination, original) => {
	return new URL(original).protocol === new URL(destination).protocol;
};

//#endregion
//#region ../node_modules/.pnpm/node-fetch@3.3.2/node_modules/node-fetch/src/body.js
/**
* Body.js
*
* Body interface provides common methods for Request and Response
*/
const pipeline = (0, node_util.promisify)(node_stream.default.pipeline);
const INTERNALS$2 = Symbol("Body internals");
/**
* Body mixin
*
* Ref: https://fetch.spec.whatwg.org/#body
*
* @param   Stream  body  Readable stream
* @param   Object  opts  Response options
* @return  Void
*/
var Body = class {
	constructor(body, { size = 0 } = {}) {
		let boundary = null;
		if (body === null) body = null;
		else if (isURLSearchParameters(body)) body = node_buffer.Buffer.from(body.toString());
		else if (isBlob(body)) {} else if (node_buffer.Buffer.isBuffer(body)) {} else if (node_util.types.isAnyArrayBuffer(body)) body = node_buffer.Buffer.from(body);
		else if (ArrayBuffer.isView(body)) body = node_buffer.Buffer.from(body.buffer, body.byteOffset, body.byteLength);
		else if (body instanceof node_stream.default) {} else if (body instanceof require_dist_cjs.FormData) {
			body = require_dist_cjs.formDataToBlob(body);
			boundary = body.type.split("=")[1];
		} else body = node_buffer.Buffer.from(String(body));
		let stream = body;
		if (node_buffer.Buffer.isBuffer(body)) stream = node_stream.default.Readable.from(body);
		else if (isBlob(body)) stream = node_stream.default.Readable.from(body.stream());
		this[INTERNALS$2] = {
			body,
			stream,
			boundary,
			disturbed: false,
			error: null
		};
		this.size = size;
		if (body instanceof node_stream.default) body.on("error", (error_) => {
			const error = error_ instanceof FetchBaseError ? error_ : new FetchError(`Invalid response body while trying to fetch ${this.url}: ${error_.message}`, "system", error_);
			this[INTERNALS$2].error = error;
		});
	}
	get body() {
		return this[INTERNALS$2].stream;
	}
	get bodyUsed() {
		return this[INTERNALS$2].disturbed;
	}
	/**
	* Decode response as ArrayBuffer
	*
	* @return  Promise
	*/
	async arrayBuffer() {
		const { buffer, byteOffset, byteLength } = await consumeBody(this);
		return buffer.slice(byteOffset, byteOffset + byteLength);
	}
	async formData() {
		const ct = this.headers.get("content-type");
		if (ct.startsWith("application/x-www-form-urlencoded")) {
			const formData = new require_dist_cjs.FormData();
			const parameters = new URLSearchParams(await this.text());
			for (const [name, value] of parameters) formData.append(name, value);
			return formData;
		}
		const { toFormData } = await Promise.resolve().then(() => require("./multipart-parser-BIHEgf6v.js"));
		return toFormData(this.body, ct);
	}
	/**
	* Return raw response as Blob
	*
	* @return Promise
	*/
	async blob() {
		const ct = this.headers && this.headers.get("content-type") || this[INTERNALS$2].body && this[INTERNALS$2].body.type || "";
		return new require_dist_cjs.fetch_blob_default([await this.arrayBuffer()], { type: ct });
	}
	/**
	* Decode response as json
	*
	* @return  Promise
	*/
	async json() {
		const text = await this.text();
		return JSON.parse(text);
	}
	/**
	* Decode response as text
	*
	* @return  Promise
	*/
	async text() {
		const buffer = await consumeBody(this);
		return new TextDecoder().decode(buffer);
	}
	/**
	* Decode response as buffer (non-spec api)
	*
	* @return  Promise
	*/
	buffer() {
		return consumeBody(this);
	}
};
Body.prototype.buffer = (0, node_util.deprecate)(Body.prototype.buffer, "Please use 'response.arrayBuffer()' instead of 'response.buffer()'", "node-fetch#buffer");
Object.defineProperties(Body.prototype, {
	body: { enumerable: true },
	bodyUsed: { enumerable: true },
	arrayBuffer: { enumerable: true },
	blob: { enumerable: true },
	json: { enumerable: true },
	text: { enumerable: true },
	data: { get: (0, node_util.deprecate)(() => {}, "data doesn't exist, use json(), text(), arrayBuffer(), or body instead", "https://github.com/node-fetch/node-fetch/issues/1000 (response)") }
});
/**
* Consume and convert an entire Body to a Buffer.
*
* Ref: https://fetch.spec.whatwg.org/#concept-body-consume-body
*
* @return Promise
*/
async function consumeBody(data) {
	if (data[INTERNALS$2].disturbed) throw new TypeError(`body used already for: ${data.url}`);
	data[INTERNALS$2].disturbed = true;
	if (data[INTERNALS$2].error) throw data[INTERNALS$2].error;
	const { body } = data;
	if (body === null) return node_buffer.Buffer.alloc(0);
	/* c8 ignore next 3 */
	if (!(body instanceof node_stream.default)) return node_buffer.Buffer.alloc(0);
	const accum = [];
	let accumBytes = 0;
	try {
		for await (const chunk of body) {
			if (data.size > 0 && accumBytes + chunk.length > data.size) {
				const error = new FetchError(`content size at ${data.url} over limit: ${data.size}`, "max-size");
				body.destroy(error);
				throw error;
			}
			accumBytes += chunk.length;
			accum.push(chunk);
		}
	} catch (error) {
		throw error instanceof FetchBaseError ? error : new FetchError(`Invalid response body while trying to fetch ${data.url}: ${error.message}`, "system", error);
	}
	if (body.readableEnded === true || body._readableState.ended === true) try {
		if (accum.every((c) => typeof c === "string")) return node_buffer.Buffer.from(accum.join(""));
		return node_buffer.Buffer.concat(accum, accumBytes);
	} catch (error) {
		throw new FetchError(`Could not create Buffer from response body for ${data.url}: ${error.message}`, "system", error);
	}
	else throw new FetchError(`Premature close of server response while trying to fetch ${data.url}`);
}
/**
* Clone body given Res/Req instance
*
* @param   Mixed   instance       Response or Request instance
* @param   String  highWaterMark  highWaterMark for both PassThrough body streams
* @return  Mixed
*/
const clone = (instance, highWaterMark) => {
	let p1;
	let p2;
	let { body } = instance[INTERNALS$2];
	if (instance.bodyUsed) throw new Error("cannot clone body after it is used");
	if (body instanceof node_stream.default && typeof body.getBoundary !== "function") {
		p1 = new node_stream.PassThrough({ highWaterMark });
		p2 = new node_stream.PassThrough({ highWaterMark });
		body.pipe(p1);
		body.pipe(p2);
		instance[INTERNALS$2].stream = p1;
		body = p2;
	}
	return body;
};
const getNonSpecFormDataBoundary = (0, node_util.deprecate)((body) => body.getBoundary(), "form-data doesn't follow the spec and requires special treatment. Use alternative package", "https://github.com/node-fetch/node-fetch/issues/1167");
/**
* Performs the operation "extract a `Content-Type` value from |object|" as
* specified in the specification:
* https://fetch.spec.whatwg.org/#concept-bodyinit-extract
*
* This function assumes that instance.body is present.
*
* @param {any} body Any options.body input
* @returns {string | null}
*/
const extractContentType = (body, request) => {
	if (body === null) return null;
	if (typeof body === "string") return "text/plain;charset=UTF-8";
	if (isURLSearchParameters(body)) return "application/x-www-form-urlencoded;charset=UTF-8";
	if (isBlob(body)) return body.type || null;
	if (node_buffer.Buffer.isBuffer(body) || node_util.types.isAnyArrayBuffer(body) || ArrayBuffer.isView(body)) return null;
	if (body instanceof require_dist_cjs.FormData) return `multipart/form-data; boundary=${request[INTERNALS$2].boundary}`;
	if (body && typeof body.getBoundary === "function") return `multipart/form-data;boundary=${getNonSpecFormDataBoundary(body)}`;
	if (body instanceof node_stream.default) return null;
	return "text/plain;charset=UTF-8";
};
/**
* The Fetch Standard treats this as if "total bytes" is a property on the body.
* For us, we have to explicitly get it with a function.
*
* ref: https://fetch.spec.whatwg.org/#concept-body-total-bytes
*
* @param {any} obj.body Body object from the Body instance.
* @returns {number | null}
*/
const getTotalBytes = (request) => {
	const { body } = request[INTERNALS$2];
	if (body === null) return 0;
	if (isBlob(body)) return body.size;
	if (node_buffer.Buffer.isBuffer(body)) return body.length;
	if (body && typeof body.getLengthSync === "function") return body.hasKnownLength && body.hasKnownLength() ? body.getLengthSync() : null;
	return null;
};
/**
* Write a Body to a Node.js WritableStream (e.g. http.Request) object.
*
* @param {Stream.Writable} dest The stream to write to.
* @param obj.body Body object from the Body instance.
* @returns {Promise<void>}
*/
const writeToStream = async (dest, { body }) => {
	if (body === null) dest.end();
	else await pipeline(body, dest);
};

//#endregion
//#region ../node_modules/.pnpm/node-fetch@3.3.2/node_modules/node-fetch/src/headers.js
/**
* Headers.js
*
* Headers class offers convenient helpers
*/
/* c8 ignore next 9 */
const validateHeaderName = typeof node_http.default.validateHeaderName === "function" ? node_http.default.validateHeaderName : (name) => {
	if (!/^[\^`\-\w!#$%&'*+.|~]+$/.test(name)) {
		const error = /* @__PURE__ */ new TypeError(`Header name must be a valid HTTP token [${name}]`);
		Object.defineProperty(error, "code", { value: "ERR_INVALID_HTTP_TOKEN" });
		throw error;
	}
};
/* c8 ignore next 9 */
const validateHeaderValue = typeof node_http.default.validateHeaderValue === "function" ? node_http.default.validateHeaderValue : (name, value) => {
	if (/[^\t\u0020-\u007E\u0080-\u00FF]/.test(value)) {
		const error = /* @__PURE__ */ new TypeError(`Invalid character in header content ["${name}"]`);
		Object.defineProperty(error, "code", { value: "ERR_INVALID_CHAR" });
		throw error;
	}
};
/**
* @typedef {Headers | Record<string, string> | Iterable<readonly [string, string]> | Iterable<Iterable<string>>} HeadersInit
*/
/**
* This Fetch API interface allows you to perform various actions on HTTP request and response headers.
* These actions include retrieving, setting, adding to, and removing.
* A Headers object has an associated header list, which is initially empty and consists of zero or more name and value pairs.
* You can add to this using methods like append() (see Examples.)
* In all methods of this interface, header names are matched by case-insensitive byte sequence.
*
*/
var Headers = class Headers extends URLSearchParams {
	/**
	* Headers class
	*
	* @constructor
	* @param {HeadersInit} [init] - Response headers
	*/
	constructor(init) {
		/** @type {string[][]} */
		let result = [];
		if (init instanceof Headers) {
			const raw = init.raw();
			for (const [name, values] of Object.entries(raw)) result.push(...values.map((value) => [name, value]));
		} else if (init == null) {} else if (typeof init === "object" && !node_util.types.isBoxedPrimitive(init)) {
			const method = init[Symbol.iterator];
			if (method == null) result.push(...Object.entries(init));
			else {
				if (typeof method !== "function") throw new TypeError("Header pairs must be iterable");
				result = [...init].map((pair) => {
					if (typeof pair !== "object" || node_util.types.isBoxedPrimitive(pair)) throw new TypeError("Each header pair must be an iterable object");
					return [...pair];
				}).map((pair) => {
					if (pair.length !== 2) throw new TypeError("Each header pair must be a name/value tuple");
					return [...pair];
				});
			}
		} else throw new TypeError("Failed to construct 'Headers': The provided value is not of type '(sequence<sequence<ByteString>> or record<ByteString, ByteString>)");
		result = result.length > 0 ? result.map(([name, value]) => {
			validateHeaderName(name);
			validateHeaderValue(name, String(value));
			return [String(name).toLowerCase(), String(value)];
		}) : void 0;
		super(result);
		return new Proxy(this, { get(target, p, receiver) {
			switch (p) {
				case "append":
				case "set": return (name, value) => {
					validateHeaderName(name);
					validateHeaderValue(name, String(value));
					return URLSearchParams.prototype[p].call(target, String(name).toLowerCase(), String(value));
				};
				case "delete":
				case "has":
				case "getAll": return (name) => {
					validateHeaderName(name);
					return URLSearchParams.prototype[p].call(target, String(name).toLowerCase());
				};
				case "keys": return () => {
					target.sort();
					return new Set(URLSearchParams.prototype.keys.call(target)).keys();
				};
				default: return Reflect.get(target, p, receiver);
			}
		} });
		/* c8 ignore next */
	}
	get [Symbol.toStringTag]() {
		return this.constructor.name;
	}
	toString() {
		return Object.prototype.toString.call(this);
	}
	get(name) {
		const values = this.getAll(name);
		if (values.length === 0) return null;
		let value = values.join(", ");
		if (/^content-encoding$/i.test(name)) value = value.toLowerCase();
		return value;
	}
	forEach(callback, thisArg = void 0) {
		for (const name of this.keys()) Reflect.apply(callback, thisArg, [
			this.get(name),
			name,
			this
		]);
	}
	*values() {
		for (const name of this.keys()) yield this.get(name);
	}
	/**
	* @type {() => IterableIterator<[string, string]>}
	*/
	*entries() {
		for (const name of this.keys()) yield [name, this.get(name)];
	}
	[Symbol.iterator]() {
		return this.entries();
	}
	/**
	* Node-fetch non-spec method
	* returning all headers and their values as array
	* @returns {Record<string, string[]>}
	*/
	raw() {
		return [...this.keys()].reduce((result, key) => {
			result[key] = this.getAll(key);
			return result;
		}, {});
	}
	/**
	* For better console.log(headers) and also to convert Headers into Node.js Request compatible format
	*/
	[Symbol.for("nodejs.util.inspect.custom")]() {
		return [...this.keys()].reduce((result, key) => {
			const values = this.getAll(key);
			if (key === "host") result[key] = values[0];
			else result[key] = values.length > 1 ? values : values[0];
			return result;
		}, {});
	}
};
/**
* Re-shaping object for Web IDL tests
* Only need to do it for overridden methods
*/
Object.defineProperties(Headers.prototype, [
	"get",
	"entries",
	"forEach",
	"values"
].reduce((result, property) => {
	result[property] = { enumerable: true };
	return result;
}, {}));
/**
* Create a Headers object from an http.IncomingMessage.rawHeaders, ignoring those that do
* not conform to HTTP grammar productions.
* @param {import('http').IncomingMessage['rawHeaders']} headers
*/
function fromRawHeaders(headers = []) {
	return new Headers(headers.reduce((result, value, index, array) => {
		if (index % 2 === 0) result.push(array.slice(index, index + 2));
		return result;
	}, []).filter(([name, value]) => {
		try {
			validateHeaderName(name);
			validateHeaderValue(name, String(value));
			return true;
		} catch {
			return false;
		}
	}));
}

//#endregion
//#region ../node_modules/.pnpm/node-fetch@3.3.2/node_modules/node-fetch/src/utils/is-redirect.js
const redirectStatus = new Set([
	301,
	302,
	303,
	307,
	308
]);
/**
* Redirect code matching
*
* @param {number} code - Status code
* @return {boolean}
*/
const isRedirect = (code) => {
	return redirectStatus.has(code);
};

//#endregion
//#region ../node_modules/.pnpm/node-fetch@3.3.2/node_modules/node-fetch/src/response.js
/**
* Response.js
*
* Response class provides content decoding
*/
const INTERNALS$1 = Symbol("Response internals");
/**
* Response class
*
* Ref: https://fetch.spec.whatwg.org/#response-class
*
* @param   Stream  body  Readable stream
* @param   Object  opts  Response options
* @return  Void
*/
var Response = class Response extends Body {
	constructor(body = null, options = {}) {
		super(body, options);
		const status = options.status != null ? options.status : 200;
		const headers = new Headers(options.headers);
		if (body !== null && !headers.has("Content-Type")) {
			const contentType = extractContentType(body, this);
			if (contentType) headers.append("Content-Type", contentType);
		}
		this[INTERNALS$1] = {
			type: "default",
			url: options.url,
			status,
			statusText: options.statusText || "",
			headers,
			counter: options.counter,
			highWaterMark: options.highWaterMark
		};
	}
	get type() {
		return this[INTERNALS$1].type;
	}
	get url() {
		return this[INTERNALS$1].url || "";
	}
	get status() {
		return this[INTERNALS$1].status;
	}
	/**
	* Convenience property representing if the request ended normally
	*/
	get ok() {
		return this[INTERNALS$1].status >= 200 && this[INTERNALS$1].status < 300;
	}
	get redirected() {
		return this[INTERNALS$1].counter > 0;
	}
	get statusText() {
		return this[INTERNALS$1].statusText;
	}
	get headers() {
		return this[INTERNALS$1].headers;
	}
	get highWaterMark() {
		return this[INTERNALS$1].highWaterMark;
	}
	/**
	* Clone this response
	*
	* @return  Response
	*/
	clone() {
		return new Response(clone(this, this.highWaterMark), {
			type: this.type,
			url: this.url,
			status: this.status,
			statusText: this.statusText,
			headers: this.headers,
			ok: this.ok,
			redirected: this.redirected,
			size: this.size,
			highWaterMark: this.highWaterMark
		});
	}
	/**
	* @param {string} url    The URL that the new response is to originate from.
	* @param {number} status An optional status code for the response (e.g., 302.)
	* @returns {Response}    A Response object.
	*/
	static redirect(url, status = 302) {
		if (!isRedirect(status)) throw new RangeError("Failed to execute \"redirect\" on \"response\": Invalid status code");
		return new Response(null, {
			headers: { location: new URL(url).toString() },
			status
		});
	}
	static error() {
		const response = new Response(null, {
			status: 0,
			statusText: ""
		});
		response[INTERNALS$1].type = "error";
		return response;
	}
	static json(data = void 0, init = {}) {
		const body = JSON.stringify(data);
		if (body === void 0) throw new TypeError("data is not JSON serializable");
		const headers = new Headers(init && init.headers);
		if (!headers.has("content-type")) headers.set("content-type", "application/json");
		return new Response(body, {
			...init,
			headers
		});
	}
	get [Symbol.toStringTag]() {
		return "Response";
	}
};
Object.defineProperties(Response.prototype, {
	type: { enumerable: true },
	url: { enumerable: true },
	status: { enumerable: true },
	ok: { enumerable: true },
	redirected: { enumerable: true },
	statusText: { enumerable: true },
	headers: { enumerable: true },
	clone: { enumerable: true }
});

//#endregion
//#region ../node_modules/.pnpm/node-fetch@3.3.2/node_modules/node-fetch/src/utils/get-search.js
const getSearch = (parsedURL) => {
	if (parsedURL.search) return parsedURL.search;
	const lastOffset = parsedURL.href.length - 1;
	const hash = parsedURL.hash || (parsedURL.href[lastOffset] === "#" ? "#" : "");
	return parsedURL.href[lastOffset - hash.length] === "?" ? "?" : "";
};

//#endregion
//#region ../node_modules/.pnpm/node-fetch@3.3.2/node_modules/node-fetch/src/utils/referrer.js
/**
* @external URL
* @see {@link https://developer.mozilla.org/en-US/docs/Web/API/URL|URL}
*/
/**
* @module utils/referrer
* @private
*/
/**
* @see {@link https://w3c.github.io/webappsec-referrer-policy/#strip-url|Referrer Policy §8.4. Strip url for use as a referrer}
* @param {string} URL
* @param {boolean} [originOnly=false]
*/
function stripURLForUseAsAReferrer(url, originOnly = false) {
	if (url == null) return "no-referrer";
	url = new URL(url);
	if (/^(about|blob|data):$/.test(url.protocol)) return "no-referrer";
	url.username = "";
	url.password = "";
	url.hash = "";
	if (originOnly) {
		url.pathname = "";
		url.search = "";
	}
	return url;
}
/**
* @see {@link https://w3c.github.io/webappsec-referrer-policy/#enumdef-referrerpolicy|enum ReferrerPolicy}
*/
const ReferrerPolicy = new Set([
	"",
	"no-referrer",
	"no-referrer-when-downgrade",
	"same-origin",
	"origin",
	"strict-origin",
	"origin-when-cross-origin",
	"strict-origin-when-cross-origin",
	"unsafe-url"
]);
/**
* @see {@link https://w3c.github.io/webappsec-referrer-policy/#default-referrer-policy|default referrer policy}
*/
const DEFAULT_REFERRER_POLICY = "strict-origin-when-cross-origin";
/**
* @see {@link https://w3c.github.io/webappsec-referrer-policy/#referrer-policies|Referrer Policy §3. Referrer Policies}
* @param {string} referrerPolicy
* @returns {string} referrerPolicy
*/
function validateReferrerPolicy(referrerPolicy) {
	if (!ReferrerPolicy.has(referrerPolicy)) throw new TypeError(`Invalid referrerPolicy: ${referrerPolicy}`);
	return referrerPolicy;
}
/**
* @see {@link https://w3c.github.io/webappsec-secure-contexts/#is-origin-trustworthy|Referrer Policy §3.2. Is origin potentially trustworthy?}
* @param {external:URL} url
* @returns `true`: "Potentially Trustworthy", `false`: "Not Trustworthy"
*/
function isOriginPotentiallyTrustworthy(url) {
	if (/^(http|ws)s:$/.test(url.protocol)) return true;
	const hostIp = url.host.replace(/(^\[)|(]$)/g, "");
	const hostIPVersion = (0, node_net.isIP)(hostIp);
	if (hostIPVersion === 4 && /^127\./.test(hostIp)) return true;
	if (hostIPVersion === 6 && /^(((0+:){7})|(::(0+:){0,6}))0*1$/.test(hostIp)) return true;
	if (url.host === "localhost" || url.host.endsWith(".localhost")) return false;
	if (url.protocol === "file:") return true;
	return false;
}
/**
* @see {@link https://w3c.github.io/webappsec-secure-contexts/#is-url-trustworthy|Referrer Policy §3.3. Is url potentially trustworthy?}
* @param {external:URL} url
* @returns `true`: "Potentially Trustworthy", `false`: "Not Trustworthy"
*/
function isUrlPotentiallyTrustworthy(url) {
	if (/^about:(blank|srcdoc)$/.test(url)) return true;
	if (url.protocol === "data:") return true;
	if (/^(blob|filesystem):$/.test(url.protocol)) return true;
	return isOriginPotentiallyTrustworthy(url);
}
/**
* Modifies the referrerURL to enforce any extra security policy considerations.
* @see {@link https://w3c.github.io/webappsec-referrer-policy/#determine-requests-referrer|Referrer Policy §8.3. Determine request's Referrer}, step 7
* @callback module:utils/referrer~referrerURLCallback
* @param {external:URL} referrerURL
* @returns {external:URL} modified referrerURL
*/
/**
* Modifies the referrerOrigin to enforce any extra security policy considerations.
* @see {@link https://w3c.github.io/webappsec-referrer-policy/#determine-requests-referrer|Referrer Policy §8.3. Determine request's Referrer}, step 7
* @callback module:utils/referrer~referrerOriginCallback
* @param {external:URL} referrerOrigin
* @returns {external:URL} modified referrerOrigin
*/
/**
* @see {@link https://w3c.github.io/webappsec-referrer-policy/#determine-requests-referrer|Referrer Policy §8.3. Determine request's Referrer}
* @param {Request} request
* @param {object} o
* @param {module:utils/referrer~referrerURLCallback} o.referrerURLCallback
* @param {module:utils/referrer~referrerOriginCallback} o.referrerOriginCallback
* @returns {external:URL} Request's referrer
*/
function determineRequestsReferrer(request, { referrerURLCallback, referrerOriginCallback } = {}) {
	if (request.referrer === "no-referrer" || request.referrerPolicy === "") return null;
	const policy = request.referrerPolicy;
	if (request.referrer === "about:client") return "no-referrer";
	const referrerSource = request.referrer;
	let referrerURL = stripURLForUseAsAReferrer(referrerSource);
	let referrerOrigin = stripURLForUseAsAReferrer(referrerSource, true);
	if (referrerURL.toString().length > 4096) referrerURL = referrerOrigin;
	if (referrerURLCallback) referrerURL = referrerURLCallback(referrerURL);
	if (referrerOriginCallback) referrerOrigin = referrerOriginCallback(referrerOrigin);
	const currentURL = new URL(request.url);
	switch (policy) {
		case "no-referrer": return "no-referrer";
		case "origin": return referrerOrigin;
		case "unsafe-url": return referrerURL;
		case "strict-origin":
			if (isUrlPotentiallyTrustworthy(referrerURL) && !isUrlPotentiallyTrustworthy(currentURL)) return "no-referrer";
			return referrerOrigin.toString();
		case "strict-origin-when-cross-origin":
			if (referrerURL.origin === currentURL.origin) return referrerURL;
			if (isUrlPotentiallyTrustworthy(referrerURL) && !isUrlPotentiallyTrustworthy(currentURL)) return "no-referrer";
			return referrerOrigin;
		case "same-origin":
			if (referrerURL.origin === currentURL.origin) return referrerURL;
			return "no-referrer";
		case "origin-when-cross-origin":
			if (referrerURL.origin === currentURL.origin) return referrerURL;
			return referrerOrigin;
		case "no-referrer-when-downgrade":
			if (isUrlPotentiallyTrustworthy(referrerURL) && !isUrlPotentiallyTrustworthy(currentURL)) return "no-referrer";
			return referrerURL;
		default: throw new TypeError(`Invalid referrerPolicy: ${policy}`);
	}
}
/**
* @see {@link https://w3c.github.io/webappsec-referrer-policy/#parse-referrer-policy-from-header|Referrer Policy §8.1. Parse a referrer policy from a Referrer-Policy header}
* @param {Headers} headers Response headers
* @returns {string} policy
*/
function parseReferrerPolicyFromHeader(headers) {
	const policyTokens = (headers.get("referrer-policy") || "").split(/[,\s]+/);
	let policy = "";
	for (const token of policyTokens) if (token && ReferrerPolicy.has(token)) policy = token;
	return policy;
}

//#endregion
//#region ../node_modules/.pnpm/node-fetch@3.3.2/node_modules/node-fetch/src/request.js
/**
* Request.js
*
* Request class contains server only options
*
* All spec algorithm step numbers are based on https://fetch.spec.whatwg.org/commit-snapshots/ae716822cb3a61843226cd090eefc6589446c1d2/.
*/
const INTERNALS = Symbol("Request internals");
/**
* Check if `obj` is an instance of Request.
*
* @param  {*} object
* @return {boolean}
*/
const isRequest = (object) => {
	return typeof object === "object" && typeof object[INTERNALS] === "object";
};
const doBadDataWarn = (0, node_util.deprecate)(() => {}, ".data is not a valid RequestInit property, use .body instead", "https://github.com/node-fetch/node-fetch/issues/1000 (request)");
/**
* Request class
*
* Ref: https://fetch.spec.whatwg.org/#request-class
*
* @param   Mixed   input  Url or Request instance
* @param   Object  init   Custom options
* @return  Void
*/
var Request = class Request extends Body {
	constructor(input, init = {}) {
		let parsedURL;
		if (isRequest(input)) parsedURL = new URL(input.url);
		else {
			parsedURL = new URL(input);
			input = {};
		}
		if (parsedURL.username !== "" || parsedURL.password !== "") throw new TypeError(`${parsedURL} is an url with embedded credentials.`);
		let method = init.method || input.method || "GET";
		if (/^(delete|get|head|options|post|put)$/i.test(method)) method = method.toUpperCase();
		if (!isRequest(init) && "data" in init) doBadDataWarn();
		if ((init.body != null || isRequest(input) && input.body !== null) && (method === "GET" || method === "HEAD")) throw new TypeError("Request with GET/HEAD method cannot have body");
		const inputBody = init.body ? init.body : isRequest(input) && input.body !== null ? clone(input) : null;
		super(inputBody, { size: init.size || input.size || 0 });
		const headers = new Headers(init.headers || input.headers || {});
		if (inputBody !== null && !headers.has("Content-Type")) {
			const contentType = extractContentType(inputBody, this);
			if (contentType) headers.set("Content-Type", contentType);
		}
		let signal = isRequest(input) ? input.signal : null;
		if ("signal" in init) signal = init.signal;
		if (signal != null && !isAbortSignal(signal)) throw new TypeError("Expected signal to be an instanceof AbortSignal or EventTarget");
		let referrer = init.referrer == null ? input.referrer : init.referrer;
		if (referrer === "") referrer = "no-referrer";
		else if (referrer) {
			const parsedReferrer = new URL(referrer);
			referrer = /^about:(\/\/)?client$/.test(parsedReferrer) ? "client" : parsedReferrer;
		} else referrer = void 0;
		this[INTERNALS] = {
			method,
			redirect: init.redirect || input.redirect || "follow",
			headers,
			parsedURL,
			signal,
			referrer
		};
		this.follow = init.follow === void 0 ? input.follow === void 0 ? 20 : input.follow : init.follow;
		this.compress = init.compress === void 0 ? input.compress === void 0 ? true : input.compress : init.compress;
		this.counter = init.counter || input.counter || 0;
		this.agent = init.agent || input.agent;
		this.highWaterMark = init.highWaterMark || input.highWaterMark || 16384;
		this.insecureHTTPParser = init.insecureHTTPParser || input.insecureHTTPParser || false;
		this.referrerPolicy = init.referrerPolicy || input.referrerPolicy || "";
	}
	/** @returns {string} */
	get method() {
		return this[INTERNALS].method;
	}
	/** @returns {string} */
	get url() {
		return (0, node_url.format)(this[INTERNALS].parsedURL);
	}
	/** @returns {Headers} */
	get headers() {
		return this[INTERNALS].headers;
	}
	get redirect() {
		return this[INTERNALS].redirect;
	}
	/** @returns {AbortSignal} */
	get signal() {
		return this[INTERNALS].signal;
	}
	get referrer() {
		if (this[INTERNALS].referrer === "no-referrer") return "";
		if (this[INTERNALS].referrer === "client") return "about:client";
		if (this[INTERNALS].referrer) return this[INTERNALS].referrer.toString();
	}
	get referrerPolicy() {
		return this[INTERNALS].referrerPolicy;
	}
	set referrerPolicy(referrerPolicy) {
		this[INTERNALS].referrerPolicy = validateReferrerPolicy(referrerPolicy);
	}
	/**
	* Clone this request
	*
	* @return  Request
	*/
	clone() {
		return new Request(this);
	}
	get [Symbol.toStringTag]() {
		return "Request";
	}
};
Object.defineProperties(Request.prototype, {
	method: { enumerable: true },
	url: { enumerable: true },
	headers: { enumerable: true },
	redirect: { enumerable: true },
	clone: { enumerable: true },
	signal: { enumerable: true },
	referrer: { enumerable: true },
	referrerPolicy: { enumerable: true }
});
/**
* Convert a Request to Node.js http request options.
*
* @param {Request} request - A Request instance
* @return The options object to be passed to http.request
*/
const getNodeRequestOptions = (request) => {
	const { parsedURL } = request[INTERNALS];
	const headers = new Headers(request[INTERNALS].headers);
	if (!headers.has("Accept")) headers.set("Accept", "*/*");
	let contentLengthValue = null;
	if (request.body === null && /^(post|put)$/i.test(request.method)) contentLengthValue = "0";
	if (request.body !== null) {
		const totalBytes = getTotalBytes(request);
		if (typeof totalBytes === "number" && !Number.isNaN(totalBytes)) contentLengthValue = String(totalBytes);
	}
	if (contentLengthValue) headers.set("Content-Length", contentLengthValue);
	if (request.referrerPolicy === "") request.referrerPolicy = DEFAULT_REFERRER_POLICY;
	if (request.referrer && request.referrer !== "no-referrer") request[INTERNALS].referrer = determineRequestsReferrer(request);
	else request[INTERNALS].referrer = "no-referrer";
	if (request[INTERNALS].referrer instanceof URL) headers.set("Referer", request.referrer);
	if (!headers.has("User-Agent")) headers.set("User-Agent", "node-fetch");
	if (request.compress && !headers.has("Accept-Encoding")) headers.set("Accept-Encoding", "gzip, deflate, br");
	let { agent } = request;
	if (typeof agent === "function") agent = agent(parsedURL);
	const search = getSearch(parsedURL);
	return {
		parsedURL,
		options: {
			path: parsedURL.pathname + search,
			method: request.method,
			headers: headers[Symbol.for("nodejs.util.inspect.custom")](),
			insecureHTTPParser: request.insecureHTTPParser,
			agent
		}
	};
};

//#endregion
//#region ../node_modules/.pnpm/node-fetch@3.3.2/node_modules/node-fetch/src/errors/abort-error.js
/**
* AbortError interface for cancelled requests
*/
var AbortError = class extends FetchBaseError {
	constructor(message, type = "aborted") {
		super(message, type);
	}
};

//#endregion
//#region ../node_modules/.pnpm/node-fetch@3.3.2/node_modules/node-fetch/src/index.js
/**
* Index.js
*
* a request API compatible with window.fetch
*
* All spec algorithm step numbers are based on https://fetch.spec.whatwg.org/commit-snapshots/ae716822cb3a61843226cd090eefc6589446c1d2/.
*/
const supportedSchemas = new Set([
	"data:",
	"http:",
	"https:"
]);
/**
* Fetch function
*
* @param   {string | URL | import('./request').default} url - Absolute url or Request instance
* @param   {*} [options_] - Fetch options
* @return  {Promise<import('./response').default>}
*/
async function fetch(url, options_) {
	return new Promise((resolve, reject) => {
		const request = new Request(url, options_);
		const { parsedURL, options } = getNodeRequestOptions(request);
		if (!supportedSchemas.has(parsedURL.protocol)) throw new TypeError(`node-fetch cannot load ${url}. URL scheme "${parsedURL.protocol.replace(/:$/, "")}" is not supported.`);
		if (parsedURL.protocol === "data:") {
			const data = dist_default(request.url);
			resolve(new Response(data, { headers: { "Content-Type": data.typeFull } }));
			return;
		}
		const send = (parsedURL.protocol === "https:" ? node_https.default : node_http.default).request;
		const { signal } = request;
		let response = null;
		const abort = () => {
			const error = new AbortError("The operation was aborted.");
			reject(error);
			if (request.body && request.body instanceof node_stream.default.Readable) request.body.destroy(error);
			if (!response || !response.body) return;
			response.body.emit("error", error);
		};
		if (signal && signal.aborted) {
			abort();
			return;
		}
		const abortAndFinalize = () => {
			abort();
			finalize();
		};
		const request_ = send(parsedURL.toString(), options);
		if (signal) signal.addEventListener("abort", abortAndFinalize);
		const finalize = () => {
			request_.abort();
			if (signal) signal.removeEventListener("abort", abortAndFinalize);
		};
		request_.on("error", (error) => {
			reject(new FetchError(`request to ${request.url} failed, reason: ${error.message}`, "system", error));
			finalize();
		});
		fixResponseChunkedTransferBadEnding(request_, (error) => {
			if (response && response.body) response.body.destroy(error);
		});
		/* c8 ignore next 18 */
		if (process.version < "v14") request_.on("socket", (s) => {
			let endedWithEventsCount;
			s.prependListener("end", () => {
				endedWithEventsCount = s._eventsCount;
			});
			s.prependListener("close", (hadError) => {
				if (response && endedWithEventsCount < s._eventsCount && !hadError) {
					const error = /* @__PURE__ */ new Error("Premature close");
					error.code = "ERR_STREAM_PREMATURE_CLOSE";
					response.body.emit("error", error);
				}
			});
		});
		request_.on("response", (response_) => {
			request_.setTimeout(0);
			const headers = fromRawHeaders(response_.rawHeaders);
			if (isRedirect(response_.statusCode)) {
				const location = headers.get("Location");
				let locationURL = null;
				try {
					locationURL = location === null ? null : new URL(location, request.url);
				} catch {
					if (request.redirect !== "manual") {
						reject(new FetchError(`uri requested responds with an invalid redirect URL: ${location}`, "invalid-redirect"));
						finalize();
						return;
					}
				}
				switch (request.redirect) {
					case "error":
						reject(new FetchError(`uri requested responds with a redirect, redirect mode is set to error: ${request.url}`, "no-redirect"));
						finalize();
						return;
					case "manual": break;
					case "follow": {
						if (locationURL === null) break;
						if (request.counter >= request.follow) {
							reject(new FetchError(`maximum redirect reached at: ${request.url}`, "max-redirect"));
							finalize();
							return;
						}
						const requestOptions = {
							headers: new Headers(request.headers),
							follow: request.follow,
							counter: request.counter + 1,
							agent: request.agent,
							compress: request.compress,
							method: request.method,
							body: clone(request),
							signal: request.signal,
							size: request.size,
							referrer: request.referrer,
							referrerPolicy: request.referrerPolicy
						};
						if (!isDomainOrSubdomain(request.url, locationURL) || !isSameProtocol(request.url, locationURL)) for (const name of [
							"authorization",
							"www-authenticate",
							"cookie",
							"cookie2"
						]) requestOptions.headers.delete(name);
						if (response_.statusCode !== 303 && request.body && options_.body instanceof node_stream.default.Readable) {
							reject(new FetchError("Cannot follow redirect with body being a readable stream", "unsupported-redirect"));
							finalize();
							return;
						}
						if (response_.statusCode === 303 || (response_.statusCode === 301 || response_.statusCode === 302) && request.method === "POST") {
							requestOptions.method = "GET";
							requestOptions.body = void 0;
							requestOptions.headers.delete("content-length");
						}
						const responseReferrerPolicy = parseReferrerPolicyFromHeader(headers);
						if (responseReferrerPolicy) requestOptions.referrerPolicy = responseReferrerPolicy;
						resolve(fetch(new Request(locationURL, requestOptions)));
						finalize();
						return;
					}
					default: return reject(/* @__PURE__ */ new TypeError(`Redirect option '${request.redirect}' is not a valid value of RequestRedirect`));
				}
			}
			if (signal) response_.once("end", () => {
				signal.removeEventListener("abort", abortAndFinalize);
			});
			let body = (0, node_stream.pipeline)(response_, new node_stream.PassThrough(), (error) => {
				if (error) reject(error);
			});
			/* c8 ignore next 3 */
			if (process.version < "v12.10") response_.on("aborted", abortAndFinalize);
			const responseOptions = {
				url: request.url,
				status: response_.statusCode,
				statusText: response_.statusMessage,
				headers,
				size: request.size,
				counter: request.counter,
				highWaterMark: request.highWaterMark
			};
			const codings = headers.get("Content-Encoding");
			if (!request.compress || request.method === "HEAD" || codings === null || response_.statusCode === 204 || response_.statusCode === 304) {
				response = new Response(body, responseOptions);
				resolve(response);
				return;
			}
			const zlibOptions = {
				flush: node_zlib.default.Z_SYNC_FLUSH,
				finishFlush: node_zlib.default.Z_SYNC_FLUSH
			};
			if (codings === "gzip" || codings === "x-gzip") {
				body = (0, node_stream.pipeline)(body, node_zlib.default.createGunzip(zlibOptions), (error) => {
					if (error) reject(error);
				});
				response = new Response(body, responseOptions);
				resolve(response);
				return;
			}
			if (codings === "deflate" || codings === "x-deflate") {
				const raw = (0, node_stream.pipeline)(response_, new node_stream.PassThrough(), (error) => {
					if (error) reject(error);
				});
				raw.once("data", (chunk) => {
					if ((chunk[0] & 15) === 8) body = (0, node_stream.pipeline)(body, node_zlib.default.createInflate(), (error) => {
						if (error) reject(error);
					});
					else body = (0, node_stream.pipeline)(body, node_zlib.default.createInflateRaw(), (error) => {
						if (error) reject(error);
					});
					response = new Response(body, responseOptions);
					resolve(response);
				});
				raw.once("end", () => {
					if (!response) {
						response = new Response(body, responseOptions);
						resolve(response);
					}
				});
				return;
			}
			if (codings === "br") {
				body = (0, node_stream.pipeline)(body, node_zlib.default.createBrotliDecompress(), (error) => {
					if (error) reject(error);
				});
				response = new Response(body, responseOptions);
				resolve(response);
				return;
			}
			response = new Response(body, responseOptions);
			resolve(response);
		});
		writeToStream(request_, request).catch(reject);
	});
}
function fixResponseChunkedTransferBadEnding(request, errorCallback) {
	const LAST_CHUNK = node_buffer.Buffer.from("0\r\n\r\n");
	let isChunkedTransfer = false;
	let properLastChunkReceived = false;
	let previousChunk;
	request.on("response", (response) => {
		const { headers } = response;
		isChunkedTransfer = headers["transfer-encoding"] === "chunked" && !headers["content-length"];
	});
	request.on("socket", (socket) => {
		const onSocketClose = () => {
			if (isChunkedTransfer && !properLastChunkReceived) {
				const error = /* @__PURE__ */ new Error("Premature close");
				error.code = "ERR_STREAM_PREMATURE_CLOSE";
				errorCallback(error);
			}
		};
		const onData = (buf) => {
			properLastChunkReceived = node_buffer.Buffer.compare(buf.slice(-5), LAST_CHUNK) === 0;
			if (!properLastChunkReceived && previousChunk) properLastChunkReceived = node_buffer.Buffer.compare(previousChunk.slice(-3), LAST_CHUNK.slice(0, 3)) === 0 && node_buffer.Buffer.compare(buf.slice(-2), LAST_CHUNK.slice(3)) === 0;
			previousChunk = buf;
		};
		socket.prependListener("close", onSocketClose);
		socket.on("data", onData);
		request.on("close", () => {
			socket.removeListener("close", onSocketClose);
			socket.removeListener("data", onData);
		});
	});
}

//#endregion
//#region ../node_modules/.pnpm/ws@8.18.3_bufferutil@4.0.8_utf-8-validate@6.0.3/node_modules/ws/lib/constants.js
var require_constants$1 = /* @__PURE__ */ require_chunk.__commonJSMin(((exports, module) => {
	const BINARY_TYPES = [
		"nodebuffer",
		"arraybuffer",
		"fragments"
	];
	const hasBlob = typeof Blob !== "undefined";
	if (hasBlob) BINARY_TYPES.push("blob");
	module.exports = {
		BINARY_TYPES,
		EMPTY_BUFFER: Buffer.alloc(0),
		GUID: "258EAFA5-E914-47DA-95CA-C5AB0DC85B11",
		hasBlob,
		kForOnEventAttribute: Symbol("kIsForOnEventAttribute"),
		kListener: Symbol("kListener"),
		kStatusCode: Symbol("status-code"),
		kWebSocket: Symbol("websocket"),
		NOOP: () => {}
	};
}));

//#endregion
//#region ../node_modules/.pnpm/node-gyp-build@4.8.4/node_modules/node-gyp-build/node-gyp-build.js
var require_node_gyp_build$1 = /* @__PURE__ */ require_chunk.__commonJSMin(((exports, module) => {
	var fs = require("fs");
	var path = require("path");
	var os = require("os");
	var runtimeRequire = typeof __webpack_require__ === "function" ? __non_webpack_require__ : require;
	var vars = process.config && process.config.variables || {};
	var prebuildsOnly = !!process.env.PREBUILDS_ONLY;
	var abi = process.versions.modules;
	var runtime = isElectron() ? "electron" : isNwjs() ? "node-webkit" : "node";
	var arch = process.env.npm_config_arch || os.arch();
	var platform = process.env.npm_config_platform || os.platform();
	var libc = process.env.LIBC || (isAlpine(platform) ? "musl" : "glibc");
	var armv = process.env.ARM_VERSION || (arch === "arm64" ? "8" : vars.arm_version) || "";
	var uv = (process.versions.uv || "").split(".")[0];
	module.exports = load;
	function load(dir) {
		return runtimeRequire(load.resolve(dir));
	}
	load.resolve = load.path = function(dir) {
		dir = path.resolve(dir || ".");
		try {
			var name = runtimeRequire(path.join(dir, "package.json")).name.toUpperCase().replace(/-/g, "_");
			if (process.env[name + "_PREBUILD"]) dir = process.env[name + "_PREBUILD"];
		} catch (err$1) {}
		if (!prebuildsOnly) {
			var release = getFirst(path.join(dir, "build/Release"), matchBuild);
			if (release) return release;
			var debug = getFirst(path.join(dir, "build/Debug"), matchBuild);
			if (debug) return debug;
		}
		var prebuild = resolve(dir);
		if (prebuild) return prebuild;
		var nearby = resolve(path.dirname(process.execPath));
		if (nearby) return nearby;
		var target = [
			"platform=" + platform,
			"arch=" + arch,
			"runtime=" + runtime,
			"abi=" + abi,
			"uv=" + uv,
			armv ? "armv=" + armv : "",
			"libc=" + libc,
			"node=" + process.versions.node,
			process.versions.electron ? "electron=" + process.versions.electron : "",
			typeof __webpack_require__ === "function" ? "webpack=true" : ""
		].filter(Boolean).join(" ");
		throw new Error("No native build was found for " + target + "\n    loaded from: " + dir + "\n");
		function resolve(dir$1) {
			var tuple = readdirSync(path.join(dir$1, "prebuilds")).map(parseTuple).filter(matchTuple(platform, arch)).sort(compareTuples)[0];
			if (!tuple) return;
			var prebuilds = path.join(dir$1, "prebuilds", tuple.name);
			var winner = readdirSync(prebuilds).map(parseTags).filter(matchTags(runtime, abi)).sort(compareTags(runtime))[0];
			if (winner) return path.join(prebuilds, winner.file);
		}
	};
	function readdirSync(dir) {
		try {
			return fs.readdirSync(dir);
		} catch (err$1) {
			return [];
		}
	}
	function getFirst(dir, filter) {
		var files = readdirSync(dir).filter(filter);
		return files[0] && path.join(dir, files[0]);
	}
	function matchBuild(name) {
		return /\.node$/.test(name);
	}
	function parseTuple(name) {
		var arr = name.split("-");
		if (arr.length !== 2) return;
		var platform = arr[0];
		var architectures = arr[1].split("+");
		if (!platform) return;
		if (!architectures.length) return;
		if (!architectures.every(Boolean)) return;
		return {
			name,
			platform,
			architectures
		};
	}
	function matchTuple(platform, arch) {
		return function(tuple) {
			if (tuple == null) return false;
			if (tuple.platform !== platform) return false;
			return tuple.architectures.includes(arch);
		};
	}
	function compareTuples(a, b) {
		return a.architectures.length - b.architectures.length;
	}
	function parseTags(file) {
		var arr = file.split(".");
		var extension = arr.pop();
		var tags = {
			file,
			specificity: 0
		};
		if (extension !== "node") return;
		for (var i = 0; i < arr.length; i++) {
			var tag = arr[i];
			if (tag === "node" || tag === "electron" || tag === "node-webkit") tags.runtime = tag;
			else if (tag === "napi") tags.napi = true;
			else if (tag.slice(0, 3) === "abi") tags.abi = tag.slice(3);
			else if (tag.slice(0, 2) === "uv") tags.uv = tag.slice(2);
			else if (tag.slice(0, 4) === "armv") tags.armv = tag.slice(4);
			else if (tag === "glibc" || tag === "musl") tags.libc = tag;
			else continue;
			tags.specificity++;
		}
		return tags;
	}
	function matchTags(runtime, abi) {
		return function(tags) {
			if (tags == null) return false;
			if (tags.runtime && tags.runtime !== runtime && !runtimeAgnostic(tags)) return false;
			if (tags.abi && tags.abi !== abi && !tags.napi) return false;
			if (tags.uv && tags.uv !== uv) return false;
			if (tags.armv && tags.armv !== armv) return false;
			if (tags.libc && tags.libc !== libc) return false;
			return true;
		};
	}
	function runtimeAgnostic(tags) {
		return tags.runtime === "node" && tags.napi;
	}
	function compareTags(runtime) {
		return function(a, b) {
			if (a.runtime !== b.runtime) return a.runtime === runtime ? -1 : 1;
			else if (a.abi !== b.abi) return a.abi ? -1 : 1;
			else if (a.specificity !== b.specificity) return a.specificity > b.specificity ? -1 : 1;
			else return 0;
		};
	}
	function isNwjs() {
		return !!(process.versions && process.versions.nw);
	}
	function isElectron() {
		if (process.versions && process.versions.electron) return true;
		if (process.env.ELECTRON_RUN_AS_NODE) return true;
		return typeof window !== "undefined" && window.process && window.process.type === "renderer";
	}
	function isAlpine(platform) {
		return platform === "linux" && fs.existsSync("/etc/alpine-release");
	}
	load.parseTags = parseTags;
	load.matchTags = matchTags;
	load.compareTags = compareTags;
	load.parseTuple = parseTuple;
	load.matchTuple = matchTuple;
	load.compareTuples = compareTuples;
}));

//#endregion
//#region ../node_modules/.pnpm/node-gyp-build@4.8.4/node_modules/node-gyp-build/index.js
var require_node_gyp_build = /* @__PURE__ */ require_chunk.__commonJSMin(((exports, module) => {
	const runtimeRequire = typeof __webpack_require__ === "function" ? __non_webpack_require__ : require;
	if (typeof runtimeRequire.addon === "function") module.exports = runtimeRequire.addon.bind(runtimeRequire);
	else module.exports = require_node_gyp_build$1();
}));

//#endregion
//#region ../node_modules/.pnpm/bufferutil@4.0.8/node_modules/bufferutil/fallback.js
var require_fallback$1 = /* @__PURE__ */ require_chunk.__commonJSMin(((exports, module) => {
	/**
	* Masks a buffer using the given mask.
	*
	* @param {Buffer} source The buffer to mask
	* @param {Buffer} mask The mask to use
	* @param {Buffer} output The buffer where to store the result
	* @param {Number} offset The offset at which to start writing
	* @param {Number} length The number of bytes to mask.
	* @public
	*/
	const mask = (source, mask, output, offset, length) => {
		for (var i = 0; i < length; i++) output[offset + i] = source[i] ^ mask[i & 3];
	};
	/**
	* Unmasks a buffer using the given mask.
	*
	* @param {Buffer} buffer The buffer to unmask
	* @param {Buffer} mask The mask to use
	* @public
	*/
	const unmask = (buffer, mask) => {
		const length = buffer.length;
		for (var i = 0; i < length; i++) buffer[i] ^= mask[i & 3];
	};
	module.exports = {
		mask,
		unmask
	};
}));

//#endregion
//#region ../node_modules/.pnpm/bufferutil@4.0.8/node_modules/bufferutil/index.js
var require_bufferutil = /* @__PURE__ */ require_chunk.__commonJSMin(((exports, module) => {
	try {
		module.exports = require_node_gyp_build()(__dirname);
	} catch (e) {
		module.exports = require_fallback$1();
	}
}));

//#endregion
//#region ../node_modules/.pnpm/ws@8.18.3_bufferutil@4.0.8_utf-8-validate@6.0.3/node_modules/ws/lib/buffer-util.js
var require_buffer_util = /* @__PURE__ */ require_chunk.__commonJSMin(((exports, module) => {
	const { EMPTY_BUFFER } = require_constants$1();
	const FastBuffer = Buffer[Symbol.species];
	/**
	* Merges an array of buffers into a new buffer.
	*
	* @param {Buffer[]} list The array of buffers to concat
	* @param {Number} totalLength The total length of buffers in the list
	* @return {Buffer} The resulting buffer
	* @public
	*/
	function concat(list, totalLength) {
		if (list.length === 0) return EMPTY_BUFFER;
		if (list.length === 1) return list[0];
		const target = Buffer.allocUnsafe(totalLength);
		let offset = 0;
		for (let i = 0; i < list.length; i++) {
			const buf = list[i];
			target.set(buf, offset);
			offset += buf.length;
		}
		if (offset < totalLength) return new FastBuffer(target.buffer, target.byteOffset, offset);
		return target;
	}
	/**
	* Masks a buffer using the given mask.
	*
	* @param {Buffer} source The buffer to mask
	* @param {Buffer} mask The mask to use
	* @param {Buffer} output The buffer where to store the result
	* @param {Number} offset The offset at which to start writing
	* @param {Number} length The number of bytes to mask.
	* @public
	*/
	function _mask(source, mask, output, offset, length) {
		for (let i = 0; i < length; i++) output[offset + i] = source[i] ^ mask[i & 3];
	}
	/**
	* Unmasks a buffer using the given mask.
	*
	* @param {Buffer} buffer The buffer to unmask
	* @param {Buffer} mask The mask to use
	* @public
	*/
	function _unmask(buffer, mask) {
		for (let i = 0; i < buffer.length; i++) buffer[i] ^= mask[i & 3];
	}
	/**
	* Converts a buffer to an `ArrayBuffer`.
	*
	* @param {Buffer} buf The buffer to convert
	* @return {ArrayBuffer} Converted buffer
	* @public
	*/
	function toArrayBuffer(buf) {
		if (buf.length === buf.buffer.byteLength) return buf.buffer;
		return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.length);
	}
	/**
	* Converts `data` to a `Buffer`.
	*
	* @param {*} data The data to convert
	* @return {Buffer} The buffer
	* @throws {TypeError}
	* @public
	*/
	function toBuffer(data) {
		toBuffer.readOnly = true;
		if (Buffer.isBuffer(data)) return data;
		let buf;
		if (data instanceof ArrayBuffer) buf = new FastBuffer(data);
		else if (ArrayBuffer.isView(data)) buf = new FastBuffer(data.buffer, data.byteOffset, data.byteLength);
		else {
			buf = Buffer.from(data);
			toBuffer.readOnly = false;
		}
		return buf;
	}
	module.exports = {
		concat,
		mask: _mask,
		toArrayBuffer,
		toBuffer,
		unmask: _unmask
	};
	/* istanbul ignore else  */
	if (!process.env.WS_NO_BUFFER_UTIL) try {
		const bufferUtil = require_bufferutil();
		module.exports.mask = function(source, mask, output, offset, length) {
			if (length < 48) _mask(source, mask, output, offset, length);
			else bufferUtil.mask(source, mask, output, offset, length);
		};
		module.exports.unmask = function(buffer, mask) {
			if (buffer.length < 32) _unmask(buffer, mask);
			else bufferUtil.unmask(buffer, mask);
		};
	} catch (e) {}
}));

//#endregion
//#region ../node_modules/.pnpm/ws@8.18.3_bufferutil@4.0.8_utf-8-validate@6.0.3/node_modules/ws/lib/limiter.js
var require_limiter = /* @__PURE__ */ require_chunk.__commonJSMin(((exports, module) => {
	const kDone = Symbol("kDone");
	const kRun = Symbol("kRun");
	/**
	* A very simple job queue with adjustable concurrency. Adapted from
	* https://github.com/STRML/async-limiter
	*/
	var Limiter = class {
		/**
		* Creates a new `Limiter`.
		*
		* @param {Number} [concurrency=Infinity] The maximum number of jobs allowed
		*     to run concurrently
		*/
		constructor(concurrency) {
			this[kDone] = () => {
				this.pending--;
				this[kRun]();
			};
			this.concurrency = concurrency || Infinity;
			this.jobs = [];
			this.pending = 0;
		}
		/**
		* Adds a job to the queue.
		*
		* @param {Function} job The job to run
		* @public
		*/
		add(job) {
			this.jobs.push(job);
			this[kRun]();
		}
		/**
		* Removes a job from the queue and runs it if possible.
		*
		* @private
		*/
		[kRun]() {
			if (this.pending === this.concurrency) return;
			if (this.jobs.length) {
				const job = this.jobs.shift();
				this.pending++;
				job(this[kDone]);
			}
		}
	};
	module.exports = Limiter;
}));

//#endregion
//#region ../node_modules/.pnpm/ws@8.18.3_bufferutil@4.0.8_utf-8-validate@6.0.3/node_modules/ws/lib/permessage-deflate.js
var require_permessage_deflate = /* @__PURE__ */ require_chunk.__commonJSMin(((exports, module) => {
	const zlib = require("zlib");
	const bufferUtil = require_buffer_util();
	const Limiter = require_limiter();
	const { kStatusCode } = require_constants$1();
	const FastBuffer = Buffer[Symbol.species];
	const TRAILER = Buffer.from([
		0,
		0,
		255,
		255
	]);
	const kPerMessageDeflate = Symbol("permessage-deflate");
	const kTotalLength = Symbol("total-length");
	const kCallback = Symbol("callback");
	const kBuffers = Symbol("buffers");
	const kError = Symbol("error");
	let zlibLimiter;
	/**
	* permessage-deflate implementation.
	*/
	var PerMessageDeflate = class {
		/**
		* Creates a PerMessageDeflate instance.
		*
		* @param {Object} [options] Configuration options
		* @param {(Boolean|Number)} [options.clientMaxWindowBits] Advertise support
		*     for, or request, a custom client window size
		* @param {Boolean} [options.clientNoContextTakeover=false] Advertise/
		*     acknowledge disabling of client context takeover
		* @param {Number} [options.concurrencyLimit=10] The number of concurrent
		*     calls to zlib
		* @param {(Boolean|Number)} [options.serverMaxWindowBits] Request/confirm the
		*     use of a custom server window size
		* @param {Boolean} [options.serverNoContextTakeover=false] Request/accept
		*     disabling of server context takeover
		* @param {Number} [options.threshold=1024] Size (in bytes) below which
		*     messages should not be compressed if context takeover is disabled
		* @param {Object} [options.zlibDeflateOptions] Options to pass to zlib on
		*     deflate
		* @param {Object} [options.zlibInflateOptions] Options to pass to zlib on
		*     inflate
		* @param {Boolean} [isServer=false] Create the instance in either server or
		*     client mode
		* @param {Number} [maxPayload=0] The maximum allowed message length
		*/
		constructor(options, isServer, maxPayload) {
			this._maxPayload = maxPayload | 0;
			this._options = options || {};
			this._threshold = this._options.threshold !== void 0 ? this._options.threshold : 1024;
			this._isServer = !!isServer;
			this._deflate = null;
			this._inflate = null;
			this.params = null;
			if (!zlibLimiter) zlibLimiter = new Limiter(this._options.concurrencyLimit !== void 0 ? this._options.concurrencyLimit : 10);
		}
		/**
		* @type {String}
		*/
		static get extensionName() {
			return "permessage-deflate";
		}
		/**
		* Create an extension negotiation offer.
		*
		* @return {Object} Extension parameters
		* @public
		*/
		offer() {
			const params = {};
			if (this._options.serverNoContextTakeover) params.server_no_context_takeover = true;
			if (this._options.clientNoContextTakeover) params.client_no_context_takeover = true;
			if (this._options.serverMaxWindowBits) params.server_max_window_bits = this._options.serverMaxWindowBits;
			if (this._options.clientMaxWindowBits) params.client_max_window_bits = this._options.clientMaxWindowBits;
			else if (this._options.clientMaxWindowBits == null) params.client_max_window_bits = true;
			return params;
		}
		/**
		* Accept an extension negotiation offer/response.
		*
		* @param {Array} configurations The extension negotiation offers/reponse
		* @return {Object} Accepted configuration
		* @public
		*/
		accept(configurations) {
			configurations = this.normalizeParams(configurations);
			this.params = this._isServer ? this.acceptAsServer(configurations) : this.acceptAsClient(configurations);
			return this.params;
		}
		/**
		* Releases all resources used by the extension.
		*
		* @public
		*/
		cleanup() {
			if (this._inflate) {
				this._inflate.close();
				this._inflate = null;
			}
			if (this._deflate) {
				const callback = this._deflate[kCallback];
				this._deflate.close();
				this._deflate = null;
				if (callback) callback(/* @__PURE__ */ new Error("The deflate stream was closed while data was being processed"));
			}
		}
		/**
		*  Accept an extension negotiation offer.
		*
		* @param {Array} offers The extension negotiation offers
		* @return {Object} Accepted configuration
		* @private
		*/
		acceptAsServer(offers) {
			const opts = this._options;
			const accepted = offers.find((params) => {
				if (opts.serverNoContextTakeover === false && params.server_no_context_takeover || params.server_max_window_bits && (opts.serverMaxWindowBits === false || typeof opts.serverMaxWindowBits === "number" && opts.serverMaxWindowBits > params.server_max_window_bits) || typeof opts.clientMaxWindowBits === "number" && !params.client_max_window_bits) return false;
				return true;
			});
			if (!accepted) throw new Error("None of the extension offers can be accepted");
			if (opts.serverNoContextTakeover) accepted.server_no_context_takeover = true;
			if (opts.clientNoContextTakeover) accepted.client_no_context_takeover = true;
			if (typeof opts.serverMaxWindowBits === "number") accepted.server_max_window_bits = opts.serverMaxWindowBits;
			if (typeof opts.clientMaxWindowBits === "number") accepted.client_max_window_bits = opts.clientMaxWindowBits;
			else if (accepted.client_max_window_bits === true || opts.clientMaxWindowBits === false) delete accepted.client_max_window_bits;
			return accepted;
		}
		/**
		* Accept the extension negotiation response.
		*
		* @param {Array} response The extension negotiation response
		* @return {Object} Accepted configuration
		* @private
		*/
		acceptAsClient(response) {
			const params = response[0];
			if (this._options.clientNoContextTakeover === false && params.client_no_context_takeover) throw new Error("Unexpected parameter \"client_no_context_takeover\"");
			if (!params.client_max_window_bits) {
				if (typeof this._options.clientMaxWindowBits === "number") params.client_max_window_bits = this._options.clientMaxWindowBits;
			} else if (this._options.clientMaxWindowBits === false || typeof this._options.clientMaxWindowBits === "number" && params.client_max_window_bits > this._options.clientMaxWindowBits) throw new Error("Unexpected or invalid parameter \"client_max_window_bits\"");
			return params;
		}
		/**
		* Normalize parameters.
		*
		* @param {Array} configurations The extension negotiation offers/reponse
		* @return {Array} The offers/response with normalized parameters
		* @private
		*/
		normalizeParams(configurations) {
			configurations.forEach((params) => {
				Object.keys(params).forEach((key) => {
					let value = params[key];
					if (value.length > 1) throw new Error(`Parameter "${key}" must have only a single value`);
					value = value[0];
					if (key === "client_max_window_bits") {
						if (value !== true) {
							const num = +value;
							if (!Number.isInteger(num) || num < 8 || num > 15) throw new TypeError(`Invalid value for parameter "${key}": ${value}`);
							value = num;
						} else if (!this._isServer) throw new TypeError(`Invalid value for parameter "${key}": ${value}`);
					} else if (key === "server_max_window_bits") {
						const num = +value;
						if (!Number.isInteger(num) || num < 8 || num > 15) throw new TypeError(`Invalid value for parameter "${key}": ${value}`);
						value = num;
					} else if (key === "client_no_context_takeover" || key === "server_no_context_takeover") {
						if (value !== true) throw new TypeError(`Invalid value for parameter "${key}": ${value}`);
					} else throw new Error(`Unknown parameter "${key}"`);
					params[key] = value;
				});
			});
			return configurations;
		}
		/**
		* Decompress data. Concurrency limited.
		*
		* @param {Buffer} data Compressed data
		* @param {Boolean} fin Specifies whether or not this is the last fragment
		* @param {Function} callback Callback
		* @public
		*/
		decompress(data, fin, callback) {
			zlibLimiter.add((done) => {
				this._decompress(data, fin, (err$1, result) => {
					done();
					callback(err$1, result);
				});
			});
		}
		/**
		* Compress data. Concurrency limited.
		*
		* @param {(Buffer|String)} data Data to compress
		* @param {Boolean} fin Specifies whether or not this is the last fragment
		* @param {Function} callback Callback
		* @public
		*/
		compress(data, fin, callback) {
			zlibLimiter.add((done) => {
				this._compress(data, fin, (err$1, result) => {
					done();
					callback(err$1, result);
				});
			});
		}
		/**
		* Decompress data.
		*
		* @param {Buffer} data Compressed data
		* @param {Boolean} fin Specifies whether or not this is the last fragment
		* @param {Function} callback Callback
		* @private
		*/
		_decompress(data, fin, callback) {
			const endpoint = this._isServer ? "client" : "server";
			if (!this._inflate) {
				const key = `${endpoint}_max_window_bits`;
				const windowBits = typeof this.params[key] !== "number" ? zlib.Z_DEFAULT_WINDOWBITS : this.params[key];
				this._inflate = zlib.createInflateRaw({
					...this._options.zlibInflateOptions,
					windowBits
				});
				this._inflate[kPerMessageDeflate] = this;
				this._inflate[kTotalLength] = 0;
				this._inflate[kBuffers] = [];
				this._inflate.on("error", inflateOnError);
				this._inflate.on("data", inflateOnData);
			}
			this._inflate[kCallback] = callback;
			this._inflate.write(data);
			if (fin) this._inflate.write(TRAILER);
			this._inflate.flush(() => {
				const err$1 = this._inflate[kError];
				if (err$1) {
					this._inflate.close();
					this._inflate = null;
					callback(err$1);
					return;
				}
				const data$1 = bufferUtil.concat(this._inflate[kBuffers], this._inflate[kTotalLength]);
				if (this._inflate._readableState.endEmitted) {
					this._inflate.close();
					this._inflate = null;
				} else {
					this._inflate[kTotalLength] = 0;
					this._inflate[kBuffers] = [];
					if (fin && this.params[`${endpoint}_no_context_takeover`]) this._inflate.reset();
				}
				callback(null, data$1);
			});
		}
		/**
		* Compress data.
		*
		* @param {(Buffer|String)} data Data to compress
		* @param {Boolean} fin Specifies whether or not this is the last fragment
		* @param {Function} callback Callback
		* @private
		*/
		_compress(data, fin, callback) {
			const endpoint = this._isServer ? "server" : "client";
			if (!this._deflate) {
				const key = `${endpoint}_max_window_bits`;
				const windowBits = typeof this.params[key] !== "number" ? zlib.Z_DEFAULT_WINDOWBITS : this.params[key];
				this._deflate = zlib.createDeflateRaw({
					...this._options.zlibDeflateOptions,
					windowBits
				});
				this._deflate[kTotalLength] = 0;
				this._deflate[kBuffers] = [];
				this._deflate.on("data", deflateOnData);
			}
			this._deflate[kCallback] = callback;
			this._deflate.write(data);
			this._deflate.flush(zlib.Z_SYNC_FLUSH, () => {
				if (!this._deflate) return;
				let data$1 = bufferUtil.concat(this._deflate[kBuffers], this._deflate[kTotalLength]);
				if (fin) data$1 = new FastBuffer(data$1.buffer, data$1.byteOffset, data$1.length - 4);
				this._deflate[kCallback] = null;
				this._deflate[kTotalLength] = 0;
				this._deflate[kBuffers] = [];
				if (fin && this.params[`${endpoint}_no_context_takeover`]) this._deflate.reset();
				callback(null, data$1);
			});
		}
	};
	module.exports = PerMessageDeflate;
	/**
	* The listener of the `zlib.DeflateRaw` stream `'data'` event.
	*
	* @param {Buffer} chunk A chunk of data
	* @private
	*/
	function deflateOnData(chunk) {
		this[kBuffers].push(chunk);
		this[kTotalLength] += chunk.length;
	}
	/**
	* The listener of the `zlib.InflateRaw` stream `'data'` event.
	*
	* @param {Buffer} chunk A chunk of data
	* @private
	*/
	function inflateOnData(chunk) {
		this[kTotalLength] += chunk.length;
		if (this[kPerMessageDeflate]._maxPayload < 1 || this[kTotalLength] <= this[kPerMessageDeflate]._maxPayload) {
			this[kBuffers].push(chunk);
			return;
		}
		this[kError] = /* @__PURE__ */ new RangeError("Max payload size exceeded");
		this[kError].code = "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH";
		this[kError][kStatusCode] = 1009;
		this.removeListener("data", inflateOnData);
		this.reset();
	}
	/**
	* The listener of the `zlib.InflateRaw` stream `'error'` event.
	*
	* @param {Error} err The emitted error
	* @private
	*/
	function inflateOnError(err$1) {
		this[kPerMessageDeflate]._inflate = null;
		if (this[kError]) {
			this[kCallback](this[kError]);
			return;
		}
		err$1[kStatusCode] = 1007;
		this[kCallback](err$1);
	}
}));

//#endregion
//#region ../node_modules/.pnpm/utf-8-validate@6.0.3/node_modules/utf-8-validate/fallback.js
var require_fallback = /* @__PURE__ */ require_chunk.__commonJSMin(((exports, module) => {
	/**
	* Checks if a given buffer contains only correct UTF-8.
	* Ported from https://www.cl.cam.ac.uk/%7Emgk25/ucs/utf8_check.c by
	* Markus Kuhn.
	*
	* @param {Buffer} buf The buffer to check
	* @return {Boolean} `true` if `buf` contains only correct UTF-8, else `false`
	* @public
	*/
	function isValidUTF8(buf) {
		const len = buf.length;
		let i = 0;
		while (i < len) if ((buf[i] & 128) === 0) i++;
		else if ((buf[i] & 224) === 192) {
			if (i + 1 === len || (buf[i + 1] & 192) !== 128 || (buf[i] & 254) === 192) return false;
			i += 2;
		} else if ((buf[i] & 240) === 224) {
			if (i + 2 >= len || (buf[i + 1] & 192) !== 128 || (buf[i + 2] & 192) !== 128 || buf[i] === 224 && (buf[i + 1] & 224) === 128 || buf[i] === 237 && (buf[i + 1] & 224) === 160) return false;
			i += 3;
		} else if ((buf[i] & 248) === 240) {
			if (i + 3 >= len || (buf[i + 1] & 192) !== 128 || (buf[i + 2] & 192) !== 128 || (buf[i + 3] & 192) !== 128 || buf[i] === 240 && (buf[i + 1] & 240) === 128 || buf[i] === 244 && buf[i + 1] > 143 || buf[i] > 244) return false;
			i += 4;
		} else return false;
		return true;
	}
	module.exports = isValidUTF8;
}));

//#endregion
//#region ../node_modules/.pnpm/utf-8-validate@6.0.3/node_modules/utf-8-validate/index.js
var require_utf_8_validate = /* @__PURE__ */ require_chunk.__commonJSMin(((exports, module) => {
	try {
		module.exports = require_node_gyp_build()(__dirname);
	} catch (e) {
		module.exports = require_fallback();
	}
}));

//#endregion
//#region ../node_modules/.pnpm/ws@8.18.3_bufferutil@4.0.8_utf-8-validate@6.0.3/node_modules/ws/lib/validation.js
var require_validation = /* @__PURE__ */ require_chunk.__commonJSMin(((exports, module) => {
	const { isUtf8 } = require("buffer");
	const { hasBlob } = require_constants$1();
	const tokenChars = [
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		1,
		0,
		1,
		1,
		1,
		1,
		1,
		0,
		0,
		1,
		1,
		0,
		1,
		1,
		0,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		0,
		0,
		0,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		0,
		1,
		0,
		1,
		0
	];
	/**
	* Checks if a status code is allowed in a close frame.
	*
	* @param {Number} code The status code
	* @return {Boolean} `true` if the status code is valid, else `false`
	* @public
	*/
	function isValidStatusCode(code) {
		return code >= 1e3 && code <= 1014 && code !== 1004 && code !== 1005 && code !== 1006 || code >= 3e3 && code <= 4999;
	}
	/**
	* Checks if a given buffer contains only correct UTF-8.
	* Ported from https://www.cl.cam.ac.uk/%7Emgk25/ucs/utf8_check.c by
	* Markus Kuhn.
	*
	* @param {Buffer} buf The buffer to check
	* @return {Boolean} `true` if `buf` contains only correct UTF-8, else `false`
	* @public
	*/
	function _isValidUTF8(buf) {
		const len = buf.length;
		let i = 0;
		while (i < len) if ((buf[i] & 128) === 0) i++;
		else if ((buf[i] & 224) === 192) {
			if (i + 1 === len || (buf[i + 1] & 192) !== 128 || (buf[i] & 254) === 192) return false;
			i += 2;
		} else if ((buf[i] & 240) === 224) {
			if (i + 2 >= len || (buf[i + 1] & 192) !== 128 || (buf[i + 2] & 192) !== 128 || buf[i] === 224 && (buf[i + 1] & 224) === 128 || buf[i] === 237 && (buf[i + 1] & 224) === 160) return false;
			i += 3;
		} else if ((buf[i] & 248) === 240) {
			if (i + 3 >= len || (buf[i + 1] & 192) !== 128 || (buf[i + 2] & 192) !== 128 || (buf[i + 3] & 192) !== 128 || buf[i] === 240 && (buf[i + 1] & 240) === 128 || buf[i] === 244 && buf[i + 1] > 143 || buf[i] > 244) return false;
			i += 4;
		} else return false;
		return true;
	}
	/**
	* Determines whether a value is a `Blob`.
	*
	* @param {*} value The value to be tested
	* @return {Boolean} `true` if `value` is a `Blob`, else `false`
	* @private
	*/
	function isBlob(value) {
		return hasBlob && typeof value === "object" && typeof value.arrayBuffer === "function" && typeof value.type === "string" && typeof value.stream === "function" && (value[Symbol.toStringTag] === "Blob" || value[Symbol.toStringTag] === "File");
	}
	module.exports = {
		isBlob,
		isValidStatusCode,
		isValidUTF8: _isValidUTF8,
		tokenChars
	};
	if (isUtf8) module.exports.isValidUTF8 = function(buf) {
		return buf.length < 24 ? _isValidUTF8(buf) : isUtf8(buf);
	};
	else if (!process.env.WS_NO_UTF_8_VALIDATE) try {
		const isValidUTF8 = require_utf_8_validate();
		module.exports.isValidUTF8 = function(buf) {
			return buf.length < 32 ? _isValidUTF8(buf) : isValidUTF8(buf);
		};
	} catch (e) {}
}));

//#endregion
//#region ../node_modules/.pnpm/ws@8.18.3_bufferutil@4.0.8_utf-8-validate@6.0.3/node_modules/ws/lib/receiver.js
var require_receiver = /* @__PURE__ */ require_chunk.__commonJSMin(((exports, module) => {
	const { Writable } = require("stream");
	const PerMessageDeflate = require_permessage_deflate();
	const { BINARY_TYPES, EMPTY_BUFFER, kStatusCode, kWebSocket } = require_constants$1();
	const { concat, toArrayBuffer, unmask } = require_buffer_util();
	const { isValidStatusCode, isValidUTF8 } = require_validation();
	const FastBuffer = Buffer[Symbol.species];
	const GET_INFO = 0;
	const GET_PAYLOAD_LENGTH_16 = 1;
	const GET_PAYLOAD_LENGTH_64 = 2;
	const GET_MASK = 3;
	const GET_DATA = 4;
	const INFLATING = 5;
	const DEFER_EVENT = 6;
	/**
	* HyBi Receiver implementation.
	*
	* @extends Writable
	*/
	var Receiver = class extends Writable {
		/**
		* Creates a Receiver instance.
		*
		* @param {Object} [options] Options object
		* @param {Boolean} [options.allowSynchronousEvents=true] Specifies whether
		*     any of the `'message'`, `'ping'`, and `'pong'` events can be emitted
		*     multiple times in the same tick
		* @param {String} [options.binaryType=nodebuffer] The type for binary data
		* @param {Object} [options.extensions] An object containing the negotiated
		*     extensions
		* @param {Boolean} [options.isServer=false] Specifies whether to operate in
		*     client or server mode
		* @param {Number} [options.maxPayload=0] The maximum allowed message length
		* @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
		*     not to skip UTF-8 validation for text and close messages
		*/
		constructor(options = {}) {
			super();
			this._allowSynchronousEvents = options.allowSynchronousEvents !== void 0 ? options.allowSynchronousEvents : true;
			this._binaryType = options.binaryType || BINARY_TYPES[0];
			this._extensions = options.extensions || {};
			this._isServer = !!options.isServer;
			this._maxPayload = options.maxPayload | 0;
			this._skipUTF8Validation = !!options.skipUTF8Validation;
			this[kWebSocket] = void 0;
			this._bufferedBytes = 0;
			this._buffers = [];
			this._compressed = false;
			this._payloadLength = 0;
			this._mask = void 0;
			this._fragmented = 0;
			this._masked = false;
			this._fin = false;
			this._opcode = 0;
			this._totalPayloadLength = 0;
			this._messageLength = 0;
			this._fragments = [];
			this._errored = false;
			this._loop = false;
			this._state = GET_INFO;
		}
		/**
		* Implements `Writable.prototype._write()`.
		*
		* @param {Buffer} chunk The chunk of data to write
		* @param {String} encoding The character encoding of `chunk`
		* @param {Function} cb Callback
		* @private
		*/
		_write(chunk, encoding, cb) {
			if (this._opcode === 8 && this._state == GET_INFO) return cb();
			this._bufferedBytes += chunk.length;
			this._buffers.push(chunk);
			this.startLoop(cb);
		}
		/**
		* Consumes `n` bytes from the buffered data.
		*
		* @param {Number} n The number of bytes to consume
		* @return {Buffer} The consumed bytes
		* @private
		*/
		consume(n) {
			this._bufferedBytes -= n;
			if (n === this._buffers[0].length) return this._buffers.shift();
			if (n < this._buffers[0].length) {
				const buf = this._buffers[0];
				this._buffers[0] = new FastBuffer(buf.buffer, buf.byteOffset + n, buf.length - n);
				return new FastBuffer(buf.buffer, buf.byteOffset, n);
			}
			const dst = Buffer.allocUnsafe(n);
			do {
				const buf = this._buffers[0];
				const offset = dst.length - n;
				if (n >= buf.length) dst.set(this._buffers.shift(), offset);
				else {
					dst.set(new Uint8Array(buf.buffer, buf.byteOffset, n), offset);
					this._buffers[0] = new FastBuffer(buf.buffer, buf.byteOffset + n, buf.length - n);
				}
				n -= buf.length;
			} while (n > 0);
			return dst;
		}
		/**
		* Starts the parsing loop.
		*
		* @param {Function} cb Callback
		* @private
		*/
		startLoop(cb) {
			this._loop = true;
			do
				switch (this._state) {
					case GET_INFO:
						this.getInfo(cb);
						break;
					case GET_PAYLOAD_LENGTH_16:
						this.getPayloadLength16(cb);
						break;
					case GET_PAYLOAD_LENGTH_64:
						this.getPayloadLength64(cb);
						break;
					case GET_MASK:
						this.getMask();
						break;
					case GET_DATA:
						this.getData(cb);
						break;
					case INFLATING:
					case DEFER_EVENT:
						this._loop = false;
						return;
				}
			while (this._loop);
			if (!this._errored) cb();
		}
		/**
		* Reads the first two bytes of a frame.
		*
		* @param {Function} cb Callback
		* @private
		*/
		getInfo(cb) {
			if (this._bufferedBytes < 2) {
				this._loop = false;
				return;
			}
			const buf = this.consume(2);
			if ((buf[0] & 48) !== 0) {
				cb(this.createError(RangeError, "RSV2 and RSV3 must be clear", true, 1002, "WS_ERR_UNEXPECTED_RSV_2_3"));
				return;
			}
			const compressed = (buf[0] & 64) === 64;
			if (compressed && !this._extensions[PerMessageDeflate.extensionName]) {
				cb(this.createError(RangeError, "RSV1 must be clear", true, 1002, "WS_ERR_UNEXPECTED_RSV_1"));
				return;
			}
			this._fin = (buf[0] & 128) === 128;
			this._opcode = buf[0] & 15;
			this._payloadLength = buf[1] & 127;
			if (this._opcode === 0) {
				if (compressed) {
					cb(this.createError(RangeError, "RSV1 must be clear", true, 1002, "WS_ERR_UNEXPECTED_RSV_1"));
					return;
				}
				if (!this._fragmented) {
					cb(this.createError(RangeError, "invalid opcode 0", true, 1002, "WS_ERR_INVALID_OPCODE"));
					return;
				}
				this._opcode = this._fragmented;
			} else if (this._opcode === 1 || this._opcode === 2) {
				if (this._fragmented) {
					cb(this.createError(RangeError, `invalid opcode ${this._opcode}`, true, 1002, "WS_ERR_INVALID_OPCODE"));
					return;
				}
				this._compressed = compressed;
			} else if (this._opcode > 7 && this._opcode < 11) {
				if (!this._fin) {
					cb(this.createError(RangeError, "FIN must be set", true, 1002, "WS_ERR_EXPECTED_FIN"));
					return;
				}
				if (compressed) {
					cb(this.createError(RangeError, "RSV1 must be clear", true, 1002, "WS_ERR_UNEXPECTED_RSV_1"));
					return;
				}
				if (this._payloadLength > 125 || this._opcode === 8 && this._payloadLength === 1) {
					cb(this.createError(RangeError, `invalid payload length ${this._payloadLength}`, true, 1002, "WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH"));
					return;
				}
			} else {
				cb(this.createError(RangeError, `invalid opcode ${this._opcode}`, true, 1002, "WS_ERR_INVALID_OPCODE"));
				return;
			}
			if (!this._fin && !this._fragmented) this._fragmented = this._opcode;
			this._masked = (buf[1] & 128) === 128;
			if (this._isServer) {
				if (!this._masked) {
					cb(this.createError(RangeError, "MASK must be set", true, 1002, "WS_ERR_EXPECTED_MASK"));
					return;
				}
			} else if (this._masked) {
				cb(this.createError(RangeError, "MASK must be clear", true, 1002, "WS_ERR_UNEXPECTED_MASK"));
				return;
			}
			if (this._payloadLength === 126) this._state = GET_PAYLOAD_LENGTH_16;
			else if (this._payloadLength === 127) this._state = GET_PAYLOAD_LENGTH_64;
			else this.haveLength(cb);
		}
		/**
		* Gets extended payload length (7+16).
		*
		* @param {Function} cb Callback
		* @private
		*/
		getPayloadLength16(cb) {
			if (this._bufferedBytes < 2) {
				this._loop = false;
				return;
			}
			this._payloadLength = this.consume(2).readUInt16BE(0);
			this.haveLength(cb);
		}
		/**
		* Gets extended payload length (7+64).
		*
		* @param {Function} cb Callback
		* @private
		*/
		getPayloadLength64(cb) {
			if (this._bufferedBytes < 8) {
				this._loop = false;
				return;
			}
			const buf = this.consume(8);
			const num = buf.readUInt32BE(0);
			if (num > Math.pow(2, 21) - 1) {
				cb(this.createError(RangeError, "Unsupported WebSocket frame: payload length > 2^53 - 1", false, 1009, "WS_ERR_UNSUPPORTED_DATA_PAYLOAD_LENGTH"));
				return;
			}
			this._payloadLength = num * Math.pow(2, 32) + buf.readUInt32BE(4);
			this.haveLength(cb);
		}
		/**
		* Payload length has been read.
		*
		* @param {Function} cb Callback
		* @private
		*/
		haveLength(cb) {
			if (this._payloadLength && this._opcode < 8) {
				this._totalPayloadLength += this._payloadLength;
				if (this._totalPayloadLength > this._maxPayload && this._maxPayload > 0) {
					cb(this.createError(RangeError, "Max payload size exceeded", false, 1009, "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH"));
					return;
				}
			}
			if (this._masked) this._state = GET_MASK;
			else this._state = GET_DATA;
		}
		/**
		* Reads mask bytes.
		*
		* @private
		*/
		getMask() {
			if (this._bufferedBytes < 4) {
				this._loop = false;
				return;
			}
			this._mask = this.consume(4);
			this._state = GET_DATA;
		}
		/**
		* Reads data bytes.
		*
		* @param {Function} cb Callback
		* @private
		*/
		getData(cb) {
			let data = EMPTY_BUFFER;
			if (this._payloadLength) {
				if (this._bufferedBytes < this._payloadLength) {
					this._loop = false;
					return;
				}
				data = this.consume(this._payloadLength);
				if (this._masked && (this._mask[0] | this._mask[1] | this._mask[2] | this._mask[3]) !== 0) unmask(data, this._mask);
			}
			if (this._opcode > 7) {
				this.controlMessage(data, cb);
				return;
			}
			if (this._compressed) {
				this._state = INFLATING;
				this.decompress(data, cb);
				return;
			}
			if (data.length) {
				this._messageLength = this._totalPayloadLength;
				this._fragments.push(data);
			}
			this.dataMessage(cb);
		}
		/**
		* Decompresses data.
		*
		* @param {Buffer} data Compressed data
		* @param {Function} cb Callback
		* @private
		*/
		decompress(data, cb) {
			this._extensions[PerMessageDeflate.extensionName].decompress(data, this._fin, (err$1, buf) => {
				if (err$1) return cb(err$1);
				if (buf.length) {
					this._messageLength += buf.length;
					if (this._messageLength > this._maxPayload && this._maxPayload > 0) {
						cb(this.createError(RangeError, "Max payload size exceeded", false, 1009, "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH"));
						return;
					}
					this._fragments.push(buf);
				}
				this.dataMessage(cb);
				if (this._state === GET_INFO) this.startLoop(cb);
			});
		}
		/**
		* Handles a data message.
		*
		* @param {Function} cb Callback
		* @private
		*/
		dataMessage(cb) {
			if (!this._fin) {
				this._state = GET_INFO;
				return;
			}
			const messageLength = this._messageLength;
			const fragments = this._fragments;
			this._totalPayloadLength = 0;
			this._messageLength = 0;
			this._fragmented = 0;
			this._fragments = [];
			if (this._opcode === 2) {
				let data;
				if (this._binaryType === "nodebuffer") data = concat(fragments, messageLength);
				else if (this._binaryType === "arraybuffer") data = toArrayBuffer(concat(fragments, messageLength));
				else if (this._binaryType === "blob") data = new Blob(fragments);
				else data = fragments;
				if (this._allowSynchronousEvents) {
					this.emit("message", data, true);
					this._state = GET_INFO;
				} else {
					this._state = DEFER_EVENT;
					setImmediate(() => {
						this.emit("message", data, true);
						this._state = GET_INFO;
						this.startLoop(cb);
					});
				}
			} else {
				const buf = concat(fragments, messageLength);
				if (!this._skipUTF8Validation && !isValidUTF8(buf)) {
					cb(this.createError(Error, "invalid UTF-8 sequence", true, 1007, "WS_ERR_INVALID_UTF8"));
					return;
				}
				if (this._state === INFLATING || this._allowSynchronousEvents) {
					this.emit("message", buf, false);
					this._state = GET_INFO;
				} else {
					this._state = DEFER_EVENT;
					setImmediate(() => {
						this.emit("message", buf, false);
						this._state = GET_INFO;
						this.startLoop(cb);
					});
				}
			}
		}
		/**
		* Handles a control message.
		*
		* @param {Buffer} data Data to handle
		* @return {(Error|RangeError|undefined)} A possible error
		* @private
		*/
		controlMessage(data, cb) {
			if (this._opcode === 8) {
				if (data.length === 0) {
					this._loop = false;
					this.emit("conclude", 1005, EMPTY_BUFFER);
					this.end();
				} else {
					const code = data.readUInt16BE(0);
					if (!isValidStatusCode(code)) {
						cb(this.createError(RangeError, `invalid status code ${code}`, true, 1002, "WS_ERR_INVALID_CLOSE_CODE"));
						return;
					}
					const buf = new FastBuffer(data.buffer, data.byteOffset + 2, data.length - 2);
					if (!this._skipUTF8Validation && !isValidUTF8(buf)) {
						cb(this.createError(Error, "invalid UTF-8 sequence", true, 1007, "WS_ERR_INVALID_UTF8"));
						return;
					}
					this._loop = false;
					this.emit("conclude", code, buf);
					this.end();
				}
				this._state = GET_INFO;
				return;
			}
			if (this._allowSynchronousEvents) {
				this.emit(this._opcode === 9 ? "ping" : "pong", data);
				this._state = GET_INFO;
			} else {
				this._state = DEFER_EVENT;
				setImmediate(() => {
					this.emit(this._opcode === 9 ? "ping" : "pong", data);
					this._state = GET_INFO;
					this.startLoop(cb);
				});
			}
		}
		/**
		* Builds an error object.
		*
		* @param {function(new:Error|RangeError)} ErrorCtor The error constructor
		* @param {String} message The error message
		* @param {Boolean} prefix Specifies whether or not to add a default prefix to
		*     `message`
		* @param {Number} statusCode The status code
		* @param {String} errorCode The exposed error code
		* @return {(Error|RangeError)} The error
		* @private
		*/
		createError(ErrorCtor, message, prefix, statusCode, errorCode) {
			this._loop = false;
			this._errored = true;
			const err$1 = new ErrorCtor(prefix ? `Invalid WebSocket frame: ${message}` : message);
			Error.captureStackTrace(err$1, this.createError);
			err$1.code = errorCode;
			err$1[kStatusCode] = statusCode;
			return err$1;
		}
	};
	module.exports = Receiver;
}));

//#endregion
//#region ../node_modules/.pnpm/ws@8.18.3_bufferutil@4.0.8_utf-8-validate@6.0.3/node_modules/ws/lib/sender.js
var require_sender = /* @__PURE__ */ require_chunk.__commonJSMin(((exports, module) => {
	const { Duplex: Duplex$3 } = require("stream");
	const { randomFillSync } = require("crypto");
	const PerMessageDeflate = require_permessage_deflate();
	const { EMPTY_BUFFER, kWebSocket, NOOP } = require_constants$1();
	const { isBlob, isValidStatusCode } = require_validation();
	const { mask: applyMask, toBuffer } = require_buffer_util();
	const kByteLength = Symbol("kByteLength");
	const maskBuffer = Buffer.alloc(4);
	const RANDOM_POOL_SIZE = 8 * 1024;
	let randomPool;
	let randomPoolPointer = RANDOM_POOL_SIZE;
	const DEFAULT = 0;
	const DEFLATING = 1;
	const GET_BLOB_DATA = 2;
	/**
	* HyBi Sender implementation.
	*/
	var Sender = class Sender {
		/**
		* Creates a Sender instance.
		*
		* @param {Duplex} socket The connection socket
		* @param {Object} [extensions] An object containing the negotiated extensions
		* @param {Function} [generateMask] The function used to generate the masking
		*     key
		*/
		constructor(socket, extensions, generateMask) {
			this._extensions = extensions || {};
			if (generateMask) {
				this._generateMask = generateMask;
				this._maskBuffer = Buffer.alloc(4);
			}
			this._socket = socket;
			this._firstFragment = true;
			this._compress = false;
			this._bufferedBytes = 0;
			this._queue = [];
			this._state = DEFAULT;
			this.onerror = NOOP;
			this[kWebSocket] = void 0;
		}
		/**
		* Frames a piece of data according to the HyBi WebSocket protocol.
		*
		* @param {(Buffer|String)} data The data to frame
		* @param {Object} options Options object
		* @param {Boolean} [options.fin=false] Specifies whether or not to set the
		*     FIN bit
		* @param {Function} [options.generateMask] The function used to generate the
		*     masking key
		* @param {Boolean} [options.mask=false] Specifies whether or not to mask
		*     `data`
		* @param {Buffer} [options.maskBuffer] The buffer used to store the masking
		*     key
		* @param {Number} options.opcode The opcode
		* @param {Boolean} [options.readOnly=false] Specifies whether `data` can be
		*     modified
		* @param {Boolean} [options.rsv1=false] Specifies whether or not to set the
		*     RSV1 bit
		* @return {(Buffer|String)[]} The framed data
		* @public
		*/
		static frame(data, options) {
			let mask;
			let merge = false;
			let offset = 2;
			let skipMasking = false;
			if (options.mask) {
				mask = options.maskBuffer || maskBuffer;
				if (options.generateMask) options.generateMask(mask);
				else {
					if (randomPoolPointer === RANDOM_POOL_SIZE) {
						/* istanbul ignore else  */
						if (randomPool === void 0) randomPool = Buffer.alloc(RANDOM_POOL_SIZE);
						randomFillSync(randomPool, 0, RANDOM_POOL_SIZE);
						randomPoolPointer = 0;
					}
					mask[0] = randomPool[randomPoolPointer++];
					mask[1] = randomPool[randomPoolPointer++];
					mask[2] = randomPool[randomPoolPointer++];
					mask[3] = randomPool[randomPoolPointer++];
				}
				skipMasking = (mask[0] | mask[1] | mask[2] | mask[3]) === 0;
				offset = 6;
			}
			let dataLength;
			if (typeof data === "string") if ((!options.mask || skipMasking) && options[kByteLength] !== void 0) dataLength = options[kByteLength];
			else {
				data = Buffer.from(data);
				dataLength = data.length;
			}
			else {
				dataLength = data.length;
				merge = options.mask && options.readOnly && !skipMasking;
			}
			let payloadLength = dataLength;
			if (dataLength >= 65536) {
				offset += 8;
				payloadLength = 127;
			} else if (dataLength > 125) {
				offset += 2;
				payloadLength = 126;
			}
			const target = Buffer.allocUnsafe(merge ? dataLength + offset : offset);
			target[0] = options.fin ? options.opcode | 128 : options.opcode;
			if (options.rsv1) target[0] |= 64;
			target[1] = payloadLength;
			if (payloadLength === 126) target.writeUInt16BE(dataLength, 2);
			else if (payloadLength === 127) {
				target[2] = target[3] = 0;
				target.writeUIntBE(dataLength, 4, 6);
			}
			if (!options.mask) return [target, data];
			target[1] |= 128;
			target[offset - 4] = mask[0];
			target[offset - 3] = mask[1];
			target[offset - 2] = mask[2];
			target[offset - 1] = mask[3];
			if (skipMasking) return [target, data];
			if (merge) {
				applyMask(data, mask, target, offset, dataLength);
				return [target];
			}
			applyMask(data, mask, data, 0, dataLength);
			return [target, data];
		}
		/**
		* Sends a close message to the other peer.
		*
		* @param {Number} [code] The status code component of the body
		* @param {(String|Buffer)} [data] The message component of the body
		* @param {Boolean} [mask=false] Specifies whether or not to mask the message
		* @param {Function} [cb] Callback
		* @public
		*/
		close(code, data, mask, cb) {
			let buf;
			if (code === void 0) buf = EMPTY_BUFFER;
			else if (typeof code !== "number" || !isValidStatusCode(code)) throw new TypeError("First argument must be a valid error code number");
			else if (data === void 0 || !data.length) {
				buf = Buffer.allocUnsafe(2);
				buf.writeUInt16BE(code, 0);
			} else {
				const length = Buffer.byteLength(data);
				if (length > 123) throw new RangeError("The message must not be greater than 123 bytes");
				buf = Buffer.allocUnsafe(2 + length);
				buf.writeUInt16BE(code, 0);
				if (typeof data === "string") buf.write(data, 2);
				else buf.set(data, 2);
			}
			const options = {
				[kByteLength]: buf.length,
				fin: true,
				generateMask: this._generateMask,
				mask,
				maskBuffer: this._maskBuffer,
				opcode: 8,
				readOnly: false,
				rsv1: false
			};
			if (this._state !== DEFAULT) this.enqueue([
				this.dispatch,
				buf,
				false,
				options,
				cb
			]);
			else this.sendFrame(Sender.frame(buf, options), cb);
		}
		/**
		* Sends a ping message to the other peer.
		*
		* @param {*} data The message to send
		* @param {Boolean} [mask=false] Specifies whether or not to mask `data`
		* @param {Function} [cb] Callback
		* @public
		*/
		ping(data, mask, cb) {
			let byteLength;
			let readOnly;
			if (typeof data === "string") {
				byteLength = Buffer.byteLength(data);
				readOnly = false;
			} else if (isBlob(data)) {
				byteLength = data.size;
				readOnly = false;
			} else {
				data = toBuffer(data);
				byteLength = data.length;
				readOnly = toBuffer.readOnly;
			}
			if (byteLength > 125) throw new RangeError("The data size must not be greater than 125 bytes");
			const options = {
				[kByteLength]: byteLength,
				fin: true,
				generateMask: this._generateMask,
				mask,
				maskBuffer: this._maskBuffer,
				opcode: 9,
				readOnly,
				rsv1: false
			};
			if (isBlob(data)) if (this._state !== DEFAULT) this.enqueue([
				this.getBlobData,
				data,
				false,
				options,
				cb
			]);
			else this.getBlobData(data, false, options, cb);
			else if (this._state !== DEFAULT) this.enqueue([
				this.dispatch,
				data,
				false,
				options,
				cb
			]);
			else this.sendFrame(Sender.frame(data, options), cb);
		}
		/**
		* Sends a pong message to the other peer.
		*
		* @param {*} data The message to send
		* @param {Boolean} [mask=false] Specifies whether or not to mask `data`
		* @param {Function} [cb] Callback
		* @public
		*/
		pong(data, mask, cb) {
			let byteLength;
			let readOnly;
			if (typeof data === "string") {
				byteLength = Buffer.byteLength(data);
				readOnly = false;
			} else if (isBlob(data)) {
				byteLength = data.size;
				readOnly = false;
			} else {
				data = toBuffer(data);
				byteLength = data.length;
				readOnly = toBuffer.readOnly;
			}
			if (byteLength > 125) throw new RangeError("The data size must not be greater than 125 bytes");
			const options = {
				[kByteLength]: byteLength,
				fin: true,
				generateMask: this._generateMask,
				mask,
				maskBuffer: this._maskBuffer,
				opcode: 10,
				readOnly,
				rsv1: false
			};
			if (isBlob(data)) if (this._state !== DEFAULT) this.enqueue([
				this.getBlobData,
				data,
				false,
				options,
				cb
			]);
			else this.getBlobData(data, false, options, cb);
			else if (this._state !== DEFAULT) this.enqueue([
				this.dispatch,
				data,
				false,
				options,
				cb
			]);
			else this.sendFrame(Sender.frame(data, options), cb);
		}
		/**
		* Sends a data message to the other peer.
		*
		* @param {*} data The message to send
		* @param {Object} options Options object
		* @param {Boolean} [options.binary=false] Specifies whether `data` is binary
		*     or text
		* @param {Boolean} [options.compress=false] Specifies whether or not to
		*     compress `data`
		* @param {Boolean} [options.fin=false] Specifies whether the fragment is the
		*     last one
		* @param {Boolean} [options.mask=false] Specifies whether or not to mask
		*     `data`
		* @param {Function} [cb] Callback
		* @public
		*/
		send(data, options, cb) {
			const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
			let opcode = options.binary ? 2 : 1;
			let rsv1 = options.compress;
			let byteLength;
			let readOnly;
			if (typeof data === "string") {
				byteLength = Buffer.byteLength(data);
				readOnly = false;
			} else if (isBlob(data)) {
				byteLength = data.size;
				readOnly = false;
			} else {
				data = toBuffer(data);
				byteLength = data.length;
				readOnly = toBuffer.readOnly;
			}
			if (this._firstFragment) {
				this._firstFragment = false;
				if (rsv1 && perMessageDeflate && perMessageDeflate.params[perMessageDeflate._isServer ? "server_no_context_takeover" : "client_no_context_takeover"]) rsv1 = byteLength >= perMessageDeflate._threshold;
				this._compress = rsv1;
			} else {
				rsv1 = false;
				opcode = 0;
			}
			if (options.fin) this._firstFragment = true;
			const opts = {
				[kByteLength]: byteLength,
				fin: options.fin,
				generateMask: this._generateMask,
				mask: options.mask,
				maskBuffer: this._maskBuffer,
				opcode,
				readOnly,
				rsv1
			};
			if (isBlob(data)) if (this._state !== DEFAULT) this.enqueue([
				this.getBlobData,
				data,
				this._compress,
				opts,
				cb
			]);
			else this.getBlobData(data, this._compress, opts, cb);
			else if (this._state !== DEFAULT) this.enqueue([
				this.dispatch,
				data,
				this._compress,
				opts,
				cb
			]);
			else this.dispatch(data, this._compress, opts, cb);
		}
		/**
		* Gets the contents of a blob as binary data.
		*
		* @param {Blob} blob The blob
		* @param {Boolean} [compress=false] Specifies whether or not to compress
		*     the data
		* @param {Object} options Options object
		* @param {Boolean} [options.fin=false] Specifies whether or not to set the
		*     FIN bit
		* @param {Function} [options.generateMask] The function used to generate the
		*     masking key
		* @param {Boolean} [options.mask=false] Specifies whether or not to mask
		*     `data`
		* @param {Buffer} [options.maskBuffer] The buffer used to store the masking
		*     key
		* @param {Number} options.opcode The opcode
		* @param {Boolean} [options.readOnly=false] Specifies whether `data` can be
		*     modified
		* @param {Boolean} [options.rsv1=false] Specifies whether or not to set the
		*     RSV1 bit
		* @param {Function} [cb] Callback
		* @private
		*/
		getBlobData(blob, compress, options, cb) {
			this._bufferedBytes += options[kByteLength];
			this._state = GET_BLOB_DATA;
			blob.arrayBuffer().then((arrayBuffer) => {
				if (this._socket.destroyed) {
					const err$1 = /* @__PURE__ */ new Error("The socket was closed while the blob was being read");
					process.nextTick(callCallbacks, this, err$1, cb);
					return;
				}
				this._bufferedBytes -= options[kByteLength];
				const data = toBuffer(arrayBuffer);
				if (!compress) {
					this._state = DEFAULT;
					this.sendFrame(Sender.frame(data, options), cb);
					this.dequeue();
				} else this.dispatch(data, compress, options, cb);
			}).catch((err$1) => {
				process.nextTick(onError, this, err$1, cb);
			});
		}
		/**
		* Dispatches a message.
		*
		* @param {(Buffer|String)} data The message to send
		* @param {Boolean} [compress=false] Specifies whether or not to compress
		*     `data`
		* @param {Object} options Options object
		* @param {Boolean} [options.fin=false] Specifies whether or not to set the
		*     FIN bit
		* @param {Function} [options.generateMask] The function used to generate the
		*     masking key
		* @param {Boolean} [options.mask=false] Specifies whether or not to mask
		*     `data`
		* @param {Buffer} [options.maskBuffer] The buffer used to store the masking
		*     key
		* @param {Number} options.opcode The opcode
		* @param {Boolean} [options.readOnly=false] Specifies whether `data` can be
		*     modified
		* @param {Boolean} [options.rsv1=false] Specifies whether or not to set the
		*     RSV1 bit
		* @param {Function} [cb] Callback
		* @private
		*/
		dispatch(data, compress, options, cb) {
			if (!compress) {
				this.sendFrame(Sender.frame(data, options), cb);
				return;
			}
			const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
			this._bufferedBytes += options[kByteLength];
			this._state = DEFLATING;
			perMessageDeflate.compress(data, options.fin, (_, buf) => {
				if (this._socket.destroyed) {
					callCallbacks(this, /* @__PURE__ */ new Error("The socket was closed while data was being compressed"), cb);
					return;
				}
				this._bufferedBytes -= options[kByteLength];
				this._state = DEFAULT;
				options.readOnly = false;
				this.sendFrame(Sender.frame(buf, options), cb);
				this.dequeue();
			});
		}
		/**
		* Executes queued send operations.
		*
		* @private
		*/
		dequeue() {
			while (this._state === DEFAULT && this._queue.length) {
				const params = this._queue.shift();
				this._bufferedBytes -= params[3][kByteLength];
				Reflect.apply(params[0], this, params.slice(1));
			}
		}
		/**
		* Enqueues a send operation.
		*
		* @param {Array} params Send operation parameters.
		* @private
		*/
		enqueue(params) {
			this._bufferedBytes += params[3][kByteLength];
			this._queue.push(params);
		}
		/**
		* Sends a frame.
		*
		* @param {(Buffer | String)[]} list The frame to send
		* @param {Function} [cb] Callback
		* @private
		*/
		sendFrame(list, cb) {
			if (list.length === 2) {
				this._socket.cork();
				this._socket.write(list[0]);
				this._socket.write(list[1], cb);
				this._socket.uncork();
			} else this._socket.write(list[0], cb);
		}
	};
	module.exports = Sender;
	/**
	* Calls queued callbacks with an error.
	*
	* @param {Sender} sender The `Sender` instance
	* @param {Error} err The error to call the callbacks with
	* @param {Function} [cb] The first callback
	* @private
	*/
	function callCallbacks(sender, err$1, cb) {
		if (typeof cb === "function") cb(err$1);
		for (let i = 0; i < sender._queue.length; i++) {
			const params = sender._queue[i];
			const callback = params[params.length - 1];
			if (typeof callback === "function") callback(err$1);
		}
	}
	/**
	* Handles a `Sender` error.
	*
	* @param {Sender} sender The `Sender` instance
	* @param {Error} err The error
	* @param {Function} [cb] The first pending callback
	* @private
	*/
	function onError(sender, err$1, cb) {
		callCallbacks(sender, err$1, cb);
		sender.onerror(err$1);
	}
}));

//#endregion
//#region ../node_modules/.pnpm/ws@8.18.3_bufferutil@4.0.8_utf-8-validate@6.0.3/node_modules/ws/lib/event-target.js
var require_event_target = /* @__PURE__ */ require_chunk.__commonJSMin(((exports, module) => {
	const { kForOnEventAttribute, kListener } = require_constants$1();
	const kCode = Symbol("kCode");
	const kData = Symbol("kData");
	const kError = Symbol("kError");
	const kMessage = Symbol("kMessage");
	const kReason = Symbol("kReason");
	const kTarget = Symbol("kTarget");
	const kType = Symbol("kType");
	const kWasClean = Symbol("kWasClean");
	/**
	* Class representing an event.
	*/
	var Event = class {
		/**
		* Create a new `Event`.
		*
		* @param {String} type The name of the event
		* @throws {TypeError} If the `type` argument is not specified
		*/
		constructor(type) {
			this[kTarget] = null;
			this[kType] = type;
		}
		/**
		* @type {*}
		*/
		get target() {
			return this[kTarget];
		}
		/**
		* @type {String}
		*/
		get type() {
			return this[kType];
		}
	};
	Object.defineProperty(Event.prototype, "target", { enumerable: true });
	Object.defineProperty(Event.prototype, "type", { enumerable: true });
	/**
	* Class representing a close event.
	*
	* @extends Event
	*/
	var CloseEvent = class extends Event {
		/**
		* Create a new `CloseEvent`.
		*
		* @param {String} type The name of the event
		* @param {Object} [options] A dictionary object that allows for setting
		*     attributes via object members of the same name
		* @param {Number} [options.code=0] The status code explaining why the
		*     connection was closed
		* @param {String} [options.reason=''] A human-readable string explaining why
		*     the connection was closed
		* @param {Boolean} [options.wasClean=false] Indicates whether or not the
		*     connection was cleanly closed
		*/
		constructor(type, options = {}) {
			super(type);
			this[kCode] = options.code === void 0 ? 0 : options.code;
			this[kReason] = options.reason === void 0 ? "" : options.reason;
			this[kWasClean] = options.wasClean === void 0 ? false : options.wasClean;
		}
		/**
		* @type {Number}
		*/
		get code() {
			return this[kCode];
		}
		/**
		* @type {String}
		*/
		get reason() {
			return this[kReason];
		}
		/**
		* @type {Boolean}
		*/
		get wasClean() {
			return this[kWasClean];
		}
	};
	Object.defineProperty(CloseEvent.prototype, "code", { enumerable: true });
	Object.defineProperty(CloseEvent.prototype, "reason", { enumerable: true });
	Object.defineProperty(CloseEvent.prototype, "wasClean", { enumerable: true });
	/**
	* Class representing an error event.
	*
	* @extends Event
	*/
	var ErrorEvent = class extends Event {
		/**
		* Create a new `ErrorEvent`.
		*
		* @param {String} type The name of the event
		* @param {Object} [options] A dictionary object that allows for setting
		*     attributes via object members of the same name
		* @param {*} [options.error=null] The error that generated this event
		* @param {String} [options.message=''] The error message
		*/
		constructor(type, options = {}) {
			super(type);
			this[kError] = options.error === void 0 ? null : options.error;
			this[kMessage] = options.message === void 0 ? "" : options.message;
		}
		/**
		* @type {*}
		*/
		get error() {
			return this[kError];
		}
		/**
		* @type {String}
		*/
		get message() {
			return this[kMessage];
		}
	};
	Object.defineProperty(ErrorEvent.prototype, "error", { enumerable: true });
	Object.defineProperty(ErrorEvent.prototype, "message", { enumerable: true });
	/**
	* Class representing a message event.
	*
	* @extends Event
	*/
	var MessageEvent = class extends Event {
		/**
		* Create a new `MessageEvent`.
		*
		* @param {String} type The name of the event
		* @param {Object} [options] A dictionary object that allows for setting
		*     attributes via object members of the same name
		* @param {*} [options.data=null] The message content
		*/
		constructor(type, options = {}) {
			super(type);
			this[kData] = options.data === void 0 ? null : options.data;
		}
		/**
		* @type {*}
		*/
		get data() {
			return this[kData];
		}
	};
	Object.defineProperty(MessageEvent.prototype, "data", { enumerable: true });
	/**
	* This provides methods for emulating the `EventTarget` interface. It's not
	* meant to be used directly.
	*
	* @mixin
	*/
	const EventTarget = {
		addEventListener(type, handler, options = {}) {
			for (const listener of this.listeners(type)) if (!options[kForOnEventAttribute] && listener[kListener] === handler && !listener[kForOnEventAttribute]) return;
			let wrapper;
			if (type === "message") wrapper = function onMessage(data, isBinary) {
				const event = new MessageEvent("message", { data: isBinary ? data : data.toString() });
				event[kTarget] = this;
				callListener(handler, this, event);
			};
			else if (type === "close") wrapper = function onClose(code, message) {
				const event = new CloseEvent("close", {
					code,
					reason: message.toString(),
					wasClean: this._closeFrameReceived && this._closeFrameSent
				});
				event[kTarget] = this;
				callListener(handler, this, event);
			};
			else if (type === "error") wrapper = function onError(error) {
				const event = new ErrorEvent("error", {
					error,
					message: error.message
				});
				event[kTarget] = this;
				callListener(handler, this, event);
			};
			else if (type === "open") wrapper = function onOpen() {
				const event = new Event("open");
				event[kTarget] = this;
				callListener(handler, this, event);
			};
			else return;
			wrapper[kForOnEventAttribute] = !!options[kForOnEventAttribute];
			wrapper[kListener] = handler;
			if (options.once) this.once(type, wrapper);
			else this.on(type, wrapper);
		},
		removeEventListener(type, handler) {
			for (const listener of this.listeners(type)) if (listener[kListener] === handler && !listener[kForOnEventAttribute]) {
				this.removeListener(type, listener);
				break;
			}
		}
	};
	module.exports = {
		CloseEvent,
		ErrorEvent,
		Event,
		EventTarget,
		MessageEvent
	};
	/**
	* Call an event listener
	*
	* @param {(Function|Object)} listener The listener to call
	* @param {*} thisArg The value to use as `this`` when calling the listener
	* @param {Event} event The event to pass to the listener
	* @private
	*/
	function callListener(listener, thisArg, event) {
		if (typeof listener === "object" && listener.handleEvent) listener.handleEvent.call(listener, event);
		else listener.call(thisArg, event);
	}
}));

//#endregion
//#region ../node_modules/.pnpm/ws@8.18.3_bufferutil@4.0.8_utf-8-validate@6.0.3/node_modules/ws/lib/extension.js
var require_extension = /* @__PURE__ */ require_chunk.__commonJSMin(((exports, module) => {
	const { tokenChars } = require_validation();
	/**
	* Adds an offer to the map of extension offers or a parameter to the map of
	* parameters.
	*
	* @param {Object} dest The map of extension offers or parameters
	* @param {String} name The extension or parameter name
	* @param {(Object|Boolean|String)} elem The extension parameters or the
	*     parameter value
	* @private
	*/
	function push(dest, name, elem) {
		if (dest[name] === void 0) dest[name] = [elem];
		else dest[name].push(elem);
	}
	/**
	* Parses the `Sec-WebSocket-Extensions` header into an object.
	*
	* @param {String} header The field value of the header
	* @return {Object} The parsed object
	* @public
	*/
	function parse(header) {
		const offers = Object.create(null);
		let params = Object.create(null);
		let mustUnescape = false;
		let isEscaping = false;
		let inQuotes = false;
		let extensionName;
		let paramName;
		let start = -1;
		let code = -1;
		let end = -1;
		let i = 0;
		for (; i < header.length; i++) {
			code = header.charCodeAt(i);
			if (extensionName === void 0) if (end === -1 && tokenChars[code] === 1) {
				if (start === -1) start = i;
			} else if (i !== 0 && (code === 32 || code === 9)) {
				if (end === -1 && start !== -1) end = i;
			} else if (code === 59 || code === 44) {
				if (start === -1) throw new SyntaxError(`Unexpected character at index ${i}`);
				if (end === -1) end = i;
				const name = header.slice(start, end);
				if (code === 44) {
					push(offers, name, params);
					params = Object.create(null);
				} else extensionName = name;
				start = end = -1;
			} else throw new SyntaxError(`Unexpected character at index ${i}`);
			else if (paramName === void 0) if (end === -1 && tokenChars[code] === 1) {
				if (start === -1) start = i;
			} else if (code === 32 || code === 9) {
				if (end === -1 && start !== -1) end = i;
			} else if (code === 59 || code === 44) {
				if (start === -1) throw new SyntaxError(`Unexpected character at index ${i}`);
				if (end === -1) end = i;
				push(params, header.slice(start, end), true);
				if (code === 44) {
					push(offers, extensionName, params);
					params = Object.create(null);
					extensionName = void 0;
				}
				start = end = -1;
			} else if (code === 61 && start !== -1 && end === -1) {
				paramName = header.slice(start, i);
				start = end = -1;
			} else throw new SyntaxError(`Unexpected character at index ${i}`);
			else if (isEscaping) {
				if (tokenChars[code] !== 1) throw new SyntaxError(`Unexpected character at index ${i}`);
				if (start === -1) start = i;
				else if (!mustUnescape) mustUnescape = true;
				isEscaping = false;
			} else if (inQuotes) if (tokenChars[code] === 1) {
				if (start === -1) start = i;
			} else if (code === 34 && start !== -1) {
				inQuotes = false;
				end = i;
			} else if (code === 92) isEscaping = true;
			else throw new SyntaxError(`Unexpected character at index ${i}`);
			else if (code === 34 && header.charCodeAt(i - 1) === 61) inQuotes = true;
			else if (end === -1 && tokenChars[code] === 1) {
				if (start === -1) start = i;
			} else if (start !== -1 && (code === 32 || code === 9)) {
				if (end === -1) end = i;
			} else if (code === 59 || code === 44) {
				if (start === -1) throw new SyntaxError(`Unexpected character at index ${i}`);
				if (end === -1) end = i;
				let value = header.slice(start, end);
				if (mustUnescape) {
					value = value.replace(/\\/g, "");
					mustUnescape = false;
				}
				push(params, paramName, value);
				if (code === 44) {
					push(offers, extensionName, params);
					params = Object.create(null);
					extensionName = void 0;
				}
				paramName = void 0;
				start = end = -1;
			} else throw new SyntaxError(`Unexpected character at index ${i}`);
		}
		if (start === -1 || inQuotes || code === 32 || code === 9) throw new SyntaxError("Unexpected end of input");
		if (end === -1) end = i;
		const token = header.slice(start, end);
		if (extensionName === void 0) push(offers, token, params);
		else {
			if (paramName === void 0) push(params, token, true);
			else if (mustUnescape) push(params, paramName, token.replace(/\\/g, ""));
			else push(params, paramName, token);
			push(offers, extensionName, params);
		}
		return offers;
	}
	/**
	* Builds the `Sec-WebSocket-Extensions` header field value.
	*
	* @param {Object} extensions The map of extensions and parameters to format
	* @return {String} A string representing the given object
	* @public
	*/
	function format(extensions) {
		return Object.keys(extensions).map((extension) => {
			let configurations = extensions[extension];
			if (!Array.isArray(configurations)) configurations = [configurations];
			return configurations.map((params) => {
				return [extension].concat(Object.keys(params).map((k) => {
					let values = params[k];
					if (!Array.isArray(values)) values = [values];
					return values.map((v) => v === true ? k : `${k}=${v}`).join("; ");
				})).join("; ");
			}).join(", ");
		}).join(", ");
	}
	module.exports = {
		format,
		parse
	};
}));

//#endregion
//#region ../node_modules/.pnpm/ws@8.18.3_bufferutil@4.0.8_utf-8-validate@6.0.3/node_modules/ws/lib/websocket.js
var require_websocket = /* @__PURE__ */ require_chunk.__commonJSMin(((exports, module) => {
	const EventEmitter$1 = require("events");
	const https = require("https");
	const http$1 = require("http");
	const net$2 = require("net");
	const tls = require("tls");
	const { randomBytes, createHash: createHash$1 } = require("crypto");
	const { Duplex: Duplex$2, Readable } = require("stream");
	const { URL: URL$1 } = require("url");
	const PerMessageDeflate = require_permessage_deflate();
	const Receiver = require_receiver();
	const Sender = require_sender();
	const { isBlob } = require_validation();
	const { BINARY_TYPES, EMPTY_BUFFER, GUID, kForOnEventAttribute, kListener, kStatusCode, kWebSocket, NOOP } = require_constants$1();
	const { EventTarget: { addEventListener, removeEventListener } } = require_event_target();
	const { format, parse } = require_extension();
	const { toBuffer } = require_buffer_util();
	const closeTimeout = 30 * 1e3;
	const kAborted = Symbol("kAborted");
	const protocolVersions = [8, 13];
	const readyStates = [
		"CONNECTING",
		"OPEN",
		"CLOSING",
		"CLOSED"
	];
	const subprotocolRegex = /^[!#$%&'*+\-.0-9A-Z^_`|a-z~]+$/;
	/**
	* Class representing a WebSocket.
	*
	* @extends EventEmitter
	*/
	var WebSocket = class WebSocket extends EventEmitter$1 {
		/**
		* Create a new `WebSocket`.
		*
		* @param {(String|URL)} address The URL to which to connect
		* @param {(String|String[])} [protocols] The subprotocols
		* @param {Object} [options] Connection options
		*/
		constructor(address, protocols, options) {
			super();
			this._binaryType = BINARY_TYPES[0];
			this._closeCode = 1006;
			this._closeFrameReceived = false;
			this._closeFrameSent = false;
			this._closeMessage = EMPTY_BUFFER;
			this._closeTimer = null;
			this._errorEmitted = false;
			this._extensions = {};
			this._paused = false;
			this._protocol = "";
			this._readyState = WebSocket.CONNECTING;
			this._receiver = null;
			this._sender = null;
			this._socket = null;
			if (address !== null) {
				this._bufferedAmount = 0;
				this._isServer = false;
				this._redirects = 0;
				if (protocols === void 0) protocols = [];
				else if (!Array.isArray(protocols)) if (typeof protocols === "object" && protocols !== null) {
					options = protocols;
					protocols = [];
				} else protocols = [protocols];
				initAsClient(this, address, protocols, options);
			} else {
				this._autoPong = options.autoPong;
				this._isServer = true;
			}
		}
		/**
		* For historical reasons, the custom "nodebuffer" type is used by the default
		* instead of "blob".
		*
		* @type {String}
		*/
		get binaryType() {
			return this._binaryType;
		}
		set binaryType(type) {
			if (!BINARY_TYPES.includes(type)) return;
			this._binaryType = type;
			if (this._receiver) this._receiver._binaryType = type;
		}
		/**
		* @type {Number}
		*/
		get bufferedAmount() {
			if (!this._socket) return this._bufferedAmount;
			return this._socket._writableState.length + this._sender._bufferedBytes;
		}
		/**
		* @type {String}
		*/
		get extensions() {
			return Object.keys(this._extensions).join();
		}
		/**
		* @type {Boolean}
		*/
		get isPaused() {
			return this._paused;
		}
		/**
		* @type {Function}
		*/
		/* istanbul ignore next */
		get onclose() {
			return null;
		}
		/**
		* @type {Function}
		*/
		/* istanbul ignore next */
		get onerror() {
			return null;
		}
		/**
		* @type {Function}
		*/
		/* istanbul ignore next */
		get onopen() {
			return null;
		}
		/**
		* @type {Function}
		*/
		/* istanbul ignore next */
		get onmessage() {
			return null;
		}
		/**
		* @type {String}
		*/
		get protocol() {
			return this._protocol;
		}
		/**
		* @type {Number}
		*/
		get readyState() {
			return this._readyState;
		}
		/**
		* @type {String}
		*/
		get url() {
			return this._url;
		}
		/**
		* Set up the socket and the internal resources.
		*
		* @param {Duplex} socket The network socket between the server and client
		* @param {Buffer} head The first packet of the upgraded stream
		* @param {Object} options Options object
		* @param {Boolean} [options.allowSynchronousEvents=false] Specifies whether
		*     any of the `'message'`, `'ping'`, and `'pong'` events can be emitted
		*     multiple times in the same tick
		* @param {Function} [options.generateMask] The function used to generate the
		*     masking key
		* @param {Number} [options.maxPayload=0] The maximum allowed message size
		* @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
		*     not to skip UTF-8 validation for text and close messages
		* @private
		*/
		setSocket(socket, head, options) {
			const receiver = new Receiver({
				allowSynchronousEvents: options.allowSynchronousEvents,
				binaryType: this.binaryType,
				extensions: this._extensions,
				isServer: this._isServer,
				maxPayload: options.maxPayload,
				skipUTF8Validation: options.skipUTF8Validation
			});
			const sender = new Sender(socket, this._extensions, options.generateMask);
			this._receiver = receiver;
			this._sender = sender;
			this._socket = socket;
			receiver[kWebSocket] = this;
			sender[kWebSocket] = this;
			socket[kWebSocket] = this;
			receiver.on("conclude", receiverOnConclude);
			receiver.on("drain", receiverOnDrain);
			receiver.on("error", receiverOnError);
			receiver.on("message", receiverOnMessage);
			receiver.on("ping", receiverOnPing);
			receiver.on("pong", receiverOnPong);
			sender.onerror = senderOnError;
			if (socket.setTimeout) socket.setTimeout(0);
			if (socket.setNoDelay) socket.setNoDelay();
			if (head.length > 0) socket.unshift(head);
			socket.on("close", socketOnClose);
			socket.on("data", socketOnData);
			socket.on("end", socketOnEnd);
			socket.on("error", socketOnError);
			this._readyState = WebSocket.OPEN;
			this.emit("open");
		}
		/**
		* Emit the `'close'` event.
		*
		* @private
		*/
		emitClose() {
			if (!this._socket) {
				this._readyState = WebSocket.CLOSED;
				this.emit("close", this._closeCode, this._closeMessage);
				return;
			}
			if (this._extensions[PerMessageDeflate.extensionName]) this._extensions[PerMessageDeflate.extensionName].cleanup();
			this._receiver.removeAllListeners();
			this._readyState = WebSocket.CLOSED;
			this.emit("close", this._closeCode, this._closeMessage);
		}
		/**
		* Start a closing handshake.
		*
		*          +----------+   +-----------+   +----------+
		*     - - -|ws.close()|-->|close frame|-->|ws.close()|- - -
		*    |     +----------+   +-----------+   +----------+     |
		*          +----------+   +-----------+         |
		* CLOSING  |ws.close()|<--|close frame|<--+-----+       CLOSING
		*          +----------+   +-----------+   |
		*    |           |                        |   +---+        |
		*                +------------------------+-->|fin| - - - -
		*    |         +---+                      |   +---+
		*     - - - - -|fin|<---------------------+
		*              +---+
		*
		* @param {Number} [code] Status code explaining why the connection is closing
		* @param {(String|Buffer)} [data] The reason why the connection is
		*     closing
		* @public
		*/
		close(code, data) {
			if (this.readyState === WebSocket.CLOSED) return;
			if (this.readyState === WebSocket.CONNECTING) {
				abortHandshake(this, this._req, "WebSocket was closed before the connection was established");
				return;
			}
			if (this.readyState === WebSocket.CLOSING) {
				if (this._closeFrameSent && (this._closeFrameReceived || this._receiver._writableState.errorEmitted)) this._socket.end();
				return;
			}
			this._readyState = WebSocket.CLOSING;
			this._sender.close(code, data, !this._isServer, (err$1) => {
				if (err$1) return;
				this._closeFrameSent = true;
				if (this._closeFrameReceived || this._receiver._writableState.errorEmitted) this._socket.end();
			});
			setCloseTimer(this);
		}
		/**
		* Pause the socket.
		*
		* @public
		*/
		pause() {
			if (this.readyState === WebSocket.CONNECTING || this.readyState === WebSocket.CLOSED) return;
			this._paused = true;
			this._socket.pause();
		}
		/**
		* Send a ping.
		*
		* @param {*} [data] The data to send
		* @param {Boolean} [mask] Indicates whether or not to mask `data`
		* @param {Function} [cb] Callback which is executed when the ping is sent
		* @public
		*/
		ping(data, mask, cb) {
			if (this.readyState === WebSocket.CONNECTING) throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
			if (typeof data === "function") {
				cb = data;
				data = mask = void 0;
			} else if (typeof mask === "function") {
				cb = mask;
				mask = void 0;
			}
			if (typeof data === "number") data = data.toString();
			if (this.readyState !== WebSocket.OPEN) {
				sendAfterClose(this, data, cb);
				return;
			}
			if (mask === void 0) mask = !this._isServer;
			this._sender.ping(data || EMPTY_BUFFER, mask, cb);
		}
		/**
		* Send a pong.
		*
		* @param {*} [data] The data to send
		* @param {Boolean} [mask] Indicates whether or not to mask `data`
		* @param {Function} [cb] Callback which is executed when the pong is sent
		* @public
		*/
		pong(data, mask, cb) {
			if (this.readyState === WebSocket.CONNECTING) throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
			if (typeof data === "function") {
				cb = data;
				data = mask = void 0;
			} else if (typeof mask === "function") {
				cb = mask;
				mask = void 0;
			}
			if (typeof data === "number") data = data.toString();
			if (this.readyState !== WebSocket.OPEN) {
				sendAfterClose(this, data, cb);
				return;
			}
			if (mask === void 0) mask = !this._isServer;
			this._sender.pong(data || EMPTY_BUFFER, mask, cb);
		}
		/**
		* Resume the socket.
		*
		* @public
		*/
		resume() {
			if (this.readyState === WebSocket.CONNECTING || this.readyState === WebSocket.CLOSED) return;
			this._paused = false;
			if (!this._receiver._writableState.needDrain) this._socket.resume();
		}
		/**
		* Send a data message.
		*
		* @param {*} data The message to send
		* @param {Object} [options] Options object
		* @param {Boolean} [options.binary] Specifies whether `data` is binary or
		*     text
		* @param {Boolean} [options.compress] Specifies whether or not to compress
		*     `data`
		* @param {Boolean} [options.fin=true] Specifies whether the fragment is the
		*     last one
		* @param {Boolean} [options.mask] Specifies whether or not to mask `data`
		* @param {Function} [cb] Callback which is executed when data is written out
		* @public
		*/
		send(data, options, cb) {
			if (this.readyState === WebSocket.CONNECTING) throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
			if (typeof options === "function") {
				cb = options;
				options = {};
			}
			if (typeof data === "number") data = data.toString();
			if (this.readyState !== WebSocket.OPEN) {
				sendAfterClose(this, data, cb);
				return;
			}
			const opts = {
				binary: typeof data !== "string",
				mask: !this._isServer,
				compress: true,
				fin: true,
				...options
			};
			if (!this._extensions[PerMessageDeflate.extensionName]) opts.compress = false;
			this._sender.send(data || EMPTY_BUFFER, opts, cb);
		}
		/**
		* Forcibly close the connection.
		*
		* @public
		*/
		terminate() {
			if (this.readyState === WebSocket.CLOSED) return;
			if (this.readyState === WebSocket.CONNECTING) {
				abortHandshake(this, this._req, "WebSocket was closed before the connection was established");
				return;
			}
			if (this._socket) {
				this._readyState = WebSocket.CLOSING;
				this._socket.destroy();
			}
		}
	};
	/**
	* @constant {Number} CONNECTING
	* @memberof WebSocket
	*/
	Object.defineProperty(WebSocket, "CONNECTING", {
		enumerable: true,
		value: readyStates.indexOf("CONNECTING")
	});
	/**
	* @constant {Number} CONNECTING
	* @memberof WebSocket.prototype
	*/
	Object.defineProperty(WebSocket.prototype, "CONNECTING", {
		enumerable: true,
		value: readyStates.indexOf("CONNECTING")
	});
	/**
	* @constant {Number} OPEN
	* @memberof WebSocket
	*/
	Object.defineProperty(WebSocket, "OPEN", {
		enumerable: true,
		value: readyStates.indexOf("OPEN")
	});
	/**
	* @constant {Number} OPEN
	* @memberof WebSocket.prototype
	*/
	Object.defineProperty(WebSocket.prototype, "OPEN", {
		enumerable: true,
		value: readyStates.indexOf("OPEN")
	});
	/**
	* @constant {Number} CLOSING
	* @memberof WebSocket
	*/
	Object.defineProperty(WebSocket, "CLOSING", {
		enumerable: true,
		value: readyStates.indexOf("CLOSING")
	});
	/**
	* @constant {Number} CLOSING
	* @memberof WebSocket.prototype
	*/
	Object.defineProperty(WebSocket.prototype, "CLOSING", {
		enumerable: true,
		value: readyStates.indexOf("CLOSING")
	});
	/**
	* @constant {Number} CLOSED
	* @memberof WebSocket
	*/
	Object.defineProperty(WebSocket, "CLOSED", {
		enumerable: true,
		value: readyStates.indexOf("CLOSED")
	});
	/**
	* @constant {Number} CLOSED
	* @memberof WebSocket.prototype
	*/
	Object.defineProperty(WebSocket.prototype, "CLOSED", {
		enumerable: true,
		value: readyStates.indexOf("CLOSED")
	});
	[
		"binaryType",
		"bufferedAmount",
		"extensions",
		"isPaused",
		"protocol",
		"readyState",
		"url"
	].forEach((property) => {
		Object.defineProperty(WebSocket.prototype, property, { enumerable: true });
	});
	[
		"open",
		"error",
		"close",
		"message"
	].forEach((method) => {
		Object.defineProperty(WebSocket.prototype, `on${method}`, {
			enumerable: true,
			get() {
				for (const listener of this.listeners(method)) if (listener[kForOnEventAttribute]) return listener[kListener];
				return null;
			},
			set(handler) {
				for (const listener of this.listeners(method)) if (listener[kForOnEventAttribute]) {
					this.removeListener(method, listener);
					break;
				}
				if (typeof handler !== "function") return;
				this.addEventListener(method, handler, { [kForOnEventAttribute]: true });
			}
		});
	});
	WebSocket.prototype.addEventListener = addEventListener;
	WebSocket.prototype.removeEventListener = removeEventListener;
	module.exports = WebSocket;
	/**
	* Initialize a WebSocket client.
	*
	* @param {WebSocket} websocket The client to initialize
	* @param {(String|URL)} address The URL to which to connect
	* @param {Array} protocols The subprotocols
	* @param {Object} [options] Connection options
	* @param {Boolean} [options.allowSynchronousEvents=true] Specifies whether any
	*     of the `'message'`, `'ping'`, and `'pong'` events can be emitted multiple
	*     times in the same tick
	* @param {Boolean} [options.autoPong=true] Specifies whether or not to
	*     automatically send a pong in response to a ping
	* @param {Function} [options.finishRequest] A function which can be used to
	*     customize the headers of each http request before it is sent
	* @param {Boolean} [options.followRedirects=false] Whether or not to follow
	*     redirects
	* @param {Function} [options.generateMask] The function used to generate the
	*     masking key
	* @param {Number} [options.handshakeTimeout] Timeout in milliseconds for the
	*     handshake request
	* @param {Number} [options.maxPayload=104857600] The maximum allowed message
	*     size
	* @param {Number} [options.maxRedirects=10] The maximum number of redirects
	*     allowed
	* @param {String} [options.origin] Value of the `Origin` or
	*     `Sec-WebSocket-Origin` header
	* @param {(Boolean|Object)} [options.perMessageDeflate=true] Enable/disable
	*     permessage-deflate
	* @param {Number} [options.protocolVersion=13] Value of the
	*     `Sec-WebSocket-Version` header
	* @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
	*     not to skip UTF-8 validation for text and close messages
	* @private
	*/
	function initAsClient(websocket, address, protocols, options) {
		const opts = {
			allowSynchronousEvents: true,
			autoPong: true,
			protocolVersion: protocolVersions[1],
			maxPayload: 100 * 1024 * 1024,
			skipUTF8Validation: false,
			perMessageDeflate: true,
			followRedirects: false,
			maxRedirects: 10,
			...options,
			socketPath: void 0,
			hostname: void 0,
			protocol: void 0,
			timeout: void 0,
			method: "GET",
			host: void 0,
			path: void 0,
			port: void 0
		};
		websocket._autoPong = opts.autoPong;
		if (!protocolVersions.includes(opts.protocolVersion)) throw new RangeError(`Unsupported protocol version: ${opts.protocolVersion} (supported versions: ${protocolVersions.join(", ")})`);
		let parsedUrl;
		if (address instanceof URL$1) parsedUrl = address;
		else try {
			parsedUrl = new URL$1(address);
		} catch (e) {
			throw new SyntaxError(`Invalid URL: ${address}`);
		}
		if (parsedUrl.protocol === "http:") parsedUrl.protocol = "ws:";
		else if (parsedUrl.protocol === "https:") parsedUrl.protocol = "wss:";
		websocket._url = parsedUrl.href;
		const isSecure = parsedUrl.protocol === "wss:";
		const isIpcUrl = parsedUrl.protocol === "ws+unix:";
		let invalidUrlMessage;
		if (parsedUrl.protocol !== "ws:" && !isSecure && !isIpcUrl) invalidUrlMessage = "The URL's protocol must be one of \"ws:\", \"wss:\", \"http:\", \"https:\", or \"ws+unix:\"";
		else if (isIpcUrl && !parsedUrl.pathname) invalidUrlMessage = "The URL's pathname is empty";
		else if (parsedUrl.hash) invalidUrlMessage = "The URL contains a fragment identifier";
		if (invalidUrlMessage) {
			const err$1 = new SyntaxError(invalidUrlMessage);
			if (websocket._redirects === 0) throw err$1;
			else {
				emitErrorAndClose(websocket, err$1);
				return;
			}
		}
		const defaultPort = isSecure ? 443 : 80;
		const key = randomBytes(16).toString("base64");
		const request = isSecure ? https.request : http$1.request;
		const protocolSet = /* @__PURE__ */ new Set();
		let perMessageDeflate;
		opts.createConnection = opts.createConnection || (isSecure ? tlsConnect : netConnect);
		opts.defaultPort = opts.defaultPort || defaultPort;
		opts.port = parsedUrl.port || defaultPort;
		opts.host = parsedUrl.hostname.startsWith("[") ? parsedUrl.hostname.slice(1, -1) : parsedUrl.hostname;
		opts.headers = {
			...opts.headers,
			"Sec-WebSocket-Version": opts.protocolVersion,
			"Sec-WebSocket-Key": key,
			Connection: "Upgrade",
			Upgrade: "websocket"
		};
		opts.path = parsedUrl.pathname + parsedUrl.search;
		opts.timeout = opts.handshakeTimeout;
		if (opts.perMessageDeflate) {
			perMessageDeflate = new PerMessageDeflate(opts.perMessageDeflate !== true ? opts.perMessageDeflate : {}, false, opts.maxPayload);
			opts.headers["Sec-WebSocket-Extensions"] = format({ [PerMessageDeflate.extensionName]: perMessageDeflate.offer() });
		}
		if (protocols.length) {
			for (const protocol of protocols) {
				if (typeof protocol !== "string" || !subprotocolRegex.test(protocol) || protocolSet.has(protocol)) throw new SyntaxError("An invalid or duplicated subprotocol was specified");
				protocolSet.add(protocol);
			}
			opts.headers["Sec-WebSocket-Protocol"] = protocols.join(",");
		}
		if (opts.origin) if (opts.protocolVersion < 13) opts.headers["Sec-WebSocket-Origin"] = opts.origin;
		else opts.headers.Origin = opts.origin;
		if (parsedUrl.username || parsedUrl.password) opts.auth = `${parsedUrl.username}:${parsedUrl.password}`;
		if (isIpcUrl) {
			const parts = opts.path.split(":");
			opts.socketPath = parts[0];
			opts.path = parts[1];
		}
		let req;
		if (opts.followRedirects) {
			if (websocket._redirects === 0) {
				websocket._originalIpc = isIpcUrl;
				websocket._originalSecure = isSecure;
				websocket._originalHostOrSocketPath = isIpcUrl ? opts.socketPath : parsedUrl.host;
				const headers = options && options.headers;
				options = {
					...options,
					headers: {}
				};
				if (headers) for (const [key$1, value] of Object.entries(headers)) options.headers[key$1.toLowerCase()] = value;
			} else if (websocket.listenerCount("redirect") === 0) {
				const isSameHost = isIpcUrl ? websocket._originalIpc ? opts.socketPath === websocket._originalHostOrSocketPath : false : websocket._originalIpc ? false : parsedUrl.host === websocket._originalHostOrSocketPath;
				if (!isSameHost || websocket._originalSecure && !isSecure) {
					delete opts.headers.authorization;
					delete opts.headers.cookie;
					if (!isSameHost) delete opts.headers.host;
					opts.auth = void 0;
				}
			}
			if (opts.auth && !options.headers.authorization) options.headers.authorization = "Basic " + Buffer.from(opts.auth).toString("base64");
			req = websocket._req = request(opts);
			if (websocket._redirects) websocket.emit("redirect", websocket.url, req);
		} else req = websocket._req = request(opts);
		if (opts.timeout) req.on("timeout", () => {
			abortHandshake(websocket, req, "Opening handshake has timed out");
		});
		req.on("error", (err$1) => {
			if (req === null || req[kAborted]) return;
			req = websocket._req = null;
			emitErrorAndClose(websocket, err$1);
		});
		req.on("response", (res) => {
			const location = res.headers.location;
			const statusCode = res.statusCode;
			if (location && opts.followRedirects && statusCode >= 300 && statusCode < 400) {
				if (++websocket._redirects > opts.maxRedirects) {
					abortHandshake(websocket, req, "Maximum redirects exceeded");
					return;
				}
				req.abort();
				let addr;
				try {
					addr = new URL$1(location, address);
				} catch (e) {
					emitErrorAndClose(websocket, /* @__PURE__ */ new SyntaxError(`Invalid URL: ${location}`));
					return;
				}
				initAsClient(websocket, addr, protocols, options);
			} else if (!websocket.emit("unexpected-response", req, res)) abortHandshake(websocket, req, `Unexpected server response: ${res.statusCode}`);
		});
		req.on("upgrade", (res, socket, head) => {
			websocket.emit("upgrade", res);
			if (websocket.readyState !== WebSocket.CONNECTING) return;
			req = websocket._req = null;
			const upgrade = res.headers.upgrade;
			if (upgrade === void 0 || upgrade.toLowerCase() !== "websocket") {
				abortHandshake(websocket, socket, "Invalid Upgrade header");
				return;
			}
			const digest = createHash$1("sha1").update(key + GUID).digest("base64");
			if (res.headers["sec-websocket-accept"] !== digest) {
				abortHandshake(websocket, socket, "Invalid Sec-WebSocket-Accept header");
				return;
			}
			const serverProt = res.headers["sec-websocket-protocol"];
			let protError;
			if (serverProt !== void 0) {
				if (!protocolSet.size) protError = "Server sent a subprotocol but none was requested";
				else if (!protocolSet.has(serverProt)) protError = "Server sent an invalid subprotocol";
			} else if (protocolSet.size) protError = "Server sent no subprotocol";
			if (protError) {
				abortHandshake(websocket, socket, protError);
				return;
			}
			if (serverProt) websocket._protocol = serverProt;
			const secWebSocketExtensions = res.headers["sec-websocket-extensions"];
			if (secWebSocketExtensions !== void 0) {
				if (!perMessageDeflate) {
					abortHandshake(websocket, socket, "Server sent a Sec-WebSocket-Extensions header but no extension was requested");
					return;
				}
				let extensions;
				try {
					extensions = parse(secWebSocketExtensions);
				} catch (err$1) {
					abortHandshake(websocket, socket, "Invalid Sec-WebSocket-Extensions header");
					return;
				}
				const extensionNames = Object.keys(extensions);
				if (extensionNames.length !== 1 || extensionNames[0] !== PerMessageDeflate.extensionName) {
					abortHandshake(websocket, socket, "Server indicated an extension that was not requested");
					return;
				}
				try {
					perMessageDeflate.accept(extensions[PerMessageDeflate.extensionName]);
				} catch (err$1) {
					abortHandshake(websocket, socket, "Invalid Sec-WebSocket-Extensions header");
					return;
				}
				websocket._extensions[PerMessageDeflate.extensionName] = perMessageDeflate;
			}
			websocket.setSocket(socket, head, {
				allowSynchronousEvents: opts.allowSynchronousEvents,
				generateMask: opts.generateMask,
				maxPayload: opts.maxPayload,
				skipUTF8Validation: opts.skipUTF8Validation
			});
		});
		if (opts.finishRequest) opts.finishRequest(req, websocket);
		else req.end();
	}
	/**
	* Emit the `'error'` and `'close'` events.
	*
	* @param {WebSocket} websocket The WebSocket instance
	* @param {Error} The error to emit
	* @private
	*/
	function emitErrorAndClose(websocket, err$1) {
		websocket._readyState = WebSocket.CLOSING;
		websocket._errorEmitted = true;
		websocket.emit("error", err$1);
		websocket.emitClose();
	}
	/**
	* Create a `net.Socket` and initiate a connection.
	*
	* @param {Object} options Connection options
	* @return {net.Socket} The newly created socket used to start the connection
	* @private
	*/
	function netConnect(options) {
		options.path = options.socketPath;
		return net$2.connect(options);
	}
	/**
	* Create a `tls.TLSSocket` and initiate a connection.
	*
	* @param {Object} options Connection options
	* @return {tls.TLSSocket} The newly created socket used to start the connection
	* @private
	*/
	function tlsConnect(options) {
		options.path = void 0;
		if (!options.servername && options.servername !== "") options.servername = net$2.isIP(options.host) ? "" : options.host;
		return tls.connect(options);
	}
	/**
	* Abort the handshake and emit an error.
	*
	* @param {WebSocket} websocket The WebSocket instance
	* @param {(http.ClientRequest|net.Socket|tls.Socket)} stream The request to
	*     abort or the socket to destroy
	* @param {String} message The error message
	* @private
	*/
	function abortHandshake(websocket, stream, message) {
		websocket._readyState = WebSocket.CLOSING;
		const err$1 = new Error(message);
		Error.captureStackTrace(err$1, abortHandshake);
		if (stream.setHeader) {
			stream[kAborted] = true;
			stream.abort();
			if (stream.socket && !stream.socket.destroyed) stream.socket.destroy();
			process.nextTick(emitErrorAndClose, websocket, err$1);
		} else {
			stream.destroy(err$1);
			stream.once("error", websocket.emit.bind(websocket, "error"));
			stream.once("close", websocket.emitClose.bind(websocket));
		}
	}
	/**
	* Handle cases where the `ping()`, `pong()`, or `send()` methods are called
	* when the `readyState` attribute is `CLOSING` or `CLOSED`.
	*
	* @param {WebSocket} websocket The WebSocket instance
	* @param {*} [data] The data to send
	* @param {Function} [cb] Callback
	* @private
	*/
	function sendAfterClose(websocket, data, cb) {
		if (data) {
			const length = isBlob(data) ? data.size : toBuffer(data).length;
			if (websocket._socket) websocket._sender._bufferedBytes += length;
			else websocket._bufferedAmount += length;
		}
		if (cb) {
			const err$1 = /* @__PURE__ */ new Error(`WebSocket is not open: readyState ${websocket.readyState} (${readyStates[websocket.readyState]})`);
			process.nextTick(cb, err$1);
		}
	}
	/**
	* The listener of the `Receiver` `'conclude'` event.
	*
	* @param {Number} code The status code
	* @param {Buffer} reason The reason for closing
	* @private
	*/
	function receiverOnConclude(code, reason) {
		const websocket = this[kWebSocket];
		websocket._closeFrameReceived = true;
		websocket._closeMessage = reason;
		websocket._closeCode = code;
		if (websocket._socket[kWebSocket] === void 0) return;
		websocket._socket.removeListener("data", socketOnData);
		process.nextTick(resume, websocket._socket);
		if (code === 1005) websocket.close();
		else websocket.close(code, reason);
	}
	/**
	* The listener of the `Receiver` `'drain'` event.
	*
	* @private
	*/
	function receiverOnDrain() {
		const websocket = this[kWebSocket];
		if (!websocket.isPaused) websocket._socket.resume();
	}
	/**
	* The listener of the `Receiver` `'error'` event.
	*
	* @param {(RangeError|Error)} err The emitted error
	* @private
	*/
	function receiverOnError(err$1) {
		const websocket = this[kWebSocket];
		if (websocket._socket[kWebSocket] !== void 0) {
			websocket._socket.removeListener("data", socketOnData);
			process.nextTick(resume, websocket._socket);
			websocket.close(err$1[kStatusCode]);
		}
		if (!websocket._errorEmitted) {
			websocket._errorEmitted = true;
			websocket.emit("error", err$1);
		}
	}
	/**
	* The listener of the `Receiver` `'finish'` event.
	*
	* @private
	*/
	function receiverOnFinish() {
		this[kWebSocket].emitClose();
	}
	/**
	* The listener of the `Receiver` `'message'` event.
	*
	* @param {Buffer|ArrayBuffer|Buffer[])} data The message
	* @param {Boolean} isBinary Specifies whether the message is binary or not
	* @private
	*/
	function receiverOnMessage(data, isBinary) {
		this[kWebSocket].emit("message", data, isBinary);
	}
	/**
	* The listener of the `Receiver` `'ping'` event.
	*
	* @param {Buffer} data The data included in the ping frame
	* @private
	*/
	function receiverOnPing(data) {
		const websocket = this[kWebSocket];
		if (websocket._autoPong) websocket.pong(data, !this._isServer, NOOP);
		websocket.emit("ping", data);
	}
	/**
	* The listener of the `Receiver` `'pong'` event.
	*
	* @param {Buffer} data The data included in the pong frame
	* @private
	*/
	function receiverOnPong(data) {
		this[kWebSocket].emit("pong", data);
	}
	/**
	* Resume a readable stream
	*
	* @param {Readable} stream The readable stream
	* @private
	*/
	function resume(stream) {
		stream.resume();
	}
	/**
	* The `Sender` error event handler.
	*
	* @param {Error} The error
	* @private
	*/
	function senderOnError(err$1) {
		const websocket = this[kWebSocket];
		if (websocket.readyState === WebSocket.CLOSED) return;
		if (websocket.readyState === WebSocket.OPEN) {
			websocket._readyState = WebSocket.CLOSING;
			setCloseTimer(websocket);
		}
		this._socket.end();
		if (!websocket._errorEmitted) {
			websocket._errorEmitted = true;
			websocket.emit("error", err$1);
		}
	}
	/**
	* Set a timer to destroy the underlying raw socket of a WebSocket.
	*
	* @param {WebSocket} websocket The WebSocket instance
	* @private
	*/
	function setCloseTimer(websocket) {
		websocket._closeTimer = setTimeout(websocket._socket.destroy.bind(websocket._socket), closeTimeout);
	}
	/**
	* The listener of the socket `'close'` event.
	*
	* @private
	*/
	function socketOnClose() {
		const websocket = this[kWebSocket];
		this.removeListener("close", socketOnClose);
		this.removeListener("data", socketOnData);
		this.removeListener("end", socketOnEnd);
		websocket._readyState = WebSocket.CLOSING;
		let chunk;
		if (!this._readableState.endEmitted && !websocket._closeFrameReceived && !websocket._receiver._writableState.errorEmitted && (chunk = websocket._socket.read()) !== null) websocket._receiver.write(chunk);
		websocket._receiver.end();
		this[kWebSocket] = void 0;
		clearTimeout(websocket._closeTimer);
		if (websocket._receiver._writableState.finished || websocket._receiver._writableState.errorEmitted) websocket.emitClose();
		else {
			websocket._receiver.on("error", receiverOnFinish);
			websocket._receiver.on("finish", receiverOnFinish);
		}
	}
	/**
	* The listener of the socket `'data'` event.
	*
	* @param {Buffer} chunk A chunk of data
	* @private
	*/
	function socketOnData(chunk) {
		if (!this[kWebSocket]._receiver.write(chunk)) this.pause();
	}
	/**
	* The listener of the socket `'end'` event.
	*
	* @private
	*/
	function socketOnEnd() {
		const websocket = this[kWebSocket];
		websocket._readyState = WebSocket.CLOSING;
		websocket._receiver.end();
		this.end();
	}
	/**
	* The listener of the socket `'error'` event.
	*
	* @private
	*/
	function socketOnError() {
		const websocket = this[kWebSocket];
		this.removeListener("error", socketOnError);
		this.on("error", NOOP);
		if (websocket) {
			websocket._readyState = WebSocket.CLOSING;
			this.destroy();
		}
	}
}));

//#endregion
//#region ../node_modules/.pnpm/ws@8.18.3_bufferutil@4.0.8_utf-8-validate@6.0.3/node_modules/ws/lib/stream.js
var require_stream = /* @__PURE__ */ require_chunk.__commonJSMin(((exports, module) => {
	require_websocket();
	const { Duplex: Duplex$1 } = require("stream");
	/**
	* Emits the `'close'` event on a stream.
	*
	* @param {Duplex} stream The stream.
	* @private
	*/
	function emitClose(stream) {
		stream.emit("close");
	}
	/**
	* The listener of the `'end'` event.
	*
	* @private
	*/
	function duplexOnEnd() {
		if (!this.destroyed && this._writableState.finished) this.destroy();
	}
	/**
	* The listener of the `'error'` event.
	*
	* @param {Error} err The error
	* @private
	*/
	function duplexOnError(err$1) {
		this.removeListener("error", duplexOnError);
		this.destroy();
		if (this.listenerCount("error") === 0) this.emit("error", err$1);
	}
	/**
	* Wraps a `WebSocket` in a duplex stream.
	*
	* @param {WebSocket} ws The `WebSocket` to wrap
	* @param {Object} [options] The options for the `Duplex` constructor
	* @return {Duplex} The duplex stream
	* @public
	*/
	function createWebSocketStream(ws, options) {
		let terminateOnDestroy = true;
		const duplex = new Duplex$1({
			...options,
			autoDestroy: false,
			emitClose: false,
			objectMode: false,
			writableObjectMode: false
		});
		ws.on("message", function message(msg, isBinary) {
			const data = !isBinary && duplex._readableState.objectMode ? msg.toString() : msg;
			if (!duplex.push(data)) ws.pause();
		});
		ws.once("error", function error(err$1) {
			if (duplex.destroyed) return;
			terminateOnDestroy = false;
			duplex.destroy(err$1);
		});
		ws.once("close", function close() {
			if (duplex.destroyed) return;
			duplex.push(null);
		});
		duplex._destroy = function(err$1, callback) {
			if (ws.readyState === ws.CLOSED) {
				callback(err$1);
				process.nextTick(emitClose, duplex);
				return;
			}
			let called = false;
			ws.once("error", function error(err$2) {
				called = true;
				callback(err$2);
			});
			ws.once("close", function close() {
				if (!called) callback(err$1);
				process.nextTick(emitClose, duplex);
			});
			if (terminateOnDestroy) ws.terminate();
		};
		duplex._final = function(callback) {
			if (ws.readyState === ws.CONNECTING) {
				ws.once("open", function open() {
					duplex._final(callback);
				});
				return;
			}
			if (ws._socket === null) return;
			if (ws._socket._writableState.finished) {
				callback();
				if (duplex._readableState.endEmitted) duplex.destroy();
			} else {
				ws._socket.once("finish", function finish() {
					callback();
				});
				ws.close();
			}
		};
		duplex._read = function() {
			if (ws.isPaused) ws.resume();
		};
		duplex._write = function(chunk, encoding, callback) {
			if (ws.readyState === ws.CONNECTING) {
				ws.once("open", function open() {
					duplex._write(chunk, encoding, callback);
				});
				return;
			}
			ws.send(chunk, callback);
		};
		duplex.on("end", duplexOnEnd);
		duplex.on("error", duplexOnError);
		return duplex;
	}
	module.exports = createWebSocketStream;
}));

//#endregion
//#region ../node_modules/.pnpm/ws@8.18.3_bufferutil@4.0.8_utf-8-validate@6.0.3/node_modules/ws/lib/subprotocol.js
var require_subprotocol = /* @__PURE__ */ require_chunk.__commonJSMin(((exports, module) => {
	const { tokenChars } = require_validation();
	/**
	* Parses the `Sec-WebSocket-Protocol` header into a set of subprotocol names.
	*
	* @param {String} header The field value of the header
	* @return {Set} The subprotocol names
	* @public
	*/
	function parse(header) {
		const protocols = /* @__PURE__ */ new Set();
		let start = -1;
		let end = -1;
		let i = 0;
		for (; i < header.length; i++) {
			const code = header.charCodeAt(i);
			if (end === -1 && tokenChars[code] === 1) {
				if (start === -1) start = i;
			} else if (i !== 0 && (code === 32 || code === 9)) {
				if (end === -1 && start !== -1) end = i;
			} else if (code === 44) {
				if (start === -1) throw new SyntaxError(`Unexpected character at index ${i}`);
				if (end === -1) end = i;
				const protocol$1 = header.slice(start, end);
				if (protocols.has(protocol$1)) throw new SyntaxError(`The "${protocol$1}" subprotocol is duplicated`);
				protocols.add(protocol$1);
				start = end = -1;
			} else throw new SyntaxError(`Unexpected character at index ${i}`);
		}
		if (start === -1 || end !== -1) throw new SyntaxError("Unexpected end of input");
		const protocol = header.slice(start, i);
		if (protocols.has(protocol)) throw new SyntaxError(`The "${protocol}" subprotocol is duplicated`);
		protocols.add(protocol);
		return protocols;
	}
	module.exports = { parse };
}));

//#endregion
//#region ../node_modules/.pnpm/ws@8.18.3_bufferutil@4.0.8_utf-8-validate@6.0.3/node_modules/ws/lib/websocket-server.js
var require_websocket_server = /* @__PURE__ */ require_chunk.__commonJSMin(((exports, module) => {
	const EventEmitter = require("events");
	const http = require("http");
	const { Duplex } = require("stream");
	const { createHash } = require("crypto");
	const extension = require_extension();
	const PerMessageDeflate = require_permessage_deflate();
	const subprotocol = require_subprotocol();
	const WebSocket = require_websocket();
	const { GUID, kWebSocket } = require_constants$1();
	const keyRegex = /^[+/0-9A-Za-z]{22}==$/;
	const RUNNING = 0;
	const CLOSING = 1;
	const CLOSED = 2;
	/**
	* Class representing a WebSocket server.
	*
	* @extends EventEmitter
	*/
	var WebSocketServer = class extends EventEmitter {
		/**
		* Create a `WebSocketServer` instance.
		*
		* @param {Object} options Configuration options
		* @param {Boolean} [options.allowSynchronousEvents=true] Specifies whether
		*     any of the `'message'`, `'ping'`, and `'pong'` events can be emitted
		*     multiple times in the same tick
		* @param {Boolean} [options.autoPong=true] Specifies whether or not to
		*     automatically send a pong in response to a ping
		* @param {Number} [options.backlog=511] The maximum length of the queue of
		*     pending connections
		* @param {Boolean} [options.clientTracking=true] Specifies whether or not to
		*     track clients
		* @param {Function} [options.handleProtocols] A hook to handle protocols
		* @param {String} [options.host] The hostname where to bind the server
		* @param {Number} [options.maxPayload=104857600] The maximum allowed message
		*     size
		* @param {Boolean} [options.noServer=false] Enable no server mode
		* @param {String} [options.path] Accept only connections matching this path
		* @param {(Boolean|Object)} [options.perMessageDeflate=false] Enable/disable
		*     permessage-deflate
		* @param {Number} [options.port] The port where to bind the server
		* @param {(http.Server|https.Server)} [options.server] A pre-created HTTP/S
		*     server to use
		* @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
		*     not to skip UTF-8 validation for text and close messages
		* @param {Function} [options.verifyClient] A hook to reject connections
		* @param {Function} [options.WebSocket=WebSocket] Specifies the `WebSocket`
		*     class to use. It must be the `WebSocket` class or class that extends it
		* @param {Function} [callback] A listener for the `listening` event
		*/
		constructor(options, callback) {
			super();
			options = {
				allowSynchronousEvents: true,
				autoPong: true,
				maxPayload: 100 * 1024 * 1024,
				skipUTF8Validation: false,
				perMessageDeflate: false,
				handleProtocols: null,
				clientTracking: true,
				verifyClient: null,
				noServer: false,
				backlog: null,
				server: null,
				host: null,
				path: null,
				port: null,
				WebSocket,
				...options
			};
			if (options.port == null && !options.server && !options.noServer || options.port != null && (options.server || options.noServer) || options.server && options.noServer) throw new TypeError("One and only one of the \"port\", \"server\", or \"noServer\" options must be specified");
			if (options.port != null) {
				this._server = http.createServer((req, res) => {
					const body = http.STATUS_CODES[426];
					res.writeHead(426, {
						"Content-Length": body.length,
						"Content-Type": "text/plain"
					});
					res.end(body);
				});
				this._server.listen(options.port, options.host, options.backlog, callback);
			} else if (options.server) this._server = options.server;
			if (this._server) {
				const emitConnection = this.emit.bind(this, "connection");
				this._removeListeners = addListeners(this._server, {
					listening: this.emit.bind(this, "listening"),
					error: this.emit.bind(this, "error"),
					upgrade: (req, socket, head) => {
						this.handleUpgrade(req, socket, head, emitConnection);
					}
				});
			}
			if (options.perMessageDeflate === true) options.perMessageDeflate = {};
			if (options.clientTracking) {
				this.clients = /* @__PURE__ */ new Set();
				this._shouldEmitClose = false;
			}
			this.options = options;
			this._state = RUNNING;
		}
		/**
		* Returns the bound address, the address family name, and port of the server
		* as reported by the operating system if listening on an IP socket.
		* If the server is listening on a pipe or UNIX domain socket, the name is
		* returned as a string.
		*
		* @return {(Object|String|null)} The address of the server
		* @public
		*/
		address() {
			if (this.options.noServer) throw new Error("The server is operating in \"noServer\" mode");
			if (!this._server) return null;
			return this._server.address();
		}
		/**
		* Stop the server from accepting new connections and emit the `'close'` event
		* when all existing connections are closed.
		*
		* @param {Function} [cb] A one-time listener for the `'close'` event
		* @public
		*/
		close(cb) {
			if (this._state === CLOSED) {
				if (cb) this.once("close", () => {
					cb(/* @__PURE__ */ new Error("The server is not running"));
				});
				process.nextTick(emitClose, this);
				return;
			}
			if (cb) this.once("close", cb);
			if (this._state === CLOSING) return;
			this._state = CLOSING;
			if (this.options.noServer || this.options.server) {
				if (this._server) {
					this._removeListeners();
					this._removeListeners = this._server = null;
				}
				if (this.clients) if (!this.clients.size) process.nextTick(emitClose, this);
				else this._shouldEmitClose = true;
				else process.nextTick(emitClose, this);
			} else {
				const server = this._server;
				this._removeListeners();
				this._removeListeners = this._server = null;
				server.close(() => {
					emitClose(this);
				});
			}
		}
		/**
		* See if a given request should be handled by this server instance.
		*
		* @param {http.IncomingMessage} req Request object to inspect
		* @return {Boolean} `true` if the request is valid, else `false`
		* @public
		*/
		shouldHandle(req) {
			if (this.options.path) {
				const index = req.url.indexOf("?");
				if ((index !== -1 ? req.url.slice(0, index) : req.url) !== this.options.path) return false;
			}
			return true;
		}
		/**
		* Handle a HTTP Upgrade request.
		*
		* @param {http.IncomingMessage} req The request object
		* @param {Duplex} socket The network socket between the server and client
		* @param {Buffer} head The first packet of the upgraded stream
		* @param {Function} cb Callback
		* @public
		*/
		handleUpgrade(req, socket, head, cb) {
			socket.on("error", socketOnError);
			const key = req.headers["sec-websocket-key"];
			const upgrade = req.headers.upgrade;
			const version = +req.headers["sec-websocket-version"];
			if (req.method !== "GET") {
				abortHandshakeOrEmitwsClientError(this, req, socket, 405, "Invalid HTTP method");
				return;
			}
			if (upgrade === void 0 || upgrade.toLowerCase() !== "websocket") {
				abortHandshakeOrEmitwsClientError(this, req, socket, 400, "Invalid Upgrade header");
				return;
			}
			if (key === void 0 || !keyRegex.test(key)) {
				abortHandshakeOrEmitwsClientError(this, req, socket, 400, "Missing or invalid Sec-WebSocket-Key header");
				return;
			}
			if (version !== 13 && version !== 8) {
				abortHandshakeOrEmitwsClientError(this, req, socket, 400, "Missing or invalid Sec-WebSocket-Version header", { "Sec-WebSocket-Version": "13, 8" });
				return;
			}
			if (!this.shouldHandle(req)) {
				abortHandshake(socket, 400);
				return;
			}
			const secWebSocketProtocol = req.headers["sec-websocket-protocol"];
			let protocols = /* @__PURE__ */ new Set();
			if (secWebSocketProtocol !== void 0) try {
				protocols = subprotocol.parse(secWebSocketProtocol);
			} catch (err$1) {
				abortHandshakeOrEmitwsClientError(this, req, socket, 400, "Invalid Sec-WebSocket-Protocol header");
				return;
			}
			const secWebSocketExtensions = req.headers["sec-websocket-extensions"];
			const extensions = {};
			if (this.options.perMessageDeflate && secWebSocketExtensions !== void 0) {
				const perMessageDeflate = new PerMessageDeflate(this.options.perMessageDeflate, true, this.options.maxPayload);
				try {
					const offers = extension.parse(secWebSocketExtensions);
					if (offers[PerMessageDeflate.extensionName]) {
						perMessageDeflate.accept(offers[PerMessageDeflate.extensionName]);
						extensions[PerMessageDeflate.extensionName] = perMessageDeflate;
					}
				} catch (err$1) {
					abortHandshakeOrEmitwsClientError(this, req, socket, 400, "Invalid or unacceptable Sec-WebSocket-Extensions header");
					return;
				}
			}
			if (this.options.verifyClient) {
				const info = {
					origin: req.headers[`${version === 8 ? "sec-websocket-origin" : "origin"}`],
					secure: !!(req.socket.authorized || req.socket.encrypted),
					req
				};
				if (this.options.verifyClient.length === 2) {
					this.options.verifyClient(info, (verified, code, message, headers) => {
						if (!verified) return abortHandshake(socket, code || 401, message, headers);
						this.completeUpgrade(extensions, key, protocols, req, socket, head, cb);
					});
					return;
				}
				if (!this.options.verifyClient(info)) return abortHandshake(socket, 401);
			}
			this.completeUpgrade(extensions, key, protocols, req, socket, head, cb);
		}
		/**
		* Upgrade the connection to WebSocket.
		*
		* @param {Object} extensions The accepted extensions
		* @param {String} key The value of the `Sec-WebSocket-Key` header
		* @param {Set} protocols The subprotocols
		* @param {http.IncomingMessage} req The request object
		* @param {Duplex} socket The network socket between the server and client
		* @param {Buffer} head The first packet of the upgraded stream
		* @param {Function} cb Callback
		* @throws {Error} If called more than once with the same socket
		* @private
		*/
		completeUpgrade(extensions, key, protocols, req, socket, head, cb) {
			if (!socket.readable || !socket.writable) return socket.destroy();
			if (socket[kWebSocket]) throw new Error("server.handleUpgrade() was called more than once with the same socket, possibly due to a misconfiguration");
			if (this._state > RUNNING) return abortHandshake(socket, 503);
			const headers = [
				"HTTP/1.1 101 Switching Protocols",
				"Upgrade: websocket",
				"Connection: Upgrade",
				`Sec-WebSocket-Accept: ${createHash("sha1").update(key + GUID).digest("base64")}`
			];
			const ws = new this.options.WebSocket(null, void 0, this.options);
			if (protocols.size) {
				const protocol = this.options.handleProtocols ? this.options.handleProtocols(protocols, req) : protocols.values().next().value;
				if (protocol) {
					headers.push(`Sec-WebSocket-Protocol: ${protocol}`);
					ws._protocol = protocol;
				}
			}
			if (extensions[PerMessageDeflate.extensionName]) {
				const params = extensions[PerMessageDeflate.extensionName].params;
				const value = extension.format({ [PerMessageDeflate.extensionName]: [params] });
				headers.push(`Sec-WebSocket-Extensions: ${value}`);
				ws._extensions = extensions;
			}
			this.emit("headers", headers, req);
			socket.write(headers.concat("\r\n").join("\r\n"));
			socket.removeListener("error", socketOnError);
			ws.setSocket(socket, head, {
				allowSynchronousEvents: this.options.allowSynchronousEvents,
				maxPayload: this.options.maxPayload,
				skipUTF8Validation: this.options.skipUTF8Validation
			});
			if (this.clients) {
				this.clients.add(ws);
				ws.on("close", () => {
					this.clients.delete(ws);
					if (this._shouldEmitClose && !this.clients.size) process.nextTick(emitClose, this);
				});
			}
			cb(ws, req);
		}
	};
	module.exports = WebSocketServer;
	/**
	* Add event listeners on an `EventEmitter` using a map of <event, listener>
	* pairs.
	*
	* @param {EventEmitter} server The event emitter
	* @param {Object.<String, Function>} map The listeners to add
	* @return {Function} A function that will remove the added listeners when
	*     called
	* @private
	*/
	function addListeners(server, map) {
		for (const event of Object.keys(map)) server.on(event, map[event]);
		return function removeListeners() {
			for (const event of Object.keys(map)) server.removeListener(event, map[event]);
		};
	}
	/**
	* Emit a `'close'` event on an `EventEmitter`.
	*
	* @param {EventEmitter} server The event emitter
	* @private
	*/
	function emitClose(server) {
		server._state = CLOSED;
		server.emit("close");
	}
	/**
	* Handle socket errors.
	*
	* @private
	*/
	function socketOnError() {
		this.destroy();
	}
	/**
	* Close the connection when preconditions are not fulfilled.
	*
	* @param {Duplex} socket The socket of the upgrade request
	* @param {Number} code The HTTP response status code
	* @param {String} [message] The HTTP response body
	* @param {Object} [headers] Additional HTTP response headers
	* @private
	*/
	function abortHandshake(socket, code, message, headers) {
		message = message || http.STATUS_CODES[code];
		headers = {
			Connection: "close",
			"Content-Type": "text/html",
			"Content-Length": Buffer.byteLength(message),
			...headers
		};
		socket.once("finish", socket.destroy);
		socket.end(`HTTP/1.1 ${code} ${http.STATUS_CODES[code]}\r\n` + Object.keys(headers).map((h) => `${h}: ${headers[h]}`).join("\r\n") + "\r\n\r\n" + message);
	}
	/**
	* Emit a `'wsClientError'` event on a `WebSocketServer` if there is at least
	* one listener for it, otherwise call `abortHandshake()`.
	*
	* @param {WebSocketServer} server The WebSocket server
	* @param {http.IncomingMessage} req The request object
	* @param {Duplex} socket The socket of the upgrade request
	* @param {Number} code The HTTP response status code
	* @param {String} message The HTTP response body
	* @param {Object} [headers] The HTTP response headers
	* @private
	*/
	function abortHandshakeOrEmitwsClientError(server, req, socket, code, message, headers) {
		if (server.listenerCount("wsClientError")) {
			const err$1 = new Error(message);
			Error.captureStackTrace(err$1, abortHandshakeOrEmitwsClientError);
			server.emit("wsClientError", err$1, socket, req);
		} else abortHandshake(socket, code, message, headers);
	}
}));

//#endregion
//#region ../node_modules/.pnpm/ws@8.18.3_bufferutil@4.0.8_utf-8-validate@6.0.3/node_modules/ws/wrapper.mjs
var import_stream = /* @__PURE__ */ require_chunk.__toESM(require_stream(), 1);
var import_receiver = /* @__PURE__ */ require_chunk.__toESM(require_receiver(), 1);
var import_sender = /* @__PURE__ */ require_chunk.__toESM(require_sender(), 1);
var import_websocket = /* @__PURE__ */ require_chunk.__toESM(require_websocket(), 1);
var import_websocket_server = /* @__PURE__ */ require_chunk.__toESM(require_websocket_server(), 1);
var wrapper_default = import_websocket.default;

//#endregion
//#region ../node_modules/.pnpm/semver@7.7.3/node_modules/semver/internal/constants.js
var require_constants = /* @__PURE__ */ require_chunk.__commonJSMin(((exports, module) => {
	const SEMVER_SPEC_VERSION = "2.0.0";
	const MAX_LENGTH = 256;
	const MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;
	const MAX_SAFE_COMPONENT_LENGTH = 16;
	const MAX_SAFE_BUILD_LENGTH = MAX_LENGTH - 6;
	const RELEASE_TYPES = [
		"major",
		"premajor",
		"minor",
		"preminor",
		"patch",
		"prepatch",
		"prerelease"
	];
	module.exports = {
		MAX_LENGTH,
		MAX_SAFE_COMPONENT_LENGTH,
		MAX_SAFE_BUILD_LENGTH,
		MAX_SAFE_INTEGER,
		RELEASE_TYPES,
		SEMVER_SPEC_VERSION,
		FLAG_INCLUDE_PRERELEASE: 1,
		FLAG_LOOSE: 2
	};
}));

//#endregion
//#region ../node_modules/.pnpm/semver@7.7.3/node_modules/semver/internal/debug.js
var require_debug = /* @__PURE__ */ require_chunk.__commonJSMin(((exports, module) => {
	const debug = typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...args) => console.error("SEMVER", ...args) : () => {};
	module.exports = debug;
}));

//#endregion
//#region ../node_modules/.pnpm/semver@7.7.3/node_modules/semver/internal/re.js
var require_re = /* @__PURE__ */ require_chunk.__commonJSMin(((exports, module) => {
	const { MAX_SAFE_COMPONENT_LENGTH, MAX_SAFE_BUILD_LENGTH, MAX_LENGTH } = require_constants();
	const debug = require_debug();
	exports = module.exports = {};
	const re = exports.re = [];
	const safeRe = exports.safeRe = [];
	const src = exports.src = [];
	const safeSrc = exports.safeSrc = [];
	const t = exports.t = {};
	let R = 0;
	const LETTERDASHNUMBER = "[a-zA-Z0-9-]";
	const safeRegexReplacements = [
		["\\s", 1],
		["\\d", MAX_LENGTH],
		[LETTERDASHNUMBER, MAX_SAFE_BUILD_LENGTH]
	];
	const makeSafeRegex = (value) => {
		for (const [token, max] of safeRegexReplacements) value = value.split(`${token}*`).join(`${token}{0,${max}}`).split(`${token}+`).join(`${token}{1,${max}}`);
		return value;
	};
	const createToken = (name, value, isGlobal) => {
		const safe = makeSafeRegex(value);
		const index = R++;
		debug(name, index, value);
		t[name] = index;
		src[index] = value;
		safeSrc[index] = safe;
		re[index] = new RegExp(value, isGlobal ? "g" : void 0);
		safeRe[index] = new RegExp(safe, isGlobal ? "g" : void 0);
	};
	createToken("NUMERICIDENTIFIER", "0|[1-9]\\d*");
	createToken("NUMERICIDENTIFIERLOOSE", "\\d+");
	createToken("NONNUMERICIDENTIFIER", `\\d*[a-zA-Z-]${LETTERDASHNUMBER}*`);
	createToken("MAINVERSION", `(${src[t.NUMERICIDENTIFIER]})\\.(${src[t.NUMERICIDENTIFIER]})\\.(${src[t.NUMERICIDENTIFIER]})`);
	createToken("MAINVERSIONLOOSE", `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.(${src[t.NUMERICIDENTIFIERLOOSE]})\\.(${src[t.NUMERICIDENTIFIERLOOSE]})`);
	createToken("PRERELEASEIDENTIFIER", `(?:${src[t.NONNUMERICIDENTIFIER]}|${src[t.NUMERICIDENTIFIER]})`);
	createToken("PRERELEASEIDENTIFIERLOOSE", `(?:${src[t.NONNUMERICIDENTIFIER]}|${src[t.NUMERICIDENTIFIERLOOSE]})`);
	createToken("PRERELEASE", `(?:-(${src[t.PRERELEASEIDENTIFIER]}(?:\\.${src[t.PRERELEASEIDENTIFIER]})*))`);
	createToken("PRERELEASELOOSE", `(?:-?(${src[t.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${src[t.PRERELEASEIDENTIFIERLOOSE]})*))`);
	createToken("BUILDIDENTIFIER", `${LETTERDASHNUMBER}+`);
	createToken("BUILD", `(?:\\+(${src[t.BUILDIDENTIFIER]}(?:\\.${src[t.BUILDIDENTIFIER]})*))`);
	createToken("FULLPLAIN", `v?${src[t.MAINVERSION]}${src[t.PRERELEASE]}?${src[t.BUILD]}?`);
	createToken("FULL", `^${src[t.FULLPLAIN]}$`);
	createToken("LOOSEPLAIN", `[v=\\s]*${src[t.MAINVERSIONLOOSE]}${src[t.PRERELEASELOOSE]}?${src[t.BUILD]}?`);
	createToken("LOOSE", `^${src[t.LOOSEPLAIN]}$`);
	createToken("GTLT", "((?:<|>)?=?)");
	createToken("XRANGEIDENTIFIERLOOSE", `${src[t.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`);
	createToken("XRANGEIDENTIFIER", `${src[t.NUMERICIDENTIFIER]}|x|X|\\*`);
	createToken("XRANGEPLAIN", `[v=\\s]*(${src[t.XRANGEIDENTIFIER]})(?:\\.(${src[t.XRANGEIDENTIFIER]})(?:\\.(${src[t.XRANGEIDENTIFIER]})(?:${src[t.PRERELEASE]})?${src[t.BUILD]}?)?)?`);
	createToken("XRANGEPLAINLOOSE", `[v=\\s]*(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:${src[t.PRERELEASELOOSE]})?${src[t.BUILD]}?)?)?`);
	createToken("XRANGE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAIN]}$`);
	createToken("XRANGELOOSE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAINLOOSE]}$`);
	createToken("COERCEPLAIN", `(^|[^\\d])(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}})(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?`);
	createToken("COERCE", `${src[t.COERCEPLAIN]}(?:$|[^\\d])`);
	createToken("COERCEFULL", src[t.COERCEPLAIN] + `(?:${src[t.PRERELEASE]})?(?:${src[t.BUILD]})?(?:$|[^\\d])`);
	createToken("COERCERTL", src[t.COERCE], true);
	createToken("COERCERTLFULL", src[t.COERCEFULL], true);
	createToken("LONETILDE", "(?:~>?)");
	createToken("TILDETRIM", `(\\s*)${src[t.LONETILDE]}\\s+`, true);
	exports.tildeTrimReplace = "$1~";
	createToken("TILDE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAIN]}$`);
	createToken("TILDELOOSE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAINLOOSE]}$`);
	createToken("LONECARET", "(?:\\^)");
	createToken("CARETTRIM", `(\\s*)${src[t.LONECARET]}\\s+`, true);
	exports.caretTrimReplace = "$1^";
	createToken("CARET", `^${src[t.LONECARET]}${src[t.XRANGEPLAIN]}$`);
	createToken("CARETLOOSE", `^${src[t.LONECARET]}${src[t.XRANGEPLAINLOOSE]}$`);
	createToken("COMPARATORLOOSE", `^${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]})$|^$`);
	createToken("COMPARATOR", `^${src[t.GTLT]}\\s*(${src[t.FULLPLAIN]})$|^$`);
	createToken("COMPARATORTRIM", `(\\s*)${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]}|${src[t.XRANGEPLAIN]})`, true);
	exports.comparatorTrimReplace = "$1$2$3";
	createToken("HYPHENRANGE", `^\\s*(${src[t.XRANGEPLAIN]})\\s+-\\s+(${src[t.XRANGEPLAIN]})\\s*$`);
	createToken("HYPHENRANGELOOSE", `^\\s*(${src[t.XRANGEPLAINLOOSE]})\\s+-\\s+(${src[t.XRANGEPLAINLOOSE]})\\s*$`);
	createToken("STAR", "(<|>)?=?\\s*\\*");
	createToken("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$");
	createToken("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
}));

//#endregion
//#region ../node_modules/.pnpm/semver@7.7.3/node_modules/semver/internal/parse-options.js
var require_parse_options = /* @__PURE__ */ require_chunk.__commonJSMin(((exports, module) => {
	const looseOption = Object.freeze({ loose: true });
	const emptyOpts = Object.freeze({});
	const parseOptions = (options) => {
		if (!options) return emptyOpts;
		if (typeof options !== "object") return looseOption;
		return options;
	};
	module.exports = parseOptions;
}));

//#endregion
//#region ../node_modules/.pnpm/semver@7.7.3/node_modules/semver/internal/identifiers.js
var require_identifiers = /* @__PURE__ */ require_chunk.__commonJSMin(((exports, module) => {
	const numeric = /^[0-9]+$/;
	const compareIdentifiers = (a, b) => {
		if (typeof a === "number" && typeof b === "number") return a === b ? 0 : a < b ? -1 : 1;
		const anum = numeric.test(a);
		const bnum = numeric.test(b);
		if (anum && bnum) {
			a = +a;
			b = +b;
		}
		return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
	};
	const rcompareIdentifiers = (a, b) => compareIdentifiers(b, a);
	module.exports = {
		compareIdentifiers,
		rcompareIdentifiers
	};
}));

//#endregion
//#region ../node_modules/.pnpm/semver@7.7.3/node_modules/semver/classes/semver.js
var require_semver$1 = /* @__PURE__ */ require_chunk.__commonJSMin(((exports, module) => {
	const debug = require_debug();
	const { MAX_LENGTH, MAX_SAFE_INTEGER } = require_constants();
	const { safeRe: re, t } = require_re();
	const parseOptions = require_parse_options();
	const { compareIdentifiers } = require_identifiers();
	var SemVer = class SemVer {
		constructor(version, options) {
			options = parseOptions(options);
			if (version instanceof SemVer) if (version.loose === !!options.loose && version.includePrerelease === !!options.includePrerelease) return version;
			else version = version.version;
			else if (typeof version !== "string") throw new TypeError(`Invalid version. Must be a string. Got type "${typeof version}".`);
			if (version.length > MAX_LENGTH) throw new TypeError(`version is longer than ${MAX_LENGTH} characters`);
			debug("SemVer", version, options);
			this.options = options;
			this.loose = !!options.loose;
			this.includePrerelease = !!options.includePrerelease;
			const m = version.trim().match(options.loose ? re[t.LOOSE] : re[t.FULL]);
			if (!m) throw new TypeError(`Invalid Version: ${version}`);
			this.raw = version;
			this.major = +m[1];
			this.minor = +m[2];
			this.patch = +m[3];
			if (this.major > MAX_SAFE_INTEGER || this.major < 0) throw new TypeError("Invalid major version");
			if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) throw new TypeError("Invalid minor version");
			if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) throw new TypeError("Invalid patch version");
			if (!m[4]) this.prerelease = [];
			else this.prerelease = m[4].split(".").map((id) => {
				if (/^[0-9]+$/.test(id)) {
					const num = +id;
					if (num >= 0 && num < MAX_SAFE_INTEGER) return num;
				}
				return id;
			});
			this.build = m[5] ? m[5].split(".") : [];
			this.format();
		}
		format() {
			this.version = `${this.major}.${this.minor}.${this.patch}`;
			if (this.prerelease.length) this.version += `-${this.prerelease.join(".")}`;
			return this.version;
		}
		toString() {
			return this.version;
		}
		compare(other) {
			debug("SemVer.compare", this.version, this.options, other);
			if (!(other instanceof SemVer)) {
				if (typeof other === "string" && other === this.version) return 0;
				other = new SemVer(other, this.options);
			}
			if (other.version === this.version) return 0;
			return this.compareMain(other) || this.comparePre(other);
		}
		compareMain(other) {
			if (!(other instanceof SemVer)) other = new SemVer(other, this.options);
			if (this.major < other.major) return -1;
			if (this.major > other.major) return 1;
			if (this.minor < other.minor) return -1;
			if (this.minor > other.minor) return 1;
			if (this.patch < other.patch) return -1;
			if (this.patch > other.patch) return 1;
			return 0;
		}
		comparePre(other) {
			if (!(other instanceof SemVer)) other = new SemVer(other, this.options);
			if (this.prerelease.length && !other.prerelease.length) return -1;
			else if (!this.prerelease.length && other.prerelease.length) return 1;
			else if (!this.prerelease.length && !other.prerelease.length) return 0;
			let i = 0;
			do {
				const a = this.prerelease[i];
				const b = other.prerelease[i];
				debug("prerelease compare", i, a, b);
				if (a === void 0 && b === void 0) return 0;
				else if (b === void 0) return 1;
				else if (a === void 0) return -1;
				else if (a === b) continue;
				else return compareIdentifiers(a, b);
			} while (++i);
		}
		compareBuild(other) {
			if (!(other instanceof SemVer)) other = new SemVer(other, this.options);
			let i = 0;
			do {
				const a = this.build[i];
				const b = other.build[i];
				debug("build compare", i, a, b);
				if (a === void 0 && b === void 0) return 0;
				else if (b === void 0) return 1;
				else if (a === void 0) return -1;
				else if (a === b) continue;
				else return compareIdentifiers(a, b);
			} while (++i);
		}
		inc(release, identifier, identifierBase) {
			if (release.startsWith("pre")) {
				if (!identifier && identifierBase === false) throw new Error("invalid increment argument: identifier is empty");
				if (identifier) {
					const match = `-${identifier}`.match(this.options.loose ? re[t.PRERELEASELOOSE] : re[t.PRERELEASE]);
					if (!match || match[1] !== identifier) throw new Error(`invalid identifier: ${identifier}`);
				}
			}
			switch (release) {
				case "premajor":
					this.prerelease.length = 0;
					this.patch = 0;
					this.minor = 0;
					this.major++;
					this.inc("pre", identifier, identifierBase);
					break;
				case "preminor":
					this.prerelease.length = 0;
					this.patch = 0;
					this.minor++;
					this.inc("pre", identifier, identifierBase);
					break;
				case "prepatch":
					this.prerelease.length = 0;
					this.inc("patch", identifier, identifierBase);
					this.inc("pre", identifier, identifierBase);
					break;
				case "prerelease":
					if (this.prerelease.length === 0) this.inc("patch", identifier, identifierBase);
					this.inc("pre", identifier, identifierBase);
					break;
				case "release":
					if (this.prerelease.length === 0) throw new Error(`version ${this.raw} is not a prerelease`);
					this.prerelease.length = 0;
					break;
				case "major":
					if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) this.major++;
					this.minor = 0;
					this.patch = 0;
					this.prerelease = [];
					break;
				case "minor":
					if (this.patch !== 0 || this.prerelease.length === 0) this.minor++;
					this.patch = 0;
					this.prerelease = [];
					break;
				case "patch":
					if (this.prerelease.length === 0) this.patch++;
					this.prerelease = [];
					break;
				case "pre": {
					const base = Number(identifierBase) ? 1 : 0;
					if (this.prerelease.length === 0) this.prerelease = [base];
					else {
						let i = this.prerelease.length;
						while (--i >= 0) if (typeof this.prerelease[i] === "number") {
							this.prerelease[i]++;
							i = -2;
						}
						if (i === -1) {
							if (identifier === this.prerelease.join(".") && identifierBase === false) throw new Error("invalid increment argument: identifier already exists");
							this.prerelease.push(base);
						}
					}
					if (identifier) {
						let prerelease = [identifier, base];
						if (identifierBase === false) prerelease = [identifier];
						if (compareIdentifiers(this.prerelease[0], identifier) === 0) {
							if (isNaN(this.prerelease[1])) this.prerelease = prerelease;
						} else this.prerelease = prerelease;
					}
					break;
				}
				default: throw new Error(`invalid increment argument: ${release}`);
			}
			this.raw = this.format();
			if (this.build.length) this.raw += `+${this.build.join(".")}`;
			return this;
		}
	};
	module.exports = SemVer;
}));

//#endregion
//#region ../node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/parse.js
var require_parse = /* @__PURE__ */ require_chunk.__commonJSMin(((exports, module) => {
	const SemVer = require_semver$1();
	const parse = (version, options, throwErrors = false) => {
		if (version instanceof SemVer) return version;
		try {
			return new SemVer(version, options);
		} catch (er) {
			if (!throwErrors) return null;
			throw er;
		}
	};
	module.exports = parse;
}));

//#endregion
//#region ../node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/valid.js
var require_valid$1 = /* @__PURE__ */ require_chunk.__commonJSMin(((exports, module) => {
	const parse = require_parse();
	const valid = (version, options) => {
		const v = parse(version, options);
		return v ? v.version : null;
	};
	module.exports = valid;
}));

//#endregion
//#region ../node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/clean.js
var require_clean = /* @__PURE__ */ require_chunk.__commonJSMin(((exports, module) => {
	const parse = require_parse();
	const clean = (version, options) => {
		const s = parse(version.trim().replace(/^[=v]+/, ""), options);
		return s ? s.version : null;
	};
	module.exports = clean;
}));

//#endregion
//#region ../node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/inc.js
var require_inc = /* @__PURE__ */ require_chunk.__commonJSMin(((exports, module) => {
	const SemVer = require_semver$1();
	const inc = (version, release, options, identifier, identifierBase) => {
		if (typeof options === "string") {
			identifierBase = identifier;
			identifier = options;
			options = void 0;
		}
		try {
			return new SemVer(version instanceof SemVer ? version.version : version, options).inc(release, identifier, identifierBase).version;
		} catch (er) {
			return null;
		}
	};
	module.exports = inc;
}));

//#endregion
//#region ../node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/diff.js
var require_diff = /* @__PURE__ */ require_chunk.__commonJSMin(((exports, module) => {
	const parse = require_parse();
	const diff = (version1, version2) => {
		const v1 = parse(version1, null, true);
		const v2 = parse(version2, null, true);
		const comparison = v1.compare(v2);
		if (comparison === 0) return null;
		const v1Higher = comparison > 0;
		const highVersion = v1Higher ? v1 : v2;
		const lowVersion = v1Higher ? v2 : v1;
		const highHasPre = !!highVersion.prerelease.length;
		if (!!lowVersion.prerelease.length && !highHasPre) {
			if (!lowVersion.patch && !lowVersion.minor) return "major";
			if (lowVersion.compareMain(highVersion) === 0) {
				if (lowVersion.minor && !lowVersion.patch) return "minor";
				return "patch";
			}
		}
		const prefix = highHasPre ? "pre" : "";
		if (v1.major !== v2.major) return prefix + "major";
		if (v1.minor !== v2.minor) return prefix + "minor";
		if (v1.patch !== v2.patch) return prefix + "patch";
		return "prerelease";
	};
	module.exports = diff;
}));

//#endregion
//#region ../node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/major.js
var require_major = /* @__PURE__ */ require_chunk.__commonJSMin(((exports, module) => {
	const SemVer = require_semver$1();
	const major = (a, loose) => new SemVer(a, loose).major;
	module.exports = major;
}));

//#endregion
//#region ../node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/minor.js
var require_minor = /* @__PURE__ */ require_chunk.__commonJSMin(((exports, module) => {
	const SemVer = require_semver$1();
	const minor = (a, loose) => new SemVer(a, loose).minor;
	module.exports = minor;
}));

//#endregion
//#region ../node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/patch.js
var require_patch = /* @__PURE__ */ require_chunk.__commonJSMin(((exports, module) => {
	const SemVer = require_semver$1();
	const patch = (a, loose) => new SemVer(a, loose).patch;
	module.exports = patch;
}));

//#endregion
//#region ../node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/prerelease.js
var require_prerelease = /* @__PURE__ */ require_chunk.__commonJSMin(((exports, module) => {
	const parse = require_parse();
	const prerelease = (version, options) => {
		const parsed = parse(version, options);
		return parsed && parsed.prerelease.length ? parsed.prerelease : null;
	};
	module.exports = prerelease;
}));

//#endregion
//#region ../node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/compare.js
var require_compare = /* @__PURE__ */ require_chunk.__commonJSMin(((exports, module) => {
	const SemVer = require_semver$1();
	const compare = (a, b, loose) => new SemVer(a, loose).compare(new SemVer(b, loose));
	module.exports = compare;
}));

//#endregion
//#region ../node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/rcompare.js
var require_rcompare = /* @__PURE__ */ require_chunk.__commonJSMin(((exports, module) => {
	const compare = require_compare();
	const rcompare = (a, b, loose) => compare(b, a, loose);
	module.exports = rcompare;
}));

//#endregion
//#region ../node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/compare-loose.js
var require_compare_loose = /* @__PURE__ */ require_chunk.__commonJSMin(((exports, module) => {
	const compare = require_compare();
	const compareLoose = (a, b) => compare(a, b, true);
	module.exports = compareLoose;
}));

//#endregion
//#region ../node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/compare-build.js
var require_compare_build = /* @__PURE__ */ require_chunk.__commonJSMin(((exports, module) => {
	const SemVer = require_semver$1();
	const compareBuild = (a, b, loose) => {
		const versionA = new SemVer(a, loose);
		const versionB = new SemVer(b, loose);
		return versionA.compare(versionB) || versionA.compareBuild(versionB);
	};
	module.exports = compareBuild;
}));

//#endregion
//#region ../node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/sort.js
var require_sort = /* @__PURE__ */ require_chunk.__commonJSMin(((exports, module) => {
	const compareBuild = require_compare_build();
	const sort = (list, loose) => list.sort((a, b) => compareBuild(a, b, loose));
	module.exports = sort;
}));

//#endregion
//#region ../node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/rsort.js
var require_rsort = /* @__PURE__ */ require_chunk.__commonJSMin(((exports, module) => {
	const compareBuild = require_compare_build();
	const rsort = (list, loose) => list.sort((a, b) => compareBuild(b, a, loose));
	module.exports = rsort;
}));

//#endregion
//#region ../node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/gt.js
var require_gt = /* @__PURE__ */ require_chunk.__commonJSMin(((exports, module) => {
	const compare = require_compare();
	const gt = (a, b, loose) => compare(a, b, loose) > 0;
	module.exports = gt;
}));

//#endregion
//#region ../node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/lt.js
var require_lt = /* @__PURE__ */ require_chunk.__commonJSMin(((exports, module) => {
	const compare = require_compare();
	const lt = (a, b, loose) => compare(a, b, loose) < 0;
	module.exports = lt;
}));

//#endregion
//#region ../node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/eq.js
var require_eq = /* @__PURE__ */ require_chunk.__commonJSMin(((exports, module) => {
	const compare = require_compare();
	const eq = (a, b, loose) => compare(a, b, loose) === 0;
	module.exports = eq;
}));

//#endregion
//#region ../node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/neq.js
var require_neq = /* @__PURE__ */ require_chunk.__commonJSMin(((exports, module) => {
	const compare = require_compare();
	const neq = (a, b, loose) => compare(a, b, loose) !== 0;
	module.exports = neq;
}));

//#endregion
//#region ../node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/gte.js
var require_gte = /* @__PURE__ */ require_chunk.__commonJSMin(((exports, module) => {
	const compare = require_compare();
	const gte = (a, b, loose) => compare(a, b, loose) >= 0;
	module.exports = gte;
}));

//#endregion
//#region ../node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/lte.js
var require_lte = /* @__PURE__ */ require_chunk.__commonJSMin(((exports, module) => {
	const compare = require_compare();
	const lte = (a, b, loose) => compare(a, b, loose) <= 0;
	module.exports = lte;
}));

//#endregion
//#region ../node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/cmp.js
var require_cmp = /* @__PURE__ */ require_chunk.__commonJSMin(((exports, module) => {
	const eq = require_eq();
	const neq = require_neq();
	const gt = require_gt();
	const gte = require_gte();
	const lt = require_lt();
	const lte = require_lte();
	const cmp = (a, op, b, loose) => {
		switch (op) {
			case "===":
				if (typeof a === "object") a = a.version;
				if (typeof b === "object") b = b.version;
				return a === b;
			case "!==":
				if (typeof a === "object") a = a.version;
				if (typeof b === "object") b = b.version;
				return a !== b;
			case "":
			case "=":
			case "==": return eq(a, b, loose);
			case "!=": return neq(a, b, loose);
			case ">": return gt(a, b, loose);
			case ">=": return gte(a, b, loose);
			case "<": return lt(a, b, loose);
			case "<=": return lte(a, b, loose);
			default: throw new TypeError(`Invalid operator: ${op}`);
		}
	};
	module.exports = cmp;
}));

//#endregion
//#region ../node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/coerce.js
var require_coerce = /* @__PURE__ */ require_chunk.__commonJSMin(((exports, module) => {
	const SemVer = require_semver$1();
	const parse = require_parse();
	const { safeRe: re, t } = require_re();
	const coerce = (version, options) => {
		if (version instanceof SemVer) return version;
		if (typeof version === "number") version = String(version);
		if (typeof version !== "string") return null;
		options = options || {};
		let match = null;
		if (!options.rtl) match = version.match(options.includePrerelease ? re[t.COERCEFULL] : re[t.COERCE]);
		else {
			const coerceRtlRegex = options.includePrerelease ? re[t.COERCERTLFULL] : re[t.COERCERTL];
			let next;
			while ((next = coerceRtlRegex.exec(version)) && (!match || match.index + match[0].length !== version.length)) {
				if (!match || next.index + next[0].length !== match.index + match[0].length) match = next;
				coerceRtlRegex.lastIndex = next.index + next[1].length + next[2].length;
			}
			coerceRtlRegex.lastIndex = -1;
		}
		if (match === null) return null;
		const major = match[2];
		return parse(`${major}.${match[3] || "0"}.${match[4] || "0"}${options.includePrerelease && match[5] ? `-${match[5]}` : ""}${options.includePrerelease && match[6] ? `+${match[6]}` : ""}`, options);
	};
	module.exports = coerce;
}));

//#endregion
//#region ../node_modules/.pnpm/semver@7.7.3/node_modules/semver/internal/lrucache.js
var require_lrucache = /* @__PURE__ */ require_chunk.__commonJSMin(((exports, module) => {
	var LRUCache = class {
		constructor() {
			this.max = 1e3;
			this.map = /* @__PURE__ */ new Map();
		}
		get(key) {
			const value = this.map.get(key);
			if (value === void 0) return;
			else {
				this.map.delete(key);
				this.map.set(key, value);
				return value;
			}
		}
		delete(key) {
			return this.map.delete(key);
		}
		set(key, value) {
			if (!this.delete(key) && value !== void 0) {
				if (this.map.size >= this.max) {
					const firstKey = this.map.keys().next().value;
					this.delete(firstKey);
				}
				this.map.set(key, value);
			}
			return this;
		}
	};
	module.exports = LRUCache;
}));

//#endregion
//#region ../node_modules/.pnpm/semver@7.7.3/node_modules/semver/classes/range.js
var require_range = /* @__PURE__ */ require_chunk.__commonJSMin(((exports, module) => {
	const SPACE_CHARACTERS = /\s+/g;
	var Range = class Range {
		constructor(range, options) {
			options = parseOptions(options);
			if (range instanceof Range) if (range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease) return range;
			else return new Range(range.raw, options);
			if (range instanceof Comparator) {
				this.raw = range.value;
				this.set = [[range]];
				this.formatted = void 0;
				return this;
			}
			this.options = options;
			this.loose = !!options.loose;
			this.includePrerelease = !!options.includePrerelease;
			this.raw = range.trim().replace(SPACE_CHARACTERS, " ");
			this.set = this.raw.split("||").map((r) => this.parseRange(r.trim())).filter((c) => c.length);
			if (!this.set.length) throw new TypeError(`Invalid SemVer Range: ${this.raw}`);
			if (this.set.length > 1) {
				const first = this.set[0];
				this.set = this.set.filter((c) => !isNullSet(c[0]));
				if (this.set.length === 0) this.set = [first];
				else if (this.set.length > 1) {
					for (const c of this.set) if (c.length === 1 && isAny(c[0])) {
						this.set = [c];
						break;
					}
				}
			}
			this.formatted = void 0;
		}
		get range() {
			if (this.formatted === void 0) {
				this.formatted = "";
				for (let i = 0; i < this.set.length; i++) {
					if (i > 0) this.formatted += "||";
					const comps = this.set[i];
					for (let k = 0; k < comps.length; k++) {
						if (k > 0) this.formatted += " ";
						this.formatted += comps[k].toString().trim();
					}
				}
			}
			return this.formatted;
		}
		format() {
			return this.range;
		}
		toString() {
			return this.range;
		}
		parseRange(range) {
			const memoKey = ((this.options.includePrerelease && FLAG_INCLUDE_PRERELEASE) | (this.options.loose && FLAG_LOOSE)) + ":" + range;
			const cached = cache.get(memoKey);
			if (cached) return cached;
			const loose = this.options.loose;
			const hr = loose ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE];
			range = range.replace(hr, hyphenReplace(this.options.includePrerelease));
			debug("hyphen replace", range);
			range = range.replace(re[t.COMPARATORTRIM], comparatorTrimReplace);
			debug("comparator trim", range);
			range = range.replace(re[t.TILDETRIM], tildeTrimReplace);
			debug("tilde trim", range);
			range = range.replace(re[t.CARETTRIM], caretTrimReplace);
			debug("caret trim", range);
			let rangeList = range.split(" ").map((comp) => parseComparator(comp, this.options)).join(" ").split(/\s+/).map((comp) => replaceGTE0(comp, this.options));
			if (loose) rangeList = rangeList.filter((comp) => {
				debug("loose invalid filter", comp, this.options);
				return !!comp.match(re[t.COMPARATORLOOSE]);
			});
			debug("range list", rangeList);
			const rangeMap = /* @__PURE__ */ new Map();
			const comparators = rangeList.map((comp) => new Comparator(comp, this.options));
			for (const comp of comparators) {
				if (isNullSet(comp)) return [comp];
				rangeMap.set(comp.value, comp);
			}
			if (rangeMap.size > 1 && rangeMap.has("")) rangeMap.delete("");
			const result = [...rangeMap.values()];
			cache.set(memoKey, result);
			return result;
		}
		intersects(range, options) {
			if (!(range instanceof Range)) throw new TypeError("a Range is required");
			return this.set.some((thisComparators) => {
				return isSatisfiable(thisComparators, options) && range.set.some((rangeComparators) => {
					return isSatisfiable(rangeComparators, options) && thisComparators.every((thisComparator) => {
						return rangeComparators.every((rangeComparator) => {
							return thisComparator.intersects(rangeComparator, options);
						});
					});
				});
			});
		}
		test(version) {
			if (!version) return false;
			if (typeof version === "string") try {
				version = new SemVer(version, this.options);
			} catch (er) {
				return false;
			}
			for (let i = 0; i < this.set.length; i++) if (testSet(this.set[i], version, this.options)) return true;
			return false;
		}
	};
	module.exports = Range;
	const cache = new (require_lrucache())();
	const parseOptions = require_parse_options();
	const Comparator = require_comparator();
	const debug = require_debug();
	const SemVer = require_semver$1();
	const { safeRe: re, t, comparatorTrimReplace, tildeTrimReplace, caretTrimReplace } = require_re();
	const { FLAG_INCLUDE_PRERELEASE, FLAG_LOOSE } = require_constants();
	const isNullSet = (c) => c.value === "<0.0.0-0";
	const isAny = (c) => c.value === "";
	const isSatisfiable = (comparators, options) => {
		let result = true;
		const remainingComparators = comparators.slice();
		let testComparator = remainingComparators.pop();
		while (result && remainingComparators.length) {
			result = remainingComparators.every((otherComparator) => {
				return testComparator.intersects(otherComparator, options);
			});
			testComparator = remainingComparators.pop();
		}
		return result;
	};
	const parseComparator = (comp, options) => {
		comp = comp.replace(re[t.BUILD], "");
		debug("comp", comp, options);
		comp = replaceCarets(comp, options);
		debug("caret", comp);
		comp = replaceTildes(comp, options);
		debug("tildes", comp);
		comp = replaceXRanges(comp, options);
		debug("xrange", comp);
		comp = replaceStars(comp, options);
		debug("stars", comp);
		return comp;
	};
	const isX = (id) => !id || id.toLowerCase() === "x" || id === "*";
	const replaceTildes = (comp, options) => {
		return comp.trim().split(/\s+/).map((c) => replaceTilde(c, options)).join(" ");
	};
	const replaceTilde = (comp, options) => {
		const r = options.loose ? re[t.TILDELOOSE] : re[t.TILDE];
		return comp.replace(r, (_, M, m, p, pr) => {
			debug("tilde", comp, _, M, m, p, pr);
			let ret;
			if (isX(M)) ret = "";
			else if (isX(m)) ret = `>=${M}.0.0 <${+M + 1}.0.0-0`;
			else if (isX(p)) ret = `>=${M}.${m}.0 <${M}.${+m + 1}.0-0`;
			else if (pr) {
				debug("replaceTilde pr", pr);
				ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
			} else ret = `>=${M}.${m}.${p} <${M}.${+m + 1}.0-0`;
			debug("tilde return", ret);
			return ret;
		});
	};
	const replaceCarets = (comp, options) => {
		return comp.trim().split(/\s+/).map((c) => replaceCaret(c, options)).join(" ");
	};
	const replaceCaret = (comp, options) => {
		debug("caret", comp, options);
		const r = options.loose ? re[t.CARETLOOSE] : re[t.CARET];
		const z = options.includePrerelease ? "-0" : "";
		return comp.replace(r, (_, M, m, p, pr) => {
			debug("caret", comp, _, M, m, p, pr);
			let ret;
			if (isX(M)) ret = "";
			else if (isX(m)) ret = `>=${M}.0.0${z} <${+M + 1}.0.0-0`;
			else if (isX(p)) if (M === "0") ret = `>=${M}.${m}.0${z} <${M}.${+m + 1}.0-0`;
			else ret = `>=${M}.${m}.0${z} <${+M + 1}.0.0-0`;
			else if (pr) {
				debug("replaceCaret pr", pr);
				if (M === "0") if (m === "0") ret = `>=${M}.${m}.${p}-${pr} <${M}.${m}.${+p + 1}-0`;
				else ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
				else ret = `>=${M}.${m}.${p}-${pr} <${+M + 1}.0.0-0`;
			} else {
				debug("no pr");
				if (M === "0") if (m === "0") ret = `>=${M}.${m}.${p}${z} <${M}.${m}.${+p + 1}-0`;
				else ret = `>=${M}.${m}.${p}${z} <${M}.${+m + 1}.0-0`;
				else ret = `>=${M}.${m}.${p} <${+M + 1}.0.0-0`;
			}
			debug("caret return", ret);
			return ret;
		});
	};
	const replaceXRanges = (comp, options) => {
		debug("replaceXRanges", comp, options);
		return comp.split(/\s+/).map((c) => replaceXRange(c, options)).join(" ");
	};
	const replaceXRange = (comp, options) => {
		comp = comp.trim();
		const r = options.loose ? re[t.XRANGELOOSE] : re[t.XRANGE];
		return comp.replace(r, (ret, gtlt, M, m, p, pr) => {
			debug("xRange", comp, ret, gtlt, M, m, p, pr);
			const xM = isX(M);
			const xm = xM || isX(m);
			const xp = xm || isX(p);
			const anyX = xp;
			if (gtlt === "=" && anyX) gtlt = "";
			pr = options.includePrerelease ? "-0" : "";
			if (xM) if (gtlt === ">" || gtlt === "<") ret = "<0.0.0-0";
			else ret = "*";
			else if (gtlt && anyX) {
				if (xm) m = 0;
				p = 0;
				if (gtlt === ">") {
					gtlt = ">=";
					if (xm) {
						M = +M + 1;
						m = 0;
						p = 0;
					} else {
						m = +m + 1;
						p = 0;
					}
				} else if (gtlt === "<=") {
					gtlt = "<";
					if (xm) M = +M + 1;
					else m = +m + 1;
				}
				if (gtlt === "<") pr = "-0";
				ret = `${gtlt + M}.${m}.${p}${pr}`;
			} else if (xm) ret = `>=${M}.0.0${pr} <${+M + 1}.0.0-0`;
			else if (xp) ret = `>=${M}.${m}.0${pr} <${M}.${+m + 1}.0-0`;
			debug("xRange return", ret);
			return ret;
		});
	};
	const replaceStars = (comp, options) => {
		debug("replaceStars", comp, options);
		return comp.trim().replace(re[t.STAR], "");
	};
	const replaceGTE0 = (comp, options) => {
		debug("replaceGTE0", comp, options);
		return comp.trim().replace(re[options.includePrerelease ? t.GTE0PRE : t.GTE0], "");
	};
	const hyphenReplace = (incPr) => ($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr) => {
		if (isX(fM)) from = "";
		else if (isX(fm)) from = `>=${fM}.0.0${incPr ? "-0" : ""}`;
		else if (isX(fp)) from = `>=${fM}.${fm}.0${incPr ? "-0" : ""}`;
		else if (fpr) from = `>=${from}`;
		else from = `>=${from}${incPr ? "-0" : ""}`;
		if (isX(tM)) to = "";
		else if (isX(tm)) to = `<${+tM + 1}.0.0-0`;
		else if (isX(tp)) to = `<${tM}.${+tm + 1}.0-0`;
		else if (tpr) to = `<=${tM}.${tm}.${tp}-${tpr}`;
		else if (incPr) to = `<${tM}.${tm}.${+tp + 1}-0`;
		else to = `<=${to}`;
		return `${from} ${to}`.trim();
	};
	const testSet = (set, version, options) => {
		for (let i = 0; i < set.length; i++) if (!set[i].test(version)) return false;
		if (version.prerelease.length && !options.includePrerelease) {
			for (let i = 0; i < set.length; i++) {
				debug(set[i].semver);
				if (set[i].semver === Comparator.ANY) continue;
				if (set[i].semver.prerelease.length > 0) {
					const allowed = set[i].semver;
					if (allowed.major === version.major && allowed.minor === version.minor && allowed.patch === version.patch) return true;
				}
			}
			return false;
		}
		return true;
	};
}));

//#endregion
//#region ../node_modules/.pnpm/semver@7.7.3/node_modules/semver/classes/comparator.js
var require_comparator = /* @__PURE__ */ require_chunk.__commonJSMin(((exports, module) => {
	const ANY = Symbol("SemVer ANY");
	var Comparator = class Comparator {
		static get ANY() {
			return ANY;
		}
		constructor(comp, options) {
			options = parseOptions(options);
			if (comp instanceof Comparator) if (comp.loose === !!options.loose) return comp;
			else comp = comp.value;
			comp = comp.trim().split(/\s+/).join(" ");
			debug("comparator", comp, options);
			this.options = options;
			this.loose = !!options.loose;
			this.parse(comp);
			if (this.semver === ANY) this.value = "";
			else this.value = this.operator + this.semver.version;
			debug("comp", this);
		}
		parse(comp) {
			const r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR];
			const m = comp.match(r);
			if (!m) throw new TypeError(`Invalid comparator: ${comp}`);
			this.operator = m[1] !== void 0 ? m[1] : "";
			if (this.operator === "=") this.operator = "";
			if (!m[2]) this.semver = ANY;
			else this.semver = new SemVer(m[2], this.options.loose);
		}
		toString() {
			return this.value;
		}
		test(version) {
			debug("Comparator.test", version, this.options.loose);
			if (this.semver === ANY || version === ANY) return true;
			if (typeof version === "string") try {
				version = new SemVer(version, this.options);
			} catch (er) {
				return false;
			}
			return cmp(version, this.operator, this.semver, this.options);
		}
		intersects(comp, options) {
			if (!(comp instanceof Comparator)) throw new TypeError("a Comparator is required");
			if (this.operator === "") {
				if (this.value === "") return true;
				return new Range(comp.value, options).test(this.value);
			} else if (comp.operator === "") {
				if (comp.value === "") return true;
				return new Range(this.value, options).test(comp.semver);
			}
			options = parseOptions(options);
			if (options.includePrerelease && (this.value === "<0.0.0-0" || comp.value === "<0.0.0-0")) return false;
			if (!options.includePrerelease && (this.value.startsWith("<0.0.0") || comp.value.startsWith("<0.0.0"))) return false;
			if (this.operator.startsWith(">") && comp.operator.startsWith(">")) return true;
			if (this.operator.startsWith("<") && comp.operator.startsWith("<")) return true;
			if (this.semver.version === comp.semver.version && this.operator.includes("=") && comp.operator.includes("=")) return true;
			if (cmp(this.semver, "<", comp.semver, options) && this.operator.startsWith(">") && comp.operator.startsWith("<")) return true;
			if (cmp(this.semver, ">", comp.semver, options) && this.operator.startsWith("<") && comp.operator.startsWith(">")) return true;
			return false;
		}
	};
	module.exports = Comparator;
	const parseOptions = require_parse_options();
	const { safeRe: re, t } = require_re();
	const cmp = require_cmp();
	const debug = require_debug();
	const SemVer = require_semver$1();
	const Range = require_range();
}));

//#endregion
//#region ../node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/satisfies.js
var require_satisfies = /* @__PURE__ */ require_chunk.__commonJSMin(((exports, module) => {
	const Range = require_range();
	const satisfies = (version, range, options) => {
		try {
			range = new Range(range, options);
		} catch (er) {
			return false;
		}
		return range.test(version);
	};
	module.exports = satisfies;
}));

//#endregion
//#region ../node_modules/.pnpm/semver@7.7.3/node_modules/semver/ranges/to-comparators.js
var require_to_comparators = /* @__PURE__ */ require_chunk.__commonJSMin(((exports, module) => {
	const Range = require_range();
	const toComparators = (range, options) => new Range(range, options).set.map((comp) => comp.map((c) => c.value).join(" ").trim().split(" "));
	module.exports = toComparators;
}));

//#endregion
//#region ../node_modules/.pnpm/semver@7.7.3/node_modules/semver/ranges/max-satisfying.js
var require_max_satisfying = /* @__PURE__ */ require_chunk.__commonJSMin(((exports, module) => {
	const SemVer = require_semver$1();
	const Range = require_range();
	const maxSatisfying = (versions, range, options) => {
		let max = null;
		let maxSV = null;
		let rangeObj = null;
		try {
			rangeObj = new Range(range, options);
		} catch (er) {
			return null;
		}
		versions.forEach((v) => {
			if (rangeObj.test(v)) {
				if (!max || maxSV.compare(v) === -1) {
					max = v;
					maxSV = new SemVer(max, options);
				}
			}
		});
		return max;
	};
	module.exports = maxSatisfying;
}));

//#endregion
//#region ../node_modules/.pnpm/semver@7.7.3/node_modules/semver/ranges/min-satisfying.js
var require_min_satisfying = /* @__PURE__ */ require_chunk.__commonJSMin(((exports, module) => {
	const SemVer = require_semver$1();
	const Range = require_range();
	const minSatisfying = (versions, range, options) => {
		let min = null;
		let minSV = null;
		let rangeObj = null;
		try {
			rangeObj = new Range(range, options);
		} catch (er) {
			return null;
		}
		versions.forEach((v) => {
			if (rangeObj.test(v)) {
				if (!min || minSV.compare(v) === 1) {
					min = v;
					minSV = new SemVer(min, options);
				}
			}
		});
		return min;
	};
	module.exports = minSatisfying;
}));

//#endregion
//#region ../node_modules/.pnpm/semver@7.7.3/node_modules/semver/ranges/min-version.js
var require_min_version = /* @__PURE__ */ require_chunk.__commonJSMin(((exports, module) => {
	const SemVer = require_semver$1();
	const Range = require_range();
	const gt = require_gt();
	const minVersion = (range, loose) => {
		range = new Range(range, loose);
		let minver = new SemVer("0.0.0");
		if (range.test(minver)) return minver;
		minver = new SemVer("0.0.0-0");
		if (range.test(minver)) return minver;
		minver = null;
		for (let i = 0; i < range.set.length; ++i) {
			const comparators = range.set[i];
			let setMin = null;
			comparators.forEach((comparator) => {
				const compver = new SemVer(comparator.semver.version);
				switch (comparator.operator) {
					case ">":
						if (compver.prerelease.length === 0) compver.patch++;
						else compver.prerelease.push(0);
						compver.raw = compver.format();
					case "":
					case ">=":
						if (!setMin || gt(compver, setMin)) setMin = compver;
						break;
					case "<":
					case "<=": break;
					default: throw new Error(`Unexpected operation: ${comparator.operator}`);
				}
			});
			if (setMin && (!minver || gt(minver, setMin))) minver = setMin;
		}
		if (minver && range.test(minver)) return minver;
		return null;
	};
	module.exports = minVersion;
}));

//#endregion
//#region ../node_modules/.pnpm/semver@7.7.3/node_modules/semver/ranges/valid.js
var require_valid = /* @__PURE__ */ require_chunk.__commonJSMin(((exports, module) => {
	const Range = require_range();
	const validRange = (range, options) => {
		try {
			return new Range(range, options).range || "*";
		} catch (er) {
			return null;
		}
	};
	module.exports = validRange;
}));

//#endregion
//#region ../node_modules/.pnpm/semver@7.7.3/node_modules/semver/ranges/outside.js
var require_outside = /* @__PURE__ */ require_chunk.__commonJSMin(((exports, module) => {
	const SemVer = require_semver$1();
	const Comparator = require_comparator();
	const { ANY } = Comparator;
	const Range = require_range();
	const satisfies = require_satisfies();
	const gt = require_gt();
	const lt = require_lt();
	const lte = require_lte();
	const gte = require_gte();
	const outside = (version, range, hilo, options) => {
		version = new SemVer(version, options);
		range = new Range(range, options);
		let gtfn, ltefn, ltfn, comp, ecomp;
		switch (hilo) {
			case ">":
				gtfn = gt;
				ltefn = lte;
				ltfn = lt;
				comp = ">";
				ecomp = ">=";
				break;
			case "<":
				gtfn = lt;
				ltefn = gte;
				ltfn = gt;
				comp = "<";
				ecomp = "<=";
				break;
			default: throw new TypeError("Must provide a hilo val of \"<\" or \">\"");
		}
		if (satisfies(version, range, options)) return false;
		for (let i = 0; i < range.set.length; ++i) {
			const comparators = range.set[i];
			let high = null;
			let low = null;
			comparators.forEach((comparator) => {
				if (comparator.semver === ANY) comparator = new Comparator(">=0.0.0");
				high = high || comparator;
				low = low || comparator;
				if (gtfn(comparator.semver, high.semver, options)) high = comparator;
				else if (ltfn(comparator.semver, low.semver, options)) low = comparator;
			});
			if (high.operator === comp || high.operator === ecomp) return false;
			if ((!low.operator || low.operator === comp) && ltefn(version, low.semver)) return false;
			else if (low.operator === ecomp && ltfn(version, low.semver)) return false;
		}
		return true;
	};
	module.exports = outside;
}));

//#endregion
//#region ../node_modules/.pnpm/semver@7.7.3/node_modules/semver/ranges/gtr.js
var require_gtr = /* @__PURE__ */ require_chunk.__commonJSMin(((exports, module) => {
	const outside = require_outside();
	const gtr = (version, range, options) => outside(version, range, ">", options);
	module.exports = gtr;
}));

//#endregion
//#region ../node_modules/.pnpm/semver@7.7.3/node_modules/semver/ranges/ltr.js
var require_ltr = /* @__PURE__ */ require_chunk.__commonJSMin(((exports, module) => {
	const outside = require_outside();
	const ltr = (version, range, options) => outside(version, range, "<", options);
	module.exports = ltr;
}));

//#endregion
//#region ../node_modules/.pnpm/semver@7.7.3/node_modules/semver/ranges/intersects.js
var require_intersects = /* @__PURE__ */ require_chunk.__commonJSMin(((exports, module) => {
	const Range = require_range();
	const intersects = (r1, r2, options) => {
		r1 = new Range(r1, options);
		r2 = new Range(r2, options);
		return r1.intersects(r2, options);
	};
	module.exports = intersects;
}));

//#endregion
//#region ../node_modules/.pnpm/semver@7.7.3/node_modules/semver/ranges/simplify.js
var require_simplify = /* @__PURE__ */ require_chunk.__commonJSMin(((exports, module) => {
	const satisfies = require_satisfies();
	const compare = require_compare();
	module.exports = (versions, range, options) => {
		const set = [];
		let first = null;
		let prev = null;
		const v = versions.sort((a, b) => compare(a, b, options));
		for (const version of v) if (satisfies(version, range, options)) {
			prev = version;
			if (!first) first = version;
		} else {
			if (prev) set.push([first, prev]);
			prev = null;
			first = null;
		}
		if (first) set.push([first, null]);
		const ranges = [];
		for (const [min, max] of set) if (min === max) ranges.push(min);
		else if (!max && min === v[0]) ranges.push("*");
		else if (!max) ranges.push(`>=${min}`);
		else if (min === v[0]) ranges.push(`<=${max}`);
		else ranges.push(`${min} - ${max}`);
		const simplified = ranges.join(" || ");
		const original = typeof range.raw === "string" ? range.raw : String(range);
		return simplified.length < original.length ? simplified : range;
	};
}));

//#endregion
//#region ../node_modules/.pnpm/semver@7.7.3/node_modules/semver/ranges/subset.js
var require_subset = /* @__PURE__ */ require_chunk.__commonJSMin(((exports, module) => {
	const Range = require_range();
	const Comparator = require_comparator();
	const { ANY } = Comparator;
	const satisfies = require_satisfies();
	const compare = require_compare();
	const subset = (sub, dom, options = {}) => {
		if (sub === dom) return true;
		sub = new Range(sub, options);
		dom = new Range(dom, options);
		let sawNonNull = false;
		OUTER: for (const simpleSub of sub.set) {
			for (const simpleDom of dom.set) {
				const isSub = simpleSubset(simpleSub, simpleDom, options);
				sawNonNull = sawNonNull || isSub !== null;
				if (isSub) continue OUTER;
			}
			if (sawNonNull) return false;
		}
		return true;
	};
	const minimumVersionWithPreRelease = [new Comparator(">=0.0.0-0")];
	const minimumVersion = [new Comparator(">=0.0.0")];
	const simpleSubset = (sub, dom, options) => {
		if (sub === dom) return true;
		if (sub.length === 1 && sub[0].semver === ANY) if (dom.length === 1 && dom[0].semver === ANY) return true;
		else if (options.includePrerelease) sub = minimumVersionWithPreRelease;
		else sub = minimumVersion;
		if (dom.length === 1 && dom[0].semver === ANY) if (options.includePrerelease) return true;
		else dom = minimumVersion;
		const eqSet = /* @__PURE__ */ new Set();
		let gt, lt;
		for (const c of sub) if (c.operator === ">" || c.operator === ">=") gt = higherGT(gt, c, options);
		else if (c.operator === "<" || c.operator === "<=") lt = lowerLT(lt, c, options);
		else eqSet.add(c.semver);
		if (eqSet.size > 1) return null;
		let gtltComp;
		if (gt && lt) {
			gtltComp = compare(gt.semver, lt.semver, options);
			if (gtltComp > 0) return null;
			else if (gtltComp === 0 && (gt.operator !== ">=" || lt.operator !== "<=")) return null;
		}
		for (const eq of eqSet) {
			if (gt && !satisfies(eq, String(gt), options)) return null;
			if (lt && !satisfies(eq, String(lt), options)) return null;
			for (const c of dom) if (!satisfies(eq, String(c), options)) return false;
			return true;
		}
		let higher, lower;
		let hasDomLT, hasDomGT;
		let needDomLTPre = lt && !options.includePrerelease && lt.semver.prerelease.length ? lt.semver : false;
		let needDomGTPre = gt && !options.includePrerelease && gt.semver.prerelease.length ? gt.semver : false;
		if (needDomLTPre && needDomLTPre.prerelease.length === 1 && lt.operator === "<" && needDomLTPre.prerelease[0] === 0) needDomLTPre = false;
		for (const c of dom) {
			hasDomGT = hasDomGT || c.operator === ">" || c.operator === ">=";
			hasDomLT = hasDomLT || c.operator === "<" || c.operator === "<=";
			if (gt) {
				if (needDomGTPre) {
					if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomGTPre.major && c.semver.minor === needDomGTPre.minor && c.semver.patch === needDomGTPre.patch) needDomGTPre = false;
				}
				if (c.operator === ">" || c.operator === ">=") {
					higher = higherGT(gt, c, options);
					if (higher === c && higher !== gt) return false;
				} else if (gt.operator === ">=" && !satisfies(gt.semver, String(c), options)) return false;
			}
			if (lt) {
				if (needDomLTPre) {
					if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomLTPre.major && c.semver.minor === needDomLTPre.minor && c.semver.patch === needDomLTPre.patch) needDomLTPre = false;
				}
				if (c.operator === "<" || c.operator === "<=") {
					lower = lowerLT(lt, c, options);
					if (lower === c && lower !== lt) return false;
				} else if (lt.operator === "<=" && !satisfies(lt.semver, String(c), options)) return false;
			}
			if (!c.operator && (lt || gt) && gtltComp !== 0) return false;
		}
		if (gt && hasDomLT && !lt && gtltComp !== 0) return false;
		if (lt && hasDomGT && !gt && gtltComp !== 0) return false;
		if (needDomGTPre || needDomLTPre) return false;
		return true;
	};
	const higherGT = (a, b, options) => {
		if (!a) return b;
		const comp = compare(a.semver, b.semver, options);
		return comp > 0 ? a : comp < 0 ? b : b.operator === ">" && a.operator === ">=" ? b : a;
	};
	const lowerLT = (a, b, options) => {
		if (!a) return b;
		const comp = compare(a.semver, b.semver, options);
		return comp < 0 ? a : comp > 0 ? b : b.operator === "<" && a.operator === "<=" ? b : a;
	};
	module.exports = subset;
}));

//#endregion
//#region ../node_modules/.pnpm/semver@7.7.3/node_modules/semver/index.js
var require_semver = /* @__PURE__ */ require_chunk.__commonJSMin(((exports, module) => {
	const internalRe = require_re();
	const constants = require_constants();
	const SemVer = require_semver$1();
	const identifiers = require_identifiers();
	const parse = require_parse();
	const valid = require_valid$1();
	const clean = require_clean();
	const inc = require_inc();
	const diff = require_diff();
	const major = require_major();
	const minor = require_minor();
	const patch = require_patch();
	const prerelease = require_prerelease();
	const compare = require_compare();
	const rcompare = require_rcompare();
	const compareLoose = require_compare_loose();
	const compareBuild = require_compare_build();
	const sort = require_sort();
	const rsort = require_rsort();
	const gt = require_gt();
	const lt = require_lt();
	const eq = require_eq();
	const neq = require_neq();
	const gte = require_gte();
	const lte = require_lte();
	const cmp = require_cmp();
	const coerce = require_coerce();
	const Comparator = require_comparator();
	const Range = require_range();
	const satisfies = require_satisfies();
	const toComparators = require_to_comparators();
	const maxSatisfying = require_max_satisfying();
	const minSatisfying = require_min_satisfying();
	const minVersion = require_min_version();
	const validRange = require_valid();
	const outside = require_outside();
	const gtr = require_gtr();
	const ltr = require_ltr();
	const intersects = require_intersects();
	const simplifyRange = require_simplify();
	const subset = require_subset();
	module.exports = {
		parse,
		valid,
		clean,
		inc,
		diff,
		major,
		minor,
		patch,
		prerelease,
		compare,
		rcompare,
		compareLoose,
		compareBuild,
		sort,
		rsort,
		gt,
		lt,
		eq,
		neq,
		gte,
		lte,
		cmp,
		coerce,
		Comparator,
		Range,
		satisfies,
		toComparators,
		maxSatisfying,
		minSatisfying,
		minVersion,
		validRange,
		outside,
		gtr,
		ltr,
		intersects,
		simplifyRange,
		subset,
		SemVer,
		re: internalRe.re,
		src: internalRe.src,
		tokens: internalRe.t,
		SEMVER_SPEC_VERSION: constants.SEMVER_SPEC_VERSION,
		RELEASE_TYPES: constants.RELEASE_TYPES,
		compareIdentifiers: identifiers.compareIdentifiers,
		rcompareIdentifiers: identifiers.rcompareIdentifiers
	};
}));

//#endregion
//#region src/cli/utils.ts
var import_semver = /* @__PURE__ */ require_chunk.__toESM(require_semver());
const checkPackage = async (it) => {
	try {
		await import(it);
		return true;
	} catch {
		return false;
	}
};
const assertPackages = async (...pkgs) => {
	try {
		for (let i = 0; i < pkgs.length; i++) await import(pkgs[i]);
	} catch {
		require_views.err(`please install required packages: ${pkgs.map((it) => `'${it}'`).join(" ")}`);
		process.exit(1);
	}
};
var QueryError = class extends Error {
	constructor(wrapped, sql, params) {
		super(wrapped.message, { cause: wrapped });
		this.sql = sql;
		this.params = params;
	}
};

//#endregion
//#region src/cli/connections.ts
const ms = (a, b) => Number(b - a) / 1e6;
const normalisePGliteUrl = (it) => {
	if (it.startsWith("file:")) return it.substring(5);
	return it;
};
const preparePostgresDB = async (credentials) => {
	if ("driver" in credentials) {
		const { driver } = credentials;
		if (driver === "aws-data-api") {
			assertPackages("@aws-sdk/client-rds-data");
			const { RDSDataClient } = await Promise.resolve().then(() => require_chunk.__toDynamicImportESM()(require("./dist-cjs-B0azHwSt.js")));
			const { AwsDataApiSession, drizzle } = await import("drizzle-orm/aws-data-api/pg");
			const { migrate } = await import("drizzle-orm/aws-data-api/pg/migrator");
			const { PgDialect } = await import("drizzle-orm/pg-core");
			const config = {
				database: credentials.database,
				resourceArn: credentials.resourceArn,
				secretArn: credentials.secretArn
			};
			const rdsClient = new RDSDataClient();
			const session = new AwsDataApiSession(rdsClient, new PgDialect(), {}, void 0, config, void 0);
			const db = drizzle({
				client: rdsClient,
				...config
			});
			const migrateFn = async (config$1) => {
				return migrate(db, config$1);
			};
			const query = async (sql, params) => {
				return await session.prepareQuery({
					sql,
					params: params ?? []
				}, void 0, void 0, false).all();
			};
			const proxy = async (params) => {
				const prepared = session.prepareQuery({
					sql: params.sql,
					params: params.params ?? [],
					typings: params.typings
				}, void 0, void 0, params.mode === "array");
				if (params.mode === "array") return (await prepared.values()).rows;
				return (await prepared.execute()).rows;
			};
			const transactionProxy = async (_queries) => {
				throw new Error("Transaction not supported");
			};
			return {
				packageName: "@aws-sdk/client-rds-data",
				query,
				proxy,
				transactionProxy,
				migrate: migrateFn
			};
		}
		if (driver === "pglite") {
			assertPackages("@electric-sql/pglite");
			const { PGlite, types: types$2 } = await import("@electric-sql/pglite");
			const { drizzle } = await import("drizzle-orm/pglite");
			const { migrate } = await import("drizzle-orm/pglite/migrator");
			const pglite = "client" in credentials ? credentials.client : new PGlite(normalisePGliteUrl(credentials.url));
			await pglite.waitReady;
			const drzl = drizzle({ client: pglite });
			const migrateFn = async (config) => {
				return migrate(drzl, config);
			};
			const parsers = {
				[types$2.TIMESTAMP]: (value) => value,
				[types$2.TIMESTAMPTZ]: (value) => value,
				[types$2.INTERVAL]: (value) => value,
				[types$2.DATE]: (value) => value
			};
			const query = async (sql, params = []) => {
				return (await pglite.query(sql, params, { parsers }).catch((e) => {
					throw new QueryError(e, sql, params);
				})).rows;
			};
			const proxy = async (params) => {
				const preparedParams = preparePGliteParams(params.params || []);
				return (await pglite.query(params.sql, preparedParams, {
					rowMode: params.mode,
					parsers
				}).catch((e) => {
					throw new QueryError(e, params.sql, params.params || []);
				})).rows;
			};
			const transactionProxy = async (queries) => {
				const results = [];
				try {
					await pglite.transaction(async (tx) => {
						for (const query$1 of queries) {
							const result = await tx.query(query$1.sql, void 0, { parsers });
							results.push(result.rows);
						}
					});
				} catch (error) {
					results.push(error);
				}
				return results;
			};
			return {
				packageName: "pglite",
				query,
				proxy,
				transactionProxy,
				migrate: migrateFn
			};
		}
		require_utils.assertUnreachable(driver);
	}
	if (await checkPackage("pg")) {
		console.log(require_views.withStyle.info(`Using 'pg' driver for database querying`));
		const { default: pg } = await import("pg");
		const { drizzle } = await import("drizzle-orm/node-postgres");
		const { migrate } = await import("drizzle-orm/node-postgres/migrator");
		const ssl = "ssl" in credentials ? credentials.ssl === "prefer" || credentials.ssl === "require" || credentials.ssl === "allow" ? { rejectUnauthorized: false } : credentials.ssl === "verify-full" ? {} : credentials.ssl : {};
		const types$2 = { getTypeParser: (typeId, format) => {
			if (typeId === pg.types.builtins.TIMESTAMPTZ) return (val) => val;
			if (typeId === pg.types.builtins.TIMESTAMP) return (val) => val;
			if (typeId === pg.types.builtins.DATE) return (val) => val;
			if (typeId === pg.types.builtins.INTERVAL) return (val) => val;
			if (typeId === pg.types.builtins.JSON || typeId === pg.types.builtins.JSONB) return (val) => require_grammar.JSONB.parse(val);
			return pg.types.getTypeParser(typeId, format);
		} };
		const pool = "url" in credentials ? new pg.Pool({
			connectionString: credentials.url,
			max: 1
		}) : new pg.Pool({
			...credentials,
			ssl,
			max: 1
		});
		const db = drizzle({ client: pool });
		const migrateFn = async (config) => {
			return migrate(db, config);
		};
		const query = async (sql, params) => {
			return (await pool.query({
				text: sql,
				values: params ?? [],
				types: types$2
			}).catch((e) => {
				throw new QueryError(e, sql, params || []);
			})).rows;
		};
		const proxy = async (params) => {
			return (await pool.query({
				text: params.sql,
				values: params.params,
				...params.mode === "array" && { rowMode: "array" },
				types: types$2
			}).catch((e) => {
				throw new QueryError(e, params.sql, params.params || []);
			})).rows;
		};
		const transactionProxy = async (queries) => {
			const results = [];
			const tx = await pool.connect();
			try {
				await tx.query("BEGIN");
				for (const query$1 of queries) {
					const result = await tx.query({
						text: query$1.sql,
						types: types$2
					});
					results.push(result.rows);
				}
				await tx.query("COMMIT");
			} catch (error) {
				await tx.query("ROLLBACK");
				results.push(error);
			} finally {
				tx.release();
			}
			return results;
		};
		const benchmarkQuery = async (client, sql, params) => {
			const explainResult = await pool.query({
				text: `EXPLAIN ANALYZE ${sql}`,
				values: params ?? [],
				types: types$2
			});
			const stringifiedResult = JSON.stringify(explainResult.rows);
			const planningMatch = stringifiedResult.match(/Planning Time:\s*([\d.]+)\s*ms/i);
			const executionMatch = stringifiedResult.match(/Execution Time:\s*([\d.]+)\s*ms/i);
			let planningTime = Number(planningMatch[1]);
			let executionTime = Number(executionMatch[1]);
			let querySentAt = 0n;
			let firstDataAt = 0n;
			let lastDataAt = 0n;
			let lastRowParsedAt = 0n;
			let queryCompletedAt = 0n;
			let bytesReceived = 0;
			let rowCount = 0;
			let parseTime = 0;
			let lastParseTime = 0;
			const rowDescriptionListener = (data) => {
				if (firstDataAt === 0n) firstDataAt = process.hrtime.bigint();
				bytesReceived += data.length;
			};
			const originalRowListener = client.connection.listeners("dataRow")[0];
			const wrappedRowListener = (data) => {
				rowCount += 1;
				const start = process.hrtime.bigint();
				lastDataAt = start;
				originalRowListener.apply(client.connection, [data]);
				const end = process.hrtime.bigint();
				lastRowParsedAt = end;
				lastParseTime = ms(start, end);
				parseTime += lastParseTime;
				bytesReceived += data.length;
			};
			client.connection.removeAllListeners("dataRow");
			client.connection.addListener("dataRow", wrappedRowListener);
			client.connection.prependListener("rowDescription", rowDescriptionListener);
			querySentAt = process.hrtime.bigint();
			await client.query({
				text: sql,
				values: params,
				types: types$2
			});
			queryCompletedAt = process.hrtime.bigint();
			client.connection.removeListener("rowDescription", rowDescriptionListener);
			client.connection.removeAllListeners("dataRow");
			client.connection.addListener("dataRow", originalRowListener);
			let querySentTime = ms(querySentAt, firstDataAt) - executionTime - planningTime;
			if (querySentTime < 0) {
				const percent = .1;
				const overflow = -querySentTime;
				const keepForSent = overflow * percent;
				const adjustedOverflow = overflow * (1 + percent);
				const total$1 = planningTime + executionTime;
				const ratioPlanning = planningTime / total$1;
				const ratioExecution = executionTime / total$1;
				planningTime -= adjustedOverflow * ratioPlanning;
				executionTime -= adjustedOverflow * ratioExecution;
				querySentTime = keepForSent;
			}
			const networkLatencyBefore = querySentTime / 2;
			const networkLatencyAfter = querySentTime / 2;
			const downloadTime = ms(firstDataAt, lastDataAt) - (rowCount > 1 ? parseTime - lastParseTime : 0);
			const total = ms(querySentAt, queryCompletedAt);
			const calculatedTotal = networkLatencyBefore + planningTime + executionTime + networkLatencyAfter + downloadTime + parseTime + ms(lastRowParsedAt, queryCompletedAt);
			const errorMargin = Math.abs(total - calculatedTotal);
			return {
				networkLatencyBefore,
				planning: planningTime,
				execution: executionTime,
				networkLatencyAfter,
				dataDownload: downloadTime,
				dataParse: parseTime,
				total,
				errorMargin,
				dataSize: bytesReceived
			};
		};
		const benchmarkProxy = async ({ sql, params }, repeats) => {
			let startAt = 0n;
			let tcpConnectedAt = 0n;
			let tlsConnectedAt = null;
			let dbReadyAt = 0n;
			const client = "url" in credentials ? new pg.Client({ connectionString: credentials.url }) : new pg.Client({
				...credentials,
				ssl
			});
			client.connection.once("connect", () => {
				tcpConnectedAt = process.hrtime.bigint();
			});
			client.connection.prependOnceListener("sslconnect", () => {
				tlsConnectedAt = process.hrtime.bigint();
			});
			client.connection.prependOnceListener("readyForQuery", () => {
				dbReadyAt = process.hrtime.bigint();
			});
			startAt = process.hrtime.bigint();
			await client.connect();
			const results = [];
			for (let i = 0; i < repeats; i++) {
				const r = await benchmarkQuery(client, sql, params);
				results.push(r);
			}
			await client.end();
			return {
				tcpHandshake: ms(startAt, tcpConnectedAt),
				tlsHandshake: tlsConnectedAt ? ms(tcpConnectedAt, tlsConnectedAt) : null,
				dbHandshake: ms(tlsConnectedAt ?? tcpConnectedAt, dbReadyAt),
				queries: results
			};
		};
		return {
			packageName: "pg",
			query,
			proxy,
			transactionProxy,
			benchmarkProxy,
			migrate: migrateFn
		};
	}
	if (await checkPackage("postgres")) {
		console.log(require_views.withStyle.info(`Using 'postgres' driver for database querying`));
		const postgres = await import("postgres");
		const { drizzle } = await import("drizzle-orm/postgres-js");
		const { migrate } = await import("drizzle-orm/postgres-js/migrator");
		const client = "url" in credentials ? postgres.default(credentials.url, { max: 1 }) : postgres.default({
			...credentials,
			max: 1
		});
		const transparentParser = (val) => val;
		for (const type of [
			"1184",
			"1082",
			"1083",
			"1114"
		]) {
			client.options.parsers[type] = transparentParser;
			client.options.serializers[type] = transparentParser;
		}
		client.options.serializers["114"] = transparentParser;
		client.options.serializers["3802"] = transparentParser;
		const db = drizzle({ client });
		const migrateFn = async (config) => {
			return migrate(db, config);
		};
		const query = async (sql, params) => {
			return await client.unsafe(sql, params ?? []).catch((e) => {
				throw new QueryError(e, sql, params || []);
			});
		};
		const proxy = async (params) => {
			if (params.mode === "array") return client.unsafe(params.sql, params.params).values().catch((e) => {
				throw new QueryError(e, params.sql, params.params || []);
			});
			return client.unsafe(params.sql, params.params).catch((e) => {
				throw new QueryError(e, params.sql, params.params || []);
			});
		};
		const transactionProxy = async (queries) => {
			const results = [];
			try {
				await client.begin(async (sql) => {
					for (const query$1 of queries) {
						const result = await sql.unsafe(query$1.sql);
						results.push(result);
					}
				});
			} catch (error) {
				results.push(error);
			}
			return results;
		};
		return {
			packageName: "postgres",
			query,
			proxy,
			transactionProxy,
			migrate: migrateFn
		};
	}
	if (await checkPackage("@vercel/postgres")) {
		console.log(require_views.withStyle.info(`Using '@vercel/postgres' driver for database querying`));
		console.log(require_views.withStyle.fullWarning("'@vercel/postgres' can only connect to remote Neon/Vercel Postgres/Supabase instances through a websocket"));
		const { VercelPool, types: pgTypes } = await import("@vercel/postgres");
		const { drizzle } = await import("drizzle-orm/vercel-postgres");
		const { migrate } = await import("drizzle-orm/vercel-postgres/migrator");
		const ssl = "ssl" in credentials ? credentials.ssl === "prefer" || credentials.ssl === "require" || credentials.ssl === "allow" ? { rejectUnauthorized: false } : credentials.ssl === "verify-full" ? {} : credentials.ssl : {};
		const types$2 = { getTypeParser: (typeId, format) => {
			if (typeId === pgTypes.builtins.TIMESTAMPTZ) return (val) => val;
			if (typeId === pgTypes.builtins.TIMESTAMP) return (val) => val;
			if (typeId === pgTypes.builtins.DATE) return (val) => val;
			if (typeId === pgTypes.builtins.INTERVAL) return (val) => val;
			return pgTypes.getTypeParser(typeId, format);
		} };
		const client = "url" in credentials ? new VercelPool({ connectionString: credentials.url }) : new VercelPool({
			...credentials,
			ssl
		});
		await client.connect();
		const db = drizzle({ client });
		const migrateFn = async (config) => {
			return migrate(db, config);
		};
		const query = async (sql, params) => {
			return (await client.query({
				text: sql,
				values: params ?? [],
				types: types$2
			}).catch((e) => {
				throw new QueryError(e, sql, params || []);
			})).rows;
		};
		const proxy = async (params) => {
			return (await client.query({
				text: params.sql,
				values: params.params,
				...params.mode === "array" && { rowMode: "array" },
				types: types$2
			}).catch((e) => {
				throw new QueryError(e, params.sql, params.params || []);
			})).rows;
		};
		const transactionProxy = async (queries) => {
			const results = [];
			const tx = await client.connect();
			try {
				await tx.query("BEGIN");
				for (const query$1 of queries) {
					const result = await tx.query({
						text: query$1.sql,
						types: types$2
					});
					results.push(result.rows);
				}
				await tx.query("COMMIT");
			} catch (error) {
				await tx.query("ROLLBACK");
				results.push(error);
			} finally {
				tx.release();
			}
			return results;
		};
		return {
			packageName: "@vercel/postgres",
			query,
			proxy,
			transactionProxy,
			migrate: migrateFn
		};
	}
	if (await checkPackage("@neondatabase/serverless")) {
		console.log(require_views.withStyle.info(`Using '@neondatabase/serverless' driver for database querying`));
		console.log(require_views.withStyle.fullWarning("'@neondatabase/serverless' can only connect to remote Neon/Vercel Postgres/Supabase instances through a websocket"));
		const { Pool, neonConfig, types: pgTypes } = await import("@neondatabase/serverless");
		const { drizzle } = await import("drizzle-orm/neon-serverless");
		const { migrate } = await import("drizzle-orm/neon-serverless/migrator");
		const ssl = "ssl" in credentials ? credentials.ssl === "prefer" || credentials.ssl === "require" || credentials.ssl === "allow" ? { rejectUnauthorized: false } : credentials.ssl === "verify-full" ? {} : credentials.ssl : {};
		const types$2 = { getTypeParser: (typeId, format) => {
			if (typeId === pgTypes.builtins.TIMESTAMPTZ) return (val) => val;
			if (typeId === pgTypes.builtins.TIMESTAMP) return (val) => val;
			if (typeId === pgTypes.builtins.DATE) return (val) => val;
			if (typeId === pgTypes.builtins.INTERVAL) return (val) => val;
			return pgTypes.getTypeParser(typeId, format);
		} };
		const client = "url" in credentials ? new Pool({
			connectionString: credentials.url,
			max: 1
		}) : new Pool({
			...credentials,
			max: 1,
			ssl
		});
		neonConfig.webSocketConstructor = wrapper_default;
		const db = drizzle({ client });
		const migrateFn = async (config) => {
			return migrate(db, config);
		};
		const query = async (sql, params) => {
			return (await client.query({
				text: sql,
				values: params ?? [],
				types: types$2
			}).catch((e) => {
				throw new QueryError(e, sql, params || []);
			})).rows;
		};
		const proxy = async (params) => {
			return (await client.query({
				text: params.sql,
				values: params.params,
				...params.mode === "array" && { rowMode: "array" },
				types: types$2
			}).catch((e) => {
				throw new QueryError(e, params.sql, params.params || []);
			})).rows;
		};
		const transactionProxy = async (queries) => {
			const results = [];
			const tx = await client.connect();
			try {
				await tx.query("BEGIN");
				for (const query$1 of queries) {
					const result = await tx.query({
						text: query$1.sql,
						types: types$2
					});
					results.push(result.rows);
				}
				await tx.query("COMMIT");
			} catch (error) {
				await tx.query("ROLLBACK");
				results.push(error);
			} finally {
				tx.release();
			}
			return results;
		};
		return {
			packageName: "@neondatabase/serverless",
			query,
			proxy,
			transactionProxy,
			migrate: migrateFn
		};
	}
	if (await checkPackage("bun")) {
		console.log(require_views.withStyle.info(`Using 'bun' driver for database querying`));
		const { SQL } = await import("bun");
		const { drizzle } = await import("drizzle-orm/bun-sql/postgres");
		const { migrate } = await import("drizzle-orm/bun-sql/postgres/migrator");
		const ssl = "ssl" in credentials ? credentials.ssl === "prefer" || credentials.ssl === "require" || credentials.ssl === "allow" ? true : false : void 0;
		const client = new SQL({
			adapter: "postgres",
			...credentials,
			ssl,
			max: 1
		});
		const db = drizzle({ client });
		const migrateFn = async (config) => {
			return migrate(db, config);
		};
		const query = async (sql, params) => {
			return await client.unsafe(sql, params ?? []);
		};
		const proxy = async (params) => {
			const query$1 = client.unsafe(params.sql, params.params);
			if (params.mode === "array") return await query$1.values();
			return await query$1;
		};
		const transactionProxy = async (queries) => {
			const results = [];
			try {
				await client.transaction(async (tx) => {
					for (const query$1 of queries) {
						const result = await tx.unsafe(query$1.sql);
						results.push(result);
					}
				});
			} catch (error) {
				results.push(error);
			}
			return results;
		};
		return {
			packageName: "bun",
			query,
			proxy,
			transactionProxy,
			migrate: migrateFn
		};
	}
	console.error("To connect to Postgres database - please install either of 'pg', 'postgres', 'bun', '@neondatabase/serverless' or '@vercel/postgres' drivers");
	console.warn("For the 'bun' driver, run your script using: bun --bun");
	process.exit(1);
};
const prepareDuckDb = async (credentials) => {
	if (await checkPackage("@duckdb/node-api")) {
		console.log(require_views.withStyle.info(`Using '@duckdb/node-api' driver for database querying`));
		const { DuckDBInstance } = await import("@duckdb/node-api");
		const client = await (await DuckDBInstance.create(credentials.url)).connect();
		const query = async (sql, params = []) => {
			return await (await client.run(sql, params)).getRowObjectsJson();
		};
		const proxy = async (params) => {
			const result = await client.run(params.sql, params.params);
			return params.mode === "array" ? await result.getRowsJson() : await result.getRowObjectsJson();
		};
		const transactionProxy = async (queries) => {
			const results = [];
			try {
				await client.run("BEGIN");
				for (const query$1 of queries) {
					const result = await client.run(query$1.sql);
					results.push(await result.getRowObjectsJson());
				}
				await client.run("COMMIT");
			} catch (error) {
				await client.run("ROLLBACK");
				results.push(error);
			}
			return results;
		};
		return {
			packageName: "@duckdb/node-api",
			query,
			proxy,
			transactionProxy,
			migrate: () => {
				throw new Error("DuckDB does not support migrations");
			}
		};
	}
	console.error("To connect to DuckDb database - please install '@duckdb/node-api' driver");
	process.exit(1);
};
const parseSingleStoreCredentials = (credentials) => {
	if ("url" in credentials) {
		const url = credentials.url;
		const pathname = new URL(url).pathname;
		const database = pathname.split("/")[pathname.split("/").length - 1];
		if (!database) {
			console.error("You should specify a database name in connection string (singlestore://USER:PASSWORD@HOST:PORT/DATABASE)");
			process.exit(1);
		}
		return {
			database,
			url
		};
	} else return {
		database: credentials.database,
		credentials
	};
};
const connectToSingleStore = async (it) => {
	const result = parseSingleStoreCredentials(it);
	if (await checkPackage("mysql2")) {
		const { createConnection } = await Promise.resolve().then(() => require_chunk.__toDynamicImportESM()(require("./promise-BY0MOHXf.js")));
		const { drizzle } = await import("drizzle-orm/singlestore");
		const { migrate } = await import("drizzle-orm/singlestore/migrator");
		const connection = result.url ? await createConnection(result.url) : await createConnection(result.credentials);
		const db = drizzle({ client: connection });
		const migrateFn = async (config) => {
			return migrate(db, config);
		};
		await connection.connect();
		const query = async (sql, params) => {
			return (await connection.execute(sql, params))[0];
		};
		const proxy = async (params) => {
			return (await connection.query({
				sql: params.sql,
				values: params.params,
				rowsAsArray: params.mode === "array"
			}))[0];
		};
		const transactionProxy = async (queries) => {
			const results = [];
			try {
				await connection.beginTransaction();
				for (const query$1 of queries) {
					const res = await connection.query(query$1.sql);
					results.push(res[0]);
				}
				await connection.commit();
			} catch (error) {
				await connection.rollback();
				results.push(error);
			}
			return results;
		};
		return {
			db: { query },
			packageName: "mysql2",
			proxy,
			transactionProxy,
			database: result.database,
			migrate: migrateFn
		};
	}
	console.error("To connect to SingleStore database - please install 'mysql2' driver");
	process.exit(1);
};
const parseMysqlCredentials = (credentials) => {
	if ("url" in credentials) {
		const url = credentials.url;
		const pathname = new URL(url).pathname;
		const database = pathname.split("/")[pathname.split("/").length - 1];
		if (!database) {
			console.error("You should specify a database name in connection string (mysql://USER:PASSWORD@HOST:PORT/DATABASE)");
			process.exit(1);
		}
		return {
			database,
			url
		};
	} else return {
		database: credentials.database,
		credentials
	};
};
const connectToMySQL = async (it) => {
	const result = parseMysqlCredentials(it);
	if (await checkPackage("mysql2")) {
		console.log(require_views.withStyle.info(`Using 'mysql2' driver for database querying`));
		const { createConnection } = await Promise.resolve().then(() => require_chunk.__toDynamicImportESM()(require("./promise-BY0MOHXf.js")));
		const { drizzle } = await import("drizzle-orm/mysql2");
		const { migrate } = await import("drizzle-orm/mysql2/migrator");
		const connection = result.url ? await createConnection(result.url) : await createConnection(result.credentials);
		const db = drizzle({ client: connection });
		const migrateFn = async (config) => {
			return migrate(db, config);
		};
		const typeCast = (field, next) => {
			if (field.type === "TIMESTAMP" || field.type === "DATETIME" || field.type === "DATE") return field.string();
			return next();
		};
		const query = async (sql, params) => {
			return (await connection.execute({
				sql,
				values: params,
				typeCast
			}).catch((e) => {
				throw new QueryError(e, sql, params || []);
			}))[0];
		};
		const proxy = async (params) => {
			return (await connection.query({
				sql: params.sql,
				values: params.params,
				rowsAsArray: params.mode === "array",
				typeCast
			}).catch((e) => {
				throw new QueryError(e, params.sql, params.params || []);
			}))[0];
		};
		const transactionProxy = async (queries) => {
			const results = [];
			try {
				await connection.beginTransaction();
				for (const query$1 of queries) {
					const res = await connection.query({
						sql: query$1.sql,
						typeCast
					});
					results.push(res[0]);
				}
				await connection.commit();
			} catch (error) {
				await connection.rollback();
				results.push(error);
			}
			return results;
		};
		const benchmarkQuery = async (newConnection, sql, params) => {
			const explainResult = await connection.query({
				sql: `EXPLAIN ANALYZE ${sql}`,
				values: params ?? [],
				typeCast
			});
			const timeMatch = JSON.stringify(explainResult[0]).match(/actual time=([0-9.eE+-]+)\.\.([0-9.eE+-]+)/);
			let executionTime = Number(timeMatch[2]);
			let querySentAt = 0n;
			let firstDataAt = 0n;
			let lastDataAt = 0n;
			let lastRowParsedAt = 0n;
			let queryCompletedAt = 0n;
			let bytesReceived = 0;
			let rowCount = 0;
			let parseTime = 0;
			let lastParseTime = 0;
			querySentAt = process.hrtime.bigint();
			await new Promise((resolve, reject) => {
				const query$1 = newConnection.query({
					sql,
					values: params ?? [],
					typeCast
				});
				const originalRowHandler = query$1.row;
				let packets = 0;
				const wrappedRowListener = (packet, connection$1) => {
					packets += 1;
					if (firstDataAt === 0n) {
						firstDataAt = process.hrtime.bigint();
						bytesReceived += packet.start;
					}
					const start = process.hrtime.bigint();
					lastDataAt = start;
					const res = originalRowHandler.apply(query$1, [packet, connection$1]);
					const end = process.hrtime.bigint();
					lastRowParsedAt = end;
					lastParseTime = ms(start, end);
					parseTime += lastParseTime;
					bytesReceived += packet.length();
					if (!res || packet.isEOF()) return res;
					return wrappedRowListener;
				};
				query$1.row = wrappedRowListener;
				query$1.on("result", () => {
					rowCount += 1;
				});
				query$1.on("error", (err$1) => {
					reject(err$1);
				});
				query$1.on("end", () => {
					resolve();
				});
			});
			queryCompletedAt = process.hrtime.bigint();
			let querySentTime = ms(querySentAt, firstDataAt) - executionTime;
			if (querySentTime < 0) {
				const percent = .1;
				const overflow = -querySentTime;
				const keepForSent = overflow * percent;
				const adjustedOverflow = overflow * (1 + percent);
				const ratioExecution = executionTime / executionTime;
				executionTime -= adjustedOverflow * ratioExecution;
				querySentTime = keepForSent;
			}
			const networkLatencyBefore = querySentTime / 2;
			const networkLatencyAfter = querySentTime / 2;
			const downloadTime = ms(firstDataAt, lastDataAt) - (rowCount > 1 ? parseTime - lastParseTime : 0);
			const total = ms(querySentAt, queryCompletedAt);
			const calculatedTotal = networkLatencyBefore + executionTime + networkLatencyAfter + downloadTime + parseTime + ms(lastRowParsedAt, queryCompletedAt);
			const errorMargin = Math.abs(total - calculatedTotal);
			return {
				networkLatencyBefore,
				planning: null,
				execution: executionTime,
				networkLatencyAfter,
				dataDownload: downloadTime,
				dataParse: parseTime,
				total,
				errorMargin,
				dataSize: bytesReceived
			};
		};
		const benchmarkProxy = async ({ sql, params }, repeats) => {
			const { createConnection: createConnection$1 } = await import("mysql2");
			let startAt = 0n;
			let tcpConnectedAt = 0n;
			let tlsConnectedAt = null;
			const createStream = ({ config }) => {
				let stream;
				if (config.socketPath) stream = net.default.connect(config.socketPath);
				else stream = net.default.connect(config.port, config.host);
				if (config.enableKeepAlive) stream.on("connect", () => {
					stream.setKeepAlive(true, config.keepAliveInitialDelay);
				});
				stream.setNoDelay(true);
				stream.once("connect", () => {
					tcpConnectedAt = process.hrtime.bigint();
				});
				return stream;
			};
			startAt = process.hrtime.bigint();
			const connection$1 = result.url ? createConnection$1({
				uri: result.url,
				stream: createStream
			}) : createConnection$1({
				...result.credentials,
				stream: createStream
			});
			await new Promise((resolve, reject) => {
				connection$1.connect((err$1) => {
					tlsConnectedAt = process.hrtime.bigint();
					if (err$1) reject(err$1);
					else resolve();
				});
			});
			const results = [];
			for (let i = 0; i < repeats; i++) {
				const r = await benchmarkQuery(connection$1, sql, params);
				results.push(r);
			}
			connection$1.end();
			return {
				tcpHandshake: ms(startAt, tcpConnectedAt),
				tlsHandshake: tlsConnectedAt ? ms(tcpConnectedAt, tlsConnectedAt) : null,
				dbHandshake: null,
				queries: results
			};
		};
		return {
			db: { query },
			packageName: "mysql2",
			proxy,
			transactionProxy,
			benchmarkProxy,
			database: result.database,
			migrate: migrateFn
		};
	}
	if (await checkPackage("@planetscale/database")) {
		console.log(require_views.withStyle.info(`Using '@planetscale/database' driver for database querying`));
		const { Client } = await import("@planetscale/database");
		const { drizzle } = await import("drizzle-orm/planetscale-serverless");
		const { migrate } = await import("drizzle-orm/planetscale-serverless/migrator");
		const connection = new Client(result);
		const db = drizzle({ client: connection });
		const migrateFn = async (config) => {
			return migrate(db, config);
		};
		const query = async (sql, params) => {
			return (await connection.execute(sql, params).catch((e) => {
				throw new QueryError(e, sql, params || []);
			})).rows;
		};
		const proxy = async (params) => {
			return (await connection.execute(params.sql, params.params, params.mode === "array" ? { as: "array" } : void 0).catch((e) => {
				throw new QueryError(e, params.sql, params.params || []);
			})).rows;
		};
		const transactionProxy = async (queries) => {
			const results = [];
			try {
				await connection.transaction(async (tx) => {
					for (const query$1 of queries) {
						const res = await tx.execute(query$1.sql);
						results.push(res.rows);
					}
				});
			} catch (error) {
				results.push(error);
			}
			return results;
		};
		return {
			db: { query },
			packageName: "@planetscale/database",
			proxy,
			transactionProxy,
			database: result.database,
			migrate: migrateFn
		};
	}
	if (await checkPackage("bun")) {
		console.log(require_views.withStyle.info(`Using 'bun' driver for database querying`));
		const { SQL } = await import("bun");
		const { drizzle } = await import("drizzle-orm/bun-sql/mysql");
		const { migrate } = await import("drizzle-orm/bun-sql/mysql/migrator");
		const ssl = result.credentials && "ssl" in result.credentials ? result.credentials.ssl === "prefer" || result.credentials.ssl === "require" || result.credentials.ssl === "allow" ? true : false : void 0;
		const client = result.url ? new SQL(result.url) : new SQL({
			adapter: "mysql",
			...result.credentials,
			ssl
		});
		const db = drizzle({ client });
		const migrateFn = async (config) => {
			return migrate(db, config);
		};
		const query = async (sql, params) => {
			return await client.unsafe(sql, params ?? []);
		};
		const proxy = async (params) => {
			const query$1 = client.unsafe(params.sql, params.params);
			if (params.mode === "array") return await query$1.values();
			return await query$1;
		};
		const transactionProxy = async (queries) => {
			const results = [];
			try {
				await client.transaction(async (tx) => {
					for (const query$1 of queries) {
						const result$1 = await tx.unsafe(query$1.sql);
						results.push(result$1);
					}
				});
			} catch (error) {
				results.push(error);
			}
			return results;
		};
		return {
			packageName: "bun",
			db: { query },
			proxy,
			transactionProxy,
			migrate: migrateFn,
			database: result.database
		};
	}
	console.error("To connect to MySQL database - please install either of 'mysql2', 'bun' or '@planetscale/database' drivers");
	console.warn("For the 'bun' driver, run your script using: bun --bun");
	process.exit(1);
};
const prepareSqliteParams = (params, driver) => {
	return params.map((param) => {
		if (param && typeof param === "object" && "type" in param && "value" in param && param.type === "binary") {
			const value = typeof param.value === "object" ? JSON.stringify(param.value) : param.value;
			if (driver === "d1-http") return value;
			return Buffer.from(value);
		}
		return param;
	});
};
const preparePGliteParams = (params) => {
	return params.map((param) => {
		if (param && typeof param === "object" && "type" in param && "value" in param && param.type === "binary") return typeof param.value === "object" ? JSON.stringify(param.value) : param.value;
		return param;
	});
};
const connectToSQLite = async (credentials) => {
	if ("driver" in credentials) {
		const { driver } = credentials;
		if (driver === "d1-http") {
			const { drizzle } = await import("drizzle-orm/sqlite-proxy");
			const { migrate } = await import("drizzle-orm/sqlite-proxy/migrator");
			const remoteCallback = async (sql, params, method) => {
				const data = await (await fetch(`https://api.cloudflare.com/client/v4/accounts/${credentials.accountId}/d1/database/${credentials.databaseId}/${method === "values" ? "raw" : "query"}`, {
					method: "POST",
					body: JSON.stringify({
						sql,
						params
					}),
					headers: {
						"Content-Type": "application/json",
						Authorization: `Bearer ${credentials.token}`
					}
				}).catch((e) => {
					throw new QueryError(e, sql, params || []);
				})).json();
				if (!data.success) throw new QueryError(new Error(data.errors.map((it) => `${it.code}: ${it.message}`).join("\n")), sql, params || []);
				const result = data.result[0].results;
				return { rows: Array.isArray(result) ? result : result.rows };
			};
			const remoteBatchCallback = async (queries) => {
				const sql = queries.map((q) => q.sql).join("; ");
				const data = await (await fetch(`https://api.cloudflare.com/client/v4/accounts/${credentials.accountId}/d1/database/${credentials.databaseId}/query`, {
					method: "POST",
					body: JSON.stringify({ sql }),
					headers: {
						"Content-Type": "application/json",
						Authorization: `Bearer ${credentials.token}`
					}
				})).json();
				if (!data.success) throw new Error(data.errors.map((it) => `${it.code}: ${it.message}`).join("\n"));
				return { rows: data.result.map((result) => {
					const res = result.results;
					return Array.isArray(res) ? res : res.rows;
				}) };
			};
			const drzl = drizzle(remoteCallback);
			const migrateFn = async (config) => {
				return migrate(drzl, async (queries) => {
					for (const query$1 of queries) await remoteCallback(query$1, [], "run");
				}, config);
			};
			const query = async (sql, params) => {
				return (await remoteCallback(sql, params || [], "all")).rows;
			};
			const run = async (query$1) => {
				await remoteCallback(query$1, [], "run");
			};
			const proxy = async (params) => {
				const preparedParams = prepareSqliteParams(params.params || [], "d1-http");
				return (await remoteCallback(params.sql, preparedParams, params.mode === "array" ? "values" : "all")).rows;
			};
			const transactionProxy = async (queries) => {
				return (await remoteBatchCallback(queries)).rows;
			};
			return {
				query,
				run,
				packageName: "d1-http",
				proxy,
				transactionProxy,
				migrate: migrateFn
			};
		} else if (driver === "sqlite-cloud") {
			assertPackages("@sqlitecloud/drivers");
			const { Database } = await import("@sqlitecloud/drivers");
			const { drizzle } = await import("drizzle-orm/sqlite-cloud");
			const { migrate } = await import("drizzle-orm/sqlite-cloud/migrator");
			const client = new Database(credentials.url);
			const drzl = drizzle({ client });
			const migrateFn = async (config) => {
				return migrate(drzl, config);
			};
			const query = async (sql, params) => {
				const stmt = client.prepare(sql).bind(params || []);
				return await new Promise((resolve, reject) => {
					stmt.all((e, d) => {
						if (e) return reject(e);
						return resolve(d.map((v) => Object.fromEntries(Object.entries(v))));
					});
				});
			};
			const run = async (query$1) => {
				return await new Promise((resolve, reject) => {
					client.exec(query$1, (e) => {
						if (e) return reject(e);
						return resolve();
					});
				});
			};
			const proxy = async (params) => {
				const preparedParams = prepareSqliteParams(params.params || []);
				const stmt = client.prepare(params.sql).bind(preparedParams);
				return await new Promise((resolve, reject) => {
					stmt.all((e, d) => {
						if (e) return reject(e);
						if (params.mode === "array") return resolve((d || []).map((v) => v.getData()));
						else return resolve((d || []).map((v) => Object.fromEntries(Object.entries(v))));
					});
				});
			};
			const transactionProxy = async (queries) => {
				const results = [];
				try {
					await new Promise((resolve, reject) => {
						client.exec("BEGIN", (e) => {
							if (e) return reject(e);
							return resolve();
						});
					});
					for (const query$1 of queries) {
						const result = await new Promise((resolve, reject) => {
							client.all(query$1.sql, (e, d) => {
								if (e) return reject(e);
								return resolve((d || []).map((v) => Object.fromEntries(Object.entries(v))));
							});
						});
						results.push(result);
					}
					await new Promise((resolve, reject) => {
						client.exec("COMMIT", (e) => {
							if (e) return reject(e);
							return resolve();
						});
					});
				} catch (error) {
					results.push(error);
					await new Promise((resolve, reject) => {
						client.exec("ROLLBACK", (e) => {
							if (e) return reject(e);
							return resolve();
						});
					});
				}
				return results;
			};
			return {
				query,
				run,
				packageName: "@sqlitecloud/drivers",
				proxy,
				transactionProxy,
				migrate: migrateFn
			};
		} else require_utils.assertUnreachable(driver);
	}
	if (await checkPackage("@libsql/client")) {
		console.log(require_views.withStyle.info(`Using '@libsql/client' driver for database querying`));
		const { createClient } = await import("@libsql/client");
		const { drizzle } = await import("drizzle-orm/libsql");
		const { migrate } = await import("drizzle-orm/libsql/migrator");
		const client = createClient({ url: require_utils_node.normaliseSQLiteUrl(credentials.url, "libsql") });
		const drzl = drizzle({ client });
		const migrateFn = async (config) => {
			return migrate(drzl, config);
		};
		const query = async (sql, params) => {
			return (await client.execute({
				sql,
				args: params || []
			})).rows;
		};
		const run = async (query$1) => {
			await client.execute(query$1);
		};
		const proxy = async (params) => {
			const preparedParams = prepareSqliteParams(params.params || []);
			const result = await client.execute({
				sql: params.sql,
				args: preparedParams
			}).catch((e) => {
				throw new QueryError(e, params.sql, params.params || []);
			});
			if (params.mode === "array") return result.rows.map((row) => Object.values(row));
			else return result.rows;
		};
		const transactionProxy = async (queries) => {
			const results = [];
			let transaction = null;
			try {
				transaction = await client.transaction();
				for (const query$1 of queries) {
					const result = await transaction.execute(query$1.sql);
					results.push(result.rows);
				}
				await transaction.commit();
			} catch (error) {
				results.push(error);
				await transaction?.rollback();
			} finally {
				transaction?.close();
			}
			return results;
		};
		return {
			query,
			run,
			packageName: "@libsql/client",
			proxy,
			transactionProxy,
			migrate: migrateFn
		};
	}
	if (await checkPackage("@tursodatabase/database")) {
		console.log(require_views.withStyle.info(`Using '@tursodatabase/database' driver for database querying`));
		const { Database } = await import("@tursodatabase/database");
		const { drizzle } = await import("drizzle-orm/tursodatabase/database");
		const { migrate } = await import("drizzle-orm/tursodatabase/migrator");
		const client = new Database(require_utils_node.normaliseSQLiteUrl(credentials.url, "@tursodatabase/database"));
		const drzl = drizzle({ client });
		const migrateFn = async (config) => {
			return migrate(drzl, config);
		};
		const query = async (sql, params) => {
			return await client.prepare(sql).bind(preparePGliteParams(params || [])).all();
		};
		const proxy = async (params) => {
			const preparedParams = prepareSqliteParams(params.params || []);
			return client.prepare(params.sql).bind(preparedParams).raw(params.mode === "array").all();
		};
		const transactionProxy = async (queries) => {
			const results = [];
			try {
				await client.transaction(async () => {
					for (const query$1 of queries) {
						const result = await client.prepare(query$1.sql).all();
						results.push(result);
					}
				})();
			} catch (error) {
				results.push(error);
			}
			return results;
		};
		return {
			query,
			packageName: "@tursodatabase/database",
			proxy,
			transactionProxy,
			migrate: migrateFn,
			run: async (query$1) => {
				await client.exec(query$1).catch((e) => {
					throw new QueryError(e, query$1, []);
				});
			}
		};
	}
	if (await checkPackage("better-sqlite3")) {
		console.log(require_views.withStyle.info(`Using 'better-sqlite3' driver for database querying`));
		const { default: Database } = await import("better-sqlite3");
		const { drizzle } = await import("drizzle-orm/better-sqlite3");
		const { migrate } = await import("drizzle-orm/better-sqlite3/migrator");
		const sqlite = new Database(require_utils_node.normaliseSQLiteUrl(credentials.url, "better-sqlite"));
		const drzl = drizzle({ client: sqlite });
		const migrateFn = async (config) => {
			return migrate(drzl, config);
		};
		const db = {
			query: async (sql, params = []) => {
				return sqlite.prepare(sql).bind(params).all();
			},
			run: async (query) => {
				sqlite.prepare(query).run();
			}
		};
		const proxy = async (params) => {
			const preparedParams = prepareSqliteParams(params.params || []);
			if (params.method === "values" || params.method === "get" || params.method === "all") return sqlite.prepare(params.sql).raw(params.mode === "array").all(preparedParams);
			sqlite.prepare(params.sql).run(preparedParams);
			return [];
		};
		const transactionProxy = async (queries) => {
			const results = [];
			const tx = sqlite.transaction((queries$1) => {
				for (const query of queries$1) {
					let result = [];
					if (query.method === "values" || query.method === "get" || query.method === "all") result = sqlite.prepare(query.sql).all();
					else sqlite.prepare(query.sql).run();
					results.push(result);
				}
			});
			try {
				tx(queries);
			} catch (error) {
				results.push(error);
			}
			return results;
		};
		return {
			...db,
			packageName: "better-sqlite3",
			proxy,
			transactionProxy,
			migrate: migrateFn
		};
	}
	if (await checkPackage("bun")) {
		console.log(require_views.withStyle.info(`Using 'bun' driver for database querying`));
		const { SQL } = await import("bun");
		const { drizzle } = await import("drizzle-orm/bun-sql/sqlite");
		const { migrate } = await import("drizzle-orm/bun-sql/sqlite/migrator");
		const client = new SQL({
			adapter: "sqlite",
			filename: require_utils_node.normaliseSQLiteUrl(credentials.url, "bun")
		});
		const db = drizzle({ client });
		const migrateFn = async (config) => {
			return migrate(db, config);
		};
		const query = async (sql, params) => {
			return await client.unsafe(sql, params ?? []);
		};
		const run = async (sql) => {
			await client.unsafe(sql);
		};
		const proxy = async (params) => {
			const query$1 = client.unsafe(params.sql, params.params);
			if (params.mode === "array") return await query$1.values();
			return await query$1;
		};
		const transactionProxy = async (queries) => {
			const results = [];
			try {
				await client.transaction(async (tx) => {
					for (const query$1 of queries) {
						const result = await tx.unsafe(query$1.sql);
						results.push(result);
					}
				});
			} catch (error) {
				results.push(error);
			}
			return results;
		};
		return {
			packageName: "bun",
			query,
			run,
			proxy,
			transactionProxy,
			migrate: migrateFn
		};
	}
	console.log("Please install either 'better-sqlite3', 'bun', '@libsql/client' or '@tursodatabase/database' for Drizzle Kit to connect to SQLite databases");
	console.warn("For the 'bun' driver, run your script using: bun --bun");
	process.exit(1);
};
const connectToLibSQL = async (credentials) => {
	if (!await checkPackage("@libsql/client")) {
		console.log("Please install '@libsql/client' for Drizzle Kit to connect to LibSQL databases");
		process.exit(1);
	}
	const { createClient } = await import("@libsql/client");
	const { drizzle } = await import("drizzle-orm/libsql");
	const { migrate } = await import("drizzle-orm/libsql/migrator");
	const client = createClient({
		url: require_utils_node.normaliseSQLiteUrl(credentials.url, "libsql"),
		authToken: credentials.authToken
	});
	const drzl = drizzle({ client });
	const migrateFn = async (config) => {
		return migrate(drzl, config);
	};
	const db = {
		query: async (sql, params) => {
			return (await client.execute({
				sql,
				args: params || []
			}).catch((e) => {
				throw new QueryError(e, sql, params || []);
			})).rows;
		},
		run: async (query) => {
			await client.execute(query).catch((e) => {
				throw new QueryError(e, query, []);
			});
		},
		batchWithPragma: async (queries) => {
			await client.migrate(queries);
		}
	};
	const proxy = async (params) => {
		const preparedParams = prepareSqliteParams(params.params || []);
		const result = await client.execute({
			sql: params.sql,
			args: preparedParams
		});
		if (params.mode === "array") return result.rows.map((row) => Object.values(row));
		else return result.rows;
	};
	const transactionProxy = async (queries) => {
		const results = [];
		let transaction = null;
		try {
			transaction = await client.transaction();
			for (const query of queries) {
				const result = await transaction.execute(query.sql);
				results.push(result.rows);
			}
			await transaction.commit();
		} catch (error) {
			results.push(error);
			await transaction?.rollback();
		} finally {
			transaction?.close();
		}
		return results;
	};
	return {
		...db,
		packageName: "@libsql/client",
		proxy,
		transactionProxy,
		migrate: migrateFn
	};
};

//#endregion
exports.connectToLibSQL = connectToLibSQL;
exports.connectToMySQL = connectToMySQL;
exports.connectToSQLite = connectToSQLite;
exports.connectToSingleStore = connectToSingleStore;
exports.prepareDuckDb = prepareDuckDb;
exports.preparePostgresDB = preparePostgresDB;