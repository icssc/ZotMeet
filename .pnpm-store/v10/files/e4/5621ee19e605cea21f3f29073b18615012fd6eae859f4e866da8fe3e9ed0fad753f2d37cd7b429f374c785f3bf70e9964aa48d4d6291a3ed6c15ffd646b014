{"version":3,"sources":["../../../src/lib/recursive-delete.ts"],"sourcesContent":["import type { Dirent } from 'node:fs'\nimport * as fs from 'node:fs'\nimport { join } from 'node:path'\nimport isError from './is-error'\nimport { wait } from './wait'\n\n// We use an exponential backoff. See the unit test for example values.\n//\n// - Node's `fs` module uses a linear backoff, starting with 100ms.\n// - Rust tries 64 times with only a `thread::yield_now` in between.\n//\n// We want something more aggressive, as `recursiveDelete` is in the critical\n// path of `next dev` and `next build` startup.\nconst INITIAL_RETRY_MS = 8\nconst MAX_RETRY_MS = 64\nconst MAX_RETRIES = 6\n\n/**\n * Used in unit test.\n * @ignore\n */\nexport function calcBackoffMs(attempt: number): number {\n  return Math.min(INITIAL_RETRY_MS * Math.pow(2, attempt), MAX_RETRY_MS)\n}\n\nfunction unlinkPath(\n  p: string,\n  isDir = false,\n  attempt = 0\n): Promise<void> | void {\n  try {\n    if (isDir) {\n      fs.rmdirSync(p)\n    } else {\n      fs.unlinkSync(p)\n    }\n  } catch (e) {\n    const code = isError(e) && e.code\n    if (\n      (code === 'EBUSY' ||\n        code === 'ENOTEMPTY' ||\n        code === 'EPERM' ||\n        code === 'EMFILE') &&\n      attempt < MAX_RETRIES\n    ) {\n      // retrying is unlikely to succeed on POSIX platforms, but Windows can\n      // fail due to temporarily-open files\n      return (async () => {\n        await wait(calcBackoffMs(attempt))\n        return unlinkPath(p, isDir, attempt + 1)\n      })()\n    }\n\n    if (code === 'ENOENT') {\n      return\n    }\n\n    throw e\n  }\n}\n\n/**\n * Recursively delete directory contents.\n *\n * This is used when cleaning the `distDir`, and is part of the critical path\n * for starting the server, so we use synchronous file IO, as we're always\n * blocked on it anyways.\n *\n * Despite using sync IO, the function signature is still `async` because we\n * asynchronously perform retries.\n */\nexport async function recursiveDeleteSyncWithAsyncRetries(\n  /** Directory to delete the contents of */\n  dir: string,\n  /** Exclude based on relative file path */\n  exclude?: RegExp,\n  /** Relative path to the directory being deleted, used for exclude */\n  previousPath: string = ''\n): Promise<void> {\n  let result\n  try {\n    result = fs.readdirSync(dir, { withFileTypes: true })\n  } catch (e) {\n    if (isError(e) && e.code === 'ENOENT') {\n      return\n    }\n    throw e\n  }\n\n  await Promise.all(\n    result.map(async (part: Dirent) => {\n      const absolutePath = join(dir, part.name)\n      const pp = join(previousPath, part.name)\n      const isNotExcluded = !exclude || !exclude.test(pp)\n\n      if (isNotExcluded) {\n        // Note: readdir does not follow symbolic links, that's good: we want to\n        // delete the links and not the destination.\n        let isDirectory = part.isDirectory()\n        if (isDirectory) {\n          await recursiveDeleteSyncWithAsyncRetries(absolutePath, exclude, pp)\n        }\n        return unlinkPath(absolutePath, isDirectory)\n      }\n    })\n  )\n}\n"],"names":["fs","join","isError","wait","INITIAL_RETRY_MS","MAX_RETRY_MS","MAX_RETRIES","calcBackoffMs","attempt","Math","min","pow","unlinkPath","p","isDir","rmdirSync","unlinkSync","e","code","recursiveDeleteSyncWithAsyncRetries","dir","exclude","previousPath","result","readdirSync","withFileTypes","Promise","all","map","part","absolutePath","name","pp","isNotExcluded","test","isDirectory"],"mappings":"AACA,YAAYA,QAAQ,UAAS;AAC7B,SAASC,IAAI,QAAQ,YAAW;AAChC,OAAOC,aAAa,aAAY;AAChC,SAASC,IAAI,QAAQ,SAAQ;AAE7B,uEAAuE;AACvE,EAAE;AACF,mEAAmE;AACnE,oEAAoE;AACpE,EAAE;AACF,6EAA6E;AAC7E,+CAA+C;AAC/C,MAAMC,mBAAmB;AACzB,MAAMC,eAAe;AACrB,MAAMC,cAAc;AAEpB;;;CAGC,GACD,OAAO,SAASC,cAAcC,OAAe;IAC3C,OAAOC,KAAKC,GAAG,CAACN,mBAAmBK,KAAKE,GAAG,CAAC,GAAGH,UAAUH;AAC3D;AAEA,SAASO,WACPC,CAAS,EACTC,QAAQ,KAAK,EACbN,UAAU,CAAC;IAEX,IAAI;QACF,IAAIM,OAAO;YACTd,GAAGe,SAAS,CAACF;QACf,OAAO;YACLb,GAAGgB,UAAU,CAACH;QAChB;IACF,EAAE,OAAOI,GAAG;QACV,MAAMC,OAAOhB,QAAQe,MAAMA,EAAEC,IAAI;QACjC,IACE,AAACA,CAAAA,SAAS,WACRA,SAAS,eACTA,SAAS,WACTA,SAAS,QAAO,KAClBV,UAAUF,aACV;YACA,sEAAsE;YACtE,qCAAqC;YACrC,OAAO,AAAC,CAAA;gBACN,MAAMH,KAAKI,cAAcC;gBACzB,OAAOI,WAAWC,GAAGC,OAAON,UAAU;YACxC,CAAA;QACF;QAEA,IAAIU,SAAS,UAAU;YACrB;QACF;QAEA,MAAMD;IACR;AACF;AAEA;;;;;;;;;CASC,GACD,OAAO,eAAeE,oCACpB,wCAAwC,GACxCC,GAAW,EACX,wCAAwC,GACxCC,OAAgB,EAChB,mEAAmE,GACnEC,eAAuB,EAAE;IAEzB,IAAIC;IACJ,IAAI;QACFA,SAASvB,GAAGwB,WAAW,CAACJ,KAAK;YAAEK,eAAe;QAAK;IACrD,EAAE,OAAOR,GAAG;QACV,IAAIf,QAAQe,MAAMA,EAAEC,IAAI,KAAK,UAAU;YACrC;QACF;QACA,MAAMD;IACR;IAEA,MAAMS,QAAQC,GAAG,CACfJ,OAAOK,GAAG,CAAC,OAAOC;QAChB,MAAMC,eAAe7B,KAAKmB,KAAKS,KAAKE,IAAI;QACxC,MAAMC,KAAK/B,KAAKqB,cAAcO,KAAKE,IAAI;QACvC,MAAME,gBAAgB,CAACZ,WAAW,CAACA,QAAQa,IAAI,CAACF;QAEhD,IAAIC,eAAe;YACjB,wEAAwE;YACxE,4CAA4C;YAC5C,IAAIE,cAAcN,KAAKM,WAAW;YAClC,IAAIA,aAAa;gBACf,MAAMhB,oCAAoCW,cAAcT,SAASW;YACnE;YACA,OAAOpB,WAAWkB,cAAcK;QAClC;IACF;AAEJ","ignoreList":[0]}