{"version":3,"file":"indexes.cjs","names":["entityKind","unique: boolean","name?: string","SQL","ExtraConfigColumn","IndexedColumn"],"sources":["../../src/pg-core/indexes.ts"],"sourcesContent":["import { entityKind, is } from '~/entity.ts';\nimport { SQL } from '~/sql/sql.ts';\nimport { ExtraConfigColumn } from './columns/index.ts';\nimport type { PgColumn } from './columns/index.ts';\nimport { IndexedColumn } from './columns/index.ts';\nimport type { PgTable } from './table.ts';\n\ninterface IndexConfig {\n\tname?: string;\n\n\tcolumns: Partial<IndexedColumn | SQL>[];\n\n\t/**\n\t * If true, the index will be created as `create unique index` instead of `create index`.\n\t */\n\tunique: boolean;\n\n\t/**\n\t * If true, the index will be created as `create index concurrently` instead of `create index`.\n\t */\n\tconcurrently?: boolean;\n\n\t/**\n\t * If true, the index will be created as `create index ... on only <table>` instead of `create index ... on <table>`.\n\t */\n\tonly: boolean;\n\n\t/**\n\t * Condition for partial index.\n\t */\n\twhere?: SQL;\n\n\t/**\n\t * The optional WITH clause specifies storage parameters for the index\n\t */\n\twith?: Record<string, any>;\n\n\t/**\n\t * The optional WITH clause method for the index\n\t */\n\tmethod?: 'btree' | string;\n}\n\nexport type IndexColumn = PgColumn;\n\nexport type PgIndexMethod = 'btree' | 'hash' | 'gist' | 'spgist' | 'gin' | 'brin' | 'hnsw' | 'ivfflat' | (string & {});\n\nexport type PgIndexOpClass =\n\t| 'abstime_ops'\n\t| 'access_method'\n\t| 'anyarray_eq'\n\t| 'anyarray_ge'\n\t| 'anyarray_gt'\n\t| 'anyarray_le'\n\t| 'anyarray_lt'\n\t| 'anyarray_ne'\n\t| 'bigint_ops'\n\t| 'bit_ops'\n\t| 'bool_ops'\n\t| 'box_ops'\n\t| 'bpchar_ops'\n\t| 'char_ops'\n\t| 'cidr_ops'\n\t| 'cstring_ops'\n\t| 'date_ops'\n\t| 'float_ops'\n\t| 'int2_ops'\n\t| 'int4_ops'\n\t| 'int8_ops'\n\t| 'interval_ops'\n\t| 'jsonb_ops'\n\t| 'macaddr_ops'\n\t| 'name_ops'\n\t| 'numeric_ops'\n\t| 'oid_ops'\n\t| 'oidint4_ops'\n\t| 'oidint8_ops'\n\t| 'oidname_ops'\n\t| 'oidvector_ops'\n\t| 'point_ops'\n\t| 'polygon_ops'\n\t| 'range_ops'\n\t| 'record_eq'\n\t| 'record_ge'\n\t| 'record_gt'\n\t| 'record_le'\n\t| 'record_lt'\n\t| 'record_ne'\n\t| 'text_ops'\n\t| 'time_ops'\n\t| 'timestamp_ops'\n\t| 'timestamptz_ops'\n\t| 'timetz_ops'\n\t| 'uuid_ops'\n\t| 'varbit_ops'\n\t| 'varchar_ops'\n\t// pg_vector types\n\t| 'xml_ops'\n\t| 'vector_l2_ops'\n\t| 'vector_ip_ops'\n\t| 'vector_cosine_ops'\n\t| 'vector_l1_ops'\n\t| 'bit_hamming_ops'\n\t| 'bit_jaccard_ops'\n\t| 'halfvec_l2_ops'\n\t| 'sparsevec_l2_op'\n\t| (string & {});\n\nexport class IndexBuilderOn {\n\tstatic readonly [entityKind]: string = 'PgIndexBuilderOn';\n\n\tconstructor(private unique: boolean, private name?: string) {}\n\n\ton(\n\t\t...columns: [Partial<ExtraConfigColumn> | SQL | PgColumn, ...(Partial<ExtraConfigColumn | SQL | PgColumn>)[]]\n\t): IndexBuilder {\n\t\treturn new IndexBuilder(\n\t\t\tcolumns.map((it) => {\n\t\t\t\tif (is(it, SQL)) {\n\t\t\t\t\treturn it;\n\t\t\t\t}\n\n\t\t\t\tif (is(it, ExtraConfigColumn)) {\n\t\t\t\t\tconst clonedIndexedColumn = new IndexedColumn(\n\t\t\t\t\t\tit.name,\n\t\t\t\t\t\t!!it.keyAsName,\n\t\t\t\t\t\tit.columnType!,\n\t\t\t\t\t\tit.indexConfig!,\n\t\t\t\t\t);\n\t\t\t\t\tit.indexConfig = JSON.parse(JSON.stringify(it.defaultConfig));\n\t\t\t\t\treturn clonedIndexedColumn;\n\t\t\t\t}\n\n\t\t\t\tit = it as PgColumn;\n\n\t\t\t\treturn new IndexedColumn(\n\t\t\t\t\tit.name,\n\t\t\t\t\t!!it.keyAsName,\n\t\t\t\t\tit.columnType!,\n\t\t\t\t\t{},\n\t\t\t\t);\n\t\t\t}),\n\t\t\tthis.unique,\n\t\t\tfalse,\n\t\t\tthis.name,\n\t\t);\n\t}\n\n\tonOnly(\n\t\t...columns: [Partial<ExtraConfigColumn | SQL | PgColumn>, ...Partial<ExtraConfigColumn | SQL | PgColumn>[]]\n\t): IndexBuilder {\n\t\treturn new IndexBuilder(\n\t\t\tcolumns.map((it) => {\n\t\t\t\tif (is(it, SQL)) {\n\t\t\t\t\treturn it;\n\t\t\t\t}\n\n\t\t\t\tif (is(it, ExtraConfigColumn)) {\n\t\t\t\t\tconst clonedIndexedColumn = new IndexedColumn(\n\t\t\t\t\t\tit.name,\n\t\t\t\t\t\t!!it.keyAsName,\n\t\t\t\t\t\tit.columnType!,\n\t\t\t\t\t\tit.indexConfig!,\n\t\t\t\t\t);\n\t\t\t\t\tit.indexConfig = JSON.parse(JSON.stringify(it.defaultConfig));\n\t\t\t\t\treturn clonedIndexedColumn;\n\t\t\t\t}\n\n\t\t\t\tit = it as PgColumn;\n\n\t\t\t\treturn new IndexedColumn(\n\t\t\t\t\tit.name,\n\t\t\t\t\t!!it.keyAsName,\n\t\t\t\t\tit.columnType!,\n\t\t\t\t\t{},\n\t\t\t\t);\n\t\t\t}),\n\t\t\tthis.unique,\n\t\t\ttrue,\n\t\t\tthis.name,\n\t\t);\n\t}\n\n\t/**\n\t * Specify what index method to use. Choices are `btree`, `hash`, `gist`, `spgist`, `gin`, `brin`, or user-installed access methods like `bloom`. The default method is `btree.\n\t *\n\t * If you have the `pg_vector` extension installed in your database, you can use the `hnsw` and `ivfflat` options, which are predefined types.\n\t *\n\t * **You can always specify any string you want in the method, in case Drizzle doesn't have it natively in its types**\n\t *\n\t * @param method The name of the index method to be used\n\t * @param columns\n\t * @returns\n\t */\n\tusing(\n\t\tmethod: PgIndexMethod,\n\t\t...columns: [Partial<ExtraConfigColumn | SQL | PgColumn>, ...Partial<ExtraConfigColumn | SQL | PgColumn>[]]\n\t): IndexBuilder {\n\t\treturn new IndexBuilder(\n\t\t\tcolumns.map((it) => {\n\t\t\t\tif (is(it, SQL)) {\n\t\t\t\t\treturn it;\n\t\t\t\t}\n\t\t\t\tif (is(it, ExtraConfigColumn)) {\n\t\t\t\t\tconst clonedIndexedColumn = new IndexedColumn(\n\t\t\t\t\t\tit.name,\n\t\t\t\t\t\t!!it.keyAsName,\n\t\t\t\t\t\tit.columnType!,\n\t\t\t\t\t\tit.indexConfig!,\n\t\t\t\t\t);\n\t\t\t\t\tit.indexConfig = JSON.parse(JSON.stringify(it.defaultConfig));\n\t\t\t\t\treturn clonedIndexedColumn;\n\t\t\t\t}\n\n\t\t\t\tit = it as PgColumn;\n\n\t\t\t\treturn new IndexedColumn(\n\t\t\t\t\tit.name,\n\t\t\t\t\t!!it.keyAsName,\n\t\t\t\t\tit.columnType!,\n\t\t\t\t\t{},\n\t\t\t\t);\n\t\t\t}),\n\t\t\tthis.unique,\n\t\t\ttrue,\n\t\t\tthis.name,\n\t\t\tmethod,\n\t\t);\n\t}\n}\n\nexport interface AnyIndexBuilder {\n\tbuild(table: PgTable): Index;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\nexport interface IndexBuilder extends AnyIndexBuilder {}\n\nexport class IndexBuilder implements AnyIndexBuilder {\n\tstatic readonly [entityKind]: string = 'PgIndexBuilder';\n\n\t/** @internal */\n\tconfig: IndexConfig;\n\n\tconstructor(\n\t\tcolumns: Partial<IndexedColumn | SQL>[],\n\t\tunique: boolean,\n\t\tonly: boolean,\n\t\tname?: string,\n\t\tmethod: string = 'btree',\n\t) {\n\t\tthis.config = {\n\t\t\tname,\n\t\t\tcolumns,\n\t\t\tunique,\n\t\t\tonly,\n\t\t\tmethod,\n\t\t};\n\t}\n\n\tconcurrently(): this {\n\t\tthis.config.concurrently = true;\n\t\treturn this;\n\t}\n\n\twith(obj: Record<string, any>): this {\n\t\tthis.config.with = obj;\n\t\treturn this;\n\t}\n\n\twhere(condition: SQL): this {\n\t\tthis.config.where = condition;\n\t\treturn this;\n\t}\n\n\t/** @internal */\n\tbuild(table: PgTable): Index {\n\t\treturn new Index(this.config, table);\n\t}\n}\n\nexport class Index {\n\tstatic readonly [entityKind]: string = 'PgIndex';\n\n\treadonly config: IndexConfig & { table: PgTable };\n\treadonly isNameExplicit: boolean;\n\n\tconstructor(config: IndexConfig, table: PgTable) {\n\t\tthis.config = { ...config, table };\n\t\tthis.isNameExplicit = !!config.name;\n\t}\n}\n\nexport type GetColumnsTableName<TColumns> = TColumns extends PgColumn ? TColumns['_']['name']\n\t: TColumns extends PgColumn[] ? TColumns[number]['_']['name']\n\t: never;\n\nexport function index(name?: string): IndexBuilderOn {\n\treturn new IndexBuilderOn(false, name);\n}\n\nexport function uniqueIndex(name?: string): IndexBuilderOn {\n\treturn new IndexBuilderOn(true, name);\n}\n"],"mappings":";;;;;;AA4GA,IAAa,iBAAb,MAA4B;CAC3B,QAAiBA,0BAAsB;CAEvC,YAAY,AAAQC,QAAiB,AAAQC,MAAe;EAAxC;EAAyB;;CAE7C,GACC,GAAG,SACY;AACf,SAAO,IAAI,aACV,QAAQ,KAAK,OAAO;AACnB,2BAAO,IAAIC,iBAAI,CACd,QAAO;AAGR,2BAAO,IAAIC,iDAAkB,EAAE;IAC9B,MAAM,sBAAsB,IAAIC,6CAC/B,GAAG,MACH,CAAC,CAAC,GAAG,WACL,GAAG,YACH,GAAG,YACH;AACD,OAAG,cAAc,KAAK,MAAM,KAAK,UAAU,GAAG,cAAc,CAAC;AAC7D,WAAO;;AAGR,QAAK;AAEL,UAAO,IAAIA,6CACV,GAAG,MACH,CAAC,CAAC,GAAG,WACL,GAAG,YACH,EAAE,CACF;IACA,EACF,KAAK,QACL,OACA,KAAK,KACL;;CAGF,OACC,GAAG,SACY;AACf,SAAO,IAAI,aACV,QAAQ,KAAK,OAAO;AACnB,2BAAO,IAAIF,iBAAI,CACd,QAAO;AAGR,2BAAO,IAAIC,iDAAkB,EAAE;IAC9B,MAAM,sBAAsB,IAAIC,6CAC/B,GAAG,MACH,CAAC,CAAC,GAAG,WACL,GAAG,YACH,GAAG,YACH;AACD,OAAG,cAAc,KAAK,MAAM,KAAK,UAAU,GAAG,cAAc,CAAC;AAC7D,WAAO;;AAGR,QAAK;AAEL,UAAO,IAAIA,6CACV,GAAG,MACH,CAAC,CAAC,GAAG,WACL,GAAG,YACH,EAAE,CACF;IACA,EACF,KAAK,QACL,MACA,KAAK,KACL;;;;;;;;;;;;;CAcF,MACC,QACA,GAAG,SACY;AACf,SAAO,IAAI,aACV,QAAQ,KAAK,OAAO;AACnB,2BAAO,IAAIF,iBAAI,CACd,QAAO;AAER,2BAAO,IAAIC,iDAAkB,EAAE;IAC9B,MAAM,sBAAsB,IAAIC,6CAC/B,GAAG,MACH,CAAC,CAAC,GAAG,WACL,GAAG,YACH,GAAG,YACH;AACD,OAAG,cAAc,KAAK,MAAM,KAAK,UAAU,GAAG,cAAc,CAAC;AAC7D,WAAO;;AAGR,QAAK;AAEL,UAAO,IAAIA,6CACV,GAAG,MACH,CAAC,CAAC,GAAG,WACL,GAAG,YACH,EAAE,CACF;IACA,EACF,KAAK,QACL,MACA,KAAK,MACL,OACA;;;AAWH,IAAa,eAAb,MAAqD;CACpD,QAAiBL,0BAAsB;;CAGvC;CAEA,YACC,SACA,QACA,MACA,MACA,SAAiB,SAChB;AACD,OAAK,SAAS;GACb;GACA;GACA;GACA;GACA;GACA;;CAGF,eAAqB;AACpB,OAAK,OAAO,eAAe;AAC3B,SAAO;;CAGR,KAAK,KAAgC;AACpC,OAAK,OAAO,OAAO;AACnB,SAAO;;CAGR,MAAM,WAAsB;AAC3B,OAAK,OAAO,QAAQ;AACpB,SAAO;;;CAIR,MAAM,OAAuB;AAC5B,SAAO,IAAI,MAAM,KAAK,QAAQ,MAAM;;;AAItC,IAAa,QAAb,MAAmB;CAClB,QAAiBA,0BAAsB;CAEvC,AAAS;CACT,AAAS;CAET,YAAY,QAAqB,OAAgB;AAChD,OAAK,SAAS;GAAE,GAAG;GAAQ;GAAO;AAClC,OAAK,iBAAiB,CAAC,CAAC,OAAO;;;AAQjC,SAAgB,MAAM,MAA+B;AACpD,QAAO,IAAI,eAAe,OAAO,KAAK;;AAGvC,SAAgB,YAAY,MAA+B;AAC1D,QAAO,IAAI,eAAe,MAAM,KAAK"}