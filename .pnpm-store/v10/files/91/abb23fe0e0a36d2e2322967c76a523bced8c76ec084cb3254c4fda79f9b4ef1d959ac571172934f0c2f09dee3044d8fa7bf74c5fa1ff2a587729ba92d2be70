const require_chunk = require('./chunk-CdAKIUsw.js');
const require_utils = require('./utils-D2E5ChQ0.js');
let _js_temporal_polyfill = require("@js-temporal/polyfill");

//#region ../node_modules/.pnpm/ohm-js@17.2.1/node_modules/ohm-js/src/common.js
var common_exports = /* @__PURE__ */ require_chunk.__exportAll({
	StringBuffer: () => StringBuffer,
	abstract: () => abstract,
	assert: () => assert,
	checkNotNull: () => checkNotNull,
	clone: () => clone,
	copyWithoutDuplicates: () => copyWithoutDuplicates,
	defineLazyProperty: () => defineLazyProperty,
	getDuplicates: () => getDuplicates,
	isLexical: () => isLexical,
	isSyntactic: () => isSyntactic,
	padLeft: () => padLeft,
	repeat: () => repeat,
	repeatFn: () => repeatFn,
	repeatStr: () => repeatStr,
	unescapeCodePoint: () => unescapeCodePoint,
	unexpectedObjToString: () => unexpectedObjToString
});
const escapeStringFor = {};
for (let c = 0; c < 128; c++) escapeStringFor[c] = String.fromCharCode(c);
escapeStringFor["'".charCodeAt(0)] = "\\'";
escapeStringFor["\"".charCodeAt(0)] = "\\\"";
escapeStringFor["\\".charCodeAt(0)] = "\\\\";
escapeStringFor["\b".charCodeAt(0)] = "\\b";
escapeStringFor["\f".charCodeAt(0)] = "\\f";
escapeStringFor["\n".charCodeAt(0)] = "\\n";
escapeStringFor["\r".charCodeAt(0)] = "\\r";
escapeStringFor["	".charCodeAt(0)] = "\\t";
escapeStringFor["\v".charCodeAt(0)] = "\\v";
function abstract(optMethodName) {
	const methodName = optMethodName || "";
	return function() {
		throw new Error("this method " + methodName + " is abstract! (it has no implementation in class " + this.constructor.name + ")");
	};
}
function assert(cond, message) {
	if (!cond) throw new Error(message || "Assertion failed");
}
function defineLazyProperty(obj, propName, getterFn) {
	let memo;
	Object.defineProperty(obj, propName, { get() {
		if (!memo) memo = getterFn.call(this);
		return memo;
	} });
}
function clone(obj) {
	if (obj) return Object.assign({}, obj);
	return obj;
}
function repeatFn(fn, n) {
	const arr = [];
	while (n-- > 0) arr.push(fn());
	return arr;
}
function repeatStr(str, n) {
	return new Array(n + 1).join(str);
}
function repeat(x, n) {
	return repeatFn(() => x, n);
}
function getDuplicates(array) {
	const duplicates = [];
	for (let idx = 0; idx < array.length; idx++) {
		const x = array[idx];
		if (array.lastIndexOf(x) !== idx && duplicates.indexOf(x) < 0) duplicates.push(x);
	}
	return duplicates;
}
function copyWithoutDuplicates(array) {
	const noDuplicates = [];
	array.forEach((entry) => {
		if (noDuplicates.indexOf(entry) < 0) noDuplicates.push(entry);
	});
	return noDuplicates;
}
function isSyntactic(ruleName) {
	const firstChar = ruleName[0];
	return firstChar === firstChar.toUpperCase();
}
function isLexical(ruleName) {
	return !isSyntactic(ruleName);
}
function padLeft(str, len, optChar) {
	const ch = optChar || " ";
	if (str.length < len) return repeatStr(ch, len - str.length) + str;
	return str;
}
function StringBuffer() {
	this.strings = [];
}
StringBuffer.prototype.append = function(str) {
	this.strings.push(str);
};
StringBuffer.prototype.contents = function() {
	return this.strings.join("");
};
const escapeUnicode = (str) => String.fromCodePoint(parseInt(str, 16));
function unescapeCodePoint(s) {
	if (s.charAt(0) === "\\") switch (s.charAt(1)) {
		case "b": return "\b";
		case "f": return "\f";
		case "n": return "\n";
		case "r": return "\r";
		case "t": return "	";
		case "v": return "\v";
		case "x": return escapeUnicode(s.slice(2, 4));
		case "u": return s.charAt(2) === "{" ? escapeUnicode(s.slice(3, -1)) : escapeUnicode(s.slice(2, 6));
		default: return s.charAt(1);
	}
	else return s;
}
function unexpectedObjToString(obj) {
	if (obj == null) return String(obj);
	const baseToString = Object.prototype.toString.call(obj);
	try {
		let typeName;
		if (obj.constructor && obj.constructor.name) typeName = obj.constructor.name;
		else if (baseToString.indexOf("[object ") === 0) typeName = baseToString.slice(8, -1);
		else typeName = typeof obj;
		return typeName + ": " + JSON.stringify(String(obj));
	} catch (e) {
		return baseToString;
	}
}
function checkNotNull(obj, message = "unexpected null value") {
	if (obj == null) throw new Error(message);
	return obj;
}

//#endregion
//#region ../node_modules/.pnpm/ohm-js@17.2.1/node_modules/ohm-js/src/UnicodeCategories.js
const UnicodeCategories = {
	Lu: /\p{Lu}/u,
	Ll: /\p{Ll}/u,
	Lt: /\p{Lt}/u,
	Lm: /\p{Lm}/u,
	Lo: /\p{Lo}/u,
	Nl: /\p{Nl}/u,
	Nd: /\p{Nd}/u,
	Mn: /\p{Mn}/u,
	Mc: /\p{Mc}/u,
	Pc: /\p{Pc}/u,
	Zs: /\p{Zs}/u,
	L: /\p{Letter}/u,
	Ltmo: /\p{Lt}|\p{Lm}|\p{Lo}/u
};

//#endregion
//#region ../node_modules/.pnpm/ohm-js@17.2.1/node_modules/ohm-js/src/pexprs-main.js
var PExpr = class PExpr {
	constructor() {
		if (this.constructor === PExpr) throw new Error("PExpr cannot be instantiated -- it's abstract");
	}
	withSource(interval) {
		if (interval) this.source = interval.trimmed();
		return this;
	}
};
const any = Object.create(PExpr.prototype);
const end = Object.create(PExpr.prototype);
var Terminal = class extends PExpr {
	constructor(obj) {
		super();
		this.obj = obj;
	}
};
var Range = class extends PExpr {
	constructor(from, to) {
		super();
		this.from = from;
		this.to = to;
		this.matchCodePoint = from.length > 1 || to.length > 1;
	}
};
var Param = class extends PExpr {
	constructor(index) {
		super();
		this.index = index;
	}
};
var Alt = class extends PExpr {
	constructor(terms) {
		super();
		this.terms = terms;
	}
};
var Extend = class extends Alt {
	constructor(superGrammar, name, body) {
		const origBody = superGrammar.rules[name].body;
		super([body, origBody]);
		this.superGrammar = superGrammar;
		this.name = name;
		this.body = body;
	}
};
var Splice = class extends Alt {
	constructor(superGrammar, ruleName, beforeTerms, afterTerms) {
		const origBody = superGrammar.rules[ruleName].body;
		super([
			...beforeTerms,
			origBody,
			...afterTerms
		]);
		this.superGrammar = superGrammar;
		this.ruleName = ruleName;
		this.expansionPos = beforeTerms.length;
	}
};
var Seq = class extends PExpr {
	constructor(factors) {
		super();
		this.factors = factors;
	}
};
var Iter = class extends PExpr {
	constructor(expr) {
		super();
		this.expr = expr;
	}
};
var Star = class extends Iter {};
var Plus = class extends Iter {};
var Opt = class extends Iter {};
Star.prototype.operator = "*";
Plus.prototype.operator = "+";
Opt.prototype.operator = "?";
Star.prototype.minNumMatches = 0;
Plus.prototype.minNumMatches = 1;
Opt.prototype.minNumMatches = 0;
Star.prototype.maxNumMatches = Number.POSITIVE_INFINITY;
Plus.prototype.maxNumMatches = Number.POSITIVE_INFINITY;
Opt.prototype.maxNumMatches = 1;
var Not = class extends PExpr {
	constructor(expr) {
		super();
		this.expr = expr;
	}
};
var Lookahead = class extends PExpr {
	constructor(expr) {
		super();
		this.expr = expr;
	}
};
var Lex = class extends PExpr {
	constructor(expr) {
		super();
		this.expr = expr;
	}
};
var Apply = class extends PExpr {
	constructor(ruleName, args = []) {
		super();
		this.ruleName = ruleName;
		this.args = args;
	}
	isSyntactic() {
		return isSyntactic(this.ruleName);
	}
	toMemoKey() {
		if (!this._memoKey) Object.defineProperty(this, "_memoKey", { value: this.toString() });
		return this._memoKey;
	}
};
var UnicodeChar = class extends PExpr {
	constructor(category) {
		super();
		this.category = category;
		this.pattern = UnicodeCategories[category];
	}
};

//#endregion
//#region ../node_modules/.pnpm/ohm-js@17.2.1/node_modules/ohm-js/src/errors.js
function createError(message, optInterval) {
	let e;
	if (optInterval) {
		e = new Error(optInterval.getLineAndColumnMessage() + message);
		e.shortMessage = message;
		e.interval = optInterval;
	} else e = new Error(message);
	return e;
}
function intervalSourcesDontMatch() {
	return createError("Interval sources don't match");
}
function undeclaredGrammar(grammarName, namespace, interval) {
	return createError(namespace ? `Grammar ${grammarName} is not declared in namespace '${namespace}'` : "Undeclared grammar " + grammarName, interval);
}
function duplicateGrammarDeclaration(grammar, namespace) {
	return createError("Grammar " + grammar.name + " is already declared in this namespace");
}
function grammarDoesNotSupportIncrementalParsing(grammar) {
	return createError(`Grammar '${grammar.name}' does not support incremental parsing`);
}
function undeclaredRule(ruleName, grammarName, optInterval) {
	return createError("Rule " + ruleName + " is not declared in grammar " + grammarName, optInterval);
}
function cannotOverrideUndeclaredRule(ruleName, grammarName, optSource) {
	return createError("Cannot override rule " + ruleName + " because it is not declared in " + grammarName, optSource);
}
function cannotExtendUndeclaredRule(ruleName, grammarName, optSource) {
	return createError("Cannot extend rule " + ruleName + " because it is not declared in " + grammarName, optSource);
}
function duplicateRuleDeclaration(ruleName, grammarName, declGrammarName, optSource) {
	let message = "Duplicate declaration for rule '" + ruleName + "' in grammar '" + grammarName + "'";
	if (grammarName !== declGrammarName) message += " (originally declared in '" + declGrammarName + "')";
	return createError(message, optSource);
}
function wrongNumberOfParameters(ruleName, expected, actual, source) {
	return createError("Wrong number of parameters for rule " + ruleName + " (expected " + expected + ", got " + actual + ")", source);
}
function wrongNumberOfArguments(ruleName, expected, actual, expr) {
	return createError("Wrong number of arguments for rule " + ruleName + " (expected " + expected + ", got " + actual + ")", expr);
}
function duplicateParameterNames(ruleName, duplicates, source) {
	return createError("Duplicate parameter names in rule " + ruleName + ": " + duplicates.join(", "), source);
}
function invalidParameter(ruleName, expr) {
	return createError("Invalid parameter to rule " + ruleName + ": " + expr + " has arity " + expr.getArity() + ", but parameter expressions must have arity 1", expr.source);
}
function applicationOfSyntacticRuleFromLexicalContext(ruleName, applyExpr) {
	return createError("Cannot apply syntactic rule " + ruleName + " from here (inside a lexical context)", applyExpr.source);
}
function applySyntacticWithLexicalRuleApplication(applyExpr) {
	const { ruleName } = applyExpr;
	return createError(`applySyntactic is for syntactic rules, but '${ruleName}' is a lexical rule. NOTE: A _syntactic rule_ is a rule whose name begins with a capital letter. See https://ohmjs.org/d/svl for more details.`, applyExpr.source);
}
function unnecessaryExperimentalApplySyntactic(applyExpr) {
	return createError("applySyntactic is not required here (in a syntactic context)", applyExpr.source);
}
function incorrectArgumentType(expectedType, expr) {
	return createError("Incorrect argument type: expected " + expectedType, expr.source);
}
function multipleSuperSplices(expr) {
	return createError("'...' can appear at most once in a rule body", expr.source);
}
function invalidCodePoint(applyWrapper) {
	const node = applyWrapper._node;
	assert(node && node.isNonterminal() && node.ctorName === "escapeChar_unicodeCodePoint");
	const digitIntervals = applyWrapper.children.slice(1, -1).map((d) => d.source);
	const fullInterval = digitIntervals[0].coverageWith(...digitIntervals.slice(1));
	return createError(`U+${fullInterval.contents} is not a valid Unicode code point`, fullInterval);
}
function kleeneExprHasNullableOperand(kleeneExpr, applicationStack) {
	const actuals = applicationStack.length > 0 ? applicationStack[applicationStack.length - 1].args : [];
	let message = "Nullable expression " + kleeneExpr.expr.substituteParams(actuals) + " is not allowed inside '" + kleeneExpr.operator + "' (possible infinite loop)";
	if (applicationStack.length > 0) {
		const stackTrace = applicationStack.map((app) => new Apply(app.ruleName, app.args)).join("\n");
		message += "\nApplication stack (most recent application last):\n" + stackTrace;
	}
	return createError(message, kleeneExpr.expr.source);
}
function inconsistentArity(ruleName, expected, actual, expr) {
	return createError("Rule " + ruleName + " involves an alternation which has inconsistent arity (expected " + expected + ", got " + actual + ")", expr.source);
}
function multipleErrors(errors) {
	const messages = errors.map((e) => e.message);
	return createError(["Errors:"].concat(messages).join("\n- "), errors[0].interval);
}
function missingSemanticAction(ctorName, name, type, stack) {
	let stackTrace = stack.slice(0, -1).map((info) => {
		const ans = "  " + info[0].name + " > " + info[1];
		return info.length === 3 ? ans + " for '" + info[2] + "'" : ans;
	}).join("\n");
	stackTrace += "\n  " + name + " > " + ctorName;
	let moreInfo = "";
	if (ctorName === "_iter") moreInfo = ["\nNOTE: as of Ohm v16, there is no default action for iteration nodes — see ", "  https://ohmjs.org/d/dsa for details."].join("\n");
	const e = createError([
		`Missing semantic action for '${ctorName}' in ${type} '${name}'.${moreInfo}`,
		"Action stack (most recent call last):",
		stackTrace
	].join("\n"));
	e.name = "missingSemanticAction";
	return e;
}
function throwErrors(errors) {
	if (errors.length === 1) throw errors[0];
	if (errors.length > 1) throw multipleErrors(errors);
}

//#endregion
//#region ../node_modules/.pnpm/ohm-js@17.2.1/node_modules/ohm-js/src/util.js
function padNumbersToEqualLength(arr) {
	let maxLen = 0;
	return arr.map((n) => {
		const str = n.toString();
		maxLen = Math.max(maxLen, str.length);
		return str;
	}).map((s) => padLeft(s, maxLen));
}
function strcpy(dest, src, offset) {
	const origDestLen = dest.length;
	const start = dest.slice(0, offset);
	const end$1 = dest.slice(offset + src.length);
	return (start + src + end$1).substr(0, origDestLen);
}
function lineAndColumnToMessage(...ranges) {
	const lineAndCol = this;
	const { offset } = lineAndCol;
	const { repeatStr: repeatStr$1 } = common_exports;
	const sb = new StringBuffer();
	sb.append("Line " + lineAndCol.lineNum + ", col " + lineAndCol.colNum + ":\n");
	const lineNumbers = padNumbersToEqualLength([
		lineAndCol.prevLine == null ? 0 : lineAndCol.lineNum - 1,
		lineAndCol.lineNum,
		lineAndCol.nextLine == null ? 0 : lineAndCol.lineNum + 1
	]);
	const appendLine = (num, content, prefix) => {
		sb.append(prefix + lineNumbers[num] + " | " + content + "\n");
	};
	if (lineAndCol.prevLine != null) appendLine(0, lineAndCol.prevLine, "  ");
	appendLine(1, lineAndCol.line, "> ");
	const lineLen = lineAndCol.line.length;
	let indicationLine = repeatStr$1(" ", lineLen + 1);
	for (let i = 0; i < ranges.length; ++i) {
		let startIdx = ranges[i][0];
		let endIdx = ranges[i][1];
		assert(startIdx >= 0 && startIdx <= endIdx, "range start must be >= 0 and <= end");
		const lineStartOffset = offset - lineAndCol.colNum + 1;
		startIdx = Math.max(0, startIdx - lineStartOffset);
		endIdx = Math.min(endIdx - lineStartOffset, lineLen);
		indicationLine = strcpy(indicationLine, repeatStr$1("~", endIdx - startIdx), startIdx);
	}
	const gutterWidth = 2 + lineNumbers[1].length + 3;
	sb.append(repeatStr$1(" ", gutterWidth));
	indicationLine = strcpy(indicationLine, "^", lineAndCol.colNum - 1);
	sb.append(indicationLine.replace(/ +$/, "") + "\n");
	if (lineAndCol.nextLine != null) appendLine(2, lineAndCol.nextLine, "  ");
	return sb.contents();
}
let builtInRulesCallbacks = [];
function awaitBuiltInRules(cb) {
	builtInRulesCallbacks.push(cb);
}
function announceBuiltInRules(grammar) {
	builtInRulesCallbacks.forEach((cb) => {
		cb(grammar);
	});
	builtInRulesCallbacks = null;
}
function getLineAndColumn(str, offset) {
	let lineNum = 1;
	let colNum = 1;
	let currOffset = 0;
	let lineStartOffset = 0;
	let nextLine = null;
	let prevLine = null;
	let prevLineStartOffset = -1;
	while (currOffset < offset) {
		const c = str.charAt(currOffset++);
		if (c === "\n") {
			lineNum++;
			colNum = 1;
			prevLineStartOffset = lineStartOffset;
			lineStartOffset = currOffset;
		} else if (c !== "\r") colNum++;
	}
	let lineEndOffset = str.indexOf("\n", lineStartOffset);
	if (lineEndOffset === -1) lineEndOffset = str.length;
	else {
		const nextLineEndOffset = str.indexOf("\n", lineEndOffset + 1);
		nextLine = nextLineEndOffset === -1 ? str.slice(lineEndOffset) : str.slice(lineEndOffset, nextLineEndOffset);
		nextLine = nextLine.replace(/^\r?\n/, "").replace(/\r$/, "");
	}
	if (prevLineStartOffset >= 0) prevLine = str.slice(prevLineStartOffset, lineStartOffset).replace(/\r?\n$/, "");
	const line = str.slice(lineStartOffset, lineEndOffset).replace(/\r$/, "");
	return {
		offset,
		lineNum,
		colNum,
		line,
		prevLine,
		nextLine,
		toString: lineAndColumnToMessage
	};
}
function getLineAndColumnMessage(str, offset, ...ranges) {
	return getLineAndColumn(str, offset).toString(...ranges);
}
const uniqueId = (() => {
	let idCounter = 0;
	return (prefix) => "" + prefix + idCounter++;
})();

//#endregion
//#region ../node_modules/.pnpm/ohm-js@17.2.1/node_modules/ohm-js/src/Interval.js
var Interval$1 = class Interval$1 {
	constructor(sourceString, startIdx, endIdx) {
		this.sourceString = sourceString;
		this.startIdx = startIdx;
		this.endIdx = endIdx;
	}
	get contents() {
		if (this._contents === void 0) this._contents = this.sourceString.slice(this.startIdx, this.endIdx);
		return this._contents;
	}
	get length() {
		return this.endIdx - this.startIdx;
	}
	coverageWith(...intervals) {
		return Interval$1.coverage(...intervals, this);
	}
	collapsedLeft() {
		return new Interval$1(this.sourceString, this.startIdx, this.startIdx);
	}
	collapsedRight() {
		return new Interval$1(this.sourceString, this.endIdx, this.endIdx);
	}
	getLineAndColumn() {
		return getLineAndColumn(this.sourceString, this.startIdx);
	}
	getLineAndColumnMessage() {
		const range = [this.startIdx, this.endIdx];
		return getLineAndColumnMessage(this.sourceString, this.startIdx, range);
	}
	minus(that) {
		if (this.sourceString !== that.sourceString) throw intervalSourcesDontMatch();
		else if (this.startIdx === that.startIdx && this.endIdx === that.endIdx) return [];
		else if (this.startIdx < that.startIdx && that.endIdx < this.endIdx) return [new Interval$1(this.sourceString, this.startIdx, that.startIdx), new Interval$1(this.sourceString, that.endIdx, this.endIdx)];
		else if (this.startIdx < that.endIdx && that.endIdx < this.endIdx) return [new Interval$1(this.sourceString, that.endIdx, this.endIdx)];
		else if (this.startIdx < that.startIdx && that.startIdx < this.endIdx) return [new Interval$1(this.sourceString, this.startIdx, that.startIdx)];
		else return [this];
	}
	relativeTo(that) {
		if (this.sourceString !== that.sourceString) throw intervalSourcesDontMatch();
		assert(this.startIdx >= that.startIdx && this.endIdx <= that.endIdx, "other interval does not cover this one");
		return new Interval$1(this.sourceString, this.startIdx - that.startIdx, this.endIdx - that.startIdx);
	}
	trimmed() {
		const { contents } = this;
		const startIdx = this.startIdx + contents.match(/^\s*/)[0].length;
		const endIdx = this.endIdx - contents.match(/\s*$/)[0].length;
		return new Interval$1(this.sourceString, startIdx, endIdx);
	}
	subInterval(offset, len) {
		const newStartIdx = this.startIdx + offset;
		return new Interval$1(this.sourceString, newStartIdx, newStartIdx + len);
	}
};
Interval$1.coverage = function(firstInterval, ...intervals) {
	let { startIdx, endIdx } = firstInterval;
	for (const interval of intervals) if (interval.sourceString !== firstInterval.sourceString) throw intervalSourcesDontMatch();
	else {
		startIdx = Math.min(startIdx, interval.startIdx);
		endIdx = Math.max(endIdx, interval.endIdx);
	}
	return new Interval$1(firstInterval.sourceString, startIdx, endIdx);
};

//#endregion
//#region ../node_modules/.pnpm/ohm-js@17.2.1/node_modules/ohm-js/src/InputStream.js
const MAX_CHAR_CODE = 65535;
var InputStream = class {
	constructor(source) {
		this.source = source;
		this.pos = 0;
		this.examinedLength = 0;
	}
	atEnd() {
		const ans = this.pos >= this.source.length;
		this.examinedLength = Math.max(this.examinedLength, this.pos + 1);
		return ans;
	}
	next() {
		const ans = this.source[this.pos++];
		this.examinedLength = Math.max(this.examinedLength, this.pos);
		return ans;
	}
	nextCharCode() {
		const nextChar = this.next();
		return nextChar && nextChar.charCodeAt(0);
	}
	nextCodePoint() {
		const cp = this.source.slice(this.pos++).codePointAt(0);
		if (cp > MAX_CHAR_CODE) this.pos += 1;
		this.examinedLength = Math.max(this.examinedLength, this.pos);
		return cp;
	}
	matchString(s, optIgnoreCase) {
		let idx;
		if (optIgnoreCase) {
			for (idx = 0; idx < s.length; idx++) {
				const actual = this.next();
				const expected = s[idx];
				if (actual == null || actual.toUpperCase() !== expected.toUpperCase()) return false;
			}
			return true;
		}
		for (idx = 0; idx < s.length; idx++) if (this.next() !== s[idx]) return false;
		return true;
	}
	sourceSlice(startIdx, endIdx) {
		return this.source.slice(startIdx, endIdx);
	}
	interval(startIdx, optEndIdx) {
		return new Interval$1(this.source, startIdx, optEndIdx ? optEndIdx : this.pos);
	}
};

//#endregion
//#region ../node_modules/.pnpm/ohm-js@17.2.1/node_modules/ohm-js/src/MatchResult.js
var MatchResult = class {
	constructor(matcher, input, startExpr, cst, cstOffset, rightmostFailurePosition, optRecordedFailures) {
		this.matcher = matcher;
		this.input = input;
		this.startExpr = startExpr;
		this._cst = cst;
		this._cstOffset = cstOffset;
		this._rightmostFailurePosition = rightmostFailurePosition;
		this._rightmostFailures = optRecordedFailures;
		if (this.failed()) {
			defineLazyProperty(this, "message", function() {
				const detail = "Expected " + this.getExpectedText();
				return getLineAndColumnMessage(this.input, this.getRightmostFailurePosition()) + detail;
			});
			defineLazyProperty(this, "shortMessage", function() {
				const detail = "expected " + this.getExpectedText();
				const errorInfo = getLineAndColumn(this.input, this.getRightmostFailurePosition());
				return "Line " + errorInfo.lineNum + ", col " + errorInfo.colNum + ": " + detail;
			});
		}
	}
	succeeded() {
		return !!this._cst;
	}
	failed() {
		return !this.succeeded();
	}
	getRightmostFailurePosition() {
		return this._rightmostFailurePosition;
	}
	getRightmostFailures() {
		if (!this._rightmostFailures) {
			this.matcher.setInput(this.input);
			this._rightmostFailures = this.matcher._match(this.startExpr, {
				tracing: false,
				positionToRecordFailures: this.getRightmostFailurePosition()
			}).getRightmostFailures();
		}
		return this._rightmostFailures;
	}
	toString() {
		return this.succeeded() ? "[match succeeded]" : "[match failed at position " + this.getRightmostFailurePosition() + "]";
	}
	getExpectedText() {
		if (this.succeeded()) throw new Error("cannot get expected text of a successful MatchResult");
		const sb = new StringBuffer();
		let failures = this.getRightmostFailures();
		failures = failures.filter((failure) => !failure.isFluffy());
		for (let idx = 0; idx < failures.length; idx++) {
			if (idx > 0) if (idx === failures.length - 1) sb.append(failures.length > 2 ? ", or " : " or ");
			else sb.append(", ");
			sb.append(failures[idx].toString());
		}
		return sb.contents();
	}
	getInterval() {
		const pos = this.getRightmostFailurePosition();
		return new Interval$1(this.input, pos, pos);
	}
};

//#endregion
//#region ../node_modules/.pnpm/ohm-js@17.2.1/node_modules/ohm-js/src/PosInfo.js
var PosInfo = class {
	constructor() {
		this.applicationMemoKeyStack = [];
		this.memo = {};
		this.maxExaminedLength = 0;
		this.maxRightmostFailureOffset = -1;
		this.currentLeftRecursion = void 0;
	}
	isActive(application) {
		return this.applicationMemoKeyStack.indexOf(application.toMemoKey()) >= 0;
	}
	enter(application) {
		this.applicationMemoKeyStack.push(application.toMemoKey());
	}
	exit() {
		this.applicationMemoKeyStack.pop();
	}
	startLeftRecursion(headApplication, memoRec) {
		memoRec.isLeftRecursion = true;
		memoRec.headApplication = headApplication;
		memoRec.nextLeftRecursion = this.currentLeftRecursion;
		this.currentLeftRecursion = memoRec;
		const { applicationMemoKeyStack } = this;
		const indexOfFirstInvolvedRule = applicationMemoKeyStack.indexOf(headApplication.toMemoKey()) + 1;
		const involvedApplicationMemoKeys = applicationMemoKeyStack.slice(indexOfFirstInvolvedRule);
		memoRec.isInvolved = function(applicationMemoKey) {
			return involvedApplicationMemoKeys.indexOf(applicationMemoKey) >= 0;
		};
		memoRec.updateInvolvedApplicationMemoKeys = function() {
			for (let idx = indexOfFirstInvolvedRule; idx < applicationMemoKeyStack.length; idx++) {
				const applicationMemoKey = applicationMemoKeyStack[idx];
				if (!this.isInvolved(applicationMemoKey)) involvedApplicationMemoKeys.push(applicationMemoKey);
			}
		};
	}
	endLeftRecursion() {
		this.currentLeftRecursion = this.currentLeftRecursion.nextLeftRecursion;
	}
	shouldUseMemoizedResult(memoRec) {
		if (!memoRec.isLeftRecursion) return true;
		const { applicationMemoKeyStack } = this;
		for (let idx = 0; idx < applicationMemoKeyStack.length; idx++) {
			const applicationMemoKey = applicationMemoKeyStack[idx];
			if (memoRec.isInvolved(applicationMemoKey)) return false;
		}
		return true;
	}
	memoize(memoKey, memoRec) {
		this.memo[memoKey] = memoRec;
		this.maxExaminedLength = Math.max(this.maxExaminedLength, memoRec.examinedLength);
		this.maxRightmostFailureOffset = Math.max(this.maxRightmostFailureOffset, memoRec.rightmostFailureOffset);
		return memoRec;
	}
	clearObsoleteEntries(pos, invalidatedIdx) {
		if (pos + this.maxExaminedLength <= invalidatedIdx) return;
		const { memo } = this;
		this.maxExaminedLength = 0;
		this.maxRightmostFailureOffset = -1;
		Object.keys(memo).forEach((k) => {
			const memoRec = memo[k];
			if (pos + memoRec.examinedLength > invalidatedIdx) delete memo[k];
			else {
				this.maxExaminedLength = Math.max(this.maxExaminedLength, memoRec.examinedLength);
				this.maxRightmostFailureOffset = Math.max(this.maxRightmostFailureOffset, memoRec.rightmostFailureOffset);
			}
		});
	}
};

//#endregion
//#region ../node_modules/.pnpm/ohm-js@17.2.1/node_modules/ohm-js/src/Trace.js
const BALLOT_X = "✗";
const CHECK_MARK = "✓";
const DOT_OPERATOR = "⋅";
const RIGHTWARDS_DOUBLE_ARROW = "⇒";
const SYMBOL_FOR_HORIZONTAL_TABULATION = "␉";
const SYMBOL_FOR_LINE_FEED = "␊";
const SYMBOL_FOR_CARRIAGE_RETURN = "␍";
const Flags = {
	succeeded: 1,
	isRootNode: 2,
	isImplicitSpaces: 4,
	isMemoized: 8,
	isHeadOfLeftRecursion: 16,
	terminatesLR: 32
};
function spaces(n) {
	return repeat(" ", n).join("");
}
function getInputExcerpt(input, pos, len) {
	const excerpt = asEscapedString(input.slice(pos, pos + len));
	if (excerpt.length < len) return excerpt + repeat(" ", len - excerpt.length).join("");
	return excerpt;
}
function asEscapedString(obj) {
	if (typeof obj === "string") return obj.replace(/ /g, DOT_OPERATOR).replace(/\t/g, SYMBOL_FOR_HORIZONTAL_TABULATION).replace(/\n/g, SYMBOL_FOR_LINE_FEED).replace(/\r/g, SYMBOL_FOR_CARRIAGE_RETURN);
	return String(obj);
}
var Trace = class Trace {
	constructor(input, pos1, pos2, expr, succeeded, bindings, optChildren) {
		this.input = input;
		this.pos = this.pos1 = pos1;
		this.pos2 = pos2;
		this.source = new Interval$1(input, pos1, pos2);
		this.expr = expr;
		this.bindings = bindings;
		this.children = optChildren || [];
		this.terminatingLREntry = null;
		this._flags = succeeded ? Flags.succeeded : 0;
	}
	get displayString() {
		return this.expr.toDisplayString();
	}
	clone() {
		return this.cloneWithExpr(this.expr);
	}
	cloneWithExpr(expr) {
		const ans = new Trace(this.input, this.pos, this.pos2, expr, this.succeeded, this.bindings, this.children);
		ans.isHeadOfLeftRecursion = this.isHeadOfLeftRecursion;
		ans.isImplicitSpaces = this.isImplicitSpaces;
		ans.isMemoized = this.isMemoized;
		ans.isRootNode = this.isRootNode;
		ans.terminatesLR = this.terminatesLR;
		ans.terminatingLREntry = this.terminatingLREntry;
		return ans;
	}
	recordLRTermination(ruleBodyTrace, value) {
		this.terminatingLREntry = new Trace(this.input, this.pos, this.pos2, this.expr, false, [value], [ruleBodyTrace]);
		this.terminatingLREntry.terminatesLR = true;
	}
	walk(visitorObjOrFn, optThisArg) {
		let visitor = visitorObjOrFn;
		if (typeof visitor === "function") visitor = { enter: visitor };
		function _walk(node, parent, depth) {
			let recurse = true;
			if (visitor.enter) {
				if (visitor.enter.call(optThisArg, node, parent, depth) === Trace.prototype.SKIP) recurse = false;
			}
			if (recurse) {
				node.children.forEach((child) => {
					_walk(child, node, depth + 1);
				});
				if (visitor.exit) visitor.exit.call(optThisArg, node, parent, depth);
			}
		}
		if (this.isRootNode) this.children.forEach((c) => {
			_walk(c, null, 0);
		});
		else _walk(this, null, 0);
	}
	toString() {
		const sb = new StringBuffer();
		this.walk((node, parent, depth) => {
			if (!node) return this.SKIP;
			if (node.expr.constructor.name === "Alt") return;
			sb.append(getInputExcerpt(node.input, node.pos, 10) + spaces(depth * 2 + 1));
			sb.append((node.succeeded ? CHECK_MARK : BALLOT_X) + " " + node.displayString);
			if (node.isHeadOfLeftRecursion) sb.append(" (LR)");
			if (node.succeeded) {
				const contents = asEscapedString(node.source.contents);
				sb.append(" " + RIGHTWARDS_DOUBLE_ARROW + "  ");
				sb.append(typeof contents === "string" ? "\"" + contents + "\"" : contents);
			}
			sb.append("\n");
		});
		return sb.contents();
	}
};
Trace.prototype.SKIP = {};
Object.keys(Flags).forEach((name) => {
	const mask = Flags[name];
	Object.defineProperty(Trace.prototype, name, {
		get() {
			return (this._flags & mask) !== 0;
		},
		set(val) {
			if (val) this._flags |= mask;
			else this._flags &= ~mask;
		}
	});
});

//#endregion
//#region ../node_modules/.pnpm/ohm-js@17.2.1/node_modules/ohm-js/src/pexprs-allowsSkippingPrecedingSpace.js
PExpr.prototype.allowsSkippingPrecedingSpace = abstract("allowsSkippingPrecedingSpace");
any.allowsSkippingPrecedingSpace = end.allowsSkippingPrecedingSpace = Apply.prototype.allowsSkippingPrecedingSpace = Terminal.prototype.allowsSkippingPrecedingSpace = Range.prototype.allowsSkippingPrecedingSpace = UnicodeChar.prototype.allowsSkippingPrecedingSpace = function() {
	return true;
};
Alt.prototype.allowsSkippingPrecedingSpace = Iter.prototype.allowsSkippingPrecedingSpace = Lex.prototype.allowsSkippingPrecedingSpace = Lookahead.prototype.allowsSkippingPrecedingSpace = Not.prototype.allowsSkippingPrecedingSpace = Param.prototype.allowsSkippingPrecedingSpace = Seq.prototype.allowsSkippingPrecedingSpace = function() {
	return false;
};

//#endregion
//#region ../node_modules/.pnpm/ohm-js@17.2.1/node_modules/ohm-js/src/pexprs-assertAllApplicationsAreValid.js
let BuiltInRules;
awaitBuiltInRules((g) => {
	BuiltInRules = g;
});
let lexifyCount;
PExpr.prototype.assertAllApplicationsAreValid = function(ruleName, grammar) {
	lexifyCount = 0;
	this._assertAllApplicationsAreValid(ruleName, grammar);
};
PExpr.prototype._assertAllApplicationsAreValid = abstract("_assertAllApplicationsAreValid");
any._assertAllApplicationsAreValid = end._assertAllApplicationsAreValid = Terminal.prototype._assertAllApplicationsAreValid = Range.prototype._assertAllApplicationsAreValid = Param.prototype._assertAllApplicationsAreValid = UnicodeChar.prototype._assertAllApplicationsAreValid = function(ruleName, grammar) {};
Lex.prototype._assertAllApplicationsAreValid = function(ruleName, grammar) {
	lexifyCount++;
	this.expr._assertAllApplicationsAreValid(ruleName, grammar);
	lexifyCount--;
};
Alt.prototype._assertAllApplicationsAreValid = function(ruleName, grammar) {
	for (let idx = 0; idx < this.terms.length; idx++) this.terms[idx]._assertAllApplicationsAreValid(ruleName, grammar);
};
Seq.prototype._assertAllApplicationsAreValid = function(ruleName, grammar) {
	for (let idx = 0; idx < this.factors.length; idx++) this.factors[idx]._assertAllApplicationsAreValid(ruleName, grammar);
};
Iter.prototype._assertAllApplicationsAreValid = Not.prototype._assertAllApplicationsAreValid = Lookahead.prototype._assertAllApplicationsAreValid = function(ruleName, grammar) {
	this.expr._assertAllApplicationsAreValid(ruleName, grammar);
};
Apply.prototype._assertAllApplicationsAreValid = function(ruleName, grammar, skipSyntacticCheck = false) {
	const ruleInfo = grammar.rules[this.ruleName];
	const isContextSyntactic = isSyntactic(ruleName) && lexifyCount === 0;
	if (!ruleInfo) throw undeclaredRule(this.ruleName, grammar.name, this.source);
	if (!skipSyntacticCheck && isSyntactic(this.ruleName) && !isContextSyntactic) throw applicationOfSyntacticRuleFromLexicalContext(this.ruleName, this);
	const actual = this.args.length;
	const expected = ruleInfo.formals.length;
	if (actual !== expected) throw wrongNumberOfArguments(this.ruleName, expected, actual, this.source);
	const isBuiltInApplySyntactic = BuiltInRules && ruleInfo === BuiltInRules.rules.applySyntactic;
	if (BuiltInRules && ruleInfo === BuiltInRules.rules.caseInsensitive) {
		if (!(this.args[0] instanceof Terminal)) throw incorrectArgumentType("a Terminal (e.g. \"abc\")", this.args[0]);
	}
	if (isBuiltInApplySyntactic) {
		const arg = this.args[0];
		if (!(arg instanceof Apply)) throw incorrectArgumentType("a syntactic rule application", arg);
		if (!isSyntactic(arg.ruleName)) throw applySyntacticWithLexicalRuleApplication(arg);
		if (isContextSyntactic) throw unnecessaryExperimentalApplySyntactic(this);
	}
	this.args.forEach((arg) => {
		arg._assertAllApplicationsAreValid(ruleName, grammar, isBuiltInApplySyntactic);
		if (arg.getArity() !== 1) throw invalidParameter(this.ruleName, arg);
	});
};

//#endregion
//#region ../node_modules/.pnpm/ohm-js@17.2.1/node_modules/ohm-js/src/pexprs-assertChoicesHaveUniformArity.js
PExpr.prototype.assertChoicesHaveUniformArity = abstract("assertChoicesHaveUniformArity");
any.assertChoicesHaveUniformArity = end.assertChoicesHaveUniformArity = Terminal.prototype.assertChoicesHaveUniformArity = Range.prototype.assertChoicesHaveUniformArity = Param.prototype.assertChoicesHaveUniformArity = Lex.prototype.assertChoicesHaveUniformArity = UnicodeChar.prototype.assertChoicesHaveUniformArity = function(ruleName) {};
Alt.prototype.assertChoicesHaveUniformArity = function(ruleName) {
	if (this.terms.length === 0) return;
	const arity = this.terms[0].getArity();
	for (let idx = 0; idx < this.terms.length; idx++) {
		const term = this.terms[idx];
		term.assertChoicesHaveUniformArity();
		const otherArity = term.getArity();
		if (arity !== otherArity) throw inconsistentArity(ruleName, arity, otherArity, term);
	}
};
Extend.prototype.assertChoicesHaveUniformArity = function(ruleName) {
	const actualArity = this.terms[0].getArity();
	const expectedArity = this.terms[1].getArity();
	if (actualArity !== expectedArity) throw inconsistentArity(ruleName, expectedArity, actualArity, this.terms[0]);
};
Seq.prototype.assertChoicesHaveUniformArity = function(ruleName) {
	for (let idx = 0; idx < this.factors.length; idx++) this.factors[idx].assertChoicesHaveUniformArity(ruleName);
};
Iter.prototype.assertChoicesHaveUniformArity = function(ruleName) {
	this.expr.assertChoicesHaveUniformArity(ruleName);
};
Not.prototype.assertChoicesHaveUniformArity = function(ruleName) {};
Lookahead.prototype.assertChoicesHaveUniformArity = function(ruleName) {
	this.expr.assertChoicesHaveUniformArity(ruleName);
};
Apply.prototype.assertChoicesHaveUniformArity = function(ruleName) {};

//#endregion
//#region ../node_modules/.pnpm/ohm-js@17.2.1/node_modules/ohm-js/src/pexprs-assertIteratedExprsAreNotNullable.js
PExpr.prototype.assertIteratedExprsAreNotNullable = abstract("assertIteratedExprsAreNotNullable");
any.assertIteratedExprsAreNotNullable = end.assertIteratedExprsAreNotNullable = Terminal.prototype.assertIteratedExprsAreNotNullable = Range.prototype.assertIteratedExprsAreNotNullable = Param.prototype.assertIteratedExprsAreNotNullable = UnicodeChar.prototype.assertIteratedExprsAreNotNullable = function(grammar) {};
Alt.prototype.assertIteratedExprsAreNotNullable = function(grammar) {
	for (let idx = 0; idx < this.terms.length; idx++) this.terms[idx].assertIteratedExprsAreNotNullable(grammar);
};
Seq.prototype.assertIteratedExprsAreNotNullable = function(grammar) {
	for (let idx = 0; idx < this.factors.length; idx++) this.factors[idx].assertIteratedExprsAreNotNullable(grammar);
};
Iter.prototype.assertIteratedExprsAreNotNullable = function(grammar) {
	this.expr.assertIteratedExprsAreNotNullable(grammar);
	if (this.expr.isNullable(grammar)) throw kleeneExprHasNullableOperand(this, []);
};
Opt.prototype.assertIteratedExprsAreNotNullable = Not.prototype.assertIteratedExprsAreNotNullable = Lookahead.prototype.assertIteratedExprsAreNotNullable = Lex.prototype.assertIteratedExprsAreNotNullable = function(grammar) {
	this.expr.assertIteratedExprsAreNotNullable(grammar);
};
Apply.prototype.assertIteratedExprsAreNotNullable = function(grammar) {
	this.args.forEach((arg) => {
		arg.assertIteratedExprsAreNotNullable(grammar);
	});
};

//#endregion
//#region ../node_modules/.pnpm/ohm-js@17.2.1/node_modules/ohm-js/src/nodes.js
var Node = class {
	constructor(matchLength) {
		this.matchLength = matchLength;
	}
	get ctorName() {
		throw new Error("subclass responsibility");
	}
	numChildren() {
		return this.children ? this.children.length : 0;
	}
	childAt(idx) {
		if (this.children) return this.children[idx];
	}
	indexOfChild(arg) {
		return this.children.indexOf(arg);
	}
	hasChildren() {
		return this.numChildren() > 0;
	}
	hasNoChildren() {
		return !this.hasChildren();
	}
	onlyChild() {
		if (this.numChildren() !== 1) throw new Error("cannot get only child of a node of type " + this.ctorName + " (it has " + this.numChildren() + " children)");
		else return this.firstChild();
	}
	firstChild() {
		if (this.hasNoChildren()) throw new Error("cannot get first child of a " + this.ctorName + " node, which has no children");
		else return this.childAt(0);
	}
	lastChild() {
		if (this.hasNoChildren()) throw new Error("cannot get last child of a " + this.ctorName + " node, which has no children");
		else return this.childAt(this.numChildren() - 1);
	}
	childBefore(child) {
		const childIdx = this.indexOfChild(child);
		if (childIdx < 0) throw new Error("Node.childBefore() called w/ an argument that is not a child");
		else if (childIdx === 0) throw new Error("cannot get child before first child");
		else return this.childAt(childIdx - 1);
	}
	childAfter(child) {
		const childIdx = this.indexOfChild(child);
		if (childIdx < 0) throw new Error("Node.childAfter() called w/ an argument that is not a child");
		else if (childIdx === this.numChildren() - 1) throw new Error("cannot get child after last child");
		else return this.childAt(childIdx + 1);
	}
	isTerminal() {
		return false;
	}
	isNonterminal() {
		return false;
	}
	isIteration() {
		return false;
	}
	isOptional() {
		return false;
	}
};
var TerminalNode = class extends Node {
	get ctorName() {
		return "_terminal";
	}
	isTerminal() {
		return true;
	}
	get primitiveValue() {
		throw new Error("The `primitiveValue` property was removed in Ohm v17.");
	}
};
var NonterminalNode = class extends Node {
	constructor(ruleName, children, childOffsets, matchLength) {
		super(matchLength);
		this.ruleName = ruleName;
		this.children = children;
		this.childOffsets = childOffsets;
	}
	get ctorName() {
		return this.ruleName;
	}
	isNonterminal() {
		return true;
	}
	isLexical() {
		return isLexical(this.ctorName);
	}
	isSyntactic() {
		return isSyntactic(this.ctorName);
	}
};
var IterationNode = class extends Node {
	constructor(children, childOffsets, matchLength, isOptional) {
		super(matchLength);
		this.children = children;
		this.childOffsets = childOffsets;
		this.optional = isOptional;
	}
	get ctorName() {
		return "_iter";
	}
	isIteration() {
		return true;
	}
	isOptional() {
		return this.optional;
	}
};

//#endregion
//#region ../node_modules/.pnpm/ohm-js@17.2.1/node_modules/ohm-js/src/pexprs-eval.js
PExpr.prototype.eval = abstract("eval");
any.eval = function(state) {
	const { inputStream } = state;
	const origPos = inputStream.pos;
	const cp = inputStream.nextCodePoint();
	if (cp !== void 0) {
		state.pushBinding(new TerminalNode(String.fromCodePoint(cp).length), origPos);
		return true;
	} else {
		state.processFailure(origPos, this);
		return false;
	}
};
end.eval = function(state) {
	const { inputStream } = state;
	const origPos = inputStream.pos;
	if (inputStream.atEnd()) {
		state.pushBinding(new TerminalNode(0), origPos);
		return true;
	} else {
		state.processFailure(origPos, this);
		return false;
	}
};
Terminal.prototype.eval = function(state) {
	const { inputStream } = state;
	const origPos = inputStream.pos;
	if (!inputStream.matchString(this.obj)) {
		state.processFailure(origPos, this);
		return false;
	} else {
		state.pushBinding(new TerminalNode(this.obj.length), origPos);
		return true;
	}
};
Range.prototype.eval = function(state) {
	const { inputStream } = state;
	const origPos = inputStream.pos;
	const cp = this.matchCodePoint ? inputStream.nextCodePoint() : inputStream.nextCharCode();
	if (cp !== void 0 && this.from.codePointAt(0) <= cp && cp <= this.to.codePointAt(0)) {
		state.pushBinding(new TerminalNode(String.fromCodePoint(cp).length), origPos);
		return true;
	} else {
		state.processFailure(origPos, this);
		return false;
	}
};
Param.prototype.eval = function(state) {
	return state.eval(state.currentApplication().args[this.index]);
};
Lex.prototype.eval = function(state) {
	state.enterLexifiedContext();
	const ans = state.eval(this.expr);
	state.exitLexifiedContext();
	return ans;
};
Alt.prototype.eval = function(state) {
	for (let idx = 0; idx < this.terms.length; idx++) if (state.eval(this.terms[idx])) return true;
	return false;
};
Seq.prototype.eval = function(state) {
	for (let idx = 0; idx < this.factors.length; idx++) {
		const factor = this.factors[idx];
		if (!state.eval(factor)) return false;
	}
	return true;
};
Iter.prototype.eval = function(state) {
	const { inputStream } = state;
	const origPos = inputStream.pos;
	const arity = this.getArity();
	const cols = [];
	const colOffsets = [];
	while (cols.length < arity) {
		cols.push([]);
		colOffsets.push([]);
	}
	let numMatches = 0;
	let prevPos = origPos;
	let idx;
	while (numMatches < this.maxNumMatches && state.eval(this.expr)) {
		if (inputStream.pos === prevPos) throw kleeneExprHasNullableOperand(this, state._applicationStack);
		prevPos = inputStream.pos;
		numMatches++;
		const row = state._bindings.splice(state._bindings.length - arity, arity);
		const rowOffsets = state._bindingOffsets.splice(state._bindingOffsets.length - arity, arity);
		for (idx = 0; idx < row.length; idx++) {
			cols[idx].push(row[idx]);
			colOffsets[idx].push(rowOffsets[idx]);
		}
	}
	if (numMatches < this.minNumMatches) return false;
	let offset = state.posToOffset(origPos);
	let matchLength = 0;
	if (numMatches > 0) {
		const lastCol = cols[arity - 1];
		const lastColOffsets = colOffsets[arity - 1];
		const endOffset = lastColOffsets[lastColOffsets.length - 1] + lastCol[lastCol.length - 1].matchLength;
		offset = colOffsets[0][0];
		matchLength = endOffset - offset;
	}
	const isOptional = this instanceof Opt;
	for (idx = 0; idx < cols.length; idx++) {
		state._bindings.push(new IterationNode(cols[idx], colOffsets[idx], matchLength, isOptional));
		state._bindingOffsets.push(offset);
	}
	return true;
};
Not.prototype.eval = function(state) {
	const { inputStream } = state;
	const origPos = inputStream.pos;
	state.pushFailuresInfo();
	const ans = state.eval(this.expr);
	state.popFailuresInfo();
	if (ans) {
		state.processFailure(origPos, this);
		return false;
	}
	inputStream.pos = origPos;
	return true;
};
Lookahead.prototype.eval = function(state) {
	const { inputStream } = state;
	const origPos = inputStream.pos;
	if (state.eval(this.expr)) {
		inputStream.pos = origPos;
		return true;
	} else return false;
};
Apply.prototype.eval = function(state) {
	const caller = state.currentApplication();
	const actuals = caller ? caller.args : [];
	const app = this.substituteParams(actuals);
	const posInfo = state.getCurrentPosInfo();
	if (posInfo.isActive(app)) return app.handleCycle(state);
	const memoKey = app.toMemoKey();
	const memoRec = posInfo.memo[memoKey];
	if (memoRec && posInfo.shouldUseMemoizedResult(memoRec)) {
		if (state.hasNecessaryInfo(memoRec)) return state.useMemoizedResult(state.inputStream.pos, memoRec);
		delete posInfo.memo[memoKey];
	}
	return app.reallyEval(state);
};
Apply.prototype.handleCycle = function(state) {
	const posInfo = state.getCurrentPosInfo();
	const { currentLeftRecursion } = posInfo;
	const memoKey = this.toMemoKey();
	let memoRec = posInfo.memo[memoKey];
	if (currentLeftRecursion && currentLeftRecursion.headApplication.toMemoKey() === memoKey) memoRec.updateInvolvedApplicationMemoKeys();
	else if (!memoRec) {
		memoRec = posInfo.memoize(memoKey, {
			matchLength: 0,
			examinedLength: 0,
			value: false,
			rightmostFailureOffset: -1
		});
		posInfo.startLeftRecursion(this, memoRec);
	}
	return state.useMemoizedResult(state.inputStream.pos, memoRec);
};
Apply.prototype.reallyEval = function(state) {
	const { inputStream } = state;
	const origPos = inputStream.pos;
	const origPosInfo = state.getCurrentPosInfo();
	const ruleInfo = state.grammar.rules[this.ruleName];
	const { body } = ruleInfo;
	const { description } = ruleInfo;
	state.enterApplication(origPosInfo, this);
	if (description) state.pushFailuresInfo();
	const origInputStreamExaminedLength = inputStream.examinedLength;
	inputStream.examinedLength = 0;
	let value = this.evalOnce(body, state);
	const currentLR = origPosInfo.currentLeftRecursion;
	const memoKey = this.toMemoKey();
	const isHeadOfLeftRecursion = currentLR && currentLR.headApplication.toMemoKey() === memoKey;
	let memoRec;
	if (state.doNotMemoize) state.doNotMemoize = false;
	else if (isHeadOfLeftRecursion) {
		value = this.growSeedResult(body, state, origPos, currentLR, value);
		origPosInfo.endLeftRecursion();
		memoRec = currentLR;
		memoRec.examinedLength = inputStream.examinedLength - origPos;
		memoRec.rightmostFailureOffset = state._getRightmostFailureOffset();
		origPosInfo.memoize(memoKey, memoRec);
	} else if (!currentLR || !currentLR.isInvolved(memoKey)) memoRec = origPosInfo.memoize(memoKey, {
		matchLength: inputStream.pos - origPos,
		examinedLength: inputStream.examinedLength - origPos,
		value,
		failuresAtRightmostPosition: state.cloneRecordedFailures(),
		rightmostFailureOffset: state._getRightmostFailureOffset()
	});
	const succeeded = !!value;
	if (description) {
		state.popFailuresInfo();
		if (!succeeded) state.processFailure(origPos, this);
		if (memoRec) memoRec.failuresAtRightmostPosition = state.cloneRecordedFailures();
	}
	if (state.isTracing() && memoRec) {
		const entry = state.getTraceEntry(origPos, this, succeeded, succeeded ? [value] : []);
		if (isHeadOfLeftRecursion) {
			assert(entry.terminatingLREntry != null || !succeeded);
			entry.isHeadOfLeftRecursion = true;
		}
		memoRec.traceEntry = entry;
	}
	inputStream.examinedLength = Math.max(inputStream.examinedLength, origInputStreamExaminedLength);
	state.exitApplication(origPosInfo, value);
	return succeeded;
};
Apply.prototype.evalOnce = function(expr, state) {
	const { inputStream } = state;
	const origPos = inputStream.pos;
	if (state.eval(expr)) {
		const arity = expr.getArity();
		const bindings = state._bindings.splice(state._bindings.length - arity, arity);
		const offsets = state._bindingOffsets.splice(state._bindingOffsets.length - arity, arity);
		const matchLength = inputStream.pos - origPos;
		return new NonterminalNode(this.ruleName, bindings, offsets, matchLength);
	} else return false;
};
Apply.prototype.growSeedResult = function(body, state, origPos, lrMemoRec, newValue) {
	if (!newValue) return false;
	const { inputStream } = state;
	while (true) {
		lrMemoRec.matchLength = inputStream.pos - origPos;
		lrMemoRec.value = newValue;
		lrMemoRec.failuresAtRightmostPosition = state.cloneRecordedFailures();
		if (state.isTracing()) {
			const seedTrace = state.trace[state.trace.length - 1];
			lrMemoRec.traceEntry = new Trace(state.input, origPos, inputStream.pos, this, true, [newValue], [seedTrace.clone()]);
		}
		inputStream.pos = origPos;
		newValue = this.evalOnce(body, state);
		if (inputStream.pos - origPos <= lrMemoRec.matchLength) break;
		if (state.isTracing()) state.trace.splice(-2, 1);
	}
	if (state.isTracing()) lrMemoRec.traceEntry.recordLRTermination(state.trace.pop(), newValue);
	inputStream.pos = origPos + lrMemoRec.matchLength;
	return lrMemoRec.value;
};
UnicodeChar.prototype.eval = function(state) {
	const { inputStream } = state;
	const origPos = inputStream.pos;
	const ch = inputStream.next();
	if (ch && this.pattern.test(ch)) {
		state.pushBinding(new TerminalNode(ch.length), origPos);
		return true;
	} else {
		state.processFailure(origPos, this);
		return false;
	}
};

//#endregion
//#region ../node_modules/.pnpm/ohm-js@17.2.1/node_modules/ohm-js/src/pexprs-getArity.js
PExpr.prototype.getArity = abstract("getArity");
any.getArity = end.getArity = Terminal.prototype.getArity = Range.prototype.getArity = Param.prototype.getArity = Apply.prototype.getArity = UnicodeChar.prototype.getArity = function() {
	return 1;
};
Alt.prototype.getArity = function() {
	return this.terms.length === 0 ? 0 : this.terms[0].getArity();
};
Seq.prototype.getArity = function() {
	let arity = 0;
	for (let idx = 0; idx < this.factors.length; idx++) arity += this.factors[idx].getArity();
	return arity;
};
Iter.prototype.getArity = function() {
	return this.expr.getArity();
};
Not.prototype.getArity = function() {
	return 0;
};
Lookahead.prototype.getArity = Lex.prototype.getArity = function() {
	return this.expr.getArity();
};

//#endregion
//#region ../node_modules/.pnpm/ohm-js@17.2.1/node_modules/ohm-js/src/pexprs-outputRecipe.js
function getMetaInfo(expr, grammarInterval) {
	const metaInfo = {};
	if (expr.source && grammarInterval) {
		const adjusted = expr.source.relativeTo(grammarInterval);
		metaInfo.sourceInterval = [adjusted.startIdx, adjusted.endIdx];
	}
	return metaInfo;
}
PExpr.prototype.outputRecipe = abstract("outputRecipe");
any.outputRecipe = function(formals, grammarInterval) {
	return ["any", getMetaInfo(this, grammarInterval)];
};
end.outputRecipe = function(formals, grammarInterval) {
	return ["end", getMetaInfo(this, grammarInterval)];
};
Terminal.prototype.outputRecipe = function(formals, grammarInterval) {
	return [
		"terminal",
		getMetaInfo(this, grammarInterval),
		this.obj
	];
};
Range.prototype.outputRecipe = function(formals, grammarInterval) {
	return [
		"range",
		getMetaInfo(this, grammarInterval),
		this.from,
		this.to
	];
};
Param.prototype.outputRecipe = function(formals, grammarInterval) {
	return [
		"param",
		getMetaInfo(this, grammarInterval),
		this.index
	];
};
Alt.prototype.outputRecipe = function(formals, grammarInterval) {
	return ["alt", getMetaInfo(this, grammarInterval)].concat(this.terms.map((term) => term.outputRecipe(formals, grammarInterval)));
};
Extend.prototype.outputRecipe = function(formals, grammarInterval) {
	return this.terms[0].outputRecipe(formals, grammarInterval);
};
Splice.prototype.outputRecipe = function(formals, grammarInterval) {
	const beforeTerms = this.terms.slice(0, this.expansionPos);
	const afterTerms = this.terms.slice(this.expansionPos + 1);
	return [
		"splice",
		getMetaInfo(this, grammarInterval),
		beforeTerms.map((term) => term.outputRecipe(formals, grammarInterval)),
		afterTerms.map((term) => term.outputRecipe(formals, grammarInterval))
	];
};
Seq.prototype.outputRecipe = function(formals, grammarInterval) {
	return ["seq", getMetaInfo(this, grammarInterval)].concat(this.factors.map((factor) => factor.outputRecipe(formals, grammarInterval)));
};
Star.prototype.outputRecipe = Plus.prototype.outputRecipe = Opt.prototype.outputRecipe = Not.prototype.outputRecipe = Lookahead.prototype.outputRecipe = Lex.prototype.outputRecipe = function(formals, grammarInterval) {
	return [
		this.constructor.name.toLowerCase(),
		getMetaInfo(this, grammarInterval),
		this.expr.outputRecipe(formals, grammarInterval)
	];
};
Apply.prototype.outputRecipe = function(formals, grammarInterval) {
	return [
		"app",
		getMetaInfo(this, grammarInterval),
		this.ruleName,
		this.args.map((arg) => arg.outputRecipe(formals, grammarInterval))
	];
};
UnicodeChar.prototype.outputRecipe = function(formals, grammarInterval) {
	return [
		"unicodeChar",
		getMetaInfo(this, grammarInterval),
		this.category
	];
};

//#endregion
//#region ../node_modules/.pnpm/ohm-js@17.2.1/node_modules/ohm-js/src/pexprs-introduceParams.js
PExpr.prototype.introduceParams = abstract("introduceParams");
any.introduceParams = end.introduceParams = Terminal.prototype.introduceParams = Range.prototype.introduceParams = Param.prototype.introduceParams = UnicodeChar.prototype.introduceParams = function(formals) {
	return this;
};
Alt.prototype.introduceParams = function(formals) {
	this.terms.forEach((term, idx, terms) => {
		terms[idx] = term.introduceParams(formals);
	});
	return this;
};
Seq.prototype.introduceParams = function(formals) {
	this.factors.forEach((factor, idx, factors) => {
		factors[idx] = factor.introduceParams(formals);
	});
	return this;
};
Iter.prototype.introduceParams = Not.prototype.introduceParams = Lookahead.prototype.introduceParams = Lex.prototype.introduceParams = function(formals) {
	this.expr = this.expr.introduceParams(formals);
	return this;
};
Apply.prototype.introduceParams = function(formals) {
	const index = formals.indexOf(this.ruleName);
	if (index >= 0) {
		if (this.args.length > 0) throw new Error("Parameterized rules cannot be passed as arguments to another rule.");
		return new Param(index).withSource(this.source);
	} else {
		this.args.forEach((arg, idx, args) => {
			args[idx] = arg.introduceParams(formals);
		});
		return this;
	}
};

//#endregion
//#region ../node_modules/.pnpm/ohm-js@17.2.1/node_modules/ohm-js/src/pexprs-isNullable.js
PExpr.prototype.isNullable = function(grammar) {
	return this._isNullable(grammar, Object.create(null));
};
PExpr.prototype._isNullable = abstract("_isNullable");
any._isNullable = Range.prototype._isNullable = Param.prototype._isNullable = Plus.prototype._isNullable = UnicodeChar.prototype._isNullable = function(grammar, memo) {
	return false;
};
end._isNullable = function(grammar, memo) {
	return true;
};
Terminal.prototype._isNullable = function(grammar, memo) {
	if (typeof this.obj === "string") return this.obj === "";
	else return false;
};
Alt.prototype._isNullable = function(grammar, memo) {
	return this.terms.length === 0 || this.terms.some((term) => term._isNullable(grammar, memo));
};
Seq.prototype._isNullable = function(grammar, memo) {
	return this.factors.every((factor) => factor._isNullable(grammar, memo));
};
Star.prototype._isNullable = Opt.prototype._isNullable = Not.prototype._isNullable = Lookahead.prototype._isNullable = function(grammar, memo) {
	return true;
};
Lex.prototype._isNullable = function(grammar, memo) {
	return this.expr._isNullable(grammar, memo);
};
Apply.prototype._isNullable = function(grammar, memo) {
	const key = this.toMemoKey();
	if (!Object.prototype.hasOwnProperty.call(memo, key)) {
		const { body } = grammar.rules[this.ruleName];
		const inlined = body.substituteParams(this.args);
		memo[key] = false;
		memo[key] = inlined._isNullable(grammar, memo);
	}
	return memo[key];
};

//#endregion
//#region ../node_modules/.pnpm/ohm-js@17.2.1/node_modules/ohm-js/src/pexprs-substituteParams.js
PExpr.prototype.substituteParams = abstract("substituteParams");
any.substituteParams = end.substituteParams = Terminal.prototype.substituteParams = Range.prototype.substituteParams = UnicodeChar.prototype.substituteParams = function(actuals) {
	return this;
};
Param.prototype.substituteParams = function(actuals) {
	return checkNotNull(actuals[this.index]);
};
Alt.prototype.substituteParams = function(actuals) {
	return new Alt(this.terms.map((term) => term.substituteParams(actuals)));
};
Seq.prototype.substituteParams = function(actuals) {
	return new Seq(this.factors.map((factor) => factor.substituteParams(actuals)));
};
Iter.prototype.substituteParams = Not.prototype.substituteParams = Lookahead.prototype.substituteParams = Lex.prototype.substituteParams = function(actuals) {
	return new this.constructor(this.expr.substituteParams(actuals));
};
Apply.prototype.substituteParams = function(actuals) {
	if (this.args.length === 0) return this;
	else {
		const args = this.args.map((arg) => arg.substituteParams(actuals));
		return new Apply(this.ruleName, args);
	}
};

//#endregion
//#region ../node_modules/.pnpm/ohm-js@17.2.1/node_modules/ohm-js/src/pexprs-toArgumentNameList.js
function isRestrictedJSIdentifier(str) {
	return /^[a-zA-Z_$][0-9a-zA-Z_$]*$/.test(str);
}
function resolveDuplicatedNames(argumentNameList) {
	const count = Object.create(null);
	argumentNameList.forEach((argName) => {
		count[argName] = (count[argName] || 0) + 1;
	});
	Object.keys(count).forEach((dupArgName) => {
		if (count[dupArgName] <= 1) return;
		let subscript = 1;
		argumentNameList.forEach((argName, idx) => {
			if (argName === dupArgName) argumentNameList[idx] = argName + "_" + subscript++;
		});
	});
}
PExpr.prototype.toArgumentNameList = abstract("toArgumentNameList");
any.toArgumentNameList = function(firstArgIndex, noDupCheck) {
	return ["any"];
};
end.toArgumentNameList = function(firstArgIndex, noDupCheck) {
	return ["end"];
};
Terminal.prototype.toArgumentNameList = function(firstArgIndex, noDupCheck) {
	if (typeof this.obj === "string" && /^[_a-zA-Z0-9]+$/.test(this.obj)) return ["_" + this.obj];
	else return ["$" + firstArgIndex];
};
Range.prototype.toArgumentNameList = function(firstArgIndex, noDupCheck) {
	let argName = this.from + "_to_" + this.to;
	if (!isRestrictedJSIdentifier(argName)) argName = "_" + argName;
	if (!isRestrictedJSIdentifier(argName)) argName = "$" + firstArgIndex;
	return [argName];
};
Alt.prototype.toArgumentNameList = function(firstArgIndex, noDupCheck) {
	const termArgNameLists = this.terms.map((term) => term.toArgumentNameList(firstArgIndex, true));
	const argumentNameList = [];
	const numArgs = termArgNameLists[0].length;
	for (let colIdx = 0; colIdx < numArgs; colIdx++) {
		const col = [];
		for (let rowIdx = 0; rowIdx < this.terms.length; rowIdx++) col.push(termArgNameLists[rowIdx][colIdx]);
		const uniqueNames = copyWithoutDuplicates(col);
		argumentNameList.push(uniqueNames.join("_or_"));
	}
	if (!noDupCheck) resolveDuplicatedNames(argumentNameList);
	return argumentNameList;
};
Seq.prototype.toArgumentNameList = function(firstArgIndex, noDupCheck) {
	let argumentNameList = [];
	this.factors.forEach((factor) => {
		const factorArgumentNameList = factor.toArgumentNameList(firstArgIndex, true);
		argumentNameList = argumentNameList.concat(factorArgumentNameList);
		firstArgIndex += factorArgumentNameList.length;
	});
	if (!noDupCheck) resolveDuplicatedNames(argumentNameList);
	return argumentNameList;
};
Iter.prototype.toArgumentNameList = function(firstArgIndex, noDupCheck) {
	const argumentNameList = this.expr.toArgumentNameList(firstArgIndex, noDupCheck).map((exprArgumentString) => exprArgumentString[exprArgumentString.length - 1] === "s" ? exprArgumentString + "es" : exprArgumentString + "s");
	if (!noDupCheck) resolveDuplicatedNames(argumentNameList);
	return argumentNameList;
};
Opt.prototype.toArgumentNameList = function(firstArgIndex, noDupCheck) {
	return this.expr.toArgumentNameList(firstArgIndex, noDupCheck).map((argName) => {
		return "opt" + argName[0].toUpperCase() + argName.slice(1);
	});
};
Not.prototype.toArgumentNameList = function(firstArgIndex, noDupCheck) {
	return [];
};
Lookahead.prototype.toArgumentNameList = Lex.prototype.toArgumentNameList = function(firstArgIndex, noDupCheck) {
	return this.expr.toArgumentNameList(firstArgIndex, noDupCheck);
};
Apply.prototype.toArgumentNameList = function(firstArgIndex, noDupCheck) {
	return [this.ruleName];
};
UnicodeChar.prototype.toArgumentNameList = function(firstArgIndex, noDupCheck) {
	return ["$" + firstArgIndex];
};
Param.prototype.toArgumentNameList = function(firstArgIndex, noDupCheck) {
	return ["param" + this.index];
};

//#endregion
//#region ../node_modules/.pnpm/ohm-js@17.2.1/node_modules/ohm-js/src/pexprs-toDisplayString.js
PExpr.prototype.toDisplayString = abstract("toDisplayString");
Alt.prototype.toDisplayString = Seq.prototype.toDisplayString = function() {
	if (this.source) return this.source.trimmed().contents;
	return "[" + this.constructor.name + "]";
};
any.toDisplayString = end.toDisplayString = Iter.prototype.toDisplayString = Not.prototype.toDisplayString = Lookahead.prototype.toDisplayString = Lex.prototype.toDisplayString = Terminal.prototype.toDisplayString = Range.prototype.toDisplayString = Param.prototype.toDisplayString = function() {
	return this.toString();
};
Apply.prototype.toDisplayString = function() {
	if (this.args.length > 0) {
		const ps = this.args.map((arg) => arg.toDisplayString());
		return this.ruleName + "<" + ps.join(",") + ">";
	} else return this.ruleName;
};
UnicodeChar.prototype.toDisplayString = function() {
	return "Unicode [" + this.category + "] character";
};

//#endregion
//#region ../node_modules/.pnpm/ohm-js@17.2.1/node_modules/ohm-js/src/Failure.js
function isValidType(type) {
	return type === "description" || type === "string" || type === "code";
}
var Failure = class Failure {
	constructor(pexpr, text, type) {
		if (!isValidType(type)) throw new Error("invalid Failure type: " + type);
		this.pexpr = pexpr;
		this.text = text;
		this.type = type;
		this.fluffy = false;
	}
	getPExpr() {
		return this.pexpr;
	}
	getText() {
		return this.text;
	}
	getType() {
		return this.type;
	}
	isDescription() {
		return this.type === "description";
	}
	isStringTerminal() {
		return this.type === "string";
	}
	isCode() {
		return this.type === "code";
	}
	isFluffy() {
		return this.fluffy;
	}
	makeFluffy() {
		this.fluffy = true;
	}
	clearFluffy() {
		this.fluffy = false;
	}
	subsumes(that) {
		return this.getText() === that.getText() && this.type === that.type && (!this.isFluffy() || this.isFluffy() && that.isFluffy());
	}
	toString() {
		return this.type === "string" ? JSON.stringify(this.getText()) : this.getText();
	}
	clone() {
		const failure = new Failure(this.pexpr, this.text, this.type);
		if (this.isFluffy()) failure.makeFluffy();
		return failure;
	}
	toKey() {
		return this.toString() + "#" + this.type;
	}
};

//#endregion
//#region ../node_modules/.pnpm/ohm-js@17.2.1/node_modules/ohm-js/src/pexprs-toFailure.js
PExpr.prototype.toFailure = abstract("toFailure");
any.toFailure = function(grammar) {
	return new Failure(this, "any object", "description");
};
end.toFailure = function(grammar) {
	return new Failure(this, "end of input", "description");
};
Terminal.prototype.toFailure = function(grammar) {
	return new Failure(this, this.obj, "string");
};
Range.prototype.toFailure = function(grammar) {
	return new Failure(this, JSON.stringify(this.from) + ".." + JSON.stringify(this.to), "code");
};
Not.prototype.toFailure = function(grammar) {
	const description = this.expr === any ? "nothing" : "not " + this.expr.toFailure(grammar);
	return new Failure(this, description, "description");
};
Lookahead.prototype.toFailure = function(grammar) {
	return this.expr.toFailure(grammar);
};
Apply.prototype.toFailure = function(grammar) {
	let { description } = grammar.rules[this.ruleName];
	if (!description) description = (/^[aeiouAEIOU]/.test(this.ruleName) ? "an" : "a") + " " + this.ruleName;
	return new Failure(this, description, "description");
};
UnicodeChar.prototype.toFailure = function(grammar) {
	return new Failure(this, "a Unicode [" + this.category + "] character", "description");
};
Alt.prototype.toFailure = function(grammar) {
	const description = "(" + this.terms.map((t) => t.toFailure(grammar)).join(" or ") + ")";
	return new Failure(this, description, "description");
};
Seq.prototype.toFailure = function(grammar) {
	const description = "(" + this.factors.map((f) => f.toFailure(grammar)).join(" ") + ")";
	return new Failure(this, description, "description");
};
Iter.prototype.toFailure = function(grammar) {
	const description = "(" + this.expr.toFailure(grammar) + this.operator + ")";
	return new Failure(this, description, "description");
};

//#endregion
//#region ../node_modules/.pnpm/ohm-js@17.2.1/node_modules/ohm-js/src/pexprs-toString.js
PExpr.prototype.toString = abstract("toString");
any.toString = function() {
	return "any";
};
end.toString = function() {
	return "end";
};
Terminal.prototype.toString = function() {
	return JSON.stringify(this.obj);
};
Range.prototype.toString = function() {
	return JSON.stringify(this.from) + ".." + JSON.stringify(this.to);
};
Param.prototype.toString = function() {
	return "$" + this.index;
};
Lex.prototype.toString = function() {
	return "#(" + this.expr.toString() + ")";
};
Alt.prototype.toString = function() {
	return this.terms.length === 1 ? this.terms[0].toString() : "(" + this.terms.map((term) => term.toString()).join(" | ") + ")";
};
Seq.prototype.toString = function() {
	return this.factors.length === 1 ? this.factors[0].toString() : "(" + this.factors.map((factor) => factor.toString()).join(" ") + ")";
};
Iter.prototype.toString = function() {
	return this.expr + this.operator;
};
Not.prototype.toString = function() {
	return "~" + this.expr;
};
Lookahead.prototype.toString = function() {
	return "&" + this.expr;
};
Apply.prototype.toString = function() {
	if (this.args.length > 0) {
		const ps = this.args.map((arg) => arg.toString());
		return this.ruleName + "<" + ps.join(",") + ">";
	} else return this.ruleName;
};
UnicodeChar.prototype.toString = function() {
	return "\\p{" + this.category + "}";
};

//#endregion
//#region ../node_modules/.pnpm/ohm-js@17.2.1/node_modules/ohm-js/src/CaseInsensitiveTerminal.js
var CaseInsensitiveTerminal = class CaseInsensitiveTerminal extends PExpr {
	constructor(param) {
		super();
		this.obj = param;
	}
	_getString(state) {
		const terminal = state.currentApplication().args[this.obj.index];
		assert(terminal instanceof Terminal, "expected a Terminal expression");
		return terminal.obj;
	}
	allowsSkippingPrecedingSpace() {
		return true;
	}
	eval(state) {
		const { inputStream } = state;
		const origPos = inputStream.pos;
		const matchStr = this._getString(state);
		if (!inputStream.matchString(matchStr, true)) {
			state.processFailure(origPos, this);
			return false;
		} else {
			state.pushBinding(new TerminalNode(matchStr.length), origPos);
			return true;
		}
	}
	getArity() {
		return 1;
	}
	substituteParams(actuals) {
		return new CaseInsensitiveTerminal(this.obj.substituteParams(actuals));
	}
	toDisplayString() {
		return this.obj.toDisplayString() + " (case-insensitive)";
	}
	toFailure(grammar) {
		return new Failure(this, this.obj.toFailure(grammar) + " (case-insensitive)", "description");
	}
	_isNullable(grammar, memo) {
		return this.obj._isNullable(grammar, memo);
	}
};

//#endregion
//#region ../node_modules/.pnpm/ohm-js@17.2.1/node_modules/ohm-js/src/MatchState.js
let builtInApplySyntacticBody;
awaitBuiltInRules((builtInRules) => {
	builtInApplySyntacticBody = builtInRules.rules.applySyntactic.body;
});
const applySpaces = new Apply("spaces");
var MatchState = class {
	constructor(matcher, startExpr, optPositionToRecordFailures) {
		this.matcher = matcher;
		this.startExpr = startExpr;
		this.grammar = matcher.grammar;
		this.input = matcher.getInput();
		this.inputStream = new InputStream(this.input);
		this.memoTable = matcher._memoTable;
		this.userData = void 0;
		this.doNotMemoize = false;
		this._bindings = [];
		this._bindingOffsets = [];
		this._applicationStack = [];
		this._posStack = [0];
		this.inLexifiedContextStack = [false];
		this.rightmostFailurePosition = -1;
		this._rightmostFailurePositionStack = [];
		this._recordedFailuresStack = [];
		if (optPositionToRecordFailures !== void 0) {
			this.positionToRecordFailures = optPositionToRecordFailures;
			this.recordedFailures = Object.create(null);
		}
	}
	posToOffset(pos) {
		return pos - this._posStack[this._posStack.length - 1];
	}
	enterApplication(posInfo, app) {
		this._posStack.push(this.inputStream.pos);
		this._applicationStack.push(app);
		this.inLexifiedContextStack.push(false);
		posInfo.enter(app);
		this._rightmostFailurePositionStack.push(this.rightmostFailurePosition);
		this.rightmostFailurePosition = -1;
	}
	exitApplication(posInfo, optNode) {
		const origPos = this._posStack.pop();
		this._applicationStack.pop();
		this.inLexifiedContextStack.pop();
		posInfo.exit();
		this.rightmostFailurePosition = Math.max(this.rightmostFailurePosition, this._rightmostFailurePositionStack.pop());
		if (optNode) this.pushBinding(optNode, origPos);
	}
	enterLexifiedContext() {
		this.inLexifiedContextStack.push(true);
	}
	exitLexifiedContext() {
		this.inLexifiedContextStack.pop();
	}
	currentApplication() {
		return this._applicationStack[this._applicationStack.length - 1];
	}
	inSyntacticContext() {
		const currentApplication = this.currentApplication();
		if (currentApplication) return currentApplication.isSyntactic() && !this.inLexifiedContext();
		else return this.startExpr.factors[0].isSyntactic();
	}
	inLexifiedContext() {
		return this.inLexifiedContextStack[this.inLexifiedContextStack.length - 1];
	}
	skipSpaces() {
		this.pushFailuresInfo();
		this.eval(applySpaces);
		this.popBinding();
		this.popFailuresInfo();
		return this.inputStream.pos;
	}
	skipSpacesIfInSyntacticContext() {
		return this.inSyntacticContext() ? this.skipSpaces() : this.inputStream.pos;
	}
	maybeSkipSpacesBefore(expr) {
		if (expr.allowsSkippingPrecedingSpace() && expr !== applySpaces) return this.skipSpacesIfInSyntacticContext();
		else return this.inputStream.pos;
	}
	pushBinding(node, origPos) {
		this._bindings.push(node);
		this._bindingOffsets.push(this.posToOffset(origPos));
	}
	popBinding() {
		this._bindings.pop();
		this._bindingOffsets.pop();
	}
	numBindings() {
		return this._bindings.length;
	}
	truncateBindings(newLength) {
		while (this._bindings.length > newLength) this.popBinding();
	}
	getCurrentPosInfo() {
		return this.getPosInfo(this.inputStream.pos);
	}
	getPosInfo(pos) {
		let posInfo = this.memoTable[pos];
		if (!posInfo) posInfo = this.memoTable[pos] = new PosInfo();
		return posInfo;
	}
	processFailure(pos, expr) {
		this.rightmostFailurePosition = Math.max(this.rightmostFailurePosition, pos);
		if (this.recordedFailures && pos === this.positionToRecordFailures) {
			const app = this.currentApplication();
			if (app) expr = expr.substituteParams(app.args);
			this.recordFailure(expr.toFailure(this.grammar), false);
		}
	}
	recordFailure(failure, shouldCloneIfNew) {
		const key = failure.toKey();
		if (!this.recordedFailures[key]) this.recordedFailures[key] = shouldCloneIfNew ? failure.clone() : failure;
		else if (this.recordedFailures[key].isFluffy() && !failure.isFluffy()) this.recordedFailures[key].clearFluffy();
	}
	recordFailures(failures, shouldCloneIfNew) {
		Object.keys(failures).forEach((key) => {
			this.recordFailure(failures[key], shouldCloneIfNew);
		});
	}
	cloneRecordedFailures() {
		if (!this.recordedFailures) return;
		const ans = Object.create(null);
		Object.keys(this.recordedFailures).forEach((key) => {
			ans[key] = this.recordedFailures[key].clone();
		});
		return ans;
	}
	getRightmostFailurePosition() {
		return this.rightmostFailurePosition;
	}
	_getRightmostFailureOffset() {
		return this.rightmostFailurePosition >= 0 ? this.posToOffset(this.rightmostFailurePosition) : -1;
	}
	getMemoizedTraceEntry(pos, expr) {
		const posInfo = this.memoTable[pos];
		if (posInfo && expr instanceof Apply) {
			const memoRec = posInfo.memo[expr.toMemoKey()];
			if (memoRec && memoRec.traceEntry) {
				const entry = memoRec.traceEntry.cloneWithExpr(expr);
				entry.isMemoized = true;
				return entry;
			}
		}
		return null;
	}
	getTraceEntry(pos, expr, succeeded, bindings) {
		if (expr instanceof Apply) {
			const app = this.currentApplication();
			const actuals = app ? app.args : [];
			expr = expr.substituteParams(actuals);
		}
		return this.getMemoizedTraceEntry(pos, expr) || new Trace(this.input, pos, this.inputStream.pos, expr, succeeded, bindings, this.trace);
	}
	isTracing() {
		return !!this.trace;
	}
	hasNecessaryInfo(memoRec) {
		if (this.trace && !memoRec.traceEntry) return false;
		if (this.recordedFailures && this.inputStream.pos + memoRec.rightmostFailureOffset === this.positionToRecordFailures) return !!memoRec.failuresAtRightmostPosition;
		return true;
	}
	useMemoizedResult(origPos, memoRec) {
		if (this.trace) this.trace.push(memoRec.traceEntry);
		const memoRecRightmostFailurePosition = this.inputStream.pos + memoRec.rightmostFailureOffset;
		this.rightmostFailurePosition = Math.max(this.rightmostFailurePosition, memoRecRightmostFailurePosition);
		if (this.recordedFailures && this.positionToRecordFailures === memoRecRightmostFailurePosition && memoRec.failuresAtRightmostPosition) this.recordFailures(memoRec.failuresAtRightmostPosition, true);
		this.inputStream.examinedLength = Math.max(this.inputStream.examinedLength, memoRec.examinedLength + origPos);
		if (memoRec.value) {
			this.inputStream.pos += memoRec.matchLength;
			this.pushBinding(memoRec.value, origPos);
			return true;
		}
		return false;
	}
	eval(expr) {
		const { inputStream } = this;
		const origNumBindings = this._bindings.length;
		const origUserData = this.userData;
		let origRecordedFailures;
		if (this.recordedFailures) {
			origRecordedFailures = this.recordedFailures;
			this.recordedFailures = Object.create(null);
		}
		const origPos = inputStream.pos;
		const memoPos = this.maybeSkipSpacesBefore(expr);
		let origTrace;
		if (this.trace) {
			origTrace = this.trace;
			this.trace = [];
		}
		const ans = expr.eval(this);
		if (this.trace) {
			const bindings = this._bindings.slice(origNumBindings);
			const traceEntry = this.getTraceEntry(memoPos, expr, ans, bindings);
			traceEntry.isImplicitSpaces = expr === applySpaces;
			traceEntry.isRootNode = expr === this.startExpr;
			origTrace.push(traceEntry);
			this.trace = origTrace;
		}
		if (ans) {
			if (this.recordedFailures && inputStream.pos === this.positionToRecordFailures) Object.keys(this.recordedFailures).forEach((key) => {
				this.recordedFailures[key].makeFluffy();
			});
		} else {
			inputStream.pos = origPos;
			this.truncateBindings(origNumBindings);
			this.userData = origUserData;
		}
		if (this.recordedFailures) this.recordFailures(origRecordedFailures, false);
		if (expr === builtInApplySyntacticBody) this.skipSpaces();
		return ans;
	}
	getMatchResult() {
		this.grammar._setUpMatchState(this);
		this.eval(this.startExpr);
		let rightmostFailures;
		if (this.recordedFailures) rightmostFailures = Object.keys(this.recordedFailures).map((key) => this.recordedFailures[key]);
		const cst = this._bindings[0];
		if (cst) cst.grammar = this.grammar;
		return new MatchResult(this.matcher, this.input, this.startExpr, cst, this._bindingOffsets[0], this.rightmostFailurePosition, rightmostFailures);
	}
	getTrace() {
		this.trace = [];
		const matchResult = this.getMatchResult();
		const rootTrace = this.trace[this.trace.length - 1];
		rootTrace.result = matchResult;
		return rootTrace;
	}
	pushFailuresInfo() {
		this._rightmostFailurePositionStack.push(this.rightmostFailurePosition);
		this._recordedFailuresStack.push(this.recordedFailures);
	}
	popFailuresInfo() {
		this.rightmostFailurePosition = this._rightmostFailurePositionStack.pop();
		this.recordedFailures = this._recordedFailuresStack.pop();
	}
};

//#endregion
//#region ../node_modules/.pnpm/ohm-js@17.2.1/node_modules/ohm-js/src/Matcher.js
var Matcher = class {
	constructor(grammar) {
		this.grammar = grammar;
		this._memoTable = [];
		this._input = "";
		this._isMemoTableStale = false;
	}
	_resetMemoTable() {
		this._memoTable = [];
		this._isMemoTableStale = false;
	}
	getInput() {
		return this._input;
	}
	setInput(str) {
		if (this._input !== str) this.replaceInputRange(0, this._input.length, str);
		return this;
	}
	replaceInputRange(startIdx, endIdx, str) {
		const prevInput = this._input;
		const memoTable = this._memoTable;
		if (startIdx < 0 || startIdx > prevInput.length || endIdx < 0 || endIdx > prevInput.length || startIdx > endIdx) throw new Error("Invalid indices: " + startIdx + " and " + endIdx);
		this._input = prevInput.slice(0, startIdx) + str + prevInput.slice(endIdx);
		if (this._input !== prevInput && memoTable.length > 0) this._isMemoTableStale = true;
		const restOfMemoTable = memoTable.slice(endIdx);
		memoTable.length = startIdx;
		for (let idx = 0; idx < str.length; idx++) memoTable.push(void 0);
		for (const posInfo of restOfMemoTable) memoTable.push(posInfo);
		for (let pos = 0; pos < startIdx; pos++) {
			const posInfo = memoTable[pos];
			if (posInfo) posInfo.clearObsoleteEntries(pos, startIdx);
		}
		return this;
	}
	match(optStartApplicationStr, options = { incremental: true }) {
		return this._match(this._getStartExpr(optStartApplicationStr), {
			incremental: options.incremental,
			tracing: false
		});
	}
	trace(optStartApplicationStr, options = { incremental: true }) {
		return this._match(this._getStartExpr(optStartApplicationStr), {
			incremental: options.incremental,
			tracing: true
		});
	}
	_match(startExpr, options = {}) {
		const opts = {
			tracing: false,
			incremental: true,
			positionToRecordFailures: void 0,
			...options
		};
		if (!opts.incremental) this._resetMemoTable();
		else if (this._isMemoTableStale && !this.grammar.supportsIncrementalParsing) throw grammarDoesNotSupportIncrementalParsing(this.grammar);
		const state = new MatchState(this, startExpr, opts.positionToRecordFailures);
		return opts.tracing ? state.getTrace() : state.getMatchResult();
	}
	_getStartExpr(optStartApplicationStr) {
		const applicationStr = optStartApplicationStr || this.grammar.defaultStartRule;
		if (!applicationStr) throw new Error("Missing start rule argument -- the grammar has no default start rule.");
		const startApp = this.grammar.parseApplication(applicationStr);
		return new Seq([startApp, end]);
	}
};

//#endregion
//#region ../node_modules/.pnpm/ohm-js@17.2.1/node_modules/ohm-js/src/Semantics.js
const globalActionStack = [];
const hasOwnProperty = (x, prop) => Object.prototype.hasOwnProperty.call(x, prop);
var Wrapper = class {
	constructor(node, sourceInterval, baseInterval) {
		this._node = node;
		this.source = sourceInterval;
		this._baseInterval = baseInterval;
		if (node.isNonterminal()) assert(sourceInterval === baseInterval);
		this._childWrappers = [];
	}
	_forgetMemoizedResultFor(attributeName) {
		delete this._node[this._semantics.attributeKeys[attributeName]];
		this.children.forEach((child) => {
			child._forgetMemoizedResultFor(attributeName);
		});
	}
	child(idx) {
		if (!(0 <= idx && idx < this._node.numChildren())) return;
		let childWrapper = this._childWrappers[idx];
		if (!childWrapper) {
			const childNode = this._node.childAt(idx);
			const offset = this._node.childOffsets[idx];
			const source = this._baseInterval.subInterval(offset, childNode.matchLength);
			const base = childNode.isNonterminal() ? source : this._baseInterval;
			childWrapper = this._childWrappers[idx] = this._semantics.wrap(childNode, source, base);
		}
		return childWrapper;
	}
	_children() {
		for (let idx = 0; idx < this._node.numChildren(); idx++) this.child(idx);
		return this._childWrappers;
	}
	isIteration() {
		return this._node.isIteration();
	}
	isTerminal() {
		return this._node.isTerminal();
	}
	isNonterminal() {
		return this._node.isNonterminal();
	}
	isSyntactic() {
		return this.isNonterminal() && this._node.isSyntactic();
	}
	isLexical() {
		return this.isNonterminal() && this._node.isLexical();
	}
	isOptional() {
		return this._node.isOptional();
	}
	iteration(optChildWrappers) {
		const childWrappers = optChildWrappers || [];
		const iter = new IterationNode(childWrappers.map((c) => c._node), [], -1, false);
		const wrapper = this._semantics.wrap(iter, null, null);
		wrapper._childWrappers = childWrappers;
		return wrapper;
	}
	get children() {
		return this._children();
	}
	get ctorName() {
		return this._node.ctorName;
	}
	get numChildren() {
		return this._node.numChildren();
	}
	get sourceString() {
		return this.source.contents;
	}
};
var Semantics = class Semantics {
	constructor(grammar, superSemantics) {
		const self = this;
		this.grammar = grammar;
		this.checkedActionDicts = false;
		this.Wrapper = class extends (superSemantics ? superSemantics.Wrapper : Wrapper) {
			constructor(node, sourceInterval, baseInterval) {
				super(node, sourceInterval, baseInterval);
				self.checkActionDictsIfHaventAlready();
				this._semantics = self;
			}
			toString() {
				return "[semantics wrapper for " + self.grammar.name + "]";
			}
		};
		this.super = superSemantics;
		if (superSemantics) {
			if (!(grammar.equals(this.super.grammar) || grammar._inheritsFrom(this.super.grammar))) throw new Error("Cannot extend a semantics for grammar '" + this.super.grammar.name + "' for use with grammar '" + grammar.name + "' (not a sub-grammar)");
			this.operations = Object.create(this.super.operations);
			this.attributes = Object.create(this.super.attributes);
			this.attributeKeys = Object.create(null);
			for (const attributeName in this.attributes) Object.defineProperty(this.attributeKeys, attributeName, { value: uniqueId(attributeName) });
		} else {
			this.operations = Object.create(null);
			this.attributes = Object.create(null);
			this.attributeKeys = Object.create(null);
		}
	}
	toString() {
		return "[semantics for " + this.grammar.name + "]";
	}
	checkActionDictsIfHaventAlready() {
		if (!this.checkedActionDicts) {
			this.checkActionDicts();
			this.checkedActionDicts = true;
		}
	}
	checkActionDicts() {
		let name;
		for (name in this.operations) this.operations[name].checkActionDict(this.grammar);
		for (name in this.attributes) this.attributes[name].checkActionDict(this.grammar);
	}
	toRecipe(semanticsOnly) {
		function hasSuperSemantics(s) {
			return s.super !== Semantics.BuiltInSemantics._getSemantics();
		}
		let str = "(function(g) {\n";
		if (hasSuperSemantics(this)) {
			str += "  var semantics = " + this.super.toRecipe(true) + "(g";
			const superSemanticsGrammar = this.super.grammar;
			let relatedGrammar = this.grammar;
			while (relatedGrammar !== superSemanticsGrammar) {
				str += ".superGrammar";
				relatedGrammar = relatedGrammar.superGrammar;
			}
			str += ");\n";
			str += "  return g.extendSemantics(semantics)";
		} else str += "  return g.createSemantics()";
		["Operation", "Attribute"].forEach((type) => {
			const semanticOperations = this[type.toLowerCase() + "s"];
			Object.keys(semanticOperations).forEach((name) => {
				const { actionDict, formals, builtInDefault } = semanticOperations[name];
				let signature = name;
				if (formals.length > 0) signature += "(" + formals.join(", ") + ")";
				let method;
				if (hasSuperSemantics(this) && this.super[type.toLowerCase() + "s"][name]) method = "extend" + type;
				else method = "add" + type;
				str += "\n    ." + method + "(" + JSON.stringify(signature) + ", {";
				const srcArray = [];
				Object.keys(actionDict).forEach((actionName) => {
					if (actionDict[actionName] !== builtInDefault) {
						let source = actionDict[actionName].toString().trim();
						source = source.replace(/^.*\(/, "function(");
						srcArray.push("\n      " + JSON.stringify(actionName) + ": " + source);
					}
				});
				str += srcArray.join(",") + "\n    })";
			});
		});
		str += ";\n  })";
		if (!semanticsOnly) str = "(function() {\n  var grammar = this.fromRecipe(" + this.grammar.toRecipe() + ");\n  var semantics = " + str + "(grammar);\n  return semantics;\n});\n";
		return str;
	}
	addOperationOrAttribute(type, signature, actionDict) {
		const typePlural = type + "s";
		const parsedNameAndFormalArgs = parseSignature(signature, type);
		const { name } = parsedNameAndFormalArgs;
		const { formals } = parsedNameAndFormalArgs;
		this.assertNewName(name, type);
		const builtInDefault = newDefaultAction(type, name, doIt);
		const realActionDict = { _default: builtInDefault };
		Object.keys(actionDict).forEach((name$1) => {
			realActionDict[name$1] = actionDict[name$1];
		});
		const entry = type === "operation" ? new Operation(name, formals, realActionDict, builtInDefault) : new Attribute(name, realActionDict, builtInDefault);
		entry.checkActionDict(this.grammar);
		this[typePlural][name] = entry;
		function doIt(...args) {
			const thisThing = this._semantics[typePlural][name];
			if (arguments.length !== thisThing.formals.length) throw new Error("Invalid number of arguments passed to " + name + " " + type + " (expected " + thisThing.formals.length + ", got " + arguments.length + ")");
			const argsObj = Object.create(null);
			for (const [idx, val] of Object.entries(args)) {
				const formal = thisThing.formals[idx];
				argsObj[formal] = val;
			}
			const oldArgs = this.args;
			this.args = argsObj;
			const ans = thisThing.execute(this._semantics, this);
			this.args = oldArgs;
			return ans;
		}
		if (type === "operation") {
			this.Wrapper.prototype[name] = doIt;
			this.Wrapper.prototype[name].toString = function() {
				return "[" + name + " operation]";
			};
		} else {
			Object.defineProperty(this.Wrapper.prototype, name, {
				get: doIt,
				configurable: true
			});
			Object.defineProperty(this.attributeKeys, name, { value: uniqueId(name) });
		}
	}
	extendOperationOrAttribute(type, name, actionDict) {
		const typePlural = type + "s";
		parseSignature(name, "attribute");
		if (!(this.super && name in this.super[typePlural])) throw new Error("Cannot extend " + type + " '" + name + "': did not inherit an " + type + " with that name");
		if (hasOwnProperty(this[typePlural], name)) throw new Error("Cannot extend " + type + " '" + name + "' again");
		const inheritedFormals = this[typePlural][name].formals;
		const inheritedActionDict = this[typePlural][name].actionDict;
		const newActionDict = Object.create(inheritedActionDict);
		Object.keys(actionDict).forEach((name$1) => {
			newActionDict[name$1] = actionDict[name$1];
		});
		this[typePlural][name] = type === "operation" ? new Operation(name, inheritedFormals, newActionDict) : new Attribute(name, newActionDict);
		this[typePlural][name].checkActionDict(this.grammar);
	}
	assertNewName(name, type) {
		if (hasOwnProperty(Wrapper.prototype, name)) throw new Error("Cannot add " + type + " '" + name + "': that's a reserved name");
		if (name in this.operations) throw new Error("Cannot add " + type + " '" + name + "': an operation with that name already exists");
		if (name in this.attributes) throw new Error("Cannot add " + type + " '" + name + "': an attribute with that name already exists");
	}
	wrap(node, source, optBaseInterval) {
		const baseInterval = optBaseInterval || source;
		return node instanceof this.Wrapper ? node : new this.Wrapper(node, source, baseInterval);
	}
};
function parseSignature(signature, type) {
	if (!Semantics.prototypeGrammar) {
		assert(signature.indexOf("(") === -1);
		return {
			name: signature,
			formals: []
		};
	}
	const r = Semantics.prototypeGrammar.match(signature, type === "operation" ? "OperationSignature" : "AttributeSignature");
	if (r.failed()) throw new Error(r.message);
	return Semantics.prototypeGrammarSemantics(r).parse();
}
function newDefaultAction(type, name, doIt) {
	return function(...children) {
		const args = (this._semantics.operations[name] || this._semantics.attributes[name]).formals.map((formal) => this.args[formal]);
		if (!this.isIteration() && children.length === 1) return doIt.apply(children[0], args);
		else throw missingSemanticAction(this.ctorName, name, type, globalActionStack);
	};
}
Semantics.createSemantics = function(grammar, optSuperSemantics) {
	const s = new Semantics(grammar, optSuperSemantics !== void 0 ? optSuperSemantics : Semantics.BuiltInSemantics._getSemantics());
	const proxy = function ASemantics(matchResult) {
		if (!(matchResult instanceof MatchResult)) throw new TypeError("Semantics expected a MatchResult, but got " + unexpectedObjToString(matchResult));
		if (matchResult.failed()) throw new TypeError("cannot apply Semantics to " + matchResult.toString());
		const cst = matchResult._cst;
		if (cst.grammar !== grammar) throw new Error("Cannot use a MatchResult from grammar '" + cst.grammar.name + "' with a semantics for '" + grammar.name + "'");
		const inputStream = new InputStream(matchResult.input);
		return s.wrap(cst, inputStream.interval(matchResult._cstOffset, matchResult.input.length));
	};
	proxy.addOperation = function(signature, actionDict) {
		s.addOperationOrAttribute("operation", signature, actionDict);
		return proxy;
	};
	proxy.extendOperation = function(name, actionDict) {
		s.extendOperationOrAttribute("operation", name, actionDict);
		return proxy;
	};
	proxy.addAttribute = function(name, actionDict) {
		s.addOperationOrAttribute("attribute", name, actionDict);
		return proxy;
	};
	proxy.extendAttribute = function(name, actionDict) {
		s.extendOperationOrAttribute("attribute", name, actionDict);
		return proxy;
	};
	proxy._getActionDict = function(operationOrAttributeName) {
		const action = s.operations[operationOrAttributeName] || s.attributes[operationOrAttributeName];
		if (!action) throw new Error("\"" + operationOrAttributeName + "\" is not a valid operation or attribute name in this semantics for \"" + grammar.name + "\"");
		return action.actionDict;
	};
	proxy._remove = function(operationOrAttributeName) {
		let semantic;
		if (operationOrAttributeName in s.operations) {
			semantic = s.operations[operationOrAttributeName];
			delete s.operations[operationOrAttributeName];
		} else if (operationOrAttributeName in s.attributes) {
			semantic = s.attributes[operationOrAttributeName];
			delete s.attributes[operationOrAttributeName];
		}
		delete s.Wrapper.prototype[operationOrAttributeName];
		return semantic;
	};
	proxy.getOperationNames = function() {
		return Object.keys(s.operations);
	};
	proxy.getAttributeNames = function() {
		return Object.keys(s.attributes);
	};
	proxy.getGrammar = function() {
		return s.grammar;
	};
	proxy.toRecipe = function(semanticsOnly) {
		return s.toRecipe(semanticsOnly);
	};
	proxy.toString = s.toString.bind(s);
	proxy._getSemantics = function() {
		return s;
	};
	return proxy;
};
var Operation = class {
	constructor(name, formals, actionDict, builtInDefault) {
		this.name = name;
		this.formals = formals;
		this.actionDict = actionDict;
		this.builtInDefault = builtInDefault;
	}
	checkActionDict(grammar) {
		grammar._checkTopDownActionDict(this.typeName, this.name, this.actionDict);
	}
	execute(semantics, nodeWrapper) {
		try {
			const { ctorName } = nodeWrapper._node;
			let actionFn = this.actionDict[ctorName];
			if (actionFn) {
				globalActionStack.push([this, ctorName]);
				return actionFn.apply(nodeWrapper, nodeWrapper._children());
			}
			if (nodeWrapper.isNonterminal()) {
				actionFn = this.actionDict._nonterminal;
				if (actionFn) {
					globalActionStack.push([
						this,
						"_nonterminal",
						ctorName
					]);
					return actionFn.apply(nodeWrapper, nodeWrapper._children());
				}
			}
			globalActionStack.push([
				this,
				"default action",
				ctorName
			]);
			return this.actionDict._default.apply(nodeWrapper, nodeWrapper._children());
		} finally {
			globalActionStack.pop();
		}
	}
};
Operation.prototype.typeName = "operation";
var Attribute = class extends Operation {
	constructor(name, actionDict, builtInDefault) {
		super(name, [], actionDict, builtInDefault);
	}
	execute(semantics, nodeWrapper) {
		const node = nodeWrapper._node;
		const key = semantics.attributeKeys[this.name];
		if (!hasOwnProperty(node, key)) node[key] = Operation.prototype.execute.call(this, semantics, nodeWrapper);
		return node[key];
	}
};
Attribute.prototype.typeName = "attribute";

//#endregion
//#region ../node_modules/.pnpm/ohm-js@17.2.1/node_modules/ohm-js/src/Grammar.js
const SPECIAL_ACTION_NAMES = [
	"_iter",
	"_terminal",
	"_nonterminal",
	"_default"
];
function getSortedRuleValues(grammar) {
	return Object.keys(grammar.rules).sort().map((name) => grammar.rules[name]);
}
const jsonToJS = (str) => str.replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029");
let ohmGrammar;
let buildGrammar$1;
var Grammar = class Grammar {
	constructor(name, superGrammar, rules, optDefaultStartRule) {
		this.name = name;
		this.superGrammar = superGrammar;
		this.rules = rules;
		if (optDefaultStartRule) {
			if (!(optDefaultStartRule in rules)) throw new Error("Invalid start rule: '" + optDefaultStartRule + "' is not a rule in grammar '" + name + "'");
			this.defaultStartRule = optDefaultStartRule;
		}
		this._matchStateInitializer = void 0;
		this.supportsIncrementalParsing = true;
	}
	matcher() {
		return new Matcher(this);
	}
	isBuiltIn() {
		return this === Grammar.ProtoBuiltInRules || this === Grammar.BuiltInRules;
	}
	equals(g) {
		if (this === g) return true;
		if (g == null || this.name !== g.name || this.defaultStartRule !== g.defaultStartRule || !(this.superGrammar === g.superGrammar || this.superGrammar.equals(g.superGrammar))) return false;
		const myRules = getSortedRuleValues(this);
		const otherRules = getSortedRuleValues(g);
		return myRules.length === otherRules.length && myRules.every((rule, i) => {
			return rule.description === otherRules[i].description && rule.formals.join(",") === otherRules[i].formals.join(",") && rule.body.toString() === otherRules[i].body.toString();
		});
	}
	match(input, optStartApplication) {
		const m = this.matcher();
		m.replaceInputRange(0, 0, input);
		return m.match(optStartApplication);
	}
	trace(input, optStartApplication) {
		const m = this.matcher();
		m.replaceInputRange(0, 0, input);
		return m.trace(optStartApplication);
	}
	createSemantics() {
		return Semantics.createSemantics(this);
	}
	extendSemantics(superSemantics) {
		return Semantics.createSemantics(this, superSemantics._getSemantics());
	}
	_checkTopDownActionDict(what, name, actionDict) {
		const problems = [];
		for (const k in actionDict) {
			const v = actionDict[k];
			if (!SPECIAL_ACTION_NAMES.includes(k) && !(k in this.rules)) {
				problems.push(`'${k}' is not a valid semantic action for '${this.name}'`);
				continue;
			}
			if (typeof v !== "function") {
				problems.push(`'${k}' must be a function in an action dictionary for '${this.name}'`);
				continue;
			}
			const actual = v.length;
			const expected = this._topDownActionArity(k);
			if (actual !== expected) {
				let details;
				if (k === "_iter" || k === "_nonterminal") details = `it should use a rest parameter, e.g. \`${k}(...children) {}\`. NOTE: this is new in Ohm v16 — see https://ohmjs.org/d/ati for details.`;
				else details = `expected ${expected}, got ${actual}`;
				problems.push(`Semantic action '${k}' has the wrong arity: ${details}`);
			}
		}
		if (problems.length > 0) {
			const prettyProblems = problems.map((problem) => "- " + problem);
			const error$1 = new Error([`Found errors in the action dictionary of the '${name}' ${what}:`, ...prettyProblems].join("\n"));
			error$1.problems = problems;
			throw error$1;
		}
	}
	_topDownActionArity(actionName) {
		return SPECIAL_ACTION_NAMES.includes(actionName) ? 0 : this.rules[actionName].body.getArity();
	}
	_inheritsFrom(grammar) {
		let g = this.superGrammar;
		while (g) {
			if (g.equals(grammar, true)) return true;
			g = g.superGrammar;
		}
		return false;
	}
	toRecipe(superGrammarExpr = void 0) {
		const metaInfo = {};
		if (this.source) metaInfo.source = this.source.contents;
		let startRule = null;
		if (this.defaultStartRule) startRule = this.defaultStartRule;
		const rules = {};
		Object.keys(this.rules).forEach((ruleName) => {
			const ruleInfo = this.rules[ruleName];
			const { body } = ruleInfo;
			const isDefinition = !this.superGrammar || !this.superGrammar.rules[ruleName];
			let operation;
			if (isDefinition) operation = "define";
			else operation = body instanceof Extend ? "extend" : "override";
			const metaInfo$1 = {};
			if (ruleInfo.source && this.source) {
				const adjusted = ruleInfo.source.relativeTo(this.source);
				metaInfo$1.sourceInterval = [adjusted.startIdx, adjusted.endIdx];
			}
			const description = isDefinition ? ruleInfo.description : null;
			const bodyRecipe = body.outputRecipe(ruleInfo.formals, this.source);
			rules[ruleName] = [
				operation,
				metaInfo$1,
				description,
				ruleInfo.formals,
				bodyRecipe
			];
		});
		let superGrammarOutput = "null";
		if (superGrammarExpr) superGrammarOutput = superGrammarExpr;
		else if (this.superGrammar && !this.superGrammar.isBuiltIn()) superGrammarOutput = this.superGrammar.toRecipe();
		return jsonToJS(`[${[
			...[
				"grammar",
				metaInfo,
				this.name
			].map(JSON.stringify),
			superGrammarOutput,
			...[startRule, rules].map(JSON.stringify)
		].join(",")}]`);
	}
	toOperationActionDictionaryTemplate() {
		return this._toOperationOrAttributeActionDictionaryTemplate();
	}
	toAttributeActionDictionaryTemplate() {
		return this._toOperationOrAttributeActionDictionaryTemplate();
	}
	_toOperationOrAttributeActionDictionaryTemplate() {
		const sb = new StringBuffer();
		sb.append("{");
		let first = true;
		for (const ruleName in this.rules) {
			const { body } = this.rules[ruleName];
			if (first) first = false;
			else sb.append(",");
			sb.append("\n");
			sb.append("  ");
			this.addSemanticActionTemplate(ruleName, body, sb);
		}
		sb.append("\n}");
		return sb.contents();
	}
	addSemanticActionTemplate(ruleName, body, sb) {
		sb.append(ruleName);
		sb.append(": function(");
		const arity = this._topDownActionArity(ruleName);
		sb.append(repeat("_", arity).join(", "));
		sb.append(") {\n");
		sb.append("  }");
	}
	parseApplication(str) {
		let app;
		if (str.indexOf("<") === -1) app = new Apply(str);
		else {
			const cst = ohmGrammar.match(str, "Base_application");
			app = buildGrammar$1(cst, {});
		}
		if (!(app.ruleName in this.rules)) throw undeclaredRule(app.ruleName, this.name);
		const { formals } = this.rules[app.ruleName];
		if (formals.length !== app.args.length) {
			const { source } = this.rules[app.ruleName];
			throw wrongNumberOfParameters(app.ruleName, formals.length, app.args.length, source);
		}
		return app;
	}
	_setUpMatchState(state) {
		if (this._matchStateInitializer) this._matchStateInitializer(state);
	}
};
Grammar.ProtoBuiltInRules = new Grammar("ProtoBuiltInRules", void 0, {
	any: {
		body: any,
		formals: [],
		description: "any character",
		primitive: true
	},
	end: {
		body: end,
		formals: [],
		description: "end of input",
		primitive: true
	},
	caseInsensitive: {
		body: new CaseInsensitiveTerminal(new Param(0)),
		formals: ["str"],
		primitive: true
	},
	lower: {
		body: new UnicodeChar("Ll"),
		formals: [],
		description: "a lowercase letter",
		primitive: true
	},
	upper: {
		body: new UnicodeChar("Lu"),
		formals: [],
		description: "an uppercase letter",
		primitive: true
	},
	unicodeLtmo: {
		body: new UnicodeChar("Ltmo"),
		formals: [],
		description: "a Unicode character in Lt, Lm, or Lo",
		primitive: true
	},
	spaces: {
		body: new Star(new Apply("space")),
		formals: []
	},
	space: {
		body: new Range("\0", " "),
		formals: [],
		description: "a space"
	}
});
Grammar.initApplicationParser = function(grammar, builderFn) {
	ohmGrammar = grammar;
	buildGrammar$1 = builderFn;
};

//#endregion
//#region ../node_modules/.pnpm/ohm-js@17.2.1/node_modules/ohm-js/src/GrammarDecl.js
var GrammarDecl = class {
	constructor(name) {
		this.name = name;
	}
	sourceInterval(startIdx, endIdx) {
		return this.source.subInterval(startIdx, endIdx - startIdx);
	}
	ensureSuperGrammar() {
		if (!this.superGrammar) this.withSuperGrammar(this.name === "BuiltInRules" ? Grammar.ProtoBuiltInRules : Grammar.BuiltInRules);
		return this.superGrammar;
	}
	ensureSuperGrammarRuleForOverriding(name, source) {
		const ruleInfo = this.ensureSuperGrammar().rules[name];
		if (!ruleInfo) throw cannotOverrideUndeclaredRule(name, this.superGrammar.name, source);
		return ruleInfo;
	}
	installOverriddenOrExtendedRule(name, formals, body, source) {
		const duplicateParameterNames$1 = getDuplicates(formals);
		if (duplicateParameterNames$1.length > 0) throw duplicateParameterNames(name, duplicateParameterNames$1, source);
		const ruleInfo = this.ensureSuperGrammar().rules[name];
		const expectedFormals = ruleInfo.formals;
		const expectedNumFormals = expectedFormals ? expectedFormals.length : 0;
		if (formals.length !== expectedNumFormals) throw wrongNumberOfParameters(name, expectedNumFormals, formals.length, source);
		return this.install(name, formals, body, ruleInfo.description, source);
	}
	install(name, formals, body, description, source, primitive = false) {
		this.rules[name] = {
			body: body.introduceParams(formals),
			formals,
			description,
			source,
			primitive
		};
		return this;
	}
	withSuperGrammar(superGrammar) {
		if (this.superGrammar) throw new Error("the super grammar of a GrammarDecl cannot be set more than once");
		this.superGrammar = superGrammar;
		this.rules = Object.create(superGrammar.rules);
		if (!superGrammar.isBuiltIn()) this.defaultStartRule = superGrammar.defaultStartRule;
		return this;
	}
	withDefaultStartRule(ruleName) {
		this.defaultStartRule = ruleName;
		return this;
	}
	withSource(source) {
		this.source = new InputStream(source).interval(0, source.length);
		return this;
	}
	build() {
		const grammar = new Grammar(this.name, this.ensureSuperGrammar(), this.rules, this.defaultStartRule);
		grammar._matchStateInitializer = grammar.superGrammar._matchStateInitializer;
		grammar.supportsIncrementalParsing = grammar.superGrammar.supportsIncrementalParsing;
		const grammarErrors = [];
		let grammarHasInvalidApplications = false;
		Object.keys(grammar.rules).forEach((ruleName) => {
			const { body } = grammar.rules[ruleName];
			try {
				body.assertChoicesHaveUniformArity(ruleName);
			} catch (e) {
				grammarErrors.push(e);
			}
			try {
				body.assertAllApplicationsAreValid(ruleName, grammar);
			} catch (e) {
				grammarErrors.push(e);
				grammarHasInvalidApplications = true;
			}
		});
		if (!grammarHasInvalidApplications) Object.keys(grammar.rules).forEach((ruleName) => {
			const { body } = grammar.rules[ruleName];
			try {
				body.assertIteratedExprsAreNotNullable(grammar, []);
			} catch (e) {
				grammarErrors.push(e);
			}
		});
		if (grammarErrors.length > 0) throwErrors(grammarErrors);
		if (this.source) grammar.source = this.source;
		return grammar;
	}
	define(name, formals, body, description, source, primitive) {
		this.ensureSuperGrammar();
		if (this.superGrammar.rules[name]) throw duplicateRuleDeclaration(name, this.name, this.superGrammar.name, source);
		else if (this.rules[name]) throw duplicateRuleDeclaration(name, this.name, this.name, source);
		const duplicateParameterNames$1 = getDuplicates(formals);
		if (duplicateParameterNames$1.length > 0) throw duplicateParameterNames(name, duplicateParameterNames$1, source);
		return this.install(name, formals, body, description, source, primitive);
	}
	override(name, formals, body, descIgnored, source) {
		this.ensureSuperGrammarRuleForOverriding(name, source);
		this.installOverriddenOrExtendedRule(name, formals, body, source);
		return this;
	}
	extend(name, formals, fragment, descIgnored, source) {
		if (!this.ensureSuperGrammar().rules[name]) throw cannotExtendUndeclaredRule(name, this.superGrammar.name, source);
		const body = new Extend(this.superGrammar, name, fragment);
		body.source = fragment.source;
		this.installOverriddenOrExtendedRule(name, formals, body, source);
		return this;
	}
};

//#endregion
//#region ../node_modules/.pnpm/ohm-js@17.2.1/node_modules/ohm-js/src/Builder.js
var Builder = class {
	constructor() {
		this.currentDecl = null;
		this.currentRuleName = null;
	}
	newGrammar(name) {
		return new GrammarDecl(name);
	}
	grammar(metaInfo, name, superGrammar, defaultStartRule, rules) {
		const gDecl = new GrammarDecl(name);
		if (superGrammar) gDecl.withSuperGrammar(superGrammar instanceof Grammar ? superGrammar : this.fromRecipe(superGrammar));
		if (defaultStartRule) gDecl.withDefaultStartRule(defaultStartRule);
		if (metaInfo && metaInfo.source) gDecl.withSource(metaInfo.source);
		this.currentDecl = gDecl;
		Object.keys(rules).forEach((ruleName) => {
			this.currentRuleName = ruleName;
			const ruleRecipe = rules[ruleName];
			const action = ruleRecipe[0];
			const metaInfo$1 = ruleRecipe[1];
			const description = ruleRecipe[2];
			const formals = ruleRecipe[3];
			const body = this.fromRecipe(ruleRecipe[4]);
			let source;
			if (gDecl.source && metaInfo$1 && metaInfo$1.sourceInterval) source = gDecl.source.subInterval(metaInfo$1.sourceInterval[0], metaInfo$1.sourceInterval[1] - metaInfo$1.sourceInterval[0]);
			gDecl[action](ruleName, formals, body, description, source);
		});
		this.currentRuleName = this.currentDecl = null;
		return gDecl.build();
	}
	terminal(x) {
		return new Terminal(x);
	}
	range(from, to) {
		return new Range(from, to);
	}
	param(index) {
		return new Param(index);
	}
	alt(...termArgs) {
		let terms = [];
		for (let arg of termArgs) {
			if (!(arg instanceof PExpr)) arg = this.fromRecipe(arg);
			if (arg instanceof Alt) terms = terms.concat(arg.terms);
			else terms.push(arg);
		}
		return terms.length === 1 ? terms[0] : new Alt(terms);
	}
	seq(...factorArgs) {
		let factors = [];
		for (let arg of factorArgs) {
			if (!(arg instanceof PExpr)) arg = this.fromRecipe(arg);
			if (arg instanceof Seq) factors = factors.concat(arg.factors);
			else factors.push(arg);
		}
		return factors.length === 1 ? factors[0] : new Seq(factors);
	}
	star(expr) {
		if (!(expr instanceof PExpr)) expr = this.fromRecipe(expr);
		return new Star(expr);
	}
	plus(expr) {
		if (!(expr instanceof PExpr)) expr = this.fromRecipe(expr);
		return new Plus(expr);
	}
	opt(expr) {
		if (!(expr instanceof PExpr)) expr = this.fromRecipe(expr);
		return new Opt(expr);
	}
	not(expr) {
		if (!(expr instanceof PExpr)) expr = this.fromRecipe(expr);
		return new Not(expr);
	}
	lookahead(expr) {
		if (!(expr instanceof PExpr)) expr = this.fromRecipe(expr);
		return new Lookahead(expr);
	}
	lex(expr) {
		if (!(expr instanceof PExpr)) expr = this.fromRecipe(expr);
		return new Lex(expr);
	}
	app(ruleName, optParams) {
		if (optParams && optParams.length > 0) optParams = optParams.map(function(param) {
			return param instanceof PExpr ? param : this.fromRecipe(param);
		}, this);
		return new Apply(ruleName, optParams);
	}
	splice(beforeTerms, afterTerms) {
		return new Splice(this.currentDecl.superGrammar, this.currentRuleName, beforeTerms.map((term) => this.fromRecipe(term)), afterTerms.map((term) => this.fromRecipe(term)));
	}
	fromRecipe(recipe) {
		const args = recipe[0] === "grammar" ? recipe.slice(1) : recipe.slice(2);
		const result$1 = this[recipe[0]](...args);
		const metaInfo = recipe[1];
		if (metaInfo) {
			if (metaInfo.sourceInterval && this.currentDecl) result$1.withSource(this.currentDecl.sourceInterval(...metaInfo.sourceInterval));
		}
		return result$1;
	}
};

//#endregion
//#region ../node_modules/.pnpm/ohm-js@17.2.1/node_modules/ohm-js/src/makeRecipe.js
function makeRecipe(recipe) {
	if (typeof recipe === "function") return recipe.call(new Builder());
	else {
		if (typeof recipe === "string") recipe = JSON.parse(recipe);
		return new Builder().fromRecipe(recipe);
	}
}

//#endregion
//#region ../node_modules/.pnpm/ohm-js@17.2.1/node_modules/ohm-js/dist/built-in-rules.js
var built_in_rules_default = makeRecipe([
	"grammar",
	{ "source": "BuiltInRules {\n\n  alnum  (an alpha-numeric character)\n    = letter\n    | digit\n\n  letter  (a letter)\n    = lower\n    | upper\n    | unicodeLtmo\n\n  digit  (a digit)\n    = \"0\"..\"9\"\n\n  hexDigit  (a hexadecimal digit)\n    = digit\n    | \"a\"..\"f\"\n    | \"A\"..\"F\"\n\n  ListOf<elem, sep>\n    = NonemptyListOf<elem, sep>\n    | EmptyListOf<elem, sep>\n\n  NonemptyListOf<elem, sep>\n    = elem (sep elem)*\n\n  EmptyListOf<elem, sep>\n    = /* nothing */\n\n  listOf<elem, sep>\n    = nonemptyListOf<elem, sep>\n    | emptyListOf<elem, sep>\n\n  nonemptyListOf<elem, sep>\n    = elem (sep elem)*\n\n  emptyListOf<elem, sep>\n    = /* nothing */\n\n  // Allows a syntactic rule application within a lexical context.\n  applySyntactic<app> = app\n}" },
	"BuiltInRules",
	null,
	null,
	{
		"alnum": [
			"define",
			{ "sourceInterval": [18, 78] },
			"an alpha-numeric character",
			[],
			[
				"alt",
				{ "sourceInterval": [60, 78] },
				[
					"app",
					{ "sourceInterval": [60, 66] },
					"letter",
					[]
				],
				[
					"app",
					{ "sourceInterval": [73, 78] },
					"digit",
					[]
				]
			]
		],
		"letter": [
			"define",
			{ "sourceInterval": [82, 142] },
			"a letter",
			[],
			[
				"alt",
				{ "sourceInterval": [107, 142] },
				[
					"app",
					{ "sourceInterval": [107, 112] },
					"lower",
					[]
				],
				[
					"app",
					{ "sourceInterval": [119, 124] },
					"upper",
					[]
				],
				[
					"app",
					{ "sourceInterval": [131, 142] },
					"unicodeLtmo",
					[]
				]
			]
		],
		"digit": [
			"define",
			{ "sourceInterval": [146, 177] },
			"a digit",
			[],
			[
				"range",
				{ "sourceInterval": [169, 177] },
				"0",
				"9"
			]
		],
		"hexDigit": [
			"define",
			{ "sourceInterval": [181, 254] },
			"a hexadecimal digit",
			[],
			[
				"alt",
				{ "sourceInterval": [219, 254] },
				[
					"app",
					{ "sourceInterval": [219, 224] },
					"digit",
					[]
				],
				[
					"range",
					{ "sourceInterval": [231, 239] },
					"a",
					"f"
				],
				[
					"range",
					{ "sourceInterval": [246, 254] },
					"A",
					"F"
				]
			]
		],
		"ListOf": [
			"define",
			{ "sourceInterval": [258, 336] },
			null,
			["elem", "sep"],
			[
				"alt",
				{ "sourceInterval": [282, 336] },
				[
					"app",
					{ "sourceInterval": [282, 307] },
					"NonemptyListOf",
					[[
						"param",
						{ "sourceInterval": [297, 301] },
						0
					], [
						"param",
						{ "sourceInterval": [303, 306] },
						1
					]]
				],
				[
					"app",
					{ "sourceInterval": [314, 336] },
					"EmptyListOf",
					[[
						"param",
						{ "sourceInterval": [326, 330] },
						0
					], [
						"param",
						{ "sourceInterval": [332, 335] },
						1
					]]
				]
			]
		],
		"NonemptyListOf": [
			"define",
			{ "sourceInterval": [340, 388] },
			null,
			["elem", "sep"],
			[
				"seq",
				{ "sourceInterval": [372, 388] },
				[
					"param",
					{ "sourceInterval": [372, 376] },
					0
				],
				[
					"star",
					{ "sourceInterval": [377, 388] },
					[
						"seq",
						{ "sourceInterval": [378, 386] },
						[
							"param",
							{ "sourceInterval": [378, 381] },
							1
						],
						[
							"param",
							{ "sourceInterval": [382, 386] },
							0
						]
					]
				]
			]
		],
		"EmptyListOf": [
			"define",
			{ "sourceInterval": [392, 434] },
			null,
			["elem", "sep"],
			["seq", { "sourceInterval": [438, 438] }]
		],
		"listOf": [
			"define",
			{ "sourceInterval": [438, 516] },
			null,
			["elem", "sep"],
			[
				"alt",
				{ "sourceInterval": [462, 516] },
				[
					"app",
					{ "sourceInterval": [462, 487] },
					"nonemptyListOf",
					[[
						"param",
						{ "sourceInterval": [477, 481] },
						0
					], [
						"param",
						{ "sourceInterval": [483, 486] },
						1
					]]
				],
				[
					"app",
					{ "sourceInterval": [494, 516] },
					"emptyListOf",
					[[
						"param",
						{ "sourceInterval": [506, 510] },
						0
					], [
						"param",
						{ "sourceInterval": [512, 515] },
						1
					]]
				]
			]
		],
		"nonemptyListOf": [
			"define",
			{ "sourceInterval": [520, 568] },
			null,
			["elem", "sep"],
			[
				"seq",
				{ "sourceInterval": [552, 568] },
				[
					"param",
					{ "sourceInterval": [552, 556] },
					0
				],
				[
					"star",
					{ "sourceInterval": [557, 568] },
					[
						"seq",
						{ "sourceInterval": [558, 566] },
						[
							"param",
							{ "sourceInterval": [558, 561] },
							1
						],
						[
							"param",
							{ "sourceInterval": [562, 566] },
							0
						]
					]
				]
			]
		],
		"emptyListOf": [
			"define",
			{ "sourceInterval": [572, 682] },
			null,
			["elem", "sep"],
			["seq", { "sourceInterval": [685, 685] }]
		],
		"applySyntactic": [
			"define",
			{ "sourceInterval": [685, 710] },
			null,
			["app"],
			[
				"param",
				{ "sourceInterval": [707, 710] },
				0
			]
		]
	}
]);

//#endregion
//#region ../node_modules/.pnpm/ohm-js@17.2.1/node_modules/ohm-js/src/main-kernel.js
Grammar.BuiltInRules = built_in_rules_default;
announceBuiltInRules(Grammar.BuiltInRules);

//#endregion
//#region ../node_modules/.pnpm/ohm-js@17.2.1/node_modules/ohm-js/dist/ohm-grammar.js
var ohm_grammar_default = makeRecipe([
	"grammar",
	{ "source": "Ohm {\n\n  Grammars\n    = Grammar*\n\n  Grammar\n    = ident SuperGrammar? \"{\" Rule* \"}\"\n\n  SuperGrammar\n    = \"<:\" ident\n\n  Rule\n    = ident Formals? ruleDescr? \"=\"  RuleBody  -- define\n    | ident Formals?            \":=\" OverrideRuleBody  -- override\n    | ident Formals?            \"+=\" RuleBody  -- extend\n\n  RuleBody\n    = \"|\"? NonemptyListOf<TopLevelTerm, \"|\">\n\n  TopLevelTerm\n    = Seq caseName  -- inline\n    | Seq\n\n  OverrideRuleBody\n    = \"|\"? NonemptyListOf<OverrideTopLevelTerm, \"|\">\n\n  OverrideTopLevelTerm\n    = \"...\"  -- superSplice\n    | TopLevelTerm\n\n  Formals\n    = \"<\" ListOf<ident, \",\"> \">\"\n\n  Params\n    = \"<\" ListOf<Seq, \",\"> \">\"\n\n  Alt\n    = NonemptyListOf<Seq, \"|\">\n\n  Seq\n    = Iter*\n\n  Iter\n    = Pred \"*\"  -- star\n    | Pred \"+\"  -- plus\n    | Pred \"?\"  -- opt\n    | Pred\n\n  Pred\n    = \"~\" Lex  -- not\n    | \"&\" Lex  -- lookahead\n    | Lex\n\n  Lex\n    = \"#\" Base  -- lex\n    | Base\n\n  Base\n    = ident Params? ~(ruleDescr? \"=\" | \":=\" | \"+=\")  -- application\n    | oneCharTerminal \"..\" oneCharTerminal           -- range\n    | terminal                                       -- terminal\n    | \"(\" Alt \")\"                                    -- paren\n\n  ruleDescr  (a rule description)\n    = \"(\" ruleDescrText \")\"\n\n  ruleDescrText\n    = (~\")\" any)*\n\n  caseName\n    = \"--\" (~\"\\n\" space)* name (~\"\\n\" space)* (\"\\n\" | &\"}\")\n\n  name  (a name)\n    = nameFirst nameRest*\n\n  nameFirst\n    = \"_\"\n    | letter\n\n  nameRest\n    = \"_\"\n    | alnum\n\n  ident  (an identifier)\n    = name\n\n  terminal\n    = \"\\\"\" terminalChar* \"\\\"\"\n\n  oneCharTerminal\n    = \"\\\"\" terminalChar \"\\\"\"\n\n  terminalChar\n    = escapeChar\n      | ~\"\\\\\" ~\"\\\"\" ~\"\\n\" \"\\u{0}\"..\"\\u{10FFFF}\"\n\n  escapeChar  (an escape sequence)\n    = \"\\\\\\\\\"                                     -- backslash\n    | \"\\\\\\\"\"                                     -- doubleQuote\n    | \"\\\\\\'\"                                     -- singleQuote\n    | \"\\\\b\"                                      -- backspace\n    | \"\\\\n\"                                      -- lineFeed\n    | \"\\\\r\"                                      -- carriageReturn\n    | \"\\\\t\"                                      -- tab\n    | \"\\\\u{\" hexDigit hexDigit? hexDigit?\n             hexDigit? hexDigit? hexDigit? \"}\"   -- unicodeCodePoint\n    | \"\\\\u\" hexDigit hexDigit hexDigit hexDigit  -- unicodeEscape\n    | \"\\\\x\" hexDigit hexDigit                    -- hexEscape\n\n  space\n   += comment\n\n  comment\n    = \"//\" (~\"\\n\" any)* &(\"\\n\" | end)  -- singleLine\n    | \"/*\" (~\"*/\" any)* \"*/\"  -- multiLine\n\n  tokens = token*\n\n  token = caseName | comment | ident | operator | punctuation | terminal | any\n\n  operator = \"<:\" | \"=\" | \":=\" | \"+=\" | \"*\" | \"+\" | \"?\" | \"~\" | \"&\"\n\n  punctuation = \"<\" | \">\" | \",\" | \"--\"\n}" },
	"Ohm",
	null,
	"Grammars",
	{
		"Grammars": [
			"define",
			{ "sourceInterval": [9, 32] },
			null,
			[],
			[
				"star",
				{ "sourceInterval": [24, 32] },
				[
					"app",
					{ "sourceInterval": [24, 31] },
					"Grammar",
					[]
				]
			]
		],
		"Grammar": [
			"define",
			{ "sourceInterval": [36, 83] },
			null,
			[],
			[
				"seq",
				{ "sourceInterval": [50, 83] },
				[
					"app",
					{ "sourceInterval": [50, 55] },
					"ident",
					[]
				],
				[
					"opt",
					{ "sourceInterval": [56, 69] },
					[
						"app",
						{ "sourceInterval": [56, 68] },
						"SuperGrammar",
						[]
					]
				],
				[
					"terminal",
					{ "sourceInterval": [70, 73] },
					"{"
				],
				[
					"star",
					{ "sourceInterval": [74, 79] },
					[
						"app",
						{ "sourceInterval": [74, 78] },
						"Rule",
						[]
					]
				],
				[
					"terminal",
					{ "sourceInterval": [80, 83] },
					"}"
				]
			]
		],
		"SuperGrammar": [
			"define",
			{ "sourceInterval": [87, 116] },
			null,
			[],
			[
				"seq",
				{ "sourceInterval": [106, 116] },
				[
					"terminal",
					{ "sourceInterval": [106, 110] },
					"<:"
				],
				[
					"app",
					{ "sourceInterval": [111, 116] },
					"ident",
					[]
				]
			]
		],
		"Rule_define": [
			"define",
			{ "sourceInterval": [131, 181] },
			null,
			[],
			[
				"seq",
				{ "sourceInterval": [131, 170] },
				[
					"app",
					{ "sourceInterval": [131, 136] },
					"ident",
					[]
				],
				[
					"opt",
					{ "sourceInterval": [137, 145] },
					[
						"app",
						{ "sourceInterval": [137, 144] },
						"Formals",
						[]
					]
				],
				[
					"opt",
					{ "sourceInterval": [146, 156] },
					[
						"app",
						{ "sourceInterval": [146, 155] },
						"ruleDescr",
						[]
					]
				],
				[
					"terminal",
					{ "sourceInterval": [157, 160] },
					"="
				],
				[
					"app",
					{ "sourceInterval": [162, 170] },
					"RuleBody",
					[]
				]
			]
		],
		"Rule_override": [
			"define",
			{ "sourceInterval": [188, 248] },
			null,
			[],
			[
				"seq",
				{ "sourceInterval": [188, 235] },
				[
					"app",
					{ "sourceInterval": [188, 193] },
					"ident",
					[]
				],
				[
					"opt",
					{ "sourceInterval": [194, 202] },
					[
						"app",
						{ "sourceInterval": [194, 201] },
						"Formals",
						[]
					]
				],
				[
					"terminal",
					{ "sourceInterval": [214, 218] },
					":="
				],
				[
					"app",
					{ "sourceInterval": [219, 235] },
					"OverrideRuleBody",
					[]
				]
			]
		],
		"Rule_extend": [
			"define",
			{ "sourceInterval": [255, 305] },
			null,
			[],
			[
				"seq",
				{ "sourceInterval": [255, 294] },
				[
					"app",
					{ "sourceInterval": [255, 260] },
					"ident",
					[]
				],
				[
					"opt",
					{ "sourceInterval": [261, 269] },
					[
						"app",
						{ "sourceInterval": [261, 268] },
						"Formals",
						[]
					]
				],
				[
					"terminal",
					{ "sourceInterval": [281, 285] },
					"+="
				],
				[
					"app",
					{ "sourceInterval": [286, 294] },
					"RuleBody",
					[]
				]
			]
		],
		"Rule": [
			"define",
			{ "sourceInterval": [120, 305] },
			null,
			[],
			[
				"alt",
				{ "sourceInterval": [131, 305] },
				[
					"app",
					{ "sourceInterval": [131, 170] },
					"Rule_define",
					[]
				],
				[
					"app",
					{ "sourceInterval": [188, 235] },
					"Rule_override",
					[]
				],
				[
					"app",
					{ "sourceInterval": [255, 294] },
					"Rule_extend",
					[]
				]
			]
		],
		"RuleBody": [
			"define",
			{ "sourceInterval": [309, 362] },
			null,
			[],
			[
				"seq",
				{ "sourceInterval": [324, 362] },
				[
					"opt",
					{ "sourceInterval": [324, 328] },
					[
						"terminal",
						{ "sourceInterval": [324, 327] },
						"|"
					]
				],
				[
					"app",
					{ "sourceInterval": [329, 362] },
					"NonemptyListOf",
					[[
						"app",
						{ "sourceInterval": [344, 356] },
						"TopLevelTerm",
						[]
					], [
						"terminal",
						{ "sourceInterval": [358, 361] },
						"|"
					]]
				]
			]
		],
		"TopLevelTerm_inline": [
			"define",
			{ "sourceInterval": [385, 408] },
			null,
			[],
			[
				"seq",
				{ "sourceInterval": [385, 397] },
				[
					"app",
					{ "sourceInterval": [385, 388] },
					"Seq",
					[]
				],
				[
					"app",
					{ "sourceInterval": [389, 397] },
					"caseName",
					[]
				]
			]
		],
		"TopLevelTerm": [
			"define",
			{ "sourceInterval": [366, 418] },
			null,
			[],
			[
				"alt",
				{ "sourceInterval": [385, 418] },
				[
					"app",
					{ "sourceInterval": [385, 397] },
					"TopLevelTerm_inline",
					[]
				],
				[
					"app",
					{ "sourceInterval": [415, 418] },
					"Seq",
					[]
				]
			]
		],
		"OverrideRuleBody": [
			"define",
			{ "sourceInterval": [422, 491] },
			null,
			[],
			[
				"seq",
				{ "sourceInterval": [445, 491] },
				[
					"opt",
					{ "sourceInterval": [445, 449] },
					[
						"terminal",
						{ "sourceInterval": [445, 448] },
						"|"
					]
				],
				[
					"app",
					{ "sourceInterval": [450, 491] },
					"NonemptyListOf",
					[[
						"app",
						{ "sourceInterval": [465, 485] },
						"OverrideTopLevelTerm",
						[]
					], [
						"terminal",
						{ "sourceInterval": [487, 490] },
						"|"
					]]
				]
			]
		],
		"OverrideTopLevelTerm_superSplice": [
			"define",
			{ "sourceInterval": [522, 543] },
			null,
			[],
			[
				"terminal",
				{ "sourceInterval": [522, 527] },
				"..."
			]
		],
		"OverrideTopLevelTerm": [
			"define",
			{ "sourceInterval": [495, 562] },
			null,
			[],
			[
				"alt",
				{ "sourceInterval": [522, 562] },
				[
					"app",
					{ "sourceInterval": [522, 527] },
					"OverrideTopLevelTerm_superSplice",
					[]
				],
				[
					"app",
					{ "sourceInterval": [550, 562] },
					"TopLevelTerm",
					[]
				]
			]
		],
		"Formals": [
			"define",
			{ "sourceInterval": [566, 606] },
			null,
			[],
			[
				"seq",
				{ "sourceInterval": [580, 606] },
				[
					"terminal",
					{ "sourceInterval": [580, 583] },
					"<"
				],
				[
					"app",
					{ "sourceInterval": [584, 602] },
					"ListOf",
					[[
						"app",
						{ "sourceInterval": [591, 596] },
						"ident",
						[]
					], [
						"terminal",
						{ "sourceInterval": [598, 601] },
						","
					]]
				],
				[
					"terminal",
					{ "sourceInterval": [603, 606] },
					">"
				]
			]
		],
		"Params": [
			"define",
			{ "sourceInterval": [610, 647] },
			null,
			[],
			[
				"seq",
				{ "sourceInterval": [623, 647] },
				[
					"terminal",
					{ "sourceInterval": [623, 626] },
					"<"
				],
				[
					"app",
					{ "sourceInterval": [627, 643] },
					"ListOf",
					[[
						"app",
						{ "sourceInterval": [634, 637] },
						"Seq",
						[]
					], [
						"terminal",
						{ "sourceInterval": [639, 642] },
						","
					]]
				],
				[
					"terminal",
					{ "sourceInterval": [644, 647] },
					">"
				]
			]
		],
		"Alt": [
			"define",
			{ "sourceInterval": [651, 685] },
			null,
			[],
			[
				"app",
				{ "sourceInterval": [661, 685] },
				"NonemptyListOf",
				[[
					"app",
					{ "sourceInterval": [676, 679] },
					"Seq",
					[]
				], [
					"terminal",
					{ "sourceInterval": [681, 684] },
					"|"
				]]
			]
		],
		"Seq": [
			"define",
			{ "sourceInterval": [689, 704] },
			null,
			[],
			[
				"star",
				{ "sourceInterval": [699, 704] },
				[
					"app",
					{ "sourceInterval": [699, 703] },
					"Iter",
					[]
				]
			]
		],
		"Iter_star": [
			"define",
			{ "sourceInterval": [719, 736] },
			null,
			[],
			[
				"seq",
				{ "sourceInterval": [719, 727] },
				[
					"app",
					{ "sourceInterval": [719, 723] },
					"Pred",
					[]
				],
				[
					"terminal",
					{ "sourceInterval": [724, 727] },
					"*"
				]
			]
		],
		"Iter_plus": [
			"define",
			{ "sourceInterval": [743, 760] },
			null,
			[],
			[
				"seq",
				{ "sourceInterval": [743, 751] },
				[
					"app",
					{ "sourceInterval": [743, 747] },
					"Pred",
					[]
				],
				[
					"terminal",
					{ "sourceInterval": [748, 751] },
					"+"
				]
			]
		],
		"Iter_opt": [
			"define",
			{ "sourceInterval": [767, 783] },
			null,
			[],
			[
				"seq",
				{ "sourceInterval": [767, 775] },
				[
					"app",
					{ "sourceInterval": [767, 771] },
					"Pred",
					[]
				],
				[
					"terminal",
					{ "sourceInterval": [772, 775] },
					"?"
				]
			]
		],
		"Iter": [
			"define",
			{ "sourceInterval": [708, 794] },
			null,
			[],
			[
				"alt",
				{ "sourceInterval": [719, 794] },
				[
					"app",
					{ "sourceInterval": [719, 727] },
					"Iter_star",
					[]
				],
				[
					"app",
					{ "sourceInterval": [743, 751] },
					"Iter_plus",
					[]
				],
				[
					"app",
					{ "sourceInterval": [767, 775] },
					"Iter_opt",
					[]
				],
				[
					"app",
					{ "sourceInterval": [790, 794] },
					"Pred",
					[]
				]
			]
		],
		"Pred_not": [
			"define",
			{ "sourceInterval": [809, 824] },
			null,
			[],
			[
				"seq",
				{ "sourceInterval": [809, 816] },
				[
					"terminal",
					{ "sourceInterval": [809, 812] },
					"~"
				],
				[
					"app",
					{ "sourceInterval": [813, 816] },
					"Lex",
					[]
				]
			]
		],
		"Pred_lookahead": [
			"define",
			{ "sourceInterval": [831, 852] },
			null,
			[],
			[
				"seq",
				{ "sourceInterval": [831, 838] },
				[
					"terminal",
					{ "sourceInterval": [831, 834] },
					"&"
				],
				[
					"app",
					{ "sourceInterval": [835, 838] },
					"Lex",
					[]
				]
			]
		],
		"Pred": [
			"define",
			{ "sourceInterval": [798, 862] },
			null,
			[],
			[
				"alt",
				{ "sourceInterval": [809, 862] },
				[
					"app",
					{ "sourceInterval": [809, 816] },
					"Pred_not",
					[]
				],
				[
					"app",
					{ "sourceInterval": [831, 838] },
					"Pred_lookahead",
					[]
				],
				[
					"app",
					{ "sourceInterval": [859, 862] },
					"Lex",
					[]
				]
			]
		],
		"Lex_lex": [
			"define",
			{ "sourceInterval": [876, 892] },
			null,
			[],
			[
				"seq",
				{ "sourceInterval": [876, 884] },
				[
					"terminal",
					{ "sourceInterval": [876, 879] },
					"#"
				],
				[
					"app",
					{ "sourceInterval": [880, 884] },
					"Base",
					[]
				]
			]
		],
		"Lex": [
			"define",
			{ "sourceInterval": [866, 903] },
			null,
			[],
			[
				"alt",
				{ "sourceInterval": [876, 903] },
				[
					"app",
					{ "sourceInterval": [876, 884] },
					"Lex_lex",
					[]
				],
				[
					"app",
					{ "sourceInterval": [899, 903] },
					"Base",
					[]
				]
			]
		],
		"Base_application": [
			"define",
			{ "sourceInterval": [918, 979] },
			null,
			[],
			[
				"seq",
				{ "sourceInterval": [918, 963] },
				[
					"app",
					{ "sourceInterval": [918, 923] },
					"ident",
					[]
				],
				[
					"opt",
					{ "sourceInterval": [924, 931] },
					[
						"app",
						{ "sourceInterval": [924, 930] },
						"Params",
						[]
					]
				],
				[
					"not",
					{ "sourceInterval": [932, 963] },
					[
						"alt",
						{ "sourceInterval": [934, 962] },
						[
							"seq",
							{ "sourceInterval": [934, 948] },
							[
								"opt",
								{ "sourceInterval": [934, 944] },
								[
									"app",
									{ "sourceInterval": [934, 943] },
									"ruleDescr",
									[]
								]
							],
							[
								"terminal",
								{ "sourceInterval": [945, 948] },
								"="
							]
						],
						[
							"terminal",
							{ "sourceInterval": [951, 955] },
							":="
						],
						[
							"terminal",
							{ "sourceInterval": [958, 962] },
							"+="
						]
					]
				]
			]
		],
		"Base_range": [
			"define",
			{ "sourceInterval": [986, 1041] },
			null,
			[],
			[
				"seq",
				{ "sourceInterval": [986, 1022] },
				[
					"app",
					{ "sourceInterval": [986, 1001] },
					"oneCharTerminal",
					[]
				],
				[
					"terminal",
					{ "sourceInterval": [1002, 1006] },
					".."
				],
				[
					"app",
					{ "sourceInterval": [1007, 1022] },
					"oneCharTerminal",
					[]
				]
			]
		],
		"Base_terminal": [
			"define",
			{ "sourceInterval": [1048, 1106] },
			null,
			[],
			[
				"app",
				{ "sourceInterval": [1048, 1056] },
				"terminal",
				[]
			]
		],
		"Base_paren": [
			"define",
			{ "sourceInterval": [1113, 1168] },
			null,
			[],
			[
				"seq",
				{ "sourceInterval": [1113, 1124] },
				[
					"terminal",
					{ "sourceInterval": [1113, 1116] },
					"("
				],
				[
					"app",
					{ "sourceInterval": [1117, 1120] },
					"Alt",
					[]
				],
				[
					"terminal",
					{ "sourceInterval": [1121, 1124] },
					")"
				]
			]
		],
		"Base": [
			"define",
			{ "sourceInterval": [907, 1168] },
			null,
			[],
			[
				"alt",
				{ "sourceInterval": [918, 1168] },
				[
					"app",
					{ "sourceInterval": [918, 963] },
					"Base_application",
					[]
				],
				[
					"app",
					{ "sourceInterval": [986, 1022] },
					"Base_range",
					[]
				],
				[
					"app",
					{ "sourceInterval": [1048, 1056] },
					"Base_terminal",
					[]
				],
				[
					"app",
					{ "sourceInterval": [1113, 1124] },
					"Base_paren",
					[]
				]
			]
		],
		"ruleDescr": [
			"define",
			{ "sourceInterval": [1172, 1231] },
			"a rule description",
			[],
			[
				"seq",
				{ "sourceInterval": [1210, 1231] },
				[
					"terminal",
					{ "sourceInterval": [1210, 1213] },
					"("
				],
				[
					"app",
					{ "sourceInterval": [1214, 1227] },
					"ruleDescrText",
					[]
				],
				[
					"terminal",
					{ "sourceInterval": [1228, 1231] },
					")"
				]
			]
		],
		"ruleDescrText": [
			"define",
			{ "sourceInterval": [1235, 1266] },
			null,
			[],
			[
				"star",
				{ "sourceInterval": [1255, 1266] },
				[
					"seq",
					{ "sourceInterval": [1256, 1264] },
					[
						"not",
						{ "sourceInterval": [1256, 1260] },
						[
							"terminal",
							{ "sourceInterval": [1257, 1260] },
							")"
						]
					],
					[
						"app",
						{ "sourceInterval": [1261, 1264] },
						"any",
						[]
					]
				]
			]
		],
		"caseName": [
			"define",
			{ "sourceInterval": [1270, 1338] },
			null,
			[],
			[
				"seq",
				{ "sourceInterval": [1285, 1338] },
				[
					"terminal",
					{ "sourceInterval": [1285, 1289] },
					"--"
				],
				[
					"star",
					{ "sourceInterval": [1290, 1304] },
					[
						"seq",
						{ "sourceInterval": [1291, 1302] },
						[
							"not",
							{ "sourceInterval": [1291, 1296] },
							[
								"terminal",
								{ "sourceInterval": [1292, 1296] },
								"\n"
							]
						],
						[
							"app",
							{ "sourceInterval": [1297, 1302] },
							"space",
							[]
						]
					]
				],
				[
					"app",
					{ "sourceInterval": [1305, 1309] },
					"name",
					[]
				],
				[
					"star",
					{ "sourceInterval": [1310, 1324] },
					[
						"seq",
						{ "sourceInterval": [1311, 1322] },
						[
							"not",
							{ "sourceInterval": [1311, 1316] },
							[
								"terminal",
								{ "sourceInterval": [1312, 1316] },
								"\n"
							]
						],
						[
							"app",
							{ "sourceInterval": [1317, 1322] },
							"space",
							[]
						]
					]
				],
				[
					"alt",
					{ "sourceInterval": [1326, 1337] },
					[
						"terminal",
						{ "sourceInterval": [1326, 1330] },
						"\n"
					],
					[
						"lookahead",
						{ "sourceInterval": [1333, 1337] },
						[
							"terminal",
							{ "sourceInterval": [1334, 1337] },
							"}"
						]
					]
				]
			]
		],
		"name": [
			"define",
			{ "sourceInterval": [1342, 1382] },
			"a name",
			[],
			[
				"seq",
				{ "sourceInterval": [1363, 1382] },
				[
					"app",
					{ "sourceInterval": [1363, 1372] },
					"nameFirst",
					[]
				],
				[
					"star",
					{ "sourceInterval": [1373, 1382] },
					[
						"app",
						{ "sourceInterval": [1373, 1381] },
						"nameRest",
						[]
					]
				]
			]
		],
		"nameFirst": [
			"define",
			{ "sourceInterval": [1386, 1418] },
			null,
			[],
			[
				"alt",
				{ "sourceInterval": [1402, 1418] },
				[
					"terminal",
					{ "sourceInterval": [1402, 1405] },
					"_"
				],
				[
					"app",
					{ "sourceInterval": [1412, 1418] },
					"letter",
					[]
				]
			]
		],
		"nameRest": [
			"define",
			{ "sourceInterval": [1422, 1452] },
			null,
			[],
			[
				"alt",
				{ "sourceInterval": [1437, 1452] },
				[
					"terminal",
					{ "sourceInterval": [1437, 1440] },
					"_"
				],
				[
					"app",
					{ "sourceInterval": [1447, 1452] },
					"alnum",
					[]
				]
			]
		],
		"ident": [
			"define",
			{ "sourceInterval": [1456, 1489] },
			"an identifier",
			[],
			[
				"app",
				{ "sourceInterval": [1485, 1489] },
				"name",
				[]
			]
		],
		"terminal": [
			"define",
			{ "sourceInterval": [1493, 1531] },
			null,
			[],
			[
				"seq",
				{ "sourceInterval": [1508, 1531] },
				[
					"terminal",
					{ "sourceInterval": [1508, 1512] },
					"\""
				],
				[
					"star",
					{ "sourceInterval": [1513, 1526] },
					[
						"app",
						{ "sourceInterval": [1513, 1525] },
						"terminalChar",
						[]
					]
				],
				[
					"terminal",
					{ "sourceInterval": [1527, 1531] },
					"\""
				]
			]
		],
		"oneCharTerminal": [
			"define",
			{ "sourceInterval": [1535, 1579] },
			null,
			[],
			[
				"seq",
				{ "sourceInterval": [1557, 1579] },
				[
					"terminal",
					{ "sourceInterval": [1557, 1561] },
					"\""
				],
				[
					"app",
					{ "sourceInterval": [1562, 1574] },
					"terminalChar",
					[]
				],
				[
					"terminal",
					{ "sourceInterval": [1575, 1579] },
					"\""
				]
			]
		],
		"terminalChar": [
			"define",
			{ "sourceInterval": [1583, 1660] },
			null,
			[],
			[
				"alt",
				{ "sourceInterval": [1602, 1660] },
				[
					"app",
					{ "sourceInterval": [1602, 1612] },
					"escapeChar",
					[]
				],
				[
					"seq",
					{ "sourceInterval": [1621, 1660] },
					[
						"not",
						{ "sourceInterval": [1621, 1626] },
						[
							"terminal",
							{ "sourceInterval": [1622, 1626] },
							"\\"
						]
					],
					[
						"not",
						{ "sourceInterval": [1627, 1632] },
						[
							"terminal",
							{ "sourceInterval": [1628, 1632] },
							"\""
						]
					],
					[
						"not",
						{ "sourceInterval": [1633, 1638] },
						[
							"terminal",
							{ "sourceInterval": [1634, 1638] },
							"\n"
						]
					],
					[
						"range",
						{ "sourceInterval": [1639, 1660] },
						"\0",
						"􏿿"
					]
				]
			]
		],
		"escapeChar_backslash": [
			"define",
			{ "sourceInterval": [1703, 1758] },
			null,
			[],
			[
				"terminal",
				{ "sourceInterval": [1703, 1709] },
				"\\\\"
			]
		],
		"escapeChar_doubleQuote": [
			"define",
			{ "sourceInterval": [1765, 1822] },
			null,
			[],
			[
				"terminal",
				{ "sourceInterval": [1765, 1771] },
				"\\\""
			]
		],
		"escapeChar_singleQuote": [
			"define",
			{ "sourceInterval": [1829, 1886] },
			null,
			[],
			[
				"terminal",
				{ "sourceInterval": [1829, 1835] },
				"\\'"
			]
		],
		"escapeChar_backspace": [
			"define",
			{ "sourceInterval": [1893, 1948] },
			null,
			[],
			[
				"terminal",
				{ "sourceInterval": [1893, 1898] },
				"\\b"
			]
		],
		"escapeChar_lineFeed": [
			"define",
			{ "sourceInterval": [1955, 2009] },
			null,
			[],
			[
				"terminal",
				{ "sourceInterval": [1955, 1960] },
				"\\n"
			]
		],
		"escapeChar_carriageReturn": [
			"define",
			{ "sourceInterval": [2016, 2076] },
			null,
			[],
			[
				"terminal",
				{ "sourceInterval": [2016, 2021] },
				"\\r"
			]
		],
		"escapeChar_tab": [
			"define",
			{ "sourceInterval": [2083, 2132] },
			null,
			[],
			[
				"terminal",
				{ "sourceInterval": [2083, 2088] },
				"\\t"
			]
		],
		"escapeChar_unicodeCodePoint": [
			"define",
			{ "sourceInterval": [2139, 2243] },
			null,
			[],
			[
				"seq",
				{ "sourceInterval": [2139, 2221] },
				[
					"terminal",
					{ "sourceInterval": [2139, 2145] },
					"\\u{"
				],
				[
					"app",
					{ "sourceInterval": [2146, 2154] },
					"hexDigit",
					[]
				],
				[
					"opt",
					{ "sourceInterval": [2155, 2164] },
					[
						"app",
						{ "sourceInterval": [2155, 2163] },
						"hexDigit",
						[]
					]
				],
				[
					"opt",
					{ "sourceInterval": [2165, 2174] },
					[
						"app",
						{ "sourceInterval": [2165, 2173] },
						"hexDigit",
						[]
					]
				],
				[
					"opt",
					{ "sourceInterval": [2188, 2197] },
					[
						"app",
						{ "sourceInterval": [2188, 2196] },
						"hexDigit",
						[]
					]
				],
				[
					"opt",
					{ "sourceInterval": [2198, 2207] },
					[
						"app",
						{ "sourceInterval": [2198, 2206] },
						"hexDigit",
						[]
					]
				],
				[
					"opt",
					{ "sourceInterval": [2208, 2217] },
					[
						"app",
						{ "sourceInterval": [2208, 2216] },
						"hexDigit",
						[]
					]
				],
				[
					"terminal",
					{ "sourceInterval": [2218, 2221] },
					"}"
				]
			]
		],
		"escapeChar_unicodeEscape": [
			"define",
			{ "sourceInterval": [2250, 2309] },
			null,
			[],
			[
				"seq",
				{ "sourceInterval": [2250, 2291] },
				[
					"terminal",
					{ "sourceInterval": [2250, 2255] },
					"\\u"
				],
				[
					"app",
					{ "sourceInterval": [2256, 2264] },
					"hexDigit",
					[]
				],
				[
					"app",
					{ "sourceInterval": [2265, 2273] },
					"hexDigit",
					[]
				],
				[
					"app",
					{ "sourceInterval": [2274, 2282] },
					"hexDigit",
					[]
				],
				[
					"app",
					{ "sourceInterval": [2283, 2291] },
					"hexDigit",
					[]
				]
			]
		],
		"escapeChar_hexEscape": [
			"define",
			{ "sourceInterval": [2316, 2371] },
			null,
			[],
			[
				"seq",
				{ "sourceInterval": [2316, 2339] },
				[
					"terminal",
					{ "sourceInterval": [2316, 2321] },
					"\\x"
				],
				[
					"app",
					{ "sourceInterval": [2322, 2330] },
					"hexDigit",
					[]
				],
				[
					"app",
					{ "sourceInterval": [2331, 2339] },
					"hexDigit",
					[]
				]
			]
		],
		"escapeChar": [
			"define",
			{ "sourceInterval": [1664, 2371] },
			"an escape sequence",
			[],
			[
				"alt",
				{ "sourceInterval": [1703, 2371] },
				[
					"app",
					{ "sourceInterval": [1703, 1709] },
					"escapeChar_backslash",
					[]
				],
				[
					"app",
					{ "sourceInterval": [1765, 1771] },
					"escapeChar_doubleQuote",
					[]
				],
				[
					"app",
					{ "sourceInterval": [1829, 1835] },
					"escapeChar_singleQuote",
					[]
				],
				[
					"app",
					{ "sourceInterval": [1893, 1898] },
					"escapeChar_backspace",
					[]
				],
				[
					"app",
					{ "sourceInterval": [1955, 1960] },
					"escapeChar_lineFeed",
					[]
				],
				[
					"app",
					{ "sourceInterval": [2016, 2021] },
					"escapeChar_carriageReturn",
					[]
				],
				[
					"app",
					{ "sourceInterval": [2083, 2088] },
					"escapeChar_tab",
					[]
				],
				[
					"app",
					{ "sourceInterval": [2139, 2221] },
					"escapeChar_unicodeCodePoint",
					[]
				],
				[
					"app",
					{ "sourceInterval": [2250, 2291] },
					"escapeChar_unicodeEscape",
					[]
				],
				[
					"app",
					{ "sourceInterval": [2316, 2339] },
					"escapeChar_hexEscape",
					[]
				]
			]
		],
		"space": [
			"extend",
			{ "sourceInterval": [2375, 2394] },
			null,
			[],
			[
				"app",
				{ "sourceInterval": [2387, 2394] },
				"comment",
				[]
			]
		],
		"comment_singleLine": [
			"define",
			{ "sourceInterval": [2412, 2458] },
			null,
			[],
			[
				"seq",
				{ "sourceInterval": [2412, 2443] },
				[
					"terminal",
					{ "sourceInterval": [2412, 2416] },
					"//"
				],
				[
					"star",
					{ "sourceInterval": [2417, 2429] },
					[
						"seq",
						{ "sourceInterval": [2418, 2427] },
						[
							"not",
							{ "sourceInterval": [2418, 2423] },
							[
								"terminal",
								{ "sourceInterval": [2419, 2423] },
								"\n"
							]
						],
						[
							"app",
							{ "sourceInterval": [2424, 2427] },
							"any",
							[]
						]
					]
				],
				[
					"lookahead",
					{ "sourceInterval": [2430, 2443] },
					[
						"alt",
						{ "sourceInterval": [2432, 2442] },
						[
							"terminal",
							{ "sourceInterval": [2432, 2436] },
							"\n"
						],
						[
							"app",
							{ "sourceInterval": [2439, 2442] },
							"end",
							[]
						]
					]
				]
			]
		],
		"comment_multiLine": [
			"define",
			{ "sourceInterval": [2465, 2501] },
			null,
			[],
			[
				"seq",
				{ "sourceInterval": [2465, 2487] },
				[
					"terminal",
					{ "sourceInterval": [2465, 2469] },
					"/*"
				],
				[
					"star",
					{ "sourceInterval": [2470, 2482] },
					[
						"seq",
						{ "sourceInterval": [2471, 2480] },
						[
							"not",
							{ "sourceInterval": [2471, 2476] },
							[
								"terminal",
								{ "sourceInterval": [2472, 2476] },
								"*/"
							]
						],
						[
							"app",
							{ "sourceInterval": [2477, 2480] },
							"any",
							[]
						]
					]
				],
				[
					"terminal",
					{ "sourceInterval": [2483, 2487] },
					"*/"
				]
			]
		],
		"comment": [
			"define",
			{ "sourceInterval": [2398, 2501] },
			null,
			[],
			[
				"alt",
				{ "sourceInterval": [2412, 2501] },
				[
					"app",
					{ "sourceInterval": [2412, 2443] },
					"comment_singleLine",
					[]
				],
				[
					"app",
					{ "sourceInterval": [2465, 2487] },
					"comment_multiLine",
					[]
				]
			]
		],
		"tokens": [
			"define",
			{ "sourceInterval": [2505, 2520] },
			null,
			[],
			[
				"star",
				{ "sourceInterval": [2514, 2520] },
				[
					"app",
					{ "sourceInterval": [2514, 2519] },
					"token",
					[]
				]
			]
		],
		"token": [
			"define",
			{ "sourceInterval": [2524, 2600] },
			null,
			[],
			[
				"alt",
				{ "sourceInterval": [2532, 2600] },
				[
					"app",
					{ "sourceInterval": [2532, 2540] },
					"caseName",
					[]
				],
				[
					"app",
					{ "sourceInterval": [2543, 2550] },
					"comment",
					[]
				],
				[
					"app",
					{ "sourceInterval": [2553, 2558] },
					"ident",
					[]
				],
				[
					"app",
					{ "sourceInterval": [2561, 2569] },
					"operator",
					[]
				],
				[
					"app",
					{ "sourceInterval": [2572, 2583] },
					"punctuation",
					[]
				],
				[
					"app",
					{ "sourceInterval": [2586, 2594] },
					"terminal",
					[]
				],
				[
					"app",
					{ "sourceInterval": [2597, 2600] },
					"any",
					[]
				]
			]
		],
		"operator": [
			"define",
			{ "sourceInterval": [2604, 2669] },
			null,
			[],
			[
				"alt",
				{ "sourceInterval": [2615, 2669] },
				[
					"terminal",
					{ "sourceInterval": [2615, 2619] },
					"<:"
				],
				[
					"terminal",
					{ "sourceInterval": [2622, 2625] },
					"="
				],
				[
					"terminal",
					{ "sourceInterval": [2628, 2632] },
					":="
				],
				[
					"terminal",
					{ "sourceInterval": [2635, 2639] },
					"+="
				],
				[
					"terminal",
					{ "sourceInterval": [2642, 2645] },
					"*"
				],
				[
					"terminal",
					{ "sourceInterval": [2648, 2651] },
					"+"
				],
				[
					"terminal",
					{ "sourceInterval": [2654, 2657] },
					"?"
				],
				[
					"terminal",
					{ "sourceInterval": [2660, 2663] },
					"~"
				],
				[
					"terminal",
					{ "sourceInterval": [2666, 2669] },
					"&"
				]
			]
		],
		"punctuation": [
			"define",
			{ "sourceInterval": [2673, 2709] },
			null,
			[],
			[
				"alt",
				{ "sourceInterval": [2687, 2709] },
				[
					"terminal",
					{ "sourceInterval": [2687, 2690] },
					"<"
				],
				[
					"terminal",
					{ "sourceInterval": [2693, 2696] },
					">"
				],
				[
					"terminal",
					{ "sourceInterval": [2699, 2702] },
					","
				],
				[
					"terminal",
					{ "sourceInterval": [2705, 2709] },
					"--"
				]
			]
		]
	}
]);

//#endregion
//#region ../node_modules/.pnpm/ohm-js@17.2.1/node_modules/ohm-js/src/buildGrammar.js
const superSplicePlaceholder = Object.create(PExpr.prototype);
function namespaceHas(ns, name) {
	for (const prop in ns) if (prop === name) return true;
	return false;
}
function buildGrammar(match, namespace, optOhmGrammarForTesting) {
	const builder = new Builder();
	let decl;
	let currentRuleName;
	let currentRuleFormals;
	let overriding = false;
	return (optOhmGrammarForTesting || ohm_grammar_default).createSemantics().addOperation("visit", {
		Grammars(grammarIter) {
			return grammarIter.children.map((c) => c.visit());
		},
		Grammar(id, s, _open, rules, _close) {
			const grammarName = id.visit();
			decl = builder.newGrammar(grammarName);
			s.child(0) && s.child(0).visit();
			rules.children.map((c) => c.visit());
			const g = decl.build();
			g.source = this.source.trimmed();
			if (namespaceHas(namespace, grammarName)) throw duplicateGrammarDeclaration(g, namespace);
			namespace[grammarName] = g;
			return g;
		},
		SuperGrammar(_, n) {
			const superGrammarName = n.visit();
			if (superGrammarName === "null") decl.withSuperGrammar(null);
			else {
				if (!namespace || !namespaceHas(namespace, superGrammarName)) throw undeclaredGrammar(superGrammarName, namespace, n.source);
				decl.withSuperGrammar(namespace[superGrammarName]);
			}
		},
		Rule_define(n, fs, d, _, b) {
			currentRuleName = n.visit();
			currentRuleFormals = fs.children.map((c) => c.visit())[0] || [];
			if (!decl.defaultStartRule && decl.ensureSuperGrammar() !== Grammar.ProtoBuiltInRules) decl.withDefaultStartRule(currentRuleName);
			const body = b.visit();
			const description = d.children.map((c) => c.visit())[0];
			const source = this.source.trimmed();
			return decl.define(currentRuleName, currentRuleFormals, body, description, source);
		},
		Rule_override(n, fs, _, b) {
			currentRuleName = n.visit();
			currentRuleFormals = fs.children.map((c) => c.visit())[0] || [];
			const source = this.source.trimmed();
			decl.ensureSuperGrammarRuleForOverriding(currentRuleName, source);
			overriding = true;
			const body = b.visit();
			overriding = false;
			return decl.override(currentRuleName, currentRuleFormals, body, null, source);
		},
		Rule_extend(n, fs, _, b) {
			currentRuleName = n.visit();
			currentRuleFormals = fs.children.map((c) => c.visit())[0] || [];
			const body = b.visit();
			const source = this.source.trimmed();
			return decl.extend(currentRuleName, currentRuleFormals, body, null, source);
		},
		RuleBody(_, terms) {
			return builder.alt(...terms.visit()).withSource(this.source);
		},
		OverrideRuleBody(_, terms) {
			const args = terms.visit();
			const expansionPos = args.indexOf(superSplicePlaceholder);
			if (expansionPos >= 0) {
				const beforeTerms = args.slice(0, expansionPos);
				const afterTerms = args.slice(expansionPos + 1);
				afterTerms.forEach((t) => {
					if (t === superSplicePlaceholder) throw multipleSuperSplices(t);
				});
				return new Splice(decl.superGrammar, currentRuleName, beforeTerms, afterTerms).withSource(this.source);
			} else return builder.alt(...args).withSource(this.source);
		},
		Formals(opointy, fs, cpointy) {
			return fs.visit();
		},
		Params(opointy, ps, cpointy) {
			return ps.visit();
		},
		Alt(seqs) {
			return builder.alt(...seqs.visit()).withSource(this.source);
		},
		TopLevelTerm_inline(b, n) {
			const inlineRuleName = currentRuleName + "_" + n.visit();
			const body = b.visit();
			const source = this.source.trimmed();
			const isNewRuleDeclaration = !(decl.superGrammar && decl.superGrammar.rules[inlineRuleName]);
			if (overriding && !isNewRuleDeclaration) decl.override(inlineRuleName, currentRuleFormals, body, null, source);
			else decl.define(inlineRuleName, currentRuleFormals, body, null, source);
			const params = currentRuleFormals.map((formal) => builder.app(formal));
			return builder.app(inlineRuleName, params).withSource(body.source);
		},
		OverrideTopLevelTerm_superSplice(_) {
			return superSplicePlaceholder;
		},
		Seq(expr) {
			return builder.seq(...expr.children.map((c) => c.visit())).withSource(this.source);
		},
		Iter_star(x, _) {
			return builder.star(x.visit()).withSource(this.source);
		},
		Iter_plus(x, _) {
			return builder.plus(x.visit()).withSource(this.source);
		},
		Iter_opt(x, _) {
			return builder.opt(x.visit()).withSource(this.source);
		},
		Pred_not(_, x) {
			return builder.not(x.visit()).withSource(this.source);
		},
		Pred_lookahead(_, x) {
			return builder.lookahead(x.visit()).withSource(this.source);
		},
		Lex_lex(_, x) {
			return builder.lex(x.visit()).withSource(this.source);
		},
		Base_application(rule, ps) {
			const params = ps.children.map((c) => c.visit())[0] || [];
			return builder.app(rule.visit(), params).withSource(this.source);
		},
		Base_range(from, _, to) {
			return builder.range(from.visit(), to.visit()).withSource(this.source);
		},
		Base_terminal(expr) {
			return builder.terminal(expr.visit()).withSource(this.source);
		},
		Base_paren(open, x, close) {
			return x.visit();
		},
		ruleDescr(open, t, close) {
			return t.visit();
		},
		ruleDescrText(_) {
			return this.sourceString.trim();
		},
		caseName(_, space1, n, space2, end$1) {
			return n.visit();
		},
		name(first, rest) {
			return this.sourceString;
		},
		nameFirst(expr) {},
		nameRest(expr) {},
		terminal(open, cs, close) {
			return cs.children.map((c) => c.visit()).join("");
		},
		oneCharTerminal(open, c, close) {
			return c.visit();
		},
		escapeChar(c) {
			try {
				return unescapeCodePoint(this.sourceString);
			} catch (err) {
				if (err instanceof RangeError && err.message.startsWith("Invalid code point ")) throw invalidCodePoint(c);
				throw err;
			}
		},
		NonemptyListOf(x, _, xs) {
			return [x.visit()].concat(xs.children.map((c) => c.visit()));
		},
		EmptyListOf() {
			return [];
		},
		_terminal() {
			return this.sourceString;
		}
	})(match).visit();
}

//#endregion
//#region ../node_modules/.pnpm/ohm-js@17.2.1/node_modules/ohm-js/dist/operations-and-attributes.js
var operations_and_attributes_default = makeRecipe([
	"grammar",
	{ "source": "OperationsAndAttributes {\n\n  AttributeSignature =\n    name\n\n  OperationSignature =\n    name Formals?\n\n  Formals\n    = \"(\" ListOf<name, \",\"> \")\"\n\n  name  (a name)\n    = nameFirst nameRest*\n\n  nameFirst\n    = \"_\"\n    | letter\n\n  nameRest\n    = \"_\"\n    | alnum\n\n}" },
	"OperationsAndAttributes",
	null,
	"AttributeSignature",
	{
		"AttributeSignature": [
			"define",
			{ "sourceInterval": [29, 58] },
			null,
			[],
			[
				"app",
				{ "sourceInterval": [54, 58] },
				"name",
				[]
			]
		],
		"OperationSignature": [
			"define",
			{ "sourceInterval": [62, 100] },
			null,
			[],
			[
				"seq",
				{ "sourceInterval": [87, 100] },
				[
					"app",
					{ "sourceInterval": [87, 91] },
					"name",
					[]
				],
				[
					"opt",
					{ "sourceInterval": [92, 100] },
					[
						"app",
						{ "sourceInterval": [92, 99] },
						"Formals",
						[]
					]
				]
			]
		],
		"Formals": [
			"define",
			{ "sourceInterval": [104, 143] },
			null,
			[],
			[
				"seq",
				{ "sourceInterval": [118, 143] },
				[
					"terminal",
					{ "sourceInterval": [118, 121] },
					"("
				],
				[
					"app",
					{ "sourceInterval": [122, 139] },
					"ListOf",
					[[
						"app",
						{ "sourceInterval": [129, 133] },
						"name",
						[]
					], [
						"terminal",
						{ "sourceInterval": [135, 138] },
						","
					]]
				],
				[
					"terminal",
					{ "sourceInterval": [140, 143] },
					")"
				]
			]
		],
		"name": [
			"define",
			{ "sourceInterval": [147, 187] },
			"a name",
			[],
			[
				"seq",
				{ "sourceInterval": [168, 187] },
				[
					"app",
					{ "sourceInterval": [168, 177] },
					"nameFirst",
					[]
				],
				[
					"star",
					{ "sourceInterval": [178, 187] },
					[
						"app",
						{ "sourceInterval": [178, 186] },
						"nameRest",
						[]
					]
				]
			]
		],
		"nameFirst": [
			"define",
			{ "sourceInterval": [191, 223] },
			null,
			[],
			[
				"alt",
				{ "sourceInterval": [207, 223] },
				[
					"terminal",
					{ "sourceInterval": [207, 210] },
					"_"
				],
				[
					"app",
					{ "sourceInterval": [217, 223] },
					"letter",
					[]
				]
			]
		],
		"nameRest": [
			"define",
			{ "sourceInterval": [227, 257] },
			null,
			[],
			[
				"alt",
				{ "sourceInterval": [242, 257] },
				[
					"terminal",
					{ "sourceInterval": [242, 245] },
					"_"
				],
				[
					"app",
					{ "sourceInterval": [252, 257] },
					"alnum",
					[]
				]
			]
		]
	}
]);

//#endregion
//#region ../node_modules/.pnpm/ohm-js@17.2.1/node_modules/ohm-js/src/semanticsDeferredInit.js
initBuiltInSemantics(Grammar.BuiltInRules);
initPrototypeParser(operations_and_attributes_default);
function initBuiltInSemantics(builtInRules) {
	const actions = {
		empty() {
			return this.iteration();
		},
		nonEmpty(first, _, rest) {
			return this.iteration([first].concat(rest.children));
		},
		self(..._children) {
			return this;
		}
	};
	Semantics.BuiltInSemantics = Semantics.createSemantics(builtInRules, null).addOperation("asIteration", {
		emptyListOf: actions.empty,
		nonemptyListOf: actions.nonEmpty,
		EmptyListOf: actions.empty,
		NonemptyListOf: actions.nonEmpty,
		_iter: actions.self
	});
}
function initPrototypeParser(grammar) {
	Semantics.prototypeGrammarSemantics = grammar.createSemantics().addOperation("parse", {
		AttributeSignature(name) {
			return {
				name: name.parse(),
				formals: []
			};
		},
		OperationSignature(name, optFormals) {
			return {
				name: name.parse(),
				formals: optFormals.children.map((c) => c.parse())[0] || []
			};
		},
		Formals(oparen, fs, cparen) {
			return fs.asIteration().children.map((c) => c.parse());
		},
		name(first, rest) {
			return this.sourceString;
		}
	});
	Semantics.prototypeGrammar = grammar;
}

//#endregion
//#region ../node_modules/.pnpm/ohm-js@17.2.1/node_modules/ohm-js/src/findIndentation.js
function findIndentation(input) {
	let pos = 0;
	const stack = [0];
	const topOfStack = () => stack[stack.length - 1];
	const result$1 = {};
	const regex = /( *).*(?:$|\r?\n|\r)/g;
	let match;
	while ((match = regex.exec(input)) != null) {
		const [line, indent] = match;
		if (line.length === 0) break;
		const indentSize = indent.length;
		const prevSize = topOfStack();
		const indentPos = pos + indentSize;
		if (indentSize > prevSize) {
			stack.push(indentSize);
			result$1[indentPos] = 1;
		} else if (indentSize < prevSize) {
			const prevLength = stack.length;
			while (topOfStack() !== indentSize) stack.pop();
			result$1[indentPos] = -1 * (prevLength - stack.length);
		}
		pos += line.length;
	}
	if (stack.length > 1) result$1[pos] = 1 - stack.length;
	return result$1;
}

//#endregion
//#region ../node_modules/.pnpm/ohm-js@17.2.1/node_modules/ohm-js/src/IndentationSensitive.js
const INDENT_DESCRIPTION = "an indented block";
const DEDENT_DESCRIPTION = "a dedent";
const INVALID_CODE_POINT = 1114112;
var InputStreamWithIndentation = class extends InputStream {
	constructor(state) {
		super(state.input);
		this.state = state;
	}
	_indentationAt(pos) {
		return this.state.userData[pos] || 0;
	}
	atEnd() {
		return super.atEnd() && this._indentationAt(this.pos) === 0;
	}
	next() {
		if (this._indentationAt(this.pos) !== 0) {
			this.examinedLength = Math.max(this.examinedLength, this.pos);
			return;
		}
		return super.next();
	}
	nextCharCode() {
		if (this._indentationAt(this.pos) !== 0) {
			this.examinedLength = Math.max(this.examinedLength, this.pos);
			return INVALID_CODE_POINT;
		}
		return super.nextCharCode();
	}
	nextCodePoint() {
		if (this._indentationAt(this.pos) !== 0) {
			this.examinedLength = Math.max(this.examinedLength, this.pos);
			return INVALID_CODE_POINT;
		}
		return super.nextCodePoint();
	}
};
var Indentation = class extends PExpr {
	constructor(isIndent = true) {
		super();
		this.isIndent = isIndent;
	}
	allowsSkippingPrecedingSpace() {
		return true;
	}
	eval(state) {
		const { inputStream } = state;
		const pseudoTokens = state.userData;
		state.doNotMemoize = true;
		const origPos = inputStream.pos;
		const sign = this.isIndent ? 1 : -1;
		if ((pseudoTokens[origPos] || 0) * sign > 0) {
			state.userData = Object.create(pseudoTokens);
			state.userData[origPos] -= sign;
			state.pushBinding(new TerminalNode(0), origPos);
			return true;
		} else {
			state.processFailure(origPos, this);
			return false;
		}
	}
	getArity() {
		return 1;
	}
	_assertAllApplicationsAreValid(ruleName, grammar) {}
	_isNullable(grammar, memo) {
		return false;
	}
	assertChoicesHaveUniformArity(ruleName) {}
	assertIteratedExprsAreNotNullable(grammar) {}
	introduceParams(formals) {
		return this;
	}
	substituteParams(actuals) {
		return this;
	}
	toString() {
		return this.isIndent ? "indent" : "dedent";
	}
	toDisplayString() {
		return this.toString();
	}
	toFailure(grammar) {
		const description = this.isIndent ? INDENT_DESCRIPTION : DEDENT_DESCRIPTION;
		return new Failure(this, description, "description");
	}
};
const applyIndent = new Apply("indent");
const applyDedent = new Apply("dedent");
const newAnyBody = new Splice(built_in_rules_default, "any", [applyIndent, applyDedent], []);
const IndentationSensitive = new Builder().newGrammar("IndentationSensitive").withSuperGrammar(built_in_rules_default).define("indent", [], new Indentation(true), INDENT_DESCRIPTION, void 0, true).define("dedent", [], new Indentation(false), DEDENT_DESCRIPTION, void 0, true).extend("any", [], newAnyBody, "any character", void 0).build();
Object.assign(IndentationSensitive, {
	_matchStateInitializer(state) {
		state.userData = findIndentation(state.input);
		state.inputStream = new InputStreamWithIndentation(state);
	},
	supportsIncrementalParsing: false
});

//#endregion
//#region ../node_modules/.pnpm/ohm-js@17.2.1/node_modules/ohm-js/src/main.js
Grammar.initApplicationParser(ohm_grammar_default, buildGrammar);

//#endregion
//#region src/utils/parse-pgarray/grammar/grammar.ohm-bundle.js
const result = {};
result.PGArrayExpression = makeRecipe([
	"grammar",
	{ source: "PGArrayExpression {    \n    Array = \"ARRAY[\" ListOf<ArrayItem, \",\"> \"]\"\n\n    ArrayItem = stringLiteral | Array | quotelessString  | nullLiteral\n\n    stringLiteral = \"\\\"\" ((~(\"\\\"\" | escapedSymbol) any) | escapedSymbol)* \"\\\"\"\n    \n    quotelessString = (~forbiddenSymbolForQuoteless any)+\n\n	escapedSymbol = \"\\\\\" any\n\n    nullLiteral = \"NULL\"\n\n	forbiddenSymbolForQuoteless = \"[\" | \"]\" | \" , \" | \"\\\"\"  | nullLiteral\n}" },
	"PGArrayExpression",
	null,
	"Array",
	{
		Array: [
			"define",
			{ sourceInterval: [28, 71] },
			null,
			[],
			[
				"seq",
				{ sourceInterval: [36, 71] },
				[
					"terminal",
					{ sourceInterval: [36, 44] },
					"ARRAY["
				],
				[
					"app",
					{ sourceInterval: [45, 67] },
					"ListOf",
					[[
						"app",
						{ sourceInterval: [52, 61] },
						"ArrayItem",
						[]
					], [
						"terminal",
						{ sourceInterval: [63, 66] },
						","
					]]
				],
				[
					"terminal",
					{ sourceInterval: [68, 71] },
					"]"
				]
			]
		],
		ArrayItem: [
			"define",
			{ sourceInterval: [77, 143] },
			null,
			[],
			[
				"alt",
				{ sourceInterval: [89, 143] },
				[
					"app",
					{ sourceInterval: [89, 102] },
					"stringLiteral",
					[]
				],
				[
					"app",
					{ sourceInterval: [105, 110] },
					"Array",
					[]
				],
				[
					"app",
					{ sourceInterval: [113, 128] },
					"quotelessString",
					[]
				],
				[
					"app",
					{ sourceInterval: [132, 143] },
					"nullLiteral",
					[]
				]
			]
		],
		stringLiteral: [
			"define",
			{ sourceInterval: [149, 223] },
			null,
			[],
			[
				"seq",
				{ sourceInterval: [165, 223] },
				[
					"terminal",
					{ sourceInterval: [165, 169] },
					"\""
				],
				[
					"star",
					{ sourceInterval: [170, 218] },
					[
						"alt",
						{ sourceInterval: [171, 216] },
						[
							"seq",
							{ sourceInterval: [171, 200] },
							[
								"not",
								{ sourceInterval: [172, 195] },
								[
									"alt",
									{ sourceInterval: [174, 194] },
									[
										"terminal",
										{ sourceInterval: [174, 178] },
										"\""
									],
									[
										"app",
										{ sourceInterval: [181, 194] },
										"escapedSymbol",
										[]
									]
								]
							],
							[
								"app",
								{ sourceInterval: [196, 199] },
								"any",
								[]
							]
						],
						[
							"app",
							{ sourceInterval: [203, 216] },
							"escapedSymbol",
							[]
						]
					]
				],
				[
					"terminal",
					{ sourceInterval: [219, 223] },
					"\""
				]
			]
		],
		quotelessString: [
			"define",
			{ sourceInterval: [233, 286] },
			null,
			[],
			[
				"plus",
				{ sourceInterval: [251, 286] },
				[
					"seq",
					{ sourceInterval: [252, 284] },
					[
						"not",
						{ sourceInterval: [252, 280] },
						[
							"app",
							{ sourceInterval: [253, 280] },
							"forbiddenSymbolForQuoteless",
							[]
						]
					],
					[
						"app",
						{ sourceInterval: [281, 284] },
						"any",
						[]
					]
				]
			]
		],
		escapedSymbol: [
			"define",
			{ sourceInterval: [289, 313] },
			null,
			[],
			[
				"seq",
				{ sourceInterval: [305, 313] },
				[
					"terminal",
					{ sourceInterval: [305, 309] },
					"\\"
				],
				[
					"app",
					{ sourceInterval: [310, 313] },
					"any",
					[]
				]
			]
		],
		nullLiteral: [
			"define",
			{ sourceInterval: [319, 339] },
			null,
			[],
			[
				"terminal",
				{ sourceInterval: [333, 339] },
				"NULL"
			]
		],
		forbiddenSymbolForQuoteless: [
			"define",
			{ sourceInterval: [342, 411] },
			null,
			[],
			[
				"alt",
				{ sourceInterval: [372, 411] },
				[
					"terminal",
					{ sourceInterval: [372, 375] },
					"["
				],
				[
					"terminal",
					{ sourceInterval: [378, 381] },
					"]"
				],
				[
					"terminal",
					{ sourceInterval: [384, 389] },
					" , "
				],
				[
					"terminal",
					{ sourceInterval: [392, 396] },
					"\""
				],
				[
					"app",
					{ sourceInterval: [400, 411] },
					"nullLiteral",
					[]
				]
			]
		]
	}
]);
result.PGArrayLiteral = makeRecipe([
	"grammar",
	{ source: "PGArrayLiteral {    \n    Array = \"{\" ListOf<ArrayItem, \",\"> \"}\"\n\n    ArrayItem = stringLiteral | quotelessString | nullLiteral | Array\n\n    stringLiteral = \"\\\"\" ((~(\"\\\"\" | escapedSymbol) any) | escapedSymbol)* \"\\\"\"\n    \n    quotelessString = (~forbiddenSymbolForQuoteless any)+\n\n	escapedSymbol = \"\\\\\" any \n\n    nullLiteral = \"NULL\"\n\n	forbiddenSymbolForQuoteless = \"{\" | \"}\" | \",\" | \"\\\"\"  | nullLiteral\n}" },
	"PGArrayLiteral",
	null,
	"Array",
	{
		Array: [
			"define",
			{ sourceInterval: [25, 63] },
			null,
			[],
			[
				"seq",
				{ sourceInterval: [33, 63] },
				[
					"terminal",
					{ sourceInterval: [33, 36] },
					"{"
				],
				[
					"app",
					{ sourceInterval: [37, 59] },
					"ListOf",
					[[
						"app",
						{ sourceInterval: [44, 53] },
						"ArrayItem",
						[]
					], [
						"terminal",
						{ sourceInterval: [55, 58] },
						","
					]]
				],
				[
					"terminal",
					{ sourceInterval: [60, 63] },
					"}"
				]
			]
		],
		ArrayItem: [
			"define",
			{ sourceInterval: [69, 134] },
			null,
			[],
			[
				"alt",
				{ sourceInterval: [81, 134] },
				[
					"app",
					{ sourceInterval: [81, 94] },
					"stringLiteral",
					[]
				],
				[
					"app",
					{ sourceInterval: [97, 112] },
					"quotelessString",
					[]
				],
				[
					"app",
					{ sourceInterval: [115, 126] },
					"nullLiteral",
					[]
				],
				[
					"app",
					{ sourceInterval: [129, 134] },
					"Array",
					[]
				]
			]
		],
		stringLiteral: [
			"define",
			{ sourceInterval: [140, 214] },
			null,
			[],
			[
				"seq",
				{ sourceInterval: [156, 214] },
				[
					"terminal",
					{ sourceInterval: [156, 160] },
					"\""
				],
				[
					"star",
					{ sourceInterval: [161, 209] },
					[
						"alt",
						{ sourceInterval: [162, 207] },
						[
							"seq",
							{ sourceInterval: [162, 191] },
							[
								"not",
								{ sourceInterval: [163, 186] },
								[
									"alt",
									{ sourceInterval: [165, 185] },
									[
										"terminal",
										{ sourceInterval: [165, 169] },
										"\""
									],
									[
										"app",
										{ sourceInterval: [172, 185] },
										"escapedSymbol",
										[]
									]
								]
							],
							[
								"app",
								{ sourceInterval: [187, 190] },
								"any",
								[]
							]
						],
						[
							"app",
							{ sourceInterval: [194, 207] },
							"escapedSymbol",
							[]
						]
					]
				],
				[
					"terminal",
					{ sourceInterval: [210, 214] },
					"\""
				]
			]
		],
		quotelessString: [
			"define",
			{ sourceInterval: [224, 277] },
			null,
			[],
			[
				"plus",
				{ sourceInterval: [242, 277] },
				[
					"seq",
					{ sourceInterval: [243, 275] },
					[
						"not",
						{ sourceInterval: [243, 271] },
						[
							"app",
							{ sourceInterval: [244, 271] },
							"forbiddenSymbolForQuoteless",
							[]
						]
					],
					[
						"app",
						{ sourceInterval: [272, 275] },
						"any",
						[]
					]
				]
			]
		],
		escapedSymbol: [
			"define",
			{ sourceInterval: [280, 304] },
			null,
			[],
			[
				"seq",
				{ sourceInterval: [296, 304] },
				[
					"terminal",
					{ sourceInterval: [296, 300] },
					"\\"
				],
				[
					"app",
					{ sourceInterval: [301, 304] },
					"any",
					[]
				]
			]
		],
		nullLiteral: [
			"define",
			{ sourceInterval: [311, 331] },
			null,
			[],
			[
				"terminal",
				{ sourceInterval: [325, 331] },
				"NULL"
			]
		],
		forbiddenSymbolForQuoteless: [
			"define",
			{ sourceInterval: [334, 401] },
			null,
			[],
			[
				"alt",
				{ sourceInterval: [364, 401] },
				[
					"terminal",
					{ sourceInterval: [364, 367] },
					"{"
				],
				[
					"terminal",
					{ sourceInterval: [370, 373] },
					"}"
				],
				[
					"terminal",
					{ sourceInterval: [376, 379] },
					","
				],
				[
					"terminal",
					{ sourceInterval: [382, 386] },
					"\""
				],
				[
					"app",
					{ sourceInterval: [390, 401] },
					"nullLiteral",
					[]
				]
			]
		]
	}
]);
var grammar_ohm_bundle_default = result;

//#endregion
//#region src/utils/parse-pgarray/index.ts
const literalArraySemantics = grammar_ohm_bundle_default.PGArrayLiteral.createSemantics();
literalArraySemantics.addOperation("parseArray", {
	Array(_lBracket, argList, _rBracket) {
		return argList["parseArray"]();
	},
	ArrayItem(arg0) {
		return arg0["parseArray"]();
	},
	NonemptyListOf(arg0, arg1, arg2) {
		return [
			arg0["parseArray"](),
			...arg1["parseArray"](),
			...arg2["parseArray"]()
		];
	},
	EmptyListOf() {
		return [];
	},
	_iter(...children) {
		return children.map((c) => c["parseArray"]()).filter((e) => e !== void 0);
	},
	_terminal() {},
	stringLiteral(_lQuote, string, _rQuote) {
		return JSON.parse("\"" + string.sourceString.replaceAll("''", "'") + "\"");
	},
	quotelessString(string) {
		return string.sourceString.replaceAll("''", "'");
	},
	nullLiteral(_) {
		return null;
	}
});
const expressionArraySemantics = grammar_ohm_bundle_default.PGArrayExpression.createSemantics();
expressionArraySemantics.addOperation("parseExpressionArray", {
	Array(_lBracket, argList, _rBracket) {
		return argList["parseExpressionArray"]();
	},
	ArrayItem(arg0) {
		return arg0["parseExpressionArray"]();
	},
	NonemptyListOf(arg0, arg1, arg2) {
		return [
			arg0["parseExpressionArray"](),
			...arg1["parseExpressionArray"](),
			...arg2["parseExpressionArray"]()
		];
	},
	EmptyListOf() {
		return [];
	},
	_iter(...children) {
		return children.map((c) => c["parseExpressionArray"]()).filter((e) => e !== void 0);
	},
	_terminal() {},
	stringLiteral(_lQuote, string, _rQuote) {
		return JSON.parse("\"" + string.sourceString.replaceAll("''", "'") + "\"");
	},
	quotelessString(string) {
		return string.sourceString.replaceAll("''", "'");
	},
	nullLiteral(_) {
		return null;
	}
});
function parseArray(array) {
	const match = grammar_ohm_bundle_default.PGArrayLiteral.match(array, "Array");
	if (match.failed()) throw new Error(`Failed to parse array: '${array}'`);
	return literalArraySemantics(match)["parseArray"]();
}
function parseExpressionArray(array) {
	const match = grammar_ohm_bundle_default.PGArrayExpression.match(array, "Array");
	if (match.failed()) throw new Error(`Failed to parse array: '${array}'`);
	return expressionArraySemantics(match)["parseExpressionArray"]();
}

//#endregion
//#region src/utils/when-json-met-bigint/lib.ts
const error = `error`;
const ignore = `ignore`;
const preserve = `preserve`;
const CONSTRUCTOR_ACTIONS = [
	error,
	ignore,
	preserve
];
const PROTO_ACTIONS = CONSTRUCTOR_ACTIONS;
const isNonNullObject = (o) => {
	return o !== null && typeof o === `object`;
};
var Cache = class {
	_cache = {};
	_size = 0;
	_old = {};
	constructor(_max = 1e6 / 2) {
		this._max = _max;
	}
	get(key) {
		return this.has(key) ? this._cache[key] : void 0;
	}
	set(key, value) {
		if (this._size >= this._max) {
			this._old = this._cache;
			this._cache = {};
			this._size = 0;
		}
		this._cache[key] = value;
		this._size++;
		return value;
	}
	has(key) {
		if (Object.prototype.hasOwnProperty.call(this._cache, key)) return true;
		if (Object.prototype.hasOwnProperty.call(this._old, key)) {
			this._cache[key] = this._old[key];
			return true;
		}
		return false;
	}
};

//#endregion
//#region src/utils/when-json-met-bigint/parse.ts
const bigint = `bigint`;
const number = `number`;
const SUSPECT_PROTO_RX = /(?:_|\\u005[Ff])(?:_|\\u005[Ff])(?:p|\\u0070)(?:r|\\u0072)(?:o|\\u006[Ff])(?:t|\\u0074)(?:o|\\u006[Ff])(?:_|\\u005[Ff])(?:_|\\u005[Ff])/;
const SUSPECT_CONSTRUCTOR_RX = /(?:c|\\u0063)(?:o|\\u006[Ff])(?:n|\\u006[Ee])(?:s|\\u0073)(?:t|\\u0074)(?:r|\\u0072)(?:u|\\u0075)(?:c|\\u0063)(?:t|\\u0074)(?:o|\\u006[Ff])(?:r|\\u0072)/;
const ESCAPEE = {
	"\"": `"`,
	"\\": `\\`,
	"/": `/`,
	b: `\b`,
	f: `\f`,
	n: `\n`,
	r: `\r`,
	t: `\t`
};
const newParse = (p_user_options) => {
	let p_current_char_index, p_current_char, p_text;
	const p_options = {
		errorOnBigIntDecimalOrScientific: false,
		errorOnDuplicatedKeys: false,
		parseBigIntAsString: false,
		alwaysParseAsBigInt: false,
		protoAction: preserve,
		constructorAction: preserve
	};
	if (p_user_options) {
		if (p_user_options.strict === true || p_user_options.errorOnBigIntDecimalOrScientific === true) p_options.errorOnBigIntDecimalOrScientific = true;
		if (p_user_options.strict === true || p_user_options.errorOnDuplicatedKeys === true) p_options.errorOnDuplicatedKeys = true;
		if (p_user_options.parseBigIntAsString === true) p_options.parseBigIntAsString = true;
		if (p_user_options.alwaysParseAsBigInt === true) p_options.alwaysParseAsBigInt = true;
		if (p_user_options.protoAction) if (PROTO_ACTIONS.includes(p_user_options.protoAction)) p_options.protoAction = p_user_options.protoAction;
		else throw new Error(`Incorrect value for protoAction option, must be ${PROTO_ACTIONS.map((a) => `"${a}"`).join(` or `)} but passed ${p_user_options.protoAction}`);
		if (p_user_options.constructorAction) if (CONSTRUCTOR_ACTIONS.includes(p_user_options.constructorAction)) p_options.constructorAction = p_user_options.constructorAction;
		else throw new Error(`Incorrect value for constructorAction option, must be ${CONSTRUCTOR_ACTIONS.map((a) => `"${a}"`).join(` or `)} but passed ${p_user_options.constructorAction}`);
	}
	const pError = (m) => {
		throw {
			name: `SyntaxError`,
			message: m,
			at: p_current_char_index,
			text: p_text
		};
	};
	const pCurrentCharIs = (c) => {
		if (c !== p_current_char) return pError(`Expected '` + c + `' instead of '` + p_current_char + `'`);
	};
	const pNext = (c) => {
		p_current_char = p_text.charAt(++p_current_char_index);
		if (c) pCurrentCharIs(c);
		return p_current_char;
	};
	const pSkipWhite = () => {
		while (p_current_char && p_current_char <= ` `) pNext();
	};
	const pObject = (schema) => {
		const result$1 = p_options.protoAction === preserve ? Object.create(null) : {};
		if (p_current_char === `{`) {
			pNext();
			pSkipWhite();
			if (p_current_char === `}`) {
				pNext();
				return result$1;
			}
			while (p_current_char) {
				const key = pString();
				const sub_schema = isNonNullObject(schema) && !Array.isArray(schema) ? schema[key] || schema[Symbol.for(`any`)] : void 0;
				pSkipWhite();
				pCurrentCharIs(`:`);
				pNext();
				if (p_options.errorOnDuplicatedKeys === true && Object.hasOwnProperty.call(result$1, key)) pError(`Duplicate key "${key}"`);
				if (SUSPECT_PROTO_RX.test(key) === true) if (p_options.protoAction === error) pError(`Object contains forbidden prototype property`);
				else if (p_options.protoAction === ignore) pJsonValue();
				else result$1[key] = pJsonValue(sub_schema);
				else if (SUSPECT_CONSTRUCTOR_RX.test(key) === true) if (p_options.constructorAction === error) pError(`Object contains forbidden constructor property`);
				else if (p_options.constructorAction === ignore) pJsonValue();
				else result$1[key] = pJsonValue(sub_schema);
				else result$1[key] = pJsonValue(sub_schema);
				pSkipWhite();
				if (p_current_char === `}`) {
					pNext();
					if (p_options.protoAction === preserve) Object.setPrototypeOf(result$1, Object.prototype);
					return result$1;
				}
				pCurrentCharIs(`,`);
				pNext();
				pSkipWhite();
			}
		}
		return pError(`Bad object`);
	};
	const pArray = (schema) => {
		const result$1 = [];
		if (p_current_char === `[`) {
			pNext();
			pSkipWhite();
			if (p_current_char === `]`) {
				pNext();
				return result$1;
			}
			const is_array = Array.isArray(schema);
			const is_tuple_like = is_array && schema.length > 1;
			while (p_current_char) {
				result$1.push(pJsonValue(is_tuple_like ? schema[result$1.length] : is_array ? schema[0] : void 0));
				pSkipWhite();
				if (p_current_char === `]`) {
					pNext();
					return result$1;
				}
				pCurrentCharIs(`,`);
				pNext();
				pSkipWhite();
			}
		}
		return pError(`Bad array`);
	};
	const pString = () => {
		let result$1 = ``;
		if (p_current_char === `"`) {
			let start_at = p_current_char_index + 1;
			while (pNext()) {
				if (p_current_char === `"`) {
					if (p_current_char_index > start_at) result$1 += p_text.substring(start_at, p_current_char_index);
					pNext();
					return result$1;
				}
				if (p_current_char === `\\`) {
					if (p_current_char_index > start_at) result$1 += p_text.substring(start_at, p_current_char_index);
					pNext();
					if (p_current_char === `u`) {
						let uffff = 0;
						for (let i = 0; i < 4; i += 1) {
							const hex = parseInt(pNext(), 16);
							if (!isFinite(hex)) break;
							uffff = uffff * 16 + hex;
						}
						result$1 += String.fromCharCode(uffff);
					} else if (typeof ESCAPEE[p_current_char] === `string`) result$1 += ESCAPEE[p_current_char];
					else break;
					start_at = p_current_char_index + 1;
				}
			}
		}
		return pError(`Bad string`);
	};
	const pNumber = (() => {
		const cache = new Cache();
		return (schema) => {
			let result_string = ``;
			let is_positive = true;
			if (p_current_char === `-`) {
				result_string = p_current_char;
				is_positive = false;
				pNext();
			}
			if (p_current_char === `0`) {
				result_string += p_current_char;
				pNext();
				if (p_current_char >= `0` && p_current_char <= `9`) pError(`Bad number`);
			}
			while (p_current_char >= `0` && p_current_char <= `9`) {
				result_string += p_current_char;
				pNext();
			}
			if (p_current_char === `.`) {
				result_string += p_current_char;
				while (pNext() && p_current_char >= `0` && p_current_char <= `9`) result_string += p_current_char;
			}
			if (p_current_char === `e` || p_current_char === `E`) {
				result_string += p_current_char;
				pNext();
				if (p_current_char === `-` || p_current_char === `+`) {
					result_string += p_current_char;
					pNext();
				}
				while (p_current_char >= `0` && p_current_char <= `9`) {
					result_string += p_current_char;
					pNext();
				}
			}
			const raw_schema = schema;
			const cache_string = cache.get(result_string);
			if (!cache_string || !cache_string.has(raw_schema)) {
				const cache_schema = cache_string || cache.set(result_string, /* @__PURE__ */ new Map());
				const result_number = Number(result_string);
				if (Number.isNaN(result_number)) cache_schema.set(raw_schema, NaN);
				else if (!Number.isFinite(result_number)) cache_schema.set(raw_schema, is_positive ? Infinity : -Infinity);
				else {
					const is_decimal_or_scientific = /[.eE]/.test(result_string);
					if (Number.isSafeInteger(result_number) || is_decimal_or_scientific) {
						if (typeof schema === `function`) schema = schema(result_number);
						cache_schema.set(raw_schema, schema === number || !p_options.alwaysParseAsBigInt && schema !== bigint || is_decimal_or_scientific && !p_options.errorOnBigIntDecimalOrScientific ? result_number : is_decimal_or_scientific ? pError(`Decimal and scientific notation cannot be bigint`) : BigInt(result_string));
					} else {
						let result_bigint;
						if (typeof schema === `function`) {
							result_bigint = BigInt(result_string);
							schema = schema(result_bigint);
						}
						if (schema === number) cache_schema.set(raw_schema, result_number);
						else cache_schema.set(raw_schema, p_options.parseBigIntAsString ? result_string : result_bigint || BigInt(result_string));
					}
				}
			}
			const result$1 = cache.get(result_string).get(raw_schema);
			return Number.isNaN(result$1) ? pError(`Bad number`) : result$1;
		};
	})();
	const pBooleanOrNull = () => {
		switch (p_current_char) {
			case `t`:
				pNext(`r`);
				pNext(`u`);
				pNext(`e`);
				pNext();
				return true;
			case `f`:
				pNext(`a`);
				pNext(`l`);
				pNext(`s`);
				pNext(`e`);
				pNext();
				return false;
			case `n`:
				pNext(`u`);
				pNext(`l`);
				pNext(`l`);
				pNext();
				return null;
		}
		return pError(`Unexpected '${p_current_char}'`);
	};
	const pJsonValue = (schema) => {
		pSkipWhite();
		switch (p_current_char) {
			case `{`: return pObject(schema);
			case `[`: return pArray(schema);
			case `"`: return pString();
			case `-`: return pNumber(schema);
			default: return p_current_char >= `0` && p_current_char <= `9` ? pNumber(schema) : pBooleanOrNull();
		}
	};
	return (text, reviver, schema) => {
		p_current_char_index = -1;
		p_current_char = ` `;
		p_text = String(text);
		const result$1 = pJsonValue(schema);
		pSkipWhite();
		if (p_current_char) pError(`Syntax error`);
		if (typeof reviver === `function`) return (function walk(object_or_array, key) {
			const value = object_or_array[key];
			if (isNonNullObject(value)) {
				const revived_keys = /* @__PURE__ */ new Set();
				for (const reviving_key in value) {
					const next_object_or_array = !Array.isArray(value) ? { ...value } : [...value];
					revived_keys.forEach((rk) => delete next_object_or_array[rk]);
					const v = walk(next_object_or_array, reviving_key);
					revived_keys.add(reviving_key);
					if (v !== void 0) value[reviving_key] = v;
					else delete value[reviving_key];
				}
			}
			return reviver.call(object_or_array, key, value);
		})({ "": result$1 }, ``);
		return result$1;
	};
};

//#endregion
//#region src/utils/when-json-met-bigint/stringify.ts
const isNonNullObjectWithToJSOnImplemented = (o) => isNonNullObject(o) && typeof o.toJSON === `function`;
const toPrimitive = (o) => o instanceof Number ? Number(o) : o instanceof String ? String(o) : o;
const quote = (() => {
	const ESCAPABLE = /[\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g;
	const META = {
		"\b": `\\b`,
		"	": `\\t`,
		"\n": `\\n`,
		"\f": `\\f`,
		"\r": `\\r`,
		"\"": `\\"`,
		"\\": `\\\\`
	};
	const cache = new Cache();
	return (s) => {
		if (!cache.has(s)) {
			ESCAPABLE.lastIndex = 0;
			cache.set(s, ESCAPABLE.test(s) ? `"` + s.replace(ESCAPABLE, function(a) {
				const c = META[a];
				return typeof c === `string` ? c : `\\u` + (`0000` + a.charCodeAt(0).toString(16)).slice(-4);
			}) + `"` : `"` + s + `"`);
		}
		return cache.get(s);
	};
})();
const stringify = (() => {
	const stack = /* @__PURE__ */ new Set();
	let indent;
	let gap;
	let sReplacer;
	const s_replacer = /* @__PURE__ */ new Set();
	const sStringify = (object_or_array, key_or_index, delim, n) => {
		let value = object_or_array[key_or_index];
		if (isNonNullObjectWithToJSOnImplemented(value)) value = value.toJSON();
		if (typeof sReplacer === `function`) value = sReplacer.call(object_or_array, key_or_index.toString(), value);
		switch (typeof value) {
			case `string`: return quote(value);
			case `number`: return Number.isFinite(value) ? value.toString() : `null`;
			case `boolean`: return value.toString();
			case `bigint`: return n ? `${value.toString()}n` : value.toString();
			case `object`: {
				if (!value) return `null`;
				if (stack.has(value)) throw new TypeError(`cyclic object value`);
				stack.add(value);
				const last_gap = indent;
				indent += gap;
				if (Array.isArray(value)) {
					const partial$1 = value.map((_v_, i) => sStringify(value, i, delim, n) || `null`);
					const result$2 = partial$1.length === 0 ? `[]` : indent ? `[\n` + indent + partial$1.join(`${delim}\n` + indent) + `\n` + last_gap + `]` : `[` + partial$1.join(delim) + `]`;
					stack.delete(value);
					indent = last_gap;
					return result$2;
				}
				const partial = [];
				(s_replacer.size > 0 ? s_replacer : Object.keys(value)).forEach((key) => {
					const v = sStringify(value, key, delim, n);
					if (v) partial.push(quote(key) + (gap ? `: ` : `:`) + v);
				});
				const result$1 = partial.length === 0 ? `{}` : indent ? `{\n` + indent + partial.join(`${delim}\n` + indent) + `\n` + last_gap + `}` : `{` + partial.join(delim) + `}`;
				stack.delete(value);
				indent = last_gap;
				return result$1;
			}
		}
	};
	return (value, replacer, space, n) => {
		value = toPrimitive(value);
		stack.clear();
		indent = ``;
		const primitive_space = toPrimitive(space);
		gap = typeof primitive_space === `number` && primitive_space > 0 ? Array.from({ length: primitive_space + 1 }).join(` `) : typeof primitive_space !== `string` ? `` : primitive_space.length > 10 ? primitive_space.slice(0, 10) : primitive_space;
		s_replacer.clear();
		if (Array.isArray(replacer)) {
			sReplacer = null;
			if (isNonNullObject(value)) replacer.forEach((e) => {
				const key = toPrimitive(e);
				if (typeof key === `string` || typeof key === `number`) {
					const key_string = key.toString();
					if (!s_replacer.has(key_string)) s_replacer.add(key_string);
				}
			});
		} else sReplacer = replacer;
		return sStringify({ "": value }, ``, ",", n);
	};
})();

//#endregion
//#region src/utils/when-json-met-bigint/index.ts
const parse = newParse();
const JSONB = Object.assign((options) => {
	return {
		parse: newParse(options),
		stringify
	};
}, {
	parse,
	stringify
});

//#endregion
//#region src/dialects/common.ts
const dictionary = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ".split("");
const hash = (input, len = 12) => {
	const dictLen = BigInt(dictionary.length);
	const combinationsCount = BigInt(dictionary.length) ** BigInt(len);
	const p = 53n;
	let power = 1n;
	let hash$1 = 0n;
	for (const ch of input) {
		hash$1 = (hash$1 + BigInt(ch.codePointAt(0) || 0) * power) % combinationsCount;
		power = power * p % combinationsCount;
	}
	const result$1 = [];
	let index = hash$1;
	for (let i = len - 1; i >= 0; i--) {
		const element = dictionary[Number(index % dictLen)];
		result$1.unshift(element);
		index = index / dictLen;
	}
	return result$1.join("");
};

//#endregion
//#region src/dialects/utils.ts
const getOrNull = (it, key) => {
	if (it === null) return null;
	return it?.[key] ?? null;
};
const groupDiffs = (arr) => {
	if (arr.length === 0) return [];
	if (!arr[0].table && !arr[0].schema) throw new Error("No schema or table in item");
	const res = [];
	for (let i = 0; i < arr.length; i++) {
		const stmnt = arr[i];
		const idx = res.findIndex((it) => ("schema" in it ? stmnt.schema === it["schema"] : true) && ("table" in it ? stmnt.table === it.table : true));
		let item;
		if (idx < 0) {
			const sch = "schema" in stmnt ? { schema: stmnt.schema } : {};
			const tbl = "table" in stmnt ? { table: stmnt.table } : {};
			item = {
				...sch,
				...tbl,
				deleted: [],
				inserted: [],
				updated: []
			};
			res.push(item);
		} else item = res[idx];
		if (stmnt.$diffType === "drop") item.deleted.push(stmnt);
		else if (stmnt.$diffType === "create") item.inserted.push(stmnt);
		else item.updated.push(stmnt);
	}
	return res;
};
const numberForTs = (value) => {
	const check = Number(value);
	if (Number.isNaN(check)) return {
		mode: "number",
		value: `sql\`${require_utils.trimChar(escapeForTsLiteral(value), "\"")}\``
	};
	if (check >= Number.MIN_SAFE_INTEGER && check <= Number.MAX_SAFE_INTEGER) return {
		mode: "number",
		value
	};
	return {
		mode: "bigint",
		value: `${value}n`
	};
};
const parseParams = (type) => {
	return type.match(/\(((?:\d+(?:\s*,\s*\d+)*)|max)\)/i)?.[1].split(",").map((x) => x.trim()) ?? [];
};
const escapeForSqlDefault = (input, mode = "default") => {
	let value = input.replace(/\\/g, "\\\\").replace(/'/g, "''");
	if (mode === "pg-arr") value = value.replaceAll("\"", "\\\"");
	return value;
};
const unescapeFromSqlDefault = (input, mode = "default") => {
	let res = input.replace(/\\"/g, "\"").replace(/\\\\/g, "\\");
	if (mode === "arr") return res;
	return res.replace(/''/g, "'");
};
const escapeForTsLiteral = (input) => {
	return JSON.stringify(input);
};
const preserveEntityNames = (collection1, collection2, mode) => {
	const items = collection1.list().filter((x) => mode === "push" || !x.nameExplicit);
	for (const left of items) {
		const { entityType: _1, name: _2, nameExplicit: _3, ...filter } = left;
		const match = collection2.list({
			...filter,
			nameExplicit: false
		});
		if (match.length !== 1 || match[0].name === left.name) continue;
		collection2.update({
			set: { name: left.name },
			where: {
				...filter,
				nameExplicit: false
			}
		});
	}
};
const filterMigrationsSchema = (interim, migrations) => {
	const migrationsSchema = migrations.schema;
	const migrationsTable = migrations.table;
	interim.tables = interim.tables.filter((table) => !(table.name === migrationsTable && (table.schema ? table.schema === migrationsSchema : true)));
	interim.columns = interim.columns.filter((column) => !(column.table === migrationsTable && (column.schema ? column.schema === migrationsSchema : true)));
	interim.pks = interim.pks.filter((pk) => !(pk.table === migrationsTable && (pk.schema ? pk.schema === migrationsSchema : true)));
	if (interim.schemas) {
		if (!interim.tables.filter((table) => table.schema === migrationsSchema).length) interim.schemas = interim.schemas.filter((schema) => schema.name !== migrationsSchema);
	}
	return interim;
};

//#endregion
//#region src/dialects/postgres/grammar.ts
const SmallInt = {
	is: (type) => /^\s*smallint(?:\s*\[\s*\])*\s*$/i.test(type),
	drizzleImport: () => "smallint",
	defaultFromDrizzle: (value) => {
		return String(value);
	},
	defaultArrayFromDrizzle: (value) => {
		return `'${require_utils.stringifyArray(value, "sql", (v) => String(v))}'`;
	},
	defaultFromIntrospect: (value) => {
		return require_utils.trimChar(value, "'");
	},
	defaultArrayFromIntrospect: (value) => {
		return value;
	},
	toTs: (_, value) => ({ default: value ?? "" }),
	toArrayTs: (_, value) => {
		if (!value) return { default: "" };
		try {
			return { default: require_utils.stringifyArray(parseArray(require_utils.trimChar(require_utils.trimChar(value, ["(", ")"]), "'")), "ts", (v) => {
				return `${v}`;
			}) };
		} catch {
			return { default: `sql\`${value}\`` };
		}
	}
};
const Int = {
	is: (type) => /^\s*integer(?:\s*\[\s*\])*\s*$/i.test(type),
	drizzleImport: () => "integer",
	defaultFromDrizzle: SmallInt.defaultFromDrizzle,
	defaultArrayFromDrizzle: SmallInt.defaultArrayFromDrizzle,
	defaultFromIntrospect: SmallInt.defaultFromIntrospect,
	defaultArrayFromIntrospect: SmallInt.defaultArrayFromIntrospect,
	toTs: SmallInt.toTs,
	toArrayTs: SmallInt.toArrayTs
};
const BigInt$1 = {
	is: (type) => /^\s*bigint(?:\s*\[\s*\])*\s*$/i.test(type),
	drizzleImport: () => "bigint",
	defaultFromDrizzle: (value) => {
		return String(value);
	},
	defaultArrayFromDrizzle: (value) => {
		return `'${require_utils.stringifyArray(value, "sql", (v) => String(v))}'`;
	},
	defaultFromIntrospect: (value) => {
		return require_utils.trimChar(value, "'");
	},
	defaultArrayFromIntrospect: (value) => {
		return value;
	},
	toTs: (_, value) => {
		if (!value) return {
			options: { mode: "number" },
			default: ""
		};
		const { mode, value: def } = numberForTs(value);
		return {
			options: { mode },
			default: def
		};
	},
	toArrayTs: (_, value) => {
		if (!value) return {
			options: { mode: "number" },
			default: ""
		};
		try {
			return {
				options: { mode: "bigint" },
				default: require_utils.stringifyArray(parseArray(require_utils.trimChar(require_utils.trimChar(value, ["(", ")"]), "'")), "ts", (v) => `${v}n`)
			};
		} catch {
			return {
				options: { mode: "bigint" },
				default: `sql\`${value}\``
			};
		}
	}
};
const Numeric = {
	is: (type) => /^\s*numeric|decimal(?:\(\d+(?:,\d+)?\))?(?:\s*\[\s*\])*\s*$/i.test(type),
	drizzleImport: () => "numeric",
	defaultFromDrizzle: (value) => {
		return `'${value}'`;
	},
	defaultArrayFromDrizzle: (value) => {
		return `'${require_utils.stringifyArray(value, "sql", (v) => String(v))}'`;
	},
	defaultFromIntrospect: (value) => {
		return `'${require_utils.trimChar(value, "'")}'`;
	},
	defaultArrayFromIntrospect: (value) => {
		return value;
	},
	toTs: (type, value) => {
		const [precision, scale] = parseParams(type);
		const options = {};
		if (precision) options["precision"] = Number(precision);
		if (scale) options["scale"] = Number(scale);
		if (!value) return {
			options,
			default: ""
		};
		const { mode, value: def } = numberForTs(require_utils.trimChar(value, "'"));
		return {
			options: {
				mode,
				...options
			},
			default: def
		};
	},
	toArrayTs: (type, value) => {
		const [precision, scale] = parseParams(type);
		const options = {};
		if (precision) options["precision"] = Number(precision);
		if (scale) options["scale"] = Number(scale);
		if (!value) return {
			options,
			default: ""
		};
		return {
			options,
			default: `sql\`${value}\``
		};
	}
};
const Real = {
	is: (type) => /^\s*real(?:\s*\[\s*\])*\s*$/i.test(type),
	drizzleImport: () => "real",
	defaultFromDrizzle: (value) => {
		return String(value);
	},
	defaultArrayFromDrizzle: (value) => {
		return `'${require_utils.stringifyArray(value, "sql", (v) => String(v))}'`;
	},
	defaultFromIntrospect: (value) => {
		return require_utils.trimChar(value, "'");
	},
	defaultArrayFromIntrospect: (value) => {
		return value;
	},
	toTs: (_, value) => ({ default: value ?? "" }),
	toArrayTs: (_, value) => {
		if (!value) return { default: "" };
		try {
			return { default: require_utils.stringifyArray(parseArray(require_utils.trimChar(require_utils.trimChar(value, ["(", ")"]), "'")), "ts", (v) => {
				return `${v}`;
			}) };
		} catch {
			return { default: `sql\`${value}\`` };
		}
	}
};
const Double = {
	is: (type) => /^\s*(?:double|double precision)(?:\s*\[\s*\])*\s*$/i.test(type),
	drizzleImport: () => "doublePrecision",
	defaultFromDrizzle: Real.defaultFromDrizzle,
	defaultArrayFromDrizzle: Real.defaultArrayFromDrizzle,
	defaultFromIntrospect: Real.defaultFromIntrospect,
	defaultArrayFromIntrospect: Real.defaultArrayFromIntrospect,
	toTs: Real.toTs,
	toArrayTs: Real.toArrayTs
};
const Boolean = {
	is: (type) => /^\s*boolean(?:\s*\[\s*\])*\s*$/i.test(type),
	drizzleImport: () => "boolean",
	defaultFromDrizzle: (value) => {
		return String(value);
	},
	defaultArrayFromDrizzle: (value) => {
		return `'${require_utils.stringifyArray(value, "sql", (v) => v === true ? "t" : "f")}'`;
	},
	defaultFromIntrospect: (value) => {
		return require_utils.trimChar(value, "'");
	},
	defaultArrayFromIntrospect: (value) => {
		return value;
	},
	toTs: (_, value) => ({ default: value ?? "" }),
	toArrayTs: (_, value) => {
		if (!value) return { default: "" };
		try {
			return { default: require_utils.stringifyArray(parseArray(require_utils.trimChar(require_utils.trimChar(value, ["(", ")"]), "'")), "ts", (v) => {
				return v === "t" ? "true" : "false";
			}) };
		} catch {
			return { default: `sql\`${value}\`` };
		}
	}
};
const Char = {
	is: (type) => /^\s*char|character(?:\(\d+\))?(?:\s*\[\s*\])*\s*$/i.test(type),
	drizzleImport: () => "char",
	defaultFromDrizzle: (value) => {
		return `'${escapeForSqlDefault(value)}'`;
	},
	defaultArrayFromDrizzle: (value) => {
		return `'${require_utils.stringifyArray(value, "sql", (v) => {
			if (typeof v !== "string") throw new Error();
			const escaped = v.replaceAll("'", "''").replaceAll("\\", "\\\\").replaceAll("\"", "\\\"");
			if (v.includes("\\") || v.includes("\"") || v.includes(",")) return `"${escaped}"`;
			return escaped;
		})}'`;
	},
	defaultFromIntrospect: (value) => {
		return value;
	},
	defaultArrayFromIntrospect: (value) => {
		return value;
	},
	toTs: (type, value) => {
		const options = {};
		const [length] = parseParams(type);
		if (length) options["length"] = Number(length);
		if (!value) return {
			options,
			default: ""
		};
		if (!value.startsWith("'") && !value.endsWith("'")) return {
			options,
			default: `sql\`${value}\``
		};
		return {
			options,
			default: escapeForTsLiteral(unescapeFromSqlDefault(require_utils.trimChar(value, "'")))
		};
	},
	toArrayTs: (type, value) => {
		const options = {};
		const [length] = parseParams(type);
		if (length) options["length"] = Number(length);
		if (!value) return {
			options,
			default: ""
		};
		try {
			return {
				options,
				default: require_utils.stringifyArray(parseArray(require_utils.trimChar(require_utils.trimChar(value, ["(", ")"]), "'")), "ts", (v) => {
					return escapeForTsLiteral(unescapeFromSqlDefault(require_utils.trimChar(v, "'"), "arr"));
				})
			};
		} catch {
			return {
				options,
				default: `sql\`${value}\``
			};
		}
	}
};
const Varchar = {
	is: (type) => /^\s*varchar|character varying(?:\(\d+\))?(?:\s*\[\s*\])*\s*$/i.test(type),
	drizzleImport: () => "varchar",
	defaultFromDrizzle: Char.defaultFromDrizzle,
	defaultArrayFromDrizzle: Char.defaultArrayFromDrizzle,
	defaultFromIntrospect: Char.defaultFromIntrospect,
	defaultArrayFromIntrospect: Char.defaultArrayFromIntrospect,
	toTs: Char.toTs,
	toArrayTs: Char.toArrayTs
};
const Text = {
	is: (type) => /^\s*text(?:\s*\[\s*\])*\s*$/i.test(type),
	drizzleImport: () => "text",
	defaultFromDrizzle: Char.defaultFromDrizzle,
	defaultArrayFromDrizzle: Char.defaultArrayFromDrizzle,
	defaultFromIntrospect: Char.defaultFromIntrospect,
	defaultArrayFromIntrospect: Char.defaultArrayFromIntrospect,
	toTs: Char.toTs,
	toArrayTs: Char.toArrayTs
};
const toDefaultArray = (value, dimensions, cb, depth = 0) => {
	if (depth === dimensions) {
		const res = cb(value);
		if (res.includes("\"")) return `"${res.replaceAll("\"", "\\\"")}"`;
		return `"${res}"`;
	}
	if (Array.isArray(value)) {
		const inner = value.map((v) => {
			return toDefaultArray(v, dimensions, cb, depth + 1);
		}).join(",");
		if (depth === 0) return `{${inner}}`;
		return `${inner}`;
	}
	return cb(value);
};
const Json = {
	is: (type) => /^\s*json(?:\s*\[\s*\])*\s*$/i.test(type),
	drizzleImport: () => "json",
	defaultFromDrizzle: (value) => {
		return `'${stringify(value, (_, value$1) => {
			if (typeof value$1 !== "string") return value$1;
			return value$1.replaceAll("'", "''");
		})}'`;
	},
	defaultArrayFromDrizzle: (def, dimensions) => {
		return `'${toDefaultArray(def, dimensions, (it) => stringify(it, (_, value) => {
			if (typeof value !== "string") return value;
			return value.replaceAll("'", "''");
		}))}'`;
	},
	defaultFromIntrospect: (value) => value,
	defaultArrayFromIntrospect: (value) => value,
	toTs: (_, value) => {
		if (!value) return { default: "" };
		const trimmed = require_utils.trimChar(value, "'");
		try {
			return { default: stringify(parse(trimmed), (_$1, value$1) => {
				if (typeof value$1 !== "string") return value$1;
				return value$1.replaceAll("''", "'");
			}, void 0, true) };
		} catch {}
		return { default: `sql\`${value}\`` };
	},
	toArrayTs: (_, def) => {
		if (!def) return { default: "" };
		return { default: `sql\`${def.replaceAll("\\\"", "\\\\\"")}\`` };
	}
};
const Jsonb = {
	is: (type) => /^\s*jsonb(?:\s*\[\s*\])*\s*$/i.test(type),
	drizzleImport: () => "jsonb",
	defaultFromDrizzle: (value) => {
		return `'${stringify(value, (_, value$1) => {
			if (typeof value$1 !== "string") return value$1;
			return value$1.replaceAll("'", "''");
		})}'`;
	},
	defaultArrayFromDrizzle: (def, dimensions) => {
		return `'${toDefaultArray(def, dimensions, (it) => stringify(it, (_, value) => {
			if (typeof value !== "string") return value;
			return value.replaceAll("'", "''");
		}))}'`;
	},
	defaultFromIntrospect: (value) => value.replaceAll(`": "`, `":"`),
	defaultArrayFromIntrospect: (value) => value,
	toTs: Json.toTs,
	toArrayTs: Json.toArrayTs
};
const Time = {
	is: (type) => /^\s*time(?:\(\d+\))?(?:\[\])*?\s*$/i.test(type),
	drizzleImport: () => "time",
	defaultFromDrizzle: (value) => {
		return require_utils.wrapWith(String(value), "'");
	},
	defaultArrayFromDrizzle: (value) => {
		return require_utils.wrapWith(require_utils.stringifyArray(value, "sql", (v) => String(v)), "'");
	},
	defaultFromIntrospect: (value) => {
		return value;
	},
	defaultArrayFromIntrospect: (value) => {
		return value;
	},
	toTs: (type, value) => {
		const options = {};
		const [precision] = parseParams(type);
		if (precision) options["precision"] = Number(precision);
		if (!value) return {
			options,
			default: ""
		};
		if (!require_utils.isTime(require_utils.trimChar(value, "'"))) return {
			options,
			default: `sql\`${value}\``
		};
		return {
			options,
			default: value
		};
	},
	toArrayTs: (type, value) => {
		const options = {};
		const [precision] = parseParams(type);
		if (precision) options["precision"] = Number(precision);
		if (!value) return {
			options,
			default: ""
		};
		try {
			return {
				options,
				default: require_utils.stringifyArray(parseArray(require_utils.trimChar(require_utils.trimChar(value, ["(", ")"]), "'")), "ts", (v) => {
					const trimmed = require_utils.trimChar(v, "'");
					if (!require_utils.isTime(trimmed)) return `sql\`${trimmed}\``;
					return require_utils.wrapWith(v, "'");
				})
			};
		} catch {
			return {
				options,
				default: `sql\`${value}\``
			};
		}
	}
};
const TimeTz = {
	is: (type) => /^\s*time(?:\(\d+\))?\s+with time zone(?:\[\])*?\s*$/i.test(type),
	drizzleImport: () => "time",
	defaultFromDrizzle: (value) => {
		const v = String(value);
		return require_utils.wrapWith(require_utils.hasTimeZoneSuffix(v) ? v : v + "+00", "'");
	},
	defaultArrayFromDrizzle: (value) => {
		return require_utils.wrapWith(require_utils.stringifyArray(value, "sql", (v) => {
			return require_utils.hasTimeZoneSuffix(v) ? v : v + "+00";
		}), "'");
	},
	defaultFromIntrospect: (value) => {
		return value;
	},
	defaultArrayFromIntrospect: (value) => {
		return value;
	},
	toTs: (type, value) => {
		const options = {};
		const [precision] = parseParams(type);
		if (precision) options["precision"] = Number(precision);
		options["withTimezone"] = true;
		if (!value) return {
			options,
			default: ""
		};
		if (!require_utils.isTime(require_utils.trimChar(value, "'"))) return {
			options,
			default: `sql\`${value}\``
		};
		return {
			options,
			default: value
		};
	},
	toArrayTs: (type, value) => {
		const options = {};
		const [precision] = parseParams(type);
		if (precision) options["precision"] = Number(precision);
		options["withTimezone"] = true;
		if (!value) return {
			options,
			default: ""
		};
		try {
			const res = parseArray(require_utils.trimChar(require_utils.trimChar(value, ["(", ")"]), "'"));
			let isDrizzleSql = false;
			const def = require_utils.stringifyArray(res, "ts", (v) => {
				if (!require_utils.isTime(require_utils.trimChar(v, "'"))) isDrizzleSql = true;
				return require_utils.wrapWith(v, "'");
			});
			return {
				options,
				default: isDrizzleSql ? `sql\`${value}\`` : def
			};
		} catch {
			return {
				options,
				default: `sql\`${value}\``
			};
		}
	}
};
const DateType = {
	is: (type) => /^\s*date(?:\s*\[\s*\])*\s*$/i.test(type),
	drizzleImport: () => "date",
	defaultFromDrizzle: (value) => {
		if (typeof value === "string") return require_utils.wrapWith(value, "'");
		if (!(value instanceof Date)) throw new Error("\"date\" default value must be instance of Date or String");
		const mapped = value.toISOString().split("T")[0];
		return require_utils.wrapWith(mapped, "'");
	},
	defaultArrayFromDrizzle: (value) => {
		return require_utils.wrapWith(require_utils.stringifyArray(value, "sql", (v) => {
			if (typeof v === "string") return v;
			if (v instanceof Date) return v.toISOString().split("T")[0];
			throw new Error("Unexpected default value for \"date\", must be String or Date");
		}), "'");
	},
	defaultFromIntrospect: (value) => {
		return value;
	},
	defaultArrayFromIntrospect: (value) => {
		return value;
	},
	toTs: (type, value) => {
		if (!value) return { default: "" };
		if (!require_utils.isDate(require_utils.trimChar(value, "'"))) return { default: `sql\`${value}\`` };
		return { default: value };
	},
	toArrayTs: (type, value) => {
		if (!value) return { default: "" };
		let isDrizzleSql = false;
		try {
			const mapped = require_utils.stringifyArray(parseArray(require_utils.trimChar(require_utils.trimChar(value, ["(", ")"]), "'")), "ts", (v) => {
				if (!require_utils.isDate(require_utils.trimChar(v, "'"))) isDrizzleSql = true;
				return require_utils.wrapWith(v, "'");
			});
			return { default: isDrizzleSql ? mapped : `sql\`${value}\`` };
		} catch {
			return { default: `sql\`${value}\`` };
		}
	}
};
const Timestamp = {
	is: (type) => /^\s*timestamp(?:\s)?(?:\(\d+\))?(?:\[\])*?\s*$/i.test(type),
	drizzleImport: () => "timestamp",
	defaultFromDrizzle: (value, _type) => {
		if (typeof value === "string") return require_utils.wrapWith(value, "'");
		if (!(value instanceof Date)) throw new Error("Timestamp default value must be instance of Date or String");
		return require_utils.wrapWith(value.toISOString().replace("T", " ").replace("Z", " ").slice(0, 23), "'");
	},
	defaultArrayFromDrizzle: (value, _type) => {
		return require_utils.wrapWith(require_utils.stringifyArray(value, "sql", (v) => {
			if (typeof v === "string") return require_utils.wrapWith(v, "\"");
			if (v instanceof Date) return require_utils.wrapWith(v.toISOString().replace("T", " ").replace("Z", " ").slice(0, 23), "\"");
			throw new Error("Unexpected default value for Timestamp, must be String or Date");
		}), "'");
	},
	defaultFromIntrospect: (value) => {
		return value;
	},
	defaultArrayFromIntrospect: (value) => {
		return value;
	},
	toTs: (type, value) => {
		const options = {};
		const [precision] = parseParams(type);
		if (precision) options["precision"] = Number(precision);
		if (!value) return {
			options,
			default: ""
		};
		let patched = require_utils.trimChar(value, "'");
		patched = patched.includes("T") ? patched : patched.replace(" ", "T") + "Z";
		const test = new Date(patched);
		if (isNaN(test.getTime())) return {
			options,
			default: `sql\`${value}\``
		};
		return {
			options,
			default: `new Date('${patched}')`
		};
	},
	toArrayTs: (type, value) => {
		const options = {};
		const [precision] = parseParams(type);
		if (precision) options["precision"] = Number(precision);
		if (!value) return {
			options,
			default: ""
		};
		let isDrizzleSql = false;
		try {
			const def = require_utils.stringifyArray(parseArray(require_utils.trimChar(require_utils.trimChar(value, ["(", ")"]), "'")), "ts", (v) => {
				const patched = v.includes("T") ? v : v.replace(" ", "T") + "Z";
				const check = new Date(patched);
				if (isNaN(check.getTime())) isDrizzleSql = true;
				return `new Date("${patched}")`;
			});
			return {
				options,
				default: isDrizzleSql ? `sql\`${value}\`` : def
			};
		} catch {
			return {
				options,
				default: `sql\`${value}\``
			};
		}
	}
};
const TimestampTz = {
	is: (type) => /^\s*timestamp(?:\s)?(?:\(\d+\))?\s+with time zone(?:\[\])*?\s*$/i.test(type),
	drizzleImport: () => "timestamp",
	defaultFromDrizzle: (value, _type) => {
		if (typeof value === "string") return require_utils.wrapWith(require_utils.hasTimeZoneSuffix(value) ? value : value + "+00", "'");
		if (!(value instanceof Date)) throw new Error("Timestamp default value must be instance of Date or String");
		return require_utils.wrapWith(value.toISOString().replace("T", " ").replace("Z", "+00"), "'");
	},
	defaultArrayFromDrizzle: (value, _type) => {
		return require_utils.wrapWith(require_utils.stringifyArray(value, "sql", (v) => {
			if (typeof v === "string") return require_utils.wrapWith(require_utils.hasTimeZoneSuffix(v) ? v : v + "+00", "\"");
			if (v instanceof Date) return require_utils.wrapWith(v.toISOString().replace("T", " ").replace("Z", "+00"), "\"");
			throw new Error("Unexpected default value for Timestamp, must be String or Date");
		}), "'");
	},
	defaultFromIntrospect: (value) => {
		return value;
	},
	defaultArrayFromIntrospect: (value) => {
		return value;
	},
	toTs: (type, value) => {
		const options = {};
		const [precision] = parseParams(type);
		if (precision) options["precision"] = Number(precision);
		options["withTimezone"] = true;
		if (!value) return {
			options,
			default: ""
		};
		let patched = require_utils.trimChar(value, "'");
		const test = new Date(patched);
		if (isNaN(test.getTime())) return {
			options,
			default: `sql\`${value}\``
		};
		return {
			options,
			default: `new Date('${patched}')`
		};
	},
	toArrayTs: (type, value) => {
		const options = {};
		const [precision] = parseParams(type);
		if (precision) options["precision"] = Number(precision);
		options["withTimezone"] = true;
		if (!value) return {
			options,
			default: ""
		};
		try {
			const res = parseArray(require_utils.trimChar(require_utils.trimChar(value, ["(", ")"]), "'"));
			let isDrizzleSql = false;
			const def = require_utils.stringifyArray(res, "ts", (v) => {
				const trimmed = require_utils.trimChar(v, "'");
				const check = new Date(trimmed);
				if (isNaN(check.getTime())) isDrizzleSql = true;
				return `new Date("${trimmed}")`;
			});
			return {
				options,
				default: isDrizzleSql ? `sql\`${value}\`` : def
			};
		} catch {
			return {
				options,
				default: `sql\`${value}\``
			};
		}
	}
};
const Uuid = {
	is: (type) => /^\s*uuid(?:\s*\[\s*\])*\s*$/i.test(type),
	drizzleImport: () => "uuid",
	defaultFromDrizzle: (value) => {
		return `'${value}'`;
	},
	defaultArrayFromDrizzle: (value) => {
		return `'${require_utils.stringifyArray(value, "sql", (v) => {
			if (typeof v !== "string") throw new Error();
			return v;
		})}'`;
	},
	defaultFromIntrospect: (value) => {
		return value;
	},
	defaultArrayFromIntrospect: (value) => {
		return value;
	},
	toTs: (type, value) => {
		const options = {};
		if (!value) return {
			options,
			default: ""
		};
		value = require_utils.trimChar(value, "'");
		if (value === "gen_random_uuid()") return {
			options,
			default: ".defaultRandom()"
		};
		if (!value.startsWith("'") && !value.endsWith("'") && value.endsWith("()")) return {
			options,
			default: `sql\`${value}\``
		};
		return {
			options,
			default: `"${require_utils.trimChar(value, "'")}"`
		};
	},
	toArrayTs: (type, value) => {
		const options = {};
		if (!value) return {
			options,
			default: ""
		};
		try {
			return {
				options,
				default: require_utils.stringifyArray(parseArray(require_utils.trimChar(require_utils.trimChar(value, ["(", ")"]), "'")), "ts", (v) => {
					return `"${v}"`;
				})
			};
		} catch {
			return {
				options,
				default: `sql\`${value}\``
			};
		}
	}
};
const Interval = {
	is: (type) => /^interval(\s+(year|month|day|hour|minute|second)(\s+to\s+(month|day|hour|minute|second))?)?(?:\((\d+)\))?(?:\s*\[\s*\])*\s*$/i.test(type),
	drizzleImport: () => "interval",
	defaultFromDrizzle: (value) => {
		return `'${value}'`;
	},
	defaultArrayFromDrizzle: (value) => {
		return `'${require_utils.stringifyArray(value, "sql", (v) => {
			if (typeof v !== "string") throw new Error();
			return `"${v}"`;
		})}'`;
	},
	defaultFromIntrospect: (value) => {
		return value;
	},
	defaultArrayFromIntrospect: (value) => {
		return value;
	},
	toTs: (type, value) => {
		const options = {};
		const [precision] = parseParams(type);
		if (precision) options["precision"] = Number(precision);
		const fields = require_utils.parseIntervalFields(type);
		if (fields.fields) options["fields"] = fields.fields;
		if (!value) return {
			options,
			default: ""
		};
		return {
			options,
			default: `"${require_utils.trimChar(value, "'")}"`
		};
	},
	toArrayTs: (type, value) => {
		const options = {};
		const [precision] = parseParams(type);
		if (precision) options["precision"] = Number(precision);
		const fields = require_utils.parseIntervalFields(type);
		if (fields.fields) options["fields"] = fields.fields;
		if (!value) return {
			options,
			default: ""
		};
		try {
			return {
				options,
				default: require_utils.stringifyArray(parseArray(require_utils.trimChar(require_utils.trimChar(value, ["(", ")"]), "'")), "ts", (v) => {
					return `"${v}"`;
				})
			};
		} catch {
			return {
				options,
				default: `sql\`${value}\``
			};
		}
	}
};
const Inet = {
	is: (type) => /^inet(?:\((\d+)\))?(\[\])?$/i.test(type),
	drizzleImport: () => "inet",
	defaultFromDrizzle: (value) => {
		return `'${value}'`;
	},
	defaultArrayFromDrizzle: (value) => {
		return require_utils.wrapWith(require_utils.stringifyArray(value, "sql", (v) => {
			if (typeof v !== "string") throw new Error();
			return v;
		}), "'");
	},
	defaultFromIntrospect: (value) => {
		return value;
	},
	defaultArrayFromIntrospect: (value) => {
		return value;
	},
	toTs: (_, value) => {
		if (!value) return { default: "" };
		return { default: `"${require_utils.trimChar(value, "'")}"` };
	},
	toArrayTs: (_, value) => {
		if (!value) return { default: "" };
		try {
			return { default: require_utils.stringifyArray(parseArray(require_utils.trimChar(require_utils.trimChar(value, ["(", ")"]), "'")), "ts", (v) => {
				return `"${v}"`;
			}) };
		} catch {
			return { default: `sql\`${value}\`` };
		}
	}
};
const Cidr = {
	is: (type) => /^cidr(?:\((\d+)\))?(\[\])?$/i.test(type),
	drizzleImport: () => "cidr",
	defaultFromDrizzle: (value) => {
		return `'${value}'`;
	},
	defaultArrayFromDrizzle: (value) => {
		return require_utils.wrapWith(require_utils.stringifyArray(value, "sql", (v) => {
			if (typeof v !== "string") throw new Error();
			return v;
		}), "'");
	},
	defaultFromIntrospect: (value) => {
		return value;
	},
	defaultArrayFromIntrospect: (value) => {
		return value;
	},
	toTs: (_, value) => {
		if (!value) return { default: "" };
		return { default: `"${require_utils.trimChar(value, "'")}"` };
	},
	toArrayTs: (_, value) => {
		if (!value) return { default: "" };
		try {
			return { default: require_utils.stringifyArray(parseArray(require_utils.trimChar(require_utils.trimChar(value, ["(", ")"]), "'")), "ts", (v) => {
				return `"${v}"`;
			}) };
		} catch {
			return { default: `sql\`${value}\`` };
		}
	}
};
const MacAddr = {
	is: (type) => /^macaddr(?:\s*\[\s*\])*\s*$/i.test(type),
	drizzleImport: () => "macaddr",
	defaultFromDrizzle: (value) => {
		return `'${value}'`;
	},
	defaultArrayFromDrizzle: (value) => {
		return require_utils.wrapWith(require_utils.stringifyArray(value, "sql", (v) => {
			if (typeof v !== "string") throw new Error();
			return v;
		}), "'");
	},
	defaultFromIntrospect: (value) => {
		return value;
	},
	defaultArrayFromIntrospect: (value) => {
		return value;
	},
	toTs: (_, value) => {
		if (!value) return { default: "" };
		return { default: `"${require_utils.trimChar(value, "'")}"` };
	},
	toArrayTs: (_, value) => {
		if (!value) return { default: "" };
		try {
			return { default: require_utils.stringifyArray(parseArray(require_utils.trimChar(require_utils.trimChar(value, ["(", ")"]), "'")), "ts", (v) => {
				return `"${v}"`;
			}) };
		} catch {
			return { default: `sql\`${value}\`` };
		}
	}
};
const MacAddr8 = {
	is: (type) => /^macaddr8(?:\s*\[\s*\])*\s*$/i.test(type),
	drizzleImport: () => "macaddr8",
	defaultFromDrizzle: MacAddr.defaultFromDrizzle,
	defaultArrayFromDrizzle: MacAddr.defaultArrayFromDrizzle,
	defaultFromIntrospect: MacAddr.defaultFromIntrospect,
	defaultArrayFromIntrospect: MacAddr.defaultArrayFromIntrospect,
	toTs: MacAddr.toTs,
	toArrayTs: MacAddr.toArrayTs
};
const Vector = {
	is: (type) => /^\s*vector(?:\(\d+\))?(?:\s*\[\s*\])*\s*$/i.test(type),
	drizzleImport: () => "vector",
	defaultFromDrizzle: (value) => {
		return `'[${String(value).replaceAll(" ", "")}]'`;
	},
	defaultArrayFromDrizzle: (value, _dimensions) => {
		return require_utils.wrapWith(require_utils.stringifyTuplesArray(value, "sql", (v) => {
			return v.length > 0 ? `"[${String(v).replaceAll(" ", "")}]"` : "\"[]\"";
		}).replaceAll(" ", ""), "'");
	},
	defaultFromIntrospect: (value) => {
		return value;
	},
	defaultArrayFromIntrospect: (value) => {
		return value;
	},
	toTs: (type, value) => {
		const options = {};
		const [dimensions] = parseParams(type);
		if (dimensions) options["dimensions"] = Number(dimensions);
		if (!value) return {
			options,
			default: ""
		};
		return {
			options,
			default: require_utils.trimChar(value, "'")
		};
	},
	toArrayTs: (type, value) => {
		const options = {};
		const [dimensions] = parseParams(type);
		if (dimensions) options["dimensions"] = Number(dimensions);
		if (!value) return {
			options,
			default: ""
		};
		try {
			return {
				options,
				default: require_utils.stringifyArray(parseArray(require_utils.trimChar(require_utils.trimChar(value, ["(", ")"]), "'")), "ts", (v) => {
					return v;
				}, Number(dimensions))
			};
		} catch {
			return {
				options,
				default: `sql\`${value}\``
			};
		}
	}
};
const HalfVec = {
	is: (type) => /^\s*halfvec(?:\(\d+(?:,\d+)?\))?(?:\s*\[\s*\])*\s*$/i.test(type),
	drizzleImport: () => "halfvec",
	defaultFromDrizzle: Vector.defaultFromDrizzle,
	defaultArrayFromDrizzle: Vector.defaultArrayFromDrizzle,
	defaultFromIntrospect: Vector.defaultFromIntrospect,
	defaultArrayFromIntrospect: Vector.defaultArrayFromIntrospect,
	toTs: Vector.toTs,
	toArrayTs: Vector.toArrayTs
};
const SparseVec = {
	is: (type) => /^\s*sparsevec(?:\(\d+(?:,\d+)?\))?(?:\s*\[\s*\])*\s*$/i.test(type),
	drizzleImport: () => "sparsevec",
	defaultFromDrizzle: (value) => {
		return require_utils.wrapWith(String(value), "'");
	},
	defaultArrayFromDrizzle: (value) => {
		return require_utils.wrapWith(require_utils.stringifyArray(value, "sql", (v) => {
			return `"${String(v).replaceAll(" ", "")}"`;
		}), "'");
	},
	defaultFromIntrospect: (value) => {
		return value;
	},
	defaultArrayFromIntrospect: (value) => {
		return value;
	},
	toTs: (type, value) => {
		const options = {};
		const [dimensions] = parseParams(type);
		if (dimensions) options["dimensions"] = Number(dimensions);
		if (!value) return {
			options,
			default: ""
		};
		return {
			options,
			default: value
		};
	},
	toArrayTs: (type, value) => {
		const options = {};
		const [dimensions] = parseParams(type);
		if (dimensions) options["dimensions"] = Number(dimensions);
		if (!value) return {
			options,
			default: ""
		};
		try {
			return {
				options,
				default: require_utils.stringifyArray(parseArray(require_utils.trimChar(require_utils.trimChar(value, ["(", ")"]), "'")), "ts", (v) => {
					return require_utils.wrapWith(v, "'");
				})
			};
		} catch {
			return {
				options,
				default: `sql\`${value}\``
			};
		}
	}
};
const Bit = {
	is: (type) => /^\s*bit(?:\(\d+(?:,\d+)?\))?(?:\s*\[\s*\])*\s*$/i.test(type),
	drizzleImport: () => "bit",
	defaultFromDrizzle: (value, _) => {
		return `'${value}'`;
	},
	defaultArrayFromDrizzle: (value, _type) => {
		return `'${require_utils.stringifyArray(value, "sql", (v) => String(v))}'`;
	},
	defaultFromIntrospect: (value) => {
		return value;
	},
	defaultArrayFromIntrospect: (value) => {
		return value;
	},
	toTs: (type, value) => {
		const [dimensions] = parseParams(type);
		const options = dimensions ? { dimensions: Number(dimensions) } : {};
		if (!value) return {
			options,
			default: ""
		};
		if (/^'[01]+'$/.test(value)) return {
			options,
			default: value
		};
		return {
			options,
			default: `sql\`${value}\``
		};
	},
	toArrayTs: (type, value) => {
		const [dimensions] = parseParams(type);
		const options = dimensions ? { dimensions: Number(dimensions) } : {};
		if (!value) return { default: "" };
		let isDrizzleSql = false;
		try {
			const def = require_utils.stringifyArray(parseArray(require_utils.trimChar(require_utils.trimChar(value, ["(", ")"]), "'")), "ts", (v) => {
				if (!/^[01]+$/.test(v)) isDrizzleSql = true;
				return `"${v}"`;
			});
			return {
				options,
				default: isDrizzleSql ? `sql\`${value}\`` : def
			};
		} catch {
			return {
				options,
				default: `sql\`${value}\``
			};
		}
	}
};
const Point = {
	is: (type) => /^\s*point(?:\s*\[\s*\])*\s*$/i.test(type),
	drizzleImport: () => "point",
	defaultFromDrizzle: (value, mode) => {
		if (!value) return "";
		if (mode === "xy") {
			const v = value;
			return Object.values(v).length > 0 ? `'(${v.x},${v.y})'` : "";
		}
		if (mode === "tuple") {
			const v = value;
			return v.length > 0 ? `'(${v[0]},${v[1]})'` : "";
		}
		throw new Error("unknown point type");
	},
	defaultArrayFromDrizzle: function(value, dimensions, mode) {
		let res;
		if (mode === "tuple") res = require_utils.stringifyTuplesArray(value, "sql", (x) => {
			return `"${x.length > 0 ? `(${x[0]},${x[1]})` : "{}"}"`;
		});
		else if (mode === "xy") res = require_utils.stringifyArray(value, "sql", (x, _depth) => {
			return `"${Object.values(x).length > 0 ? `(${x.x},${x.y})` : "{}"}"`;
		});
		else throw new Error("unknown point type");
		return require_utils.wrapWith(res, "'");
	},
	defaultFromIntrospect: function(value) {
		return value;
	},
	defaultArrayFromIntrospect: function(value) {
		return value;
	},
	toTs: function(type, value) {
		if (!value) return { default: "" };
		if (/^'\(\d+,\d+\)'$/.test(value)) return {
			default: require_utils.trimChar(value, "'").replace("(", "[").replace(")", "]"),
			options: {}
		};
		return {
			default: `sql\`${value}\``,
			options: {}
		};
	},
	toArrayTs: function(type, value) {
		if (!value) return { default: "" };
		let isDrizzleSql = false;
		try {
			const def = require_utils.stringifyArray(parseArray(require_utils.trimChar(require_utils.trimChar(value, ["(", ")"]), "'")), "ts", (v) => {
				if (!/^\(\d+,\d+\)$/.test(v)) isDrizzleSql = true;
				return v.replace("(", "[").replace(")", "]");
			});
			return { default: isDrizzleSql ? `sql\`${value}\`` : def };
		} catch {
			return { default: `sql\`${value}\`` };
		}
	}
};
const Line = {
	is: (type) => /^\s*line(?:\s*\[\s*\])*\s*$/i.test(type),
	drizzleImport: () => "line",
	defaultFromDrizzle: (value, mode) => {
		if (!value) return "";
		if (mode === "tuple") {
			const v = value;
			return v.length > 0 ? `'{${v[0]},${v[1]},${v[2]}}'` : "";
		}
		if (mode === "abc") {
			const v = value;
			return Object.values(v).length > 0 ? `'{${v.a},${v.b},${v.c}}'` : "";
		}
		throw new Error("unknown line type");
	},
	defaultArrayFromDrizzle: function(value, dimensions, mode) {
		let res;
		if (mode === "tuple") res = require_utils.stringifyTuplesArray(value, "sql", (x) => {
			return `"${x.length > 0 ? `{${x[0]},${x[1]},${x[2]}}` : "{}"}"`;
		});
		else if (mode === "abc") res = require_utils.stringifyArray(value, "sql", (x, _depth) => {
			return `"${Object.values(x).length > 0 ? `{${x.a},${x.b},${x.c}}` : "{}"}"`;
		});
		else throw new Error("unknown line type");
		return require_utils.wrapWith(res, "'");
	},
	defaultFromIntrospect: function(value) {
		return value;
	},
	defaultArrayFromIntrospect: function(value) {
		return value;
	},
	toTs: function(type, value) {
		if (!value) return { default: "" };
		if (/^'\{\d+,\d+,\d+\}'$/.test(value)) return {
			default: require_utils.trimChar(value, "'").replace("{", "[").replace("}", "]"),
			options: {}
		};
		return {
			default: `sql\`${value}\``,
			options: {}
		};
	},
	toArrayTs: function(type, value) {
		if (!value) return { default: "" };
		let isDrizzleSql = false;
		try {
			const def = require_utils.stringifyArray(parseArray(require_utils.trimChar(require_utils.trimChar(value, ["(", ")"]), "'")), "ts", (v) => {
				if (!/^\{\d+,\d+,\d+\}$/.test(v)) isDrizzleSql = true;
				return v.replace("{", "[").replace("}", "]");
			});
			return { default: isDrizzleSql ? `sql\`${value}\`` : def };
		} catch {
			return { default: `sql\`${value}\`` };
		}
	}
};
const GeometryPoint = {
	is: (type) => /^\s*geometry\(point(?:,\d+)?\)(?:\[\s*\])*\s*$/i.test(type),
	drizzleImport: () => "geometry",
	defaultFromDrizzle: (value, mode, config) => {
		if (!value) return "";
		const srid = config ? Number(config) : void 0;
		let sridPrefix = srid ? `SRID=${srid};` : "";
		if (mode === "tuple") {
			const v = value;
			return v.length > 0 ? `'${sridPrefix}POINT(${v[0]} ${v[1]})'` : "";
		}
		if (mode === "object") {
			const v = value;
			return Object.values(v).length > 0 ? `'${sridPrefix}POINT(${v.x} ${v.y})'` : "";
		}
		throw new Error("unknown geometry type");
	},
	defaultArrayFromDrizzle: function(value, dimensions, mode, config) {
		let res;
		const srid = config ? Number(config) : void 0;
		let sridPrefix = srid ? `SRID=${srid};` : "";
		if (mode === "tuple") res = require_utils.stringifyTuplesArray(value, "geometry-sql", (x) => {
			return `'${`${sridPrefix}POINT(${x[0]} ${x[1]})`}'`;
		});
		else if (mode === "object") res = require_utils.stringifyArray(value, "geometry-sql", (x, _depth) => {
			return `'${`${sridPrefix}POINT(${x.x} ${x.y})`}'`;
		});
		else throw new Error("unknown geometry type");
		return res;
	},
	defaultFromIntrospect: function(value) {
		let def;
		try {
			const { srid, point } = require_utils.parseEWKB(require_utils.trimChar(value, "'"));
			def = `'${srid ? `SRID=${srid};` : ""}POINT(${point[0]} ${point[1]})'`;
		} catch {
			def = value;
		}
		return def;
	},
	defaultArrayFromIntrospect: function(value) {
		/**
		* Potential values here are:
		* DEFAULT {'POINT(10 10)'} -> '{010100000000000000000024400000000000002440}'::geometry(Point,435)[]
		* DEFAULT ARRAY['POINT(10 10)'] -> ARRAY['POINT(10 10)'::text]
		* DEFAULT ARRAY['POINT(10 10)']::geometry(point) -> ARRAY['010100000000000000000024400000000000002440'::geometry(Point)]
		* DEFAULT ARRAY['POINT(10 10)'::text]::geometry(point) -> ARRAY[('POINT(10 10)'::text)::geometry(Point)]
		*/
		let def = value;
		if (def === "'{}'") return def;
		try {
			if (value.startsWith("'{") && value.endsWith("}'")) def = require_utils.stringifyArray(parseArray(require_utils.trimChar(value, "'")), "geometry-sql", (v) => {
				try {
					const { srid, point } = require_utils.parseEWKB(v);
					return `'${srid ? `SRID=${srid};` : ""}POINT(${point[0]} ${point[1]})'`;
				} catch {
					return v;
				}
			});
			else def = require_utils.stringifyArray(parseExpressionArray(value), "geometry-sql", (v) => {
				v = trimDefaultValueSuffix(trimDefaultValueSuffix(v).replace(/^\((.*)\)$/, "$1"));
				try {
					const { srid, point } = require_utils.parseEWKB(require_utils.trimChar(v, "'"));
					return `'${srid ? `SRID=${srid};` : ""}POINT(${point[0]} ${point[1]})'`;
				} catch {
					return v;
				}
			});
		} catch {}
		return def;
	},
	toTs: function(type, value) {
		if (!value) return { default: "" };
		const options = { type: "point" };
		const sridOption = splitSqlType(type).options?.split(",")[1];
		if (sridOption) options.srid = Number(sridOption);
		if (!value.includes("POINT(")) return {
			default: `sql\`${value}\``,
			options
		};
		const sridInDef = value.startsWith("'SRID=") ? Number(value.split("SRID=")[1].split(";")[0]) : void 0;
		if (!sridOption && sridInDef) return {
			default: `sql\`${value}\``,
			options
		};
		const [res1, res2] = value.split("POINT(")[1].split(")")[0].split(" ");
		return {
			default: `[${res1},${res2}]`,
			options
		};
	},
	toArrayTs: function(type, value) {
		if (!value) return { default: "" };
		const options = { type: "point" };
		const sridOption = splitSqlType(type).options?.split(",")[1];
		if (sridOption) options.srid = Number(sridOption);
		if (!value) return {
			default: "",
			options
		};
		if (value === "'{}'") return {
			default: "[]",
			options
		};
		let isDrizzleSql;
		const srids = [];
		try {
			const def = require_utils.stringifyArray(parseExpressionArray(require_utils.trimChar(require_utils.trimChar(value, ["(", ")"]), "'")), "ts", (v) => {
				if (v.includes("SRID=")) srids.push(Number(v.split("SRID=")[1].split(";")[0]));
				const [res1, res2] = value.split("POINT(")[1].split(")")[0].split(" ");
				if (!value.includes("POINT(")) isDrizzleSql = true;
				return `[${res1}, ${res2}]`;
			});
			if (!isDrizzleSql) isDrizzleSql = srids.some((it) => it !== srids[0]);
			if (!isDrizzleSql && !sridOption && srids.length > 0) isDrizzleSql = true;
			return {
				options,
				default: isDrizzleSql ? `sql\`${value}\`` : def
			};
		} catch {
			return {
				options,
				default: `sql\`${value}\``
			};
		}
	}
};
const Enum = {
	is: (_type) => {
		throw Error("Mocked");
	},
	drizzleImport: () => "pgEnum",
	defaultFromDrizzle: (value) => {
		if (!value) return "";
		return `'${value.replaceAll("'", "''")}'`;
	},
	defaultArrayFromDrizzle: (value) => {
		return `'${require_utils.stringifyArray(value, "sql", (v) => {
			if (typeof v !== "string") throw new Error();
			const escaped = escapeForSqlDefault(v, "pg-arr");
			if (v.includes("\\") || v.includes("\"") || v.includes(",")) return `"${escaped}"`;
			return escaped;
		})}'`;
	},
	defaultFromIntrospect: (value) => {
		return value;
	},
	defaultArrayFromIntrospect: (value) => {
		return value;
	},
	toTs: (type, value) => {
		const options = {};
		const [length] = parseParams(type);
		if (length) options["length"] = Number(length);
		if (!value) return {
			options,
			default: ""
		};
		return {
			options,
			default: escapeForTsLiteral(require_utils.trimChar(value, "'").replaceAll("''", "'"))
		};
	},
	toArrayTs: (type, value) => {
		if (!value) return { default: "" };
		try {
			return { default: require_utils.stringifyArray(parseArray(require_utils.trimChar(require_utils.trimChar(value, ["(", ")"]), "'")), "ts", (v) => {
				return escapeForTsLiteral(unescapeFromSqlDefault(require_utils.trimChar(v, "'")));
			}) };
		} catch {
			return { default: `sql\`${value}\`` };
		}
	}
};
const Serial = {
	is: (type) => /^(?:serial)(?:[\s(].*)?$/i.test(type),
	drizzleImport: () => "serial",
	defaultFromDrizzle: (value) => {
		throw new Error(`Unexpected default for serial type: ${value}`);
	},
	defaultArrayFromDrizzle: (v) => {
		throw new Error(`Unexpected default for serial type: ${v}`);
	},
	defaultFromIntrospect: (value) => {
		return value;
	},
	defaultArrayFromIntrospect: function(value) {
		return value;
	},
	toTs: () => {
		return { default: "" };
	},
	toArrayTs: () => {
		return { default: "" };
	}
};
const BigSerial = {
	is: (type) => /^(?:bigserial)(?:[\s(].*)?$/i.test(type),
	drizzleImport: () => "bigserial",
	defaultFromDrizzle: Serial.defaultFromDrizzle,
	defaultArrayFromDrizzle: Serial.defaultArrayFromDrizzle,
	defaultFromIntrospect: Serial.defaultFromIntrospect,
	defaultArrayFromIntrospect: Serial.defaultArrayFromIntrospect,
	toTs: () => {
		return {
			options: { mode: "number" },
			default: ""
		};
	},
	toArrayTs: () => {
		return {
			options: { mode: "number" },
			default: ""
		};
	}
};
const SmallSerial = {
	is: (type) => /^(?:smallserial)(?:[\s(].*)?$/i.test(type),
	drizzleImport: () => "smallserial",
	defaultFromDrizzle: Serial.defaultFromDrizzle,
	defaultArrayFromDrizzle: Serial.defaultArrayFromDrizzle,
	defaultFromIntrospect: Serial.defaultFromIntrospect,
	defaultArrayFromIntrospect: Serial.defaultArrayFromIntrospect,
	toTs: Serial.toTs,
	toArrayTs: Serial.toArrayTs
};
const Custom = {
	is: (_type) => {
		throw Error("Mocked");
	},
	drizzleImport: () => "customType",
	defaultFromDrizzle: (value) => {
		if (!value) return "";
		return String(value);
	},
	defaultArrayFromDrizzle: (value) => {
		return String(value);
	},
	defaultFromIntrospect: (value) => {
		return value;
	},
	defaultArrayFromIntrospect: (value) => {
		return value;
	},
	toTs: (type, value) => {
		const options = {};
		if (!value) return {
			options,
			default: "",
			customType: type
		};
		return {
			default: escapeForTsLiteral(value),
			customType: type
		};
	},
	toArrayTs: (type, value) => {
		if (!value) return {
			default: "",
			customType: type
		};
		try {
			return {
				default: require_utils.stringifyArray(parseArray(require_utils.trimChar(require_utils.trimChar(value, ["(", ")"]), "'")), "ts", (v) => {
					return escapeForTsLiteral(v);
				}),
				customType: type
			};
		} catch {
			return {
				default: `sql\`${value}\``,
				customType: type
			};
		}
	}
};
const typeFor = (type, isEnum) => {
	if (isEnum) return Enum;
	if (SmallInt.is(type)) return SmallInt;
	if (Int.is(type)) return Int;
	if (BigInt$1.is(type)) return BigInt$1;
	if (Numeric.is(type)) return Numeric;
	if (Real.is(type)) return Real;
	if (Double.is(type)) return Double;
	if (Boolean.is(type)) return Boolean;
	if (Char.is(type)) return Char;
	if (Varchar.is(type)) return Varchar;
	if (Text.is(type)) return Text;
	if (Json.is(type)) return Json;
	if (Jsonb.is(type)) return Jsonb;
	if (Time.is(type)) return Time;
	if (TimeTz.is(type)) return TimeTz;
	if (Timestamp.is(type)) return Timestamp;
	if (TimestampTz.is(type)) return TimestampTz;
	if (Uuid.is(type)) return Uuid;
	if (Interval.is(type)) return Interval;
	if (Inet.is(type)) return Inet;
	if (Cidr.is(type)) return Cidr;
	if (MacAddr.is(type)) return MacAddr;
	if (MacAddr8.is(type)) return MacAddr8;
	if (Vector.is(type)) return Vector;
	if (HalfVec.is(type)) return HalfVec;
	if (SparseVec.is(type)) return SparseVec;
	if (Bit.is(type)) return Bit;
	if (Point.is(type)) return Point;
	if (Line.is(type)) return Line;
	if (DateType.is(type)) return DateType;
	if (GeometryPoint.is(type)) return GeometryPoint;
	if (Serial.is(type)) return Serial;
	if (SmallSerial.is(type)) return SmallSerial;
	if (BigSerial.is(type)) return BigSerial;
	return Custom;
};
const splitSqlType = (sqlType) => {
	const toMatch = sqlType.replaceAll("[]", "");
	const match = toMatch.match(/^(\w+(?:\s+\w+)*)\(([^)]*)\)(?:\s+with time zone)?$/i);
	return {
		type: match ? match[1] + (match[3] ?? "") : toMatch,
		options: match ? match[2].replaceAll(", ", ",") : null
	};
};
const vectorOps = [
	"vector_l2_ops",
	"vector_ip_ops",
	"vector_cosine_ops",
	"vector_l1_ops",
	"bit_hamming_ops",
	"bit_jaccard_ops",
	"halfvec_l2_ops",
	"sparsevec_l2_ops"
];
const indexName = (tableName, columns) => {
	return `${tableName}_${columns.join("_")}_index`;
};
function stringFromIdentityProperty(field) {
	return typeof field === "string" ? field : typeof field === "undefined" ? void 0 : String(field);
}
function maxRangeForIdentityBasedOn(columnType) {
	return columnType === "integer" ? "2147483647" : columnType === "bigint" ? "9223372036854775807" : "32767";
}
function minRangeForIdentityBasedOn(columnType) {
	return columnType === "integer" ? "-2147483648" : columnType === "bigint" ? "-9223372036854775808" : "-32768";
}
const isSerialExpression = (expr, schema) => {
	const schemaPrefix = schema === "public" ? "" : `${schema}.`;
	return (expr.startsWith(`nextval('${schemaPrefix}`) || expr.startsWith(`nextval('"${schemaPrefix}`)) && (expr.endsWith(`_seq'::regclass)`) || expr.endsWith(`_seq"'::regclass)`));
};
function stringFromDatabaseIdentityProperty(field) {
	return typeof field === "string" ? field : typeof field === "undefined" || field === null ? null : typeof field === "bigint" ? field.toString() : String(field);
}
const parseOnType = (type) => {
	switch (type) {
		case "a": return "NO ACTION";
		case "r": return "RESTRICT";
		case "n": return "SET NULL";
		case "c": return "CASCADE";
		case "d": return "SET DEFAULT";
		default: throw new Error(`Unknown foreign key type: ${type}`);
	}
};
const planetscaleNamespaces = ["pscale_extensions"];
const systemNamespaceNames = [
	"pg_toast",
	"pg_catalog",
	"information_schema",
	...planetscaleNamespaces
];
const isSystemNamespace = (name) => {
	return name.startsWith("pg_toast") || name === "pg_default" || name === "pg_global" || name.startsWith("pg_temp_") || systemNamespaceNames.indexOf(name) >= 0;
};
const wrapRecord = (it) => {
	return {
		bool: (key) => {
			if (key in it) {
				const value = it[key];
				if (value === "true" || value === "1" || value === "on" || value === "yes") return true;
				if (value === "false" || value === "0" || value === "off" || value === "no") return false;
				throw new Error(`Invalid options boolean value for ${key}: ${it[key]}`);
			}
			return null;
		},
		num: (key) => {
			if (key in it) {
				const value = Number(it[key]);
				if (isNaN(value)) throw new Error(`Invalid options number value for ${key}: ${it[key]}`);
				return value;
			}
			return null;
		},
		str: (key) => {
			if (key in it) return it[key];
			return null;
		},
		literal: (key, allowed) => {
			if (!(key in it)) return null;
			const value = it[key];
			if (allowed.includes(value)) return value;
			throw new Error(`Invalid options literal value for ${key}: ${it[key]}`);
		}
	};
};
const parseViewDefinition = (value) => {
	if (!value) return null;
	return value.replace(/\s+/g, " ").replace(";", "").trim();
};
const defaultNameForPK = (table) => {
	return `${table}_pkey`;
};
const defaultNameForFK = (table, columns, tableTo, columnsTo) => {
	const desired = `${table}_${columns.join("_")}_${tableTo}_${columnsTo.join("_")}_fkey`;
	return desired.length > 63 ? table.length < 45 ? `${table}_${hash(desired)}_fkey` : `${hash(desired)}_fkey` : desired;
};
const defaultNameForUnique = (table, ...columns) => {
	return `${table}_${columns.join("_")}_key`;
};
const defaultNameForIndex = (table, columns) => {
	return `${table}_${columns.join("_")}_idx`;
};
const trimDefaultValueSuffix = (value) => {
	let res = value.endsWith("[]") ? value.slice(0, -2) : value;
	res = res.replace(/(::["\w.\s]+(?:\([^)]*\))?(?:\swith(?:out)?\stime\szone)?(?:\[\])?)+$/gi, "");
	return res;
};
const defaultForColumn = (type, def, dimensions, isEnum) => {
	if (def === null || def === void 0 || type === "serial" || type === "smallserial" || type === "bigserial") return null;
	if (typeof def === "boolean") return String(def);
	if (typeof def === "number") return String(def);
	let value = trimDefaultValueSuffix(def);
	const grammarType = typeFor(type, isEnum);
	if (dimensions > 0) return grammarType.defaultArrayFromIntrospect(value);
	return grammarType.defaultFromIntrospect(String(value));
};
const defaultToSQL = (it) => {
	if (!it.default) return "";
	const { type: columnType, dimensions, typeSchema } = it;
	const value = it.default;
	if (typeSchema) return `${value}::${typeSchema && typeSchema !== "public" ? `"${typeSchema}".` : ""}"${columnType}"${dimensions > 0 ? "[]" : ""}`;
	const suffix = dimensions > 0 ? `::${columnType}[]` : "";
	return `${it.default ?? ""}${suffix}`;
};
const isDefaultAction = (action) => {
	return action.toLowerCase() === "no action";
};
const isSerialType = (type) => {
	return /^(?:serial|bigserial|smallserial)$/i.test(type);
};
const mapSerialToInt = (type) => {
	switch (type) {
		case "smallserial": return "smallint";
		case "serial": return "int";
		case "bigserial": return "bigint";
		default: throw new Error(`Unsupported type: ${type}`);
	}
};
function formatTimestampTz(date) {
	if (!require_utils.isTimestamp(date)) return date;
	return _js_temporal_polyfill.Temporal.Instant.from(date).toString({ timeZone: "UTC" });
}
function formatTime(date) {
	if (!require_utils.isTime(date)) return date;
	return _js_temporal_polyfill.Temporal.Instant.from(`1970-01-01 ${date}`).toString({ timeZone: "UTC" });
}
const defaultsCommutative = (diffDef, type, dimensions) => {
	if (!diffDef) return false;
	let from = diffDef.from;
	let to = diffDef.to;
	if (from === to) return true;
	if (from === `(${to})`) return true;
	if (to === `(${from})`) return true;
	if (type.startsWith("timestamp") && type.includes("with time zone")) {
		if (from && to) {
			from = require_utils.trimChar(from, "'");
			to = require_utils.trimChar(to, "'");
			if (dimensions > 0) {
				try {
					const fromArray = require_utils.stringifyArray(parseArray(from), "sql", (v) => {
						return `"${formatTimestampTz(v)}"`;
					});
					if (require_utils.stringifyArray(parseArray(to), "sql", (v) => {
						return `"${formatTimestampTz(v)}"`;
					}) === fromArray) return true;
				} catch {}
				return false;
			}
			if (formatTimestampTz(to) === formatTimestampTz(from)) return true;
		}
		return false;
	}
	if (type.startsWith("time") && type.includes("with time zone")) {
		if (from && to) {
			from = require_utils.trimChar(from, "'");
			to = require_utils.trimChar(to, "'");
			if (dimensions > 0) {
				try {
					const fromArray = require_utils.stringifyArray(parseArray(from), "sql", (v) => {
						return `"${formatTime(v)}"`;
					});
					if (require_utils.stringifyArray(parseArray(to), "sql", (v) => {
						return `"${formatTime(v)}"`;
					}) === fromArray) return true;
				} catch {}
				return false;
			}
			if (formatTime(to) === formatTime(from)) return true;
		}
		return false;
	}
	if (type.startsWith("vector")) {
		if (from?.replaceAll(".0", "") === to) return true;
	}
	return false;
};
const defaults = {
	tablespace: "pg_default",
	accessMethod: "heap",
	nullsNotDistinct: false,
	identity: {
		startWith: "1",
		increment: "1",
		min: "1",
		maxFor: (type) => {
			if (type === "smallint") return "32767";
			if (type === "integer") return "2147483647";
			if (type === "bigint") return "9223372036854775807";
			throw new Error(`Unknow identity column type: ${type}`);
		},
		cache: 1,
		cycle: false
	},
	index: { method: "btree" },
	types: { geometry: { defSrid: 0 } }
};

//#endregion
Object.defineProperty(exports, 'GeometryPoint', {
  enumerable: true,
  get: function () {
    return GeometryPoint;
  }
});
Object.defineProperty(exports, 'JSONB', {
  enumerable: true,
  get: function () {
    return JSONB;
  }
});
Object.defineProperty(exports, 'Line', {
  enumerable: true,
  get: function () {
    return Line;
  }
});
Object.defineProperty(exports, 'Point', {
  enumerable: true,
  get: function () {
    return Point;
  }
});
Object.defineProperty(exports, 'defaultForColumn', {
  enumerable: true,
  get: function () {
    return defaultForColumn;
  }
});
Object.defineProperty(exports, 'defaultNameForFK', {
  enumerable: true,
  get: function () {
    return defaultNameForFK;
  }
});
Object.defineProperty(exports, 'defaultNameForIndex', {
  enumerable: true,
  get: function () {
    return defaultNameForIndex;
  }
});
Object.defineProperty(exports, 'defaultNameForPK', {
  enumerable: true,
  get: function () {
    return defaultNameForPK;
  }
});
Object.defineProperty(exports, 'defaultNameForUnique', {
  enumerable: true,
  get: function () {
    return defaultNameForUnique;
  }
});
Object.defineProperty(exports, 'defaultToSQL', {
  enumerable: true,
  get: function () {
    return defaultToSQL;
  }
});
Object.defineProperty(exports, 'defaults', {
  enumerable: true,
  get: function () {
    return defaults;
  }
});
Object.defineProperty(exports, 'defaultsCommutative', {
  enumerable: true,
  get: function () {
    return defaultsCommutative;
  }
});
Object.defineProperty(exports, 'escapeForSqlDefault', {
  enumerable: true,
  get: function () {
    return escapeForSqlDefault;
  }
});
Object.defineProperty(exports, 'escapeForTsLiteral', {
  enumerable: true,
  get: function () {
    return escapeForTsLiteral;
  }
});
Object.defineProperty(exports, 'filterMigrationsSchema', {
  enumerable: true,
  get: function () {
    return filterMigrationsSchema;
  }
});
Object.defineProperty(exports, 'getOrNull', {
  enumerable: true,
  get: function () {
    return getOrNull;
  }
});
Object.defineProperty(exports, 'groupDiffs', {
  enumerable: true,
  get: function () {
    return groupDiffs;
  }
});
Object.defineProperty(exports, 'indexName', {
  enumerable: true,
  get: function () {
    return indexName;
  }
});
Object.defineProperty(exports, 'isDefaultAction', {
  enumerable: true,
  get: function () {
    return isDefaultAction;
  }
});
Object.defineProperty(exports, 'isSerialExpression', {
  enumerable: true,
  get: function () {
    return isSerialExpression;
  }
});
Object.defineProperty(exports, 'isSerialType', {
  enumerable: true,
  get: function () {
    return isSerialType;
  }
});
Object.defineProperty(exports, 'isSystemNamespace', {
  enumerable: true,
  get: function () {
    return isSystemNamespace;
  }
});
Object.defineProperty(exports, 'mapSerialToInt', {
  enumerable: true,
  get: function () {
    return mapSerialToInt;
  }
});
Object.defineProperty(exports, 'maxRangeForIdentityBasedOn', {
  enumerable: true,
  get: function () {
    return maxRangeForIdentityBasedOn;
  }
});
Object.defineProperty(exports, 'minRangeForIdentityBasedOn', {
  enumerable: true,
  get: function () {
    return minRangeForIdentityBasedOn;
  }
});
Object.defineProperty(exports, 'parse', {
  enumerable: true,
  get: function () {
    return parse;
  }
});
Object.defineProperty(exports, 'parseArray', {
  enumerable: true,
  get: function () {
    return parseArray;
  }
});
Object.defineProperty(exports, 'parseOnType', {
  enumerable: true,
  get: function () {
    return parseOnType;
  }
});
Object.defineProperty(exports, 'parseParams', {
  enumerable: true,
  get: function () {
    return parseParams;
  }
});
Object.defineProperty(exports, 'parseViewDefinition', {
  enumerable: true,
  get: function () {
    return parseViewDefinition;
  }
});
Object.defineProperty(exports, 'preserveEntityNames', {
  enumerable: true,
  get: function () {
    return preserveEntityNames;
  }
});
Object.defineProperty(exports, 'splitSqlType', {
  enumerable: true,
  get: function () {
    return splitSqlType;
  }
});
Object.defineProperty(exports, 'stringFromDatabaseIdentityProperty', {
  enumerable: true,
  get: function () {
    return stringFromDatabaseIdentityProperty;
  }
});
Object.defineProperty(exports, 'stringFromIdentityProperty', {
  enumerable: true,
  get: function () {
    return stringFromIdentityProperty;
  }
});
Object.defineProperty(exports, 'stringify', {
  enumerable: true,
  get: function () {
    return stringify;
  }
});
Object.defineProperty(exports, 'trimDefaultValueSuffix', {
  enumerable: true,
  get: function () {
    return trimDefaultValueSuffix;
  }
});
Object.defineProperty(exports, 'typeFor', {
  enumerable: true,
  get: function () {
    return typeFor;
  }
});
Object.defineProperty(exports, 'unescapeFromSqlDefault', {
  enumerable: true,
  get: function () {
    return unescapeFromSqlDefault;
  }
});
Object.defineProperty(exports, 'vectorOps', {
  enumerable: true,
  get: function () {
    return vectorOps;
  }
});
Object.defineProperty(exports, 'wrapRecord', {
  enumerable: true,
  get: function () {
    return wrapRecord;
  }
});