{"version":3,"file":"varchar.js","names":[],"sources":["../../../src/pg-core/columns/varchar.ts"],"sourcesContent":["import { entityKind } from '~/entity.ts';\nimport type { PgTable } from '~/pg-core/table.ts';\nimport { type Equal, getColumnNameAndConfig, type Writable } from '~/utils.ts';\nimport { PgColumn, PgColumnBuilder } from './common.ts';\n\ntype PgVarcharBuilderConfig<TEnum extends [string, ...string[]]> = Equal<TEnum, [string, ...string[]]> extends true\n\t? { dataType: 'string'; data: string; driverParam: string }\n\t: { dataType: 'string enum'; data: TEnum[number]; enumValues: TEnum; driverParam: string };\n\nexport class PgVarcharBuilder<TEnum extends [string, ...string[]] = [string, ...string[]]> extends PgColumnBuilder<\n\tPgVarcharBuilderConfig<TEnum>,\n\t{ length: number | undefined; enumValues: TEnum }\n> {\n\tstatic override readonly [entityKind]: string = 'PgVarcharBuilder';\n\n\tconstructor(name: string, config: PgVarcharConfig<TEnum>) {\n\t\tsuper(name, config.enum?.length ? 'string enum' : 'string', 'PgVarchar');\n\t\tthis.config.length = config.length!;\n\t\tthis.config.enumValues = config.enum as TEnum;\n\t}\n\n\t/** @internal */\n\toverride build(table: PgTable<any>) {\n\t\treturn new PgVarchar(\n\t\t\ttable,\n\t\t\tthis.config as any,\n\t\t);\n\t}\n}\n\nexport class PgVarchar<TEnum extends [string, ...string[]] = [string, ...string[]]>\n\textends PgColumn<Equal<TEnum, [string, ...string[]]> extends true ? 'string' : 'string enum'>\n{\n\tstatic override readonly [entityKind]: string = 'PgVarchar';\n\n\toverride readonly enumValues: TEnum;\n\n\tconstructor(table: PgTable<any>, config: PgVarcharBuilder<TEnum>['config']) {\n\t\tsuper(table, config as any);\n\t\tthis.enumValues = config.enumValues;\n\t}\n\n\tgetSQLType(): string {\n\t\treturn this.length === undefined ? `varchar` : `varchar(${this.length})`;\n\t}\n}\n\nexport interface PgVarcharConfig<\n\tTEnum extends readonly string[] | string[] | undefined = readonly string[] | string[] | undefined,\n> {\n\tenum?: TEnum;\n\tlength?: number;\n}\n\nexport function varchar(): PgVarcharBuilder;\nexport function varchar(name: string): PgVarcharBuilder;\nexport function varchar(config: { length?: number }): PgVarcharBuilder;\nexport function varchar(name: string, config: { length?: number }): PgVarcharBuilder;\nexport function varchar<U extends string, T extends Readonly<[U, ...U[]]>>(\n\tconfig: PgVarcharConfig<T | Writable<T>> & { enum: T | Writable<T> },\n): PgVarcharBuilder<Writable<T>>;\nexport function varchar<U extends string, T extends Readonly<[U, ...U[]]>>(\n\tname: string,\n\tconfig: PgVarcharConfig<T | Writable<T>> & { enum: T | Writable<T> },\n): PgVarcharBuilder<Writable<T>>;\nexport function varchar(a?: string | PgVarcharConfig, b: PgVarcharConfig = {}): any {\n\tconst { name, config } = getColumnNameAndConfig<PgVarcharConfig>(a, b);\n\treturn new PgVarcharBuilder(name, config as any);\n}\n"],"mappings":";;;;;AASA,IAAa,mBAAb,cAAmG,gBAGjG;CACD,QAA0B,cAAsB;CAEhD,YAAY,MAAc,QAAgC;AACzD,QAAM,MAAM,OAAO,MAAM,SAAS,gBAAgB,UAAU,YAAY;AACxE,OAAK,OAAO,SAAS,OAAO;AAC5B,OAAK,OAAO,aAAa,OAAO;;;CAIjC,AAAS,MAAM,OAAqB;AACnC,SAAO,IAAI,UACV,OACA,KAAK,OACL;;;AAIH,IAAa,YAAb,cACS,SACT;CACC,QAA0B,cAAsB;CAEhD,AAAkB;CAElB,YAAY,OAAqB,QAA2C;AAC3E,QAAM,OAAO,OAAc;AAC3B,OAAK,aAAa,OAAO;;CAG1B,aAAqB;AACpB,SAAO,KAAK,WAAW,SAAY,YAAY,WAAW,KAAK,OAAO;;;AAsBxE,SAAgB,QAAQ,GAA8B,IAAqB,EAAE,EAAO;CACnF,MAAM,EAAE,MAAM,WAAW,uBAAwC,GAAG,EAAE;AACtE,QAAO,IAAI,iBAAiB,MAAM,OAAc"}