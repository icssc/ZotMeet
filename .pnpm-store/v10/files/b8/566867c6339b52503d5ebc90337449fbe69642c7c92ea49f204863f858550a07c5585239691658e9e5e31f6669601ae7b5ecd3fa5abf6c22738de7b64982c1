{"version":3,"sources":["../../../../../src/server/lib/trace/tracer.ts"],"sourcesContent":["import type { FetchEventResult } from '../../web/types'\nimport type { TextMapSetter } from '@opentelemetry/api'\nimport type { SpanTypes } from './constants'\nimport { LogSpanAllowList, NextVanillaSpanAllowlist } from './constants'\n\nimport type {\n  ContextAPI,\n  Span,\n  SpanOptions,\n  Tracer,\n  AttributeValue,\n  TextMapGetter,\n} from 'next/dist/compiled/@opentelemetry/api'\nimport { isThenable } from '../../../shared/lib/is-thenable'\n\nconst NEXT_OTEL_PERFORMANCE_PREFIX = process.env.NEXT_OTEL_PERFORMANCE_PREFIX\n\nlet api: typeof import('next/dist/compiled/@opentelemetry/api')\n\n// we want to allow users to use their own version of @opentelemetry/api if they\n// want to, so we try to require it first, and if it fails we fall back to the\n// version that is bundled with Next.js\n// this is because @opentelemetry/api has to be synced with the version of\n// @opentelemetry/tracing that is used, and we don't want to force users to use\n// the version that is bundled with Next.js.\n// the API is ~stable, so this should be fine\nif (process.env.NEXT_RUNTIME === 'edge') {\n  api = require('@opentelemetry/api') as typeof import('@opentelemetry/api')\n} else {\n  try {\n    api = require('@opentelemetry/api') as typeof import('@opentelemetry/api')\n  } catch (err) {\n    api =\n      require('next/dist/compiled/@opentelemetry/api') as typeof import('next/dist/compiled/@opentelemetry/api')\n  }\n}\n\nconst { context, propagation, trace, SpanStatusCode, SpanKind, ROOT_CONTEXT } =\n  api\n\nexport class BubbledError extends Error {\n  constructor(\n    public readonly bubble?: boolean,\n    public readonly result?: FetchEventResult\n  ) {\n    super()\n  }\n}\n\nexport function isBubbledError(error: unknown): error is BubbledError {\n  if (typeof error !== 'object' || error === null) return false\n  return error instanceof BubbledError\n}\n\nconst closeSpanWithError = (span: Span, error?: Error) => {\n  if (isBubbledError(error) && error.bubble) {\n    span.setAttribute('next.bubble', true)\n  } else {\n    if (error) {\n      span.recordException(error)\n      span.setAttribute('error.type', error.name)\n    }\n    span.setStatus({ code: SpanStatusCode.ERROR, message: error?.message })\n  }\n  span.end()\n}\n\ntype TracerSpanOptions = Omit<SpanOptions, 'attributes'> & {\n  parentSpan?: Span\n  spanName?: string\n  attributes?: Partial<Record<AttributeNames, AttributeValue | undefined>>\n  hideSpan?: boolean\n}\n\ninterface NextTracer {\n  getContext(): ContextAPI\n\n  /**\n   * Instruments a function by automatically creating a span activated on its\n   * scope.\n   *\n   * The span will automatically be finished when one of these conditions is\n   * met:\n   *\n   * * The function returns a promise, in which case the span will finish when\n   * the promise is resolved or rejected.\n   * * The function takes a callback as its second parameter, in which case the\n   * span will finish when that callback is called.\n   * * The function doesn't accept a callback and doesn't return a promise, in\n   * which case the span will finish at the end of the function execution.\n   *\n   */\n  trace<T>(\n    type: SpanTypes,\n    fn: (span?: Span, done?: (error?: Error) => any) => Promise<T>\n  ): Promise<T>\n  trace<T>(\n    type: SpanTypes,\n    fn: (span?: Span, done?: (error?: Error) => any) => T\n  ): T\n  trace<T>(\n    type: SpanTypes,\n    options: TracerSpanOptions,\n    fn: (span?: Span, done?: (error?: Error) => any) => Promise<T>\n  ): Promise<T>\n  trace<T>(\n    type: SpanTypes,\n    options: TracerSpanOptions,\n    fn: (span?: Span, done?: (error?: Error) => any) => T\n  ): T\n\n  /**\n   * Wrap a function to automatically create a span activated on its\n   * scope when it's called.\n   *\n   * The span will automatically be finished when one of these conditions is\n   * met:\n   *\n   * * The function returns a promise, in which case the span will finish when\n   * the promise is resolved or rejected.\n   * * The function takes a callback as its last parameter, in which case the\n   * span will finish when that callback is called.\n   * * The function doesn't accept a callback and doesn't return a promise, in\n   * which case the span will finish at the end of the function execution.\n   */\n  wrap<T = (...args: Array<any>) => any>(type: SpanTypes, fn: T): T\n  wrap<T = (...args: Array<any>) => any>(\n    type: SpanTypes,\n    options: TracerSpanOptions,\n    fn: T\n  ): T\n  wrap<T = (...args: Array<any>) => any>(\n    type: SpanTypes,\n    options: (...args: any[]) => TracerSpanOptions,\n    fn: T\n  ): T\n\n  /**\n   * Starts and returns a new Span representing a logical unit of work.\n   *\n   * This method do NOT modify the current Context by default. In result, any inner span will not\n   * automatically set its parent context to the span created by this method unless manually activate\n   * context via `tracer.getContext().with`. `trace`, or `wrap` is generally recommended as it gracefully\n   * handles context activation. (ref: https://github.com/open-telemetry/opentelemetry-js/issues/1923)\n   */\n  startSpan(type: SpanTypes): Span\n  startSpan(type: SpanTypes, options: TracerSpanOptions): Span\n\n  /**\n   * Returns currently activated span if current context is in the scope of the span.\n   * Returns undefined otherwise.\n   */\n  getActiveScopeSpan(): Span | undefined\n\n  /**\n   * Returns trace propagation data for the currently active context. The format is equal to data provided\n   * through the OpenTelemetry propagator API.\n   */\n  getTracePropagationData(): ClientTraceDataEntry[]\n\n  /**\n   * Executes a function with the given span set as the active span in the context.\n   * This allows child spans created within the function to automatically parent to this span.\n   */\n  withSpan<T>(span: Span, fn: () => T): T\n}\n\ntype NextAttributeNames =\n  | 'next.route'\n  | 'next.page'\n  | 'next.rsc'\n  | 'next.segment'\n  | 'next.span_name'\n  | 'next.span_type'\n  | 'next.clientComponentLoadCount'\ntype OTELAttributeNames = `http.${string}` | `net.${string}`\ntype AttributeNames = NextAttributeNames | OTELAttributeNames\n\n/** we use this map to propagate attributes from nested spans to the top span */\nconst rootSpanAttributesStore = new Map<\n  number,\n  Map<AttributeNames, AttributeValue | undefined>\n>()\nconst rootSpanIdKey = api.createContextKey('next.rootSpanId')\nlet lastSpanId = 0\nconst getSpanId = () => lastSpanId++\n\nexport interface ClientTraceDataEntry {\n  key: string\n  value: string\n}\n\nconst clientTraceDataSetter: TextMapSetter<ClientTraceDataEntry[]> = {\n  set(carrier, key, value) {\n    carrier.push({\n      key,\n      value,\n    })\n  },\n}\n\nclass NextTracerImpl implements NextTracer {\n  /**\n   * Returns an instance to the trace with configured name.\n   * Since wrap / trace can be defined in any place prior to actual trace subscriber initialization,\n   * This should be lazily evaluated.\n   */\n  private getTracerInstance(): Tracer {\n    return trace.getTracer('next.js', '0.0.1')\n  }\n\n  public getContext(): ContextAPI {\n    return context\n  }\n\n  public getTracePropagationData(): ClientTraceDataEntry[] {\n    const activeContext = context.active()\n    const entries: ClientTraceDataEntry[] = []\n    propagation.inject(activeContext, entries, clientTraceDataSetter)\n    return entries\n  }\n\n  public getActiveScopeSpan(): Span | undefined {\n    return trace.getSpan(context?.active())\n  }\n\n  public withPropagatedContext<T, C>(\n    carrier: C,\n    fn: () => T,\n    getter?: TextMapGetter<C>\n  ): T {\n    const activeContext = context.active()\n    if (trace.getSpanContext(activeContext)) {\n      // Active span is already set, too late to propagate.\n      return fn()\n    }\n    const remoteContext = propagation.extract(activeContext, carrier, getter)\n    return context.with(remoteContext, fn)\n  }\n\n  // Trace, wrap implementation is inspired by datadog trace implementation\n  // (https://datadoghq.dev/dd-trace-js/interfaces/tracer.html#trace).\n  public trace<T>(\n    type: SpanTypes,\n    fn: (span?: Span, done?: (error?: Error) => any) => Promise<T>\n  ): Promise<T>\n  public trace<T>(\n    type: SpanTypes,\n    fn: (span?: Span, done?: (error?: Error) => any) => T\n  ): T\n  public trace<T>(\n    type: SpanTypes,\n    options: TracerSpanOptions,\n    fn: (span?: Span, done?: (error?: Error) => any) => Promise<T>\n  ): Promise<T>\n  public trace<T>(\n    type: SpanTypes,\n    options: TracerSpanOptions,\n    fn: (span?: Span, done?: (error?: Error) => any) => T\n  ): T\n  public trace<T>(...args: Array<any>) {\n    const [type, fnOrOptions, fnOrEmpty] = args\n\n    // coerce options form overload\n    const {\n      fn,\n      options,\n    }: {\n      fn: (span?: Span, done?: (error?: Error) => any) => T | Promise<T>\n      options: TracerSpanOptions\n    } =\n      typeof fnOrOptions === 'function'\n        ? {\n            fn: fnOrOptions,\n            options: {},\n          }\n        : {\n            fn: fnOrEmpty,\n            options: { ...fnOrOptions },\n          }\n\n    const spanName = options.spanName ?? type\n\n    if (\n      (!NextVanillaSpanAllowlist.has(type) &&\n        process.env.NEXT_OTEL_VERBOSE !== '1') ||\n      options.hideSpan\n    ) {\n      return fn()\n    }\n\n    // Trying to get active scoped span to assign parent. If option specifies parent span manually, will try to use it.\n    let spanContext = this.getSpanContext(\n      options?.parentSpan ?? this.getActiveScopeSpan()\n    )\n\n    if (!spanContext) {\n      spanContext = context?.active() ?? ROOT_CONTEXT\n    }\n    // Check if there's already a root span in the store for this trace\n    // We are intentionally not checking whether there is an active context\n    // from outside of nextjs to ensure that we can provide the same level\n    // of telemetry when using a custom server\n    const existingRootSpanId = spanContext.getValue(rootSpanIdKey)\n    const isRootSpan =\n      typeof existingRootSpanId !== 'number' ||\n      !rootSpanAttributesStore.has(existingRootSpanId)\n\n    const spanId = getSpanId()\n\n    options.attributes = {\n      'next.span_name': spanName,\n      'next.span_type': type,\n      ...options.attributes,\n    }\n\n    return context.with(spanContext.setValue(rootSpanIdKey, spanId), () =>\n      this.getTracerInstance().startActiveSpan(\n        spanName,\n        options,\n        (span: Span) => {\n          let startTime: number | undefined\n          if (\n            NEXT_OTEL_PERFORMANCE_PREFIX &&\n            type &&\n            LogSpanAllowList.has(type)\n          ) {\n            startTime =\n              'performance' in globalThis && 'measure' in performance\n                ? globalThis.performance.now()\n                : undefined\n          }\n\n          let cleanedUp = false\n          const onCleanup = () => {\n            if (cleanedUp) return\n            cleanedUp = true\n            rootSpanAttributesStore.delete(spanId)\n            if (startTime) {\n              performance.measure(\n                `${NEXT_OTEL_PERFORMANCE_PREFIX}:next-${(\n                  type.split('.').pop() || ''\n                ).replace(\n                  /[A-Z]/g,\n                  (match: string) => '-' + match.toLowerCase()\n                )}`,\n                {\n                  start: startTime,\n                  end: performance.now(),\n                }\n              )\n            }\n          }\n\n          if (isRootSpan) {\n            rootSpanAttributesStore.set(\n              spanId,\n              new Map(\n                Object.entries(options.attributes ?? {}) as [\n                  AttributeNames,\n                  AttributeValue | undefined,\n                ][]\n              )\n            )\n          }\n          if (fn.length > 1) {\n            try {\n              return fn(span, (err) => closeSpanWithError(span, err))\n            } catch (err: any) {\n              closeSpanWithError(span, err)\n              throw err\n            } finally {\n              onCleanup()\n            }\n          }\n\n          try {\n            const result = fn(span)\n            if (isThenable(result)) {\n              // If there's error make sure it throws\n              return result\n                .then((res) => {\n                  span.end()\n                  // Need to pass down the promise result,\n                  // it could be react stream response with error { error, stream }\n                  return res\n                })\n                .catch((err) => {\n                  closeSpanWithError(span, err)\n                  throw err\n                })\n                .finally(onCleanup)\n            } else {\n              span.end()\n              onCleanup()\n            }\n\n            return result\n          } catch (err: any) {\n            closeSpanWithError(span, err)\n            onCleanup()\n            throw err\n          }\n        }\n      )\n    )\n  }\n\n  public wrap<T = (...args: Array<any>) => any>(type: SpanTypes, fn: T): T\n  public wrap<T = (...args: Array<any>) => any>(\n    type: SpanTypes,\n    options: TracerSpanOptions,\n    fn: T\n  ): T\n  public wrap<T = (...args: Array<any>) => any>(\n    type: SpanTypes,\n    options: (...args: any[]) => TracerSpanOptions,\n    fn: T\n  ): T\n  public wrap(...args: Array<any>) {\n    const tracer = this\n    const [name, options, fn] =\n      args.length === 3 ? args : [args[0], {}, args[1]]\n\n    if (\n      !NextVanillaSpanAllowlist.has(name) &&\n      process.env.NEXT_OTEL_VERBOSE !== '1'\n    ) {\n      return fn\n    }\n\n    return function (this: any) {\n      let optionsObj = options\n      if (typeof optionsObj === 'function' && typeof fn === 'function') {\n        optionsObj = optionsObj.apply(this, arguments)\n      }\n\n      const lastArgId = arguments.length - 1\n      const cb = arguments[lastArgId]\n\n      if (typeof cb === 'function') {\n        const scopeBoundCb = tracer.getContext().bind(context.active(), cb)\n        return tracer.trace(name, optionsObj, (_span, done) => {\n          arguments[lastArgId] = function (err: any) {\n            done?.(err)\n            return scopeBoundCb.apply(this, arguments)\n          }\n\n          return fn.apply(this, arguments)\n        })\n      } else {\n        return tracer.trace(name, optionsObj, () => fn.apply(this, arguments))\n      }\n    }\n  }\n\n  public startSpan(type: SpanTypes): Span\n  public startSpan(type: SpanTypes, options: TracerSpanOptions): Span\n  public startSpan(...args: Array<any>): Span {\n    const [type, options]: [string, TracerSpanOptions | undefined] = args as any\n\n    const spanContext = this.getSpanContext(\n      options?.parentSpan ?? this.getActiveScopeSpan()\n    )\n    return this.getTracerInstance().startSpan(type, options, spanContext)\n  }\n\n  private getSpanContext(parentSpan?: Span) {\n    const spanContext = parentSpan\n      ? trace.setSpan(context.active(), parentSpan)\n      : undefined\n\n    return spanContext\n  }\n\n  public getRootSpanAttributes() {\n    const spanId = context.active().getValue(rootSpanIdKey) as number\n    return rootSpanAttributesStore.get(spanId)\n  }\n\n  public setRootSpanAttribute(key: AttributeNames, value: AttributeValue) {\n    const spanId = context.active().getValue(rootSpanIdKey) as number\n    const attributes = rootSpanAttributesStore.get(spanId)\n    if (attributes && !attributes.has(key)) {\n      attributes.set(key, value)\n    }\n  }\n\n  public withSpan<T>(span: Span, fn: () => T): T {\n    const spanContext = trace.setSpan(context.active(), span)\n    return context.with(spanContext, fn)\n  }\n}\n\nconst getTracer = (() => {\n  const tracer = new NextTracerImpl()\n\n  return () => tracer\n})()\n\nexport { getTracer, SpanStatusCode, SpanKind }\nexport type { NextTracer, Span, SpanOptions, ContextAPI, TracerSpanOptions }\n"],"names":["LogSpanAllowList","NextVanillaSpanAllowlist","isThenable","NEXT_OTEL_PERFORMANCE_PREFIX","process","env","api","NEXT_RUNTIME","require","err","context","propagation","trace","SpanStatusCode","SpanKind","ROOT_CONTEXT","BubbledError","Error","constructor","bubble","result","isBubbledError","error","closeSpanWithError","span","setAttribute","recordException","name","setStatus","code","ERROR","message","end","rootSpanAttributesStore","Map","rootSpanIdKey","createContextKey","lastSpanId","getSpanId","clientTraceDataSetter","set","carrier","key","value","push","NextTracerImpl","getTracerInstance","getTracer","getContext","getTracePropagationData","activeContext","active","entries","inject","getActiveScopeSpan","getSpan","withPropagatedContext","fn","getter","getSpanContext","remoteContext","extract","with","args","type","fnOrOptions","fnOrEmpty","options","spanName","has","NEXT_OTEL_VERBOSE","hideSpan","spanContext","parentSpan","existingRootSpanId","getValue","isRootSpan","spanId","attributes","setValue","startActiveSpan","startTime","globalThis","performance","now","undefined","cleanedUp","onCleanup","delete","measure","split","pop","replace","match","toLowerCase","start","Object","length","then","res","catch","finally","wrap","tracer","optionsObj","apply","arguments","lastArgId","cb","scopeBoundCb","bind","_span","done","startSpan","setSpan","getRootSpanAttributes","get","setRootSpanAttribute","withSpan"],"mappings":"AAGA,SAASA,gBAAgB,EAAEC,wBAAwB,QAAQ,cAAa;AAUxE,SAASC,UAAU,QAAQ,kCAAiC;AAE5D,MAAMC,+BAA+BC,QAAQC,GAAG,CAACF,4BAA4B;AAE7E,IAAIG;AAEJ,gFAAgF;AAChF,8EAA8E;AAC9E,uCAAuC;AACvC,0EAA0E;AAC1E,+EAA+E;AAC/E,4CAA4C;AAC5C,6CAA6C;AAC7C,IAAIF,QAAQC,GAAG,CAACE,YAAY,KAAK,QAAQ;IACvCD,MAAME,QAAQ;AAChB,OAAO;IACL,IAAI;QACFF,MAAME,QAAQ;IAChB,EAAE,OAAOC,KAAK;QACZH,MACEE,QAAQ;IACZ;AACF;AAEA,MAAM,EAAEE,OAAO,EAAEC,WAAW,EAAEC,KAAK,EAAEC,cAAc,EAAEC,QAAQ,EAAEC,YAAY,EAAE,GAC3ET;AAEF,OAAO,MAAMU,qBAAqBC;IAChCC,YACE,AAAgBC,MAAgB,EAChC,AAAgBC,MAAyB,CACzC;QACA,KAAK,SAHWD,SAAAA,aACAC,SAAAA;IAGlB;AACF;AAEA,OAAO,SAASC,eAAeC,KAAc;IAC3C,IAAI,OAAOA,UAAU,YAAYA,UAAU,MAAM,OAAO;IACxD,OAAOA,iBAAiBN;AAC1B;AAEA,MAAMO,qBAAqB,CAACC,MAAYF;IACtC,IAAID,eAAeC,UAAUA,MAAMH,MAAM,EAAE;QACzCK,KAAKC,YAAY,CAAC,eAAe;IACnC,OAAO;QACL,IAAIH,OAAO;YACTE,KAAKE,eAAe,CAACJ;YACrBE,KAAKC,YAAY,CAAC,cAAcH,MAAMK,IAAI;QAC5C;QACAH,KAAKI,SAAS,CAAC;YAAEC,MAAMhB,eAAeiB,KAAK;YAAEC,OAAO,EAAET,yBAAAA,MAAOS,OAAO;QAAC;IACvE;IACAP,KAAKQ,GAAG;AACV;AAiHA,8EAA8E,GAC9E,MAAMC,0BAA0B,IAAIC;AAIpC,MAAMC,gBAAgB7B,IAAI8B,gBAAgB,CAAC;AAC3C,IAAIC,aAAa;AACjB,MAAMC,YAAY,IAAMD;AAOxB,MAAME,wBAA+D;IACnEC,KAAIC,OAAO,EAAEC,GAAG,EAAEC,KAAK;QACrBF,QAAQG,IAAI,CAAC;YACXF;YACAC;QACF;IACF;AACF;AAEA,MAAME;IACJ;;;;GAIC,GACD,AAAQC,oBAA4B;QAClC,OAAOlC,MAAMmC,SAAS,CAAC,WAAW;IACpC;IAEOC,aAAyB;QAC9B,OAAOtC;IACT;IAEOuC,0BAAkD;QACvD,MAAMC,gBAAgBxC,QAAQyC,MAAM;QACpC,MAAMC,UAAkC,EAAE;QAC1CzC,YAAY0C,MAAM,CAACH,eAAeE,SAASb;QAC3C,OAAOa;IACT;IAEOE,qBAAuC;QAC5C,OAAO1C,MAAM2C,OAAO,CAAC7C,2BAAAA,QAASyC,MAAM;IACtC;IAEOK,sBACLf,OAAU,EACVgB,EAAW,EACXC,MAAyB,EACtB;QACH,MAAMR,gBAAgBxC,QAAQyC,MAAM;QACpC,IAAIvC,MAAM+C,cAAc,CAACT,gBAAgB;YACvC,qDAAqD;YACrD,OAAOO;QACT;QACA,MAAMG,gBAAgBjD,YAAYkD,OAAO,CAACX,eAAeT,SAASiB;QAClE,OAAOhD,QAAQoD,IAAI,CAACF,eAAeH;IACrC;IAsBO7C,MAAS,GAAGmD,IAAgB,EAAE;QACnC,MAAM,CAACC,MAAMC,aAAaC,UAAU,GAAGH;QAEvC,+BAA+B;QAC/B,MAAM,EACJN,EAAE,EACFU,OAAO,EACR,GAIC,OAAOF,gBAAgB,aACnB;YACER,IAAIQ;YACJE,SAAS,CAAC;QACZ,IACA;YACEV,IAAIS;YACJC,SAAS;gBAAE,GAAGF,WAAW;YAAC;QAC5B;QAEN,MAAMG,WAAWD,QAAQC,QAAQ,IAAIJ;QAErC,IACE,AAAC,CAAC/D,yBAAyBoE,GAAG,CAACL,SAC7B5D,QAAQC,GAAG,CAACiE,iBAAiB,KAAK,OACpCH,QAAQI,QAAQ,EAChB;YACA,OAAOd;QACT;QAEA,mHAAmH;QACnH,IAAIe,cAAc,IAAI,CAACb,cAAc,CACnCQ,CAAAA,2BAAAA,QAASM,UAAU,KAAI,IAAI,CAACnB,kBAAkB;QAGhD,IAAI,CAACkB,aAAa;YAChBA,cAAc9D,CAAAA,2BAAAA,QAASyC,MAAM,OAAMpC;QACrC;QACA,mEAAmE;QACnE,uEAAuE;QACvE,sEAAsE;QACtE,0CAA0C;QAC1C,MAAM2D,qBAAqBF,YAAYG,QAAQ,CAACxC;QAChD,MAAMyC,aACJ,OAAOF,uBAAuB,YAC9B,CAACzC,wBAAwBoC,GAAG,CAACK;QAE/B,MAAMG,SAASvC;QAEf6B,QAAQW,UAAU,GAAG;YACnB,kBAAkBV;YAClB,kBAAkBJ;YAClB,GAAGG,QAAQW,UAAU;QACvB;QAEA,OAAOpE,QAAQoD,IAAI,CAACU,YAAYO,QAAQ,CAAC5C,eAAe0C,SAAS,IAC/D,IAAI,CAAC/B,iBAAiB,GAAGkC,eAAe,CACtCZ,UACAD,SACA,CAAC3C;gBACC,IAAIyD;gBACJ,IACE9E,gCACA6D,QACAhE,iBAAiBqE,GAAG,CAACL,OACrB;oBACAiB,YACE,iBAAiBC,cAAc,aAAaC,cACxCD,WAAWC,WAAW,CAACC,GAAG,KAC1BC;gBACR;gBAEA,IAAIC,YAAY;gBAChB,MAAMC,YAAY;oBAChB,IAAID,WAAW;oBACfA,YAAY;oBACZrD,wBAAwBuD,MAAM,CAACX;oBAC/B,IAAII,WAAW;wBACbE,YAAYM,OAAO,CACjB,GAAGtF,6BAA6B,MAAM,EAAE,AACtC6D,CAAAA,KAAK0B,KAAK,CAAC,KAAKC,GAAG,MAAM,EAAC,EAC1BC,OAAO,CACP,UACA,CAACC,QAAkB,MAAMA,MAAMC,WAAW,KACzC,EACH;4BACEC,OAAOd;4BACPjD,KAAKmD,YAAYC,GAAG;wBACtB;oBAEJ;gBACF;gBAEA,IAAIR,YAAY;oBACd3C,wBAAwBO,GAAG,CACzBqC,QACA,IAAI3C,IACF8D,OAAO5C,OAAO,CAACe,QAAQW,UAAU,IAAI,CAAC;gBAM5C;gBACA,IAAIrB,GAAGwC,MAAM,GAAG,GAAG;oBACjB,IAAI;wBACF,OAAOxC,GAAGjC,MAAM,CAACf,MAAQc,mBAAmBC,MAAMf;oBACpD,EAAE,OAAOA,KAAU;wBACjBc,mBAAmBC,MAAMf;wBACzB,MAAMA;oBACR,SAAU;wBACR8E;oBACF;gBACF;gBAEA,IAAI;oBACF,MAAMnE,SAASqC,GAAGjC;oBAClB,IAAItB,WAAWkB,SAAS;wBACtB,uCAAuC;wBACvC,OAAOA,OACJ8E,IAAI,CAAC,CAACC;4BACL3E,KAAKQ,GAAG;4BACR,wCAAwC;4BACxC,iEAAiE;4BACjE,OAAOmE;wBACT,GACCC,KAAK,CAAC,CAAC3F;4BACNc,mBAAmBC,MAAMf;4BACzB,MAAMA;wBACR,GACC4F,OAAO,CAACd;oBACb,OAAO;wBACL/D,KAAKQ,GAAG;wBACRuD;oBACF;oBAEA,OAAOnE;gBACT,EAAE,OAAOX,KAAU;oBACjBc,mBAAmBC,MAAMf;oBACzB8E;oBACA,MAAM9E;gBACR;YACF;IAGN;IAaO6F,KAAK,GAAGvC,IAAgB,EAAE;QAC/B,MAAMwC,SAAS,IAAI;QACnB,MAAM,CAAC5E,MAAMwC,SAASV,GAAG,GACvBM,KAAKkC,MAAM,KAAK,IAAIlC,OAAO;YAACA,IAAI,CAAC,EAAE;YAAE,CAAC;YAAGA,IAAI,CAAC,EAAE;SAAC;QAEnD,IACE,CAAC9D,yBAAyBoE,GAAG,CAAC1C,SAC9BvB,QAAQC,GAAG,CAACiE,iBAAiB,KAAK,KAClC;YACA,OAAOb;QACT;QAEA,OAAO;YACL,IAAI+C,aAAarC;YACjB,IAAI,OAAOqC,eAAe,cAAc,OAAO/C,OAAO,YAAY;gBAChE+C,aAAaA,WAAWC,KAAK,CAAC,IAAI,EAAEC;YACtC;YAEA,MAAMC,YAAYD,UAAUT,MAAM,GAAG;YACrC,MAAMW,KAAKF,SAAS,CAACC,UAAU;YAE/B,IAAI,OAAOC,OAAO,YAAY;gBAC5B,MAAMC,eAAeN,OAAOvD,UAAU,GAAG8D,IAAI,CAACpG,QAAQyC,MAAM,IAAIyD;gBAChE,OAAOL,OAAO3F,KAAK,CAACe,MAAM6E,YAAY,CAACO,OAAOC;oBAC5CN,SAAS,CAACC,UAAU,GAAG,SAAUlG,GAAQ;wBACvCuG,wBAAAA,KAAOvG;wBACP,OAAOoG,aAAaJ,KAAK,CAAC,IAAI,EAAEC;oBAClC;oBAEA,OAAOjD,GAAGgD,KAAK,CAAC,IAAI,EAAEC;gBACxB;YACF,OAAO;gBACL,OAAOH,OAAO3F,KAAK,CAACe,MAAM6E,YAAY,IAAM/C,GAAGgD,KAAK,CAAC,IAAI,EAAEC;YAC7D;QACF;IACF;IAIOO,UAAU,GAAGlD,IAAgB,EAAQ;QAC1C,MAAM,CAACC,MAAMG,QAAQ,GAA4CJ;QAEjE,MAAMS,cAAc,IAAI,CAACb,cAAc,CACrCQ,CAAAA,2BAAAA,QAASM,UAAU,KAAI,IAAI,CAACnB,kBAAkB;QAEhD,OAAO,IAAI,CAACR,iBAAiB,GAAGmE,SAAS,CAACjD,MAAMG,SAASK;IAC3D;IAEQb,eAAec,UAAiB,EAAE;QACxC,MAAMD,cAAcC,aAChB7D,MAAMsG,OAAO,CAACxG,QAAQyC,MAAM,IAAIsB,cAChCY;QAEJ,OAAOb;IACT;IAEO2C,wBAAwB;QAC7B,MAAMtC,SAASnE,QAAQyC,MAAM,GAAGwB,QAAQ,CAACxC;QACzC,OAAOF,wBAAwBmF,GAAG,CAACvC;IACrC;IAEOwC,qBAAqB3E,GAAmB,EAAEC,KAAqB,EAAE;QACtE,MAAMkC,SAASnE,QAAQyC,MAAM,GAAGwB,QAAQ,CAACxC;QACzC,MAAM2C,aAAa7C,wBAAwBmF,GAAG,CAACvC;QAC/C,IAAIC,cAAc,CAACA,WAAWT,GAAG,CAAC3B,MAAM;YACtCoC,WAAWtC,GAAG,CAACE,KAAKC;QACtB;IACF;IAEO2E,SAAY9F,IAAU,EAAEiC,EAAW,EAAK;QAC7C,MAAMe,cAAc5D,MAAMsG,OAAO,CAACxG,QAAQyC,MAAM,IAAI3B;QACpD,OAAOd,QAAQoD,IAAI,CAACU,aAAaf;IACnC;AACF;AAEA,MAAMV,YAAY,AAAC,CAAA;IACjB,MAAMwD,SAAS,IAAI1D;IAEnB,OAAO,IAAM0D;AACf,CAAA;AAEA,SAASxD,SAAS,EAAElC,cAAc,EAAEC,QAAQ,GAAE","ignoreList":[0]}