{"version":3,"file":"session.js","names":["dialect: MsSqlDialect","parts: string[]","schema: V1.RelationalSchemaConfig<TSchema> | undefined","nestedIndex: number"],"sources":["../../src/mssql-core/session.ts"],"sourcesContent":["import type * as V1 from '~/_relations.ts';\nimport { entityKind } from '~/entity.ts';\nimport { TransactionRollbackError } from '~/errors.ts';\nimport { type Query, type SQL, sql } from '~/sql/sql.ts';\nimport type { Assume, Equal } from '~/utils.ts';\nimport { MsSqlDatabase } from './db.ts';\nimport type { MsSqlDialect } from './dialect.ts';\nimport type { SelectedFieldsOrdered } from './query-builders/select.types.ts';\n\nexport interface QueryResultHKT {\n\treadonly $brand: 'MsSqlQueryRowHKT';\n\treadonly row: unknown;\n\treadonly type: unknown;\n}\n\nexport interface AnyQueryResultHKT extends QueryResultHKT {\n\treadonly type: any;\n}\n\nexport type QueryResultKind<TKind extends QueryResultHKT, TRow> = (TKind & {\n\treadonly row: TRow;\n})['type'];\n\nexport interface PreparedQueryConfig {\n\texecute: unknown;\n\titerator: unknown;\n}\n\nexport interface PreparedQueryHKT {\n\treadonly $brand: 'MsSqlPreparedQueryHKT';\n\treadonly config: unknown;\n\treadonly type: unknown;\n}\n\nexport type PreparedQueryKind<\n\tTKind extends PreparedQueryHKT,\n\tTConfig extends PreparedQueryConfig,\n\tTAssume extends boolean = false,\n> = Equal<TAssume, true> extends true ? Assume<(TKind & { readonly config: TConfig })['type'], PreparedQuery<TConfig>>\n\t: (TKind & { readonly config: TConfig })['type'];\n\nexport abstract class PreparedQuery<T extends PreparedQueryConfig> {\n\tstatic readonly [entityKind]: string = 'MsSqlPreparedQuery';\n\n\t/** @internal */\n\tjoinsNotNullableMap?: Record<string, boolean>;\n\n\tabstract execute(placeholderValues?: Record<string, unknown>): Promise<T['execute']>;\n\n\tabstract iterator(placeholderValues?: Record<string, unknown>): AsyncGenerator<T['iterator']>;\n}\n\nexport interface MsSqlTransactionConfig {\n\tisolationLevel: 'read uncommitted' | 'read committed' | 'repeatable read' | 'serializable' | 'snapshot';\n}\n\nexport abstract class MsSqlSession<\n\tTQueryResult extends QueryResultHKT = QueryResultHKT,\n\tTPreparedQueryHKT extends PreparedQueryHKTBase = PreparedQueryHKTBase,\n\tTFullSchema extends Record<string, unknown> = Record<string, never>,\n\tTSchema extends V1.TablesRelationalConfig = Record<string, never>,\n> {\n\tstatic readonly [entityKind]: string = 'MsSqlSession';\n\n\tconstructor(protected dialect: MsSqlDialect) {}\n\n\tabstract prepareQuery<T extends PreparedQueryConfig, TPreparedQueryHKT extends PreparedQueryHKT>(\n\t\tquery: Query,\n\t\tfields: SelectedFieldsOrdered | undefined,\n\t\tcustomResultMapper?: (rows: unknown[][]) => T['execute'],\n\t): PreparedQueryKind<TPreparedQueryHKT, T>;\n\n\texecute<T>(query: SQL): Promise<T> {\n\t\treturn this.prepareQuery<PreparedQueryConfig & { execute: T }, PreparedQueryHKTBase>(\n\t\t\tthis.dialect.sqlToQuery(query),\n\t\t\tundefined,\n\t\t).execute();\n\t}\n\n\tabstract all<T = unknown>(query: SQL): Promise<T[]>;\n\n\tabstract transaction<T>(\n\t\ttransaction: (tx: MsSqlTransaction<TQueryResult, TPreparedQueryHKT, TFullSchema, TSchema>) => Promise<T>,\n\t\tconfig?: MsSqlTransactionConfig,\n\t): Promise<T>;\n\n\tprotected getSetTransactionSQL(config: MsSqlTransactionConfig): SQL | undefined {\n\t\tconst parts: string[] = [];\n\n\t\tif (config.isolationLevel) {\n\t\t\tparts.push(`isolation level ${config.isolationLevel}`);\n\t\t}\n\n\t\treturn parts.length ? sql.join(['set transaction ', parts.join(' ')]) : undefined;\n\t}\n\n\tprotected getStartTransactionSQL(_config: MsSqlTransactionConfig): SQL | undefined {\n\t\treturn sql`begin transaction`;\n\t}\n}\n\nexport abstract class MsSqlTransaction<\n\tTQueryResult extends QueryResultHKT,\n\tTPreparedQueryHKT extends PreparedQueryHKTBase,\n\tTFullSchema extends Record<string, unknown> = Record<string, never>,\n\tTSchema extends V1.TablesRelationalConfig = Record<string, never>,\n> extends MsSqlDatabase<TQueryResult, TPreparedQueryHKT, TFullSchema, TSchema> {\n\tstatic override readonly [entityKind]: string = 'MsSqlTransaction';\n\n\tconstructor(\n\t\tdialect: MsSqlDialect,\n\t\tsession: MsSqlSession,\n\t\tprotected schema: V1.RelationalSchemaConfig<TSchema> | undefined,\n\t\tprotected readonly nestedIndex: number,\n\t) {\n\t\tsuper(dialect, session, schema);\n\t}\n\n\trollback(): never {\n\t\tthrow new TransactionRollbackError();\n\t}\n\n\t/** Nested transactions (aka savepoints) only work with InnoDB engine. */\n\tabstract override transaction<T>(\n\t\ttransaction: (tx: MsSqlTransaction<TQueryResult, TPreparedQueryHKT, TFullSchema, TSchema>) => Promise<T>,\n\t): Promise<T>;\n}\n\nexport interface PreparedQueryHKTBase extends PreparedQueryHKT {\n\ttype: PreparedQuery<Assume<this['config'], PreparedQueryConfig>>;\n}\n"],"mappings":";;;;;;AAyCA,IAAsB,gBAAtB,MAAmE;CAClE,QAAiB,cAAsB;;CAGvC;;AAWD,IAAsB,eAAtB,MAKE;CACD,QAAiB,cAAsB;CAEvC,YAAY,AAAUA,SAAuB;EAAvB;;CAQtB,QAAW,OAAwB;AAClC,SAAO,KAAK,aACX,KAAK,QAAQ,WAAW,MAAM,EAC9B,OACA,CAAC,SAAS;;CAUZ,AAAU,qBAAqB,QAAiD;EAC/E,MAAMC,QAAkB,EAAE;AAE1B,MAAI,OAAO,eACV,OAAM,KAAK,mBAAmB,OAAO,iBAAiB;AAGvD,SAAO,MAAM,SAAS,IAAI,KAAK,CAAC,oBAAoB,MAAM,KAAK,IAAI,CAAC,CAAC,GAAG;;CAGzE,AAAU,uBAAuB,SAAkD;AAClF,SAAO,GAAG;;;AAIZ,IAAsB,mBAAtB,cAKU,cAAqE;CAC9E,QAA0B,cAAsB;CAEhD,YACC,SACA,SACA,AAAUC,QACV,AAAmBC,aAClB;AACD,QAAM,SAAS,SAAS,OAAO;EAHrB;EACS;;CAKpB,WAAkB;AACjB,QAAM,IAAI,0BAA0B"}