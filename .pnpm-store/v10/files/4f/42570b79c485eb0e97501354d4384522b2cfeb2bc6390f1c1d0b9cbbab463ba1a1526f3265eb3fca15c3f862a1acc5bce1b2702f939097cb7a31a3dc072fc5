{"version":3,"file":"relations.js","names":["reverseRelation: Relation | undefined","targetTableName: TTargetTableName","config: AnyManyConfig | undefined","one: Record<string, OneFn<TTables[string], string>>","many: Record<string, ManyFn<TTables[string], string>>","acc","parts: (SQL)[]","parts: SQL[]","filter","subqueries: SQL[]","selection: BuildRelationalQueryResult['selection']"],"sources":["../src/relations.ts"],"sourcesContent":["import { IsAlias, OriginalName, Table, TableColumns, TableSchema } from '~/table.ts';\nimport { aliasedTable } from './alias.ts';\nimport type { CasingCache } from './casing.ts';\nimport { type AnyColumn, Column } from './column.ts';\nimport { entityKind, is } from './entity.ts';\nimport { DrizzleError } from './errors.ts';\nimport {\n\tand,\n\tarrayContained,\n\tarrayContains,\n\tarrayOverlaps,\n\tasc,\n\tbetween,\n\tdesc,\n\teq,\n\texists,\n\tgt,\n\tgte,\n\tilike,\n\tinArray,\n\tisNotNull,\n\tisNull,\n\tlike,\n\tlt,\n\tlte,\n\tne,\n\tnot,\n\tnotBetween,\n\tnotExists,\n\tnotIlike,\n\tnotInArray,\n\tnotLike,\n\tor,\n} from './sql/expressions/index.ts';\nimport { noopDecoder, Placeholder, SQL, sql, type SQLWrapper, View } from './sql/sql.ts';\nimport type { Assume, DrizzleTypeError, Equal, Simplify, ValueOrArray } from './utils.ts';\n\nexport type FilteredSchemaEntry = Table<any> | View<string, boolean, FieldSelection>;\n\nexport type SchemaEntry = Table<any> | View<string, boolean, any>;\n\nexport type Schema = Record<string, SchemaEntry>;\n\nexport type GetTableViewColumns<T extends SchemaEntry> = T extends View<string, boolean, any> ? T['_']['selectedFields']\n\t: T extends Table<any> ? T['_']['columns']\n\t: never;\n\nexport type GetTableViewFieldSelection<T extends SchemaEntry> = T extends View<string, boolean, FieldSelection>\n\t? T['_']['selectedFields']\n\t: T extends Table<any> ? T['_']['columns']\n\t: never;\n\nexport type FieldValue =\n\t| Column<any>\n\t| SQLWrapper\n\t| SQL.Aliased\n\t| SQL;\n\nexport type FieldSelection = Record<string, FieldValue>;\n\nexport function processRelations(tablesConfig: TablesRelationalConfig, tables: Schema) {\n\tfor (const tableConfig of Object.values(tablesConfig)) {\n\t\tfor (const [relationFieldName, relation] of Object.entries(tableConfig.relations)) {\n\t\t\tif (!is(relation, Relation)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\trelation.sourceTable = tableConfig.table;\n\t\t\trelation.fieldName = relationFieldName;\n\t\t}\n\t}\n\n\tfor (const [sourceTableName, tableConfig] of Object.entries(tablesConfig)) {\n\t\tfor (const [relationFieldName, relation] of Object.entries(tableConfig.relations)) {\n\t\t\tif (!is(relation, Relation)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tlet reverseRelation: Relation | undefined;\n\t\t\tconst {\n\t\t\t\ttargetTableName,\n\t\t\t\talias,\n\t\t\t\tsourceColumns,\n\t\t\t\ttargetColumns,\n\t\t\t\tthroughTable,\n\t\t\t\tsourceTable,\n\t\t\t\tthrough,\n\t\t\t\ttargetTable,\n\t\t\t\twhere,\n\t\t\t\tsourceColumnTableNames,\n\t\t\t\ttargetColumnTableNames,\n\t\t\t} = relation;\n\t\t\tconst relationPrintName = `relations -> ${tableConfig.name}: { ${relationFieldName}: r.${\n\t\t\t\tis(relation, One) ? 'one' : 'many'\n\t\t\t}.${targetTableName}(...) }`;\n\n\t\t\tif (relationFieldName in tableConfig.table[TableColumns]) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`${relationPrintName}: relation name collides with column \"${relationFieldName}\" of table \"${tableConfig.name}\"`,\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tif (typeof alias === 'string' && !alias) {\n\t\t\t\tthrow new Error(`${relationPrintName}: \"alias\" cannot be an empty string - omit it if you don't need it`);\n\t\t\t}\n\n\t\t\tif (sourceColumns?.length === 0) {\n\t\t\t\tthrow new Error(`${relationPrintName}: \"from\" cannot be empty`);\n\t\t\t}\n\n\t\t\tif (targetColumns?.length === 0) {\n\t\t\t\tthrow new Error(`${relationPrintName}: \"to\" cannot be empty`);\n\t\t\t}\n\n\t\t\tif (sourceColumns && targetColumns) {\n\t\t\t\tif (sourceColumns.length !== targetColumns.length && !throughTable) {\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t`${relationPrintName}: \"from\" and \"to\" fields without \"through\" must have the same length`,\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tfor (const sName of sourceColumnTableNames) {\n\t\t\t\t\tif (sName !== sourceTableName) {\n\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t`${relationPrintName}: all \"from\" columns must belong to table \"${sourceTableName}\", found column of table \"${sName}\"`,\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (const tName of targetColumnTableNames) {\n\t\t\t\t\tif (tName !== targetTableName) {\n\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t`${relationPrintName}: all \"to\" columns must belong to table \"${targetTable}\", found column of table \"${tName}\"`,\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (through) {\n\t\t\t\t\tif (\n\t\t\t\t\t\tthrough.source.length !== sourceColumns.length\n\t\t\t\t\t\t|| through.target.length !== targetColumns.length\n\t\t\t\t\t) {\n\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t`${relationPrintName}: \".through(column)\" must be used either on all columns in \"from\" and \"to\" or not defined on any of them`,\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\n\t\t\t\t\tfor (const column of through.source) {\n\t\t\t\t\t\tif (tables[column._.tableName] !== throughTable) {\n\t\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t\t`${relationPrintName}: \".through(column)\" must be used on the same table by all columns of the relation`,\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tfor (const column of through.target) {\n\t\t\t\t\t\tif (tables[column._.tableName] !== throughTable) {\n\t\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t\t`${relationPrintName}: \".through(column)\" must be used on the same table by all columns of the relation`,\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (sourceColumns || targetColumns) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`${relationPrintName}: relation must have either both \"from\" and \"to\" defined, or none of them`,\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tconst reverseTableConfig = tablesConfig[targetTableName];\n\t\t\tif (!reverseTableConfig) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`${relationPrintName}: not enough data provided to build the relation - \"from\"/\"to\" are not defined, and no reverse relations of table \"${targetTableName}\" were found\"`,\n\t\t\t\t);\n\t\t\t}\n\t\t\tif (alias) {\n\t\t\t\tconst reverseRelations = Object.values(reverseTableConfig.relations).filter((it): it is Relation =>\n\t\t\t\t\tis(it, Relation) && it.alias === alias && it !== relation\n\t\t\t\t);\n\t\t\t\tif (reverseRelations.length > 1) {\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t`${relationPrintName}: not enough data provided to build the relation - \"from\"/\"to\" are not defined, and multiple relations with alias \"${alias}\" found in table \"${targetTableName}\": ${\n\t\t\t\t\t\t\treverseRelations.map((it) => `\"${it.fieldName}\"`).join(', ')\n\t\t\t\t\t\t}`,\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\treverseRelation = reverseRelations[0];\n\t\t\t\tif (!reverseRelation) {\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t`${relationPrintName}: not enough data provided to build the relation - \"from\"/\"to\" are not defined, and there is no reverse relation of table \"${targetTableName}\" with alias \"${alias}\"`,\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconst reverseRelations = Object.values(reverseTableConfig.relations).filter((it): it is Relation =>\n\t\t\t\t\tis(it, Relation) && it.targetTable === sourceTable && !it.alias && it !== relation\n\t\t\t\t);\n\t\t\t\tif (reverseRelations.length > 1) {\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t`${relationPrintName}: not enough data provided to build the relation - \"from\"/\"to\" are not defined, and multiple relations between \"${targetTableName}\" and \"${sourceTableName}\" were found.\\nHint: you can specify \"alias\" on both sides of the relation with the same value`,\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\treverseRelation = reverseRelations[0];\n\t\t\t\tif (!reverseRelation) {\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t`${relationPrintName}: not enough data provided to build the relation - \"from\"/\"to\" are not defined, and no reverse relation of table \"${targetTableName}\" with target table \"${sourceTableName}\" was found`,\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!reverseRelation.sourceColumns || !reverseRelation.targetColumns) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`${relationPrintName}: not enough data provided to build the relation - \"from\"/\"to\" are not defined, and reverse relation \"${targetTableName}.${reverseRelation.fieldName}\" does not have \"from\"/\"to\" defined`,\n\t\t\t\t);\n\t\t\t}\n\n\t\t\trelation.sourceColumns = reverseRelation.targetColumns;\n\t\t\trelation.targetColumns = reverseRelation.sourceColumns;\n\t\t\trelation.through = reverseRelation.through\n\t\t\t\t? {\n\t\t\t\t\tsource: reverseRelation.through.target,\n\t\t\t\t\ttarget: reverseRelation.through.source,\n\t\t\t\t}\n\t\t\t\t: undefined;\n\t\t\trelation.throughTable = reverseRelation.throughTable;\n\t\t\trelation.isReversed = !where;\n\t\t\trelation.where = where ?? reverseRelation.where;\n\t\t}\n\t}\n\n\treturn tablesConfig;\n}\n\n/** Builds relational config for every table in schema */\nexport function buildRelations<TTables extends Schema, TConfig extends AnyRelationsBuilderConfig>(\n\ttables: TTables,\n\tconfig: TConfig,\n): ExtractTablesWithRelations<TConfig, TTables> {\n\tconst tablesConfig = {} as TablesRelationalConfig;\n\n\tfor (const [tsName, table] of Object.entries(tables)) {\n\t\ttablesConfig[tsName] = {\n\t\t\ttable,\n\t\t\tname: tsName,\n\t\t\trelations: config[tsName] ?? {},\n\t\t};\n\t}\n\n\treturn processRelations(tablesConfig, tables) as any;\n}\n\n/** Builds relational config only for tables present in relational config */\nexport function buildRelationsParts<TTables extends Schema, TConfig extends AnyRelationsBuilderConfig>(\n\ttables: TTables,\n\tconfig: TConfig,\n): ExtractTablesWithRelationsParts<TConfig, TTables> {\n\tconst tablesConfig = {} as TablesRelationalConfig;\n\n\tfor (const [tsName, relations] of Object.entries(config)) {\n\t\tif (!relations || !tables[tsName]) continue;\n\t\ttablesConfig[tsName] = {\n\t\t\ttable: tables[tsName],\n\t\t\tname: tsName,\n\t\t\trelations,\n\t\t};\n\t}\n\n\treturn processRelations(tablesConfig, tables) as any;\n}\n\nexport type RelationsRecord = Record<string, AnyRelation>;\nexport type EmptyRelations = {};\nexport type AnyRelations = TablesRelationalConfig;\n\nexport abstract class Relation<\n\tTTargetTableName extends string = string,\n> {\n\tstatic readonly [entityKind]: string = 'RelationV2';\n\tdeclare readonly $brand: 'RelationV2';\n\tdeclare public readonly relationType: 'many' | 'one';\n\n\tfieldName!: string;\n\tsourceColumns!: Column<any>[];\n\ttargetColumns!: Column<any>[];\n\talias: string | undefined;\n\twhere: AnyTableFilter | undefined;\n\tsourceTable!: SchemaEntry;\n\ttargetTable: SchemaEntry;\n\tthrough?: {\n\t\tsource: RelationsBuilderColumnBase[];\n\t\ttarget: RelationsBuilderColumnBase[];\n\t};\n\tthroughTable?: SchemaEntry;\n\tisReversed?: boolean;\n\n\t/** @internal */\n\tsourceColumnTableNames: string[] = [];\n\t/** @internal */\n\ttargetColumnTableNames: string[] = [];\n\n\tconstructor(\n\t\ttargetTable: SchemaEntry,\n\t\treadonly targetTableName: TTargetTableName,\n\t) {\n\t\tthis.targetTable = targetTable;\n\t}\n}\n\nexport type AnyRelation = Relation<string>;\n\nexport class One<\n\tTTargetTableName extends string,\n\tTOptional extends boolean = boolean,\n> extends Relation<TTargetTableName> {\n\tstatic override readonly [entityKind]: string = 'OneV2';\n\tdeclare protected $relationBrand: 'OneV2';\n\n\tpublic override readonly relationType = 'one' as const;\n\n\treadonly optional: TOptional;\n\n\tconstructor(\n\t\ttables: Schema,\n\t\ttargetTable: SchemaEntry,\n\t\ttargetTableName: TTargetTableName,\n\t\tconfig: AnyOneConfig | undefined,\n\t) {\n\t\tsuper(targetTable, targetTableName);\n\t\tthis.alias = config?.alias;\n\t\tthis.where = config?.where;\n\t\tif (config?.from) {\n\t\t\tthis.sourceColumns = ((Array.isArray(config.from)\n\t\t\t\t? config.from\n\t\t\t\t: [config.from]) as RelationsBuilderColumnBase[]).map((it: RelationsBuilderColumnBase) => {\n\t\t\t\t\tthis.throughTable ??= it._.through ? tables[it._.through._.tableName]! as SchemaEntry : undefined;\n\t\t\t\t\tthis.sourceColumnTableNames.push(it._.tableName);\n\t\t\t\t\treturn it._.column as Column;\n\t\t\t\t});\n\t\t}\n\t\tif (config?.to) {\n\t\t\tthis.targetColumns = (Array.isArray(config.to)\n\t\t\t\t? config.to\n\t\t\t\t: [config.to]).map((it: RelationsBuilderColumnBase) => {\n\t\t\t\t\tthis.throughTable ??= it._.through ? tables[it._.through._.tableName]! as SchemaEntry : undefined;\n\t\t\t\t\tthis.targetColumnTableNames.push(it._.tableName);\n\t\t\t\t\treturn it._.column as Column;\n\t\t\t\t});\n\t\t}\n\n\t\tif (this.throughTable) {\n\t\t\tthis.through = {\n\t\t\t\tsource: (Array.isArray(config?.from) ? config.from : config?.from ? [config.from] : []).map((\n\t\t\t\t\tc,\n\t\t\t\t) => c._.through!),\n\t\t\t\ttarget: (Array.isArray(config?.to) ? config.to : config?.to ? [config.to] : []).map((c) => c._.through!),\n\t\t\t};\n\t\t}\n\t\tthis.optional = (config?.optional ?? true) as TOptional;\n\t}\n}\n\nexport type AnyOne = One<string, boolean>;\n\nexport class Many<TTargetTableName extends string> extends Relation<TTargetTableName> {\n\tstatic override readonly [entityKind]: string = 'ManyV2';\n\tdeclare protected $relationBrand: 'ManyV2';\n\n\tpublic override readonly relationType = 'many' as const;\n\n\tconstructor(\n\t\ttables: Schema,\n\t\ttargetTable: SchemaEntry,\n\t\ttargetTableName: TTargetTableName,\n\t\treadonly config: AnyManyConfig | undefined,\n\t) {\n\t\tsuper(targetTable, targetTableName);\n\t\tthis.alias = config?.alias;\n\t\tthis.where = config?.where;\n\t\tif (config?.from) {\n\t\t\tthis.sourceColumns = ((Array.isArray(config.from)\n\t\t\t\t? config.from\n\t\t\t\t: [config.from]) as RelationsBuilderColumnBase[]).map((it: RelationsBuilderColumnBase) => {\n\t\t\t\t\tthis.throughTable ??= it._.through ? tables[it._.through._.tableName]! as SchemaEntry : undefined;\n\t\t\t\t\tthis.sourceColumnTableNames.push(it._.tableName);\n\t\t\t\t\treturn it._.column as Column;\n\t\t\t\t});\n\t\t}\n\t\tif (config?.to) {\n\t\t\tthis.targetColumns = (Array.isArray(config.to)\n\t\t\t\t? config.to\n\t\t\t\t: [config.to]).map((it: RelationsBuilderColumnBase) => {\n\t\t\t\t\tthis.throughTable ??= it._.through ? tables[it._.through._.tableName]! as SchemaEntry : undefined;\n\t\t\t\t\tthis.targetColumnTableNames.push(it._.tableName);\n\t\t\t\t\treturn it._.column as Column;\n\t\t\t\t});\n\t\t}\n\t\tif (this.throughTable) {\n\t\t\tthis.through = {\n\t\t\t\tsource: (Array.isArray(config?.from) ? config.from : config?.from ? [config.from] : []).map((\n\t\t\t\t\tc,\n\t\t\t\t) => c._.through!),\n\t\t\t\ttarget: (Array.isArray(config?.to) ? config.to : config?.to ? [config.to] : []).map((c) => c._.through!),\n\t\t\t};\n\t\t}\n\t}\n}\n\nexport type AnyMany = Many<string>;\n\nexport abstract class AggregatedField<T = unknown> implements SQLWrapper<T> {\n\tstatic readonly [entityKind]: string = 'AggregatedField';\n\n\tdeclare readonly $brand: 'AggregatedField';\n\n\tdeclare readonly _: {\n\t\treadonly data: T;\n\t};\n\n\tprotected table: SchemaEntry | undefined;\n\n\tonTable(table: SchemaEntry) {\n\t\tthis.table = table;\n\n\t\treturn this;\n\t}\n\n\tabstract getSQL(): SQL<T>;\n}\n\nexport class Count extends AggregatedField<number> {\n\tstatic override readonly [entityKind]: string = 'AggregatedFieldCount';\n\n\tdeclare protected $aggregatedFieldBrand: 'Count';\n\n\tprivate query: SQL<number> | undefined;\n\n\tgetSQL(): SQL<number> {\n\t\tif (!this.query) {\n\t\t\tif (!this.table) throw new Error('Table must be set before building aggregate field');\n\t\t\tthis.query = sql`select count(*) as ${sql.identifier('r')} from ${getTableAsAliasSQL(this.table)}`\n\t\t\t\t.mapWith(Number);\n\t\t}\n\n\t\treturn this.query;\n\t}\n}\n\nexport type ExtractObjectValues<T> = T[keyof T];\n\nexport const operators = {\n\tand,\n\tbetween,\n\teq,\n\texists,\n\tgt,\n\tgte,\n\tilike,\n\tinArray,\n\tarrayContains,\n\tarrayContained,\n\tarrayOverlaps,\n\tisNull,\n\tisNotNull,\n\tlike,\n\tlt,\n\tlte,\n\tne,\n\tnot,\n\tnotBetween,\n\tnotExists,\n\tnotLike,\n\tnotIlike,\n\tnotInArray,\n\tor,\n\tsql,\n};\n\nexport type Operators = typeof operators;\n\nexport const orderByOperators = {\n\tsql,\n\tasc,\n\tdesc,\n};\n\nexport type OrderByOperators = typeof orderByOperators;\n\nexport function getOrderByOperators(): OrderByOperators {\n\treturn orderByOperators;\n}\n\nexport type FindTargetTableInRelationalConfig<\n\tTConfig extends TablesRelationalConfig,\n\tTRelation extends AnyRelation,\n> = TConfig[TRelation['targetTableName']];\n\nexport interface SQLOperator {\n\tsql: Operators['sql'];\n}\n\nexport type DBQueryConfigColumns<TColumns extends FieldSelection> = {\n\t[K in keyof TColumns]?: boolean | undefined;\n};\n\nexport type DBQueryConfigExtras<TTable extends SchemaEntry> = Record<\n\tstring,\n\t| SQLWrapper\n\t| ((\n\t\ttable: TTable,\n\t\toperators: SQLOperator,\n\t) => SQLWrapper)\n>;\n\nexport type DBQueryConfigOrderByCallback<TTable extends SchemaEntry> = (\n\ttable: TTable,\n\toperators: OrderByOperators,\n) => ValueOrArray<AnyColumn | SQL>;\n\nexport type DBQueryConfigOrderByObject<TColumns extends FieldSelection> = {\n\t[K in keyof TColumns]?: 'asc' | 'desc' | undefined;\n};\n\nexport type DBQueryConfigOrderBy<TTable extends SchemaEntry, TColumns extends FieldSelection> =\n\t| DBQueryConfigOrderByCallback<TTable>\n\t| DBQueryConfigOrderByObject<TColumns>;\n\nexport type DBQueryConfigWith<TSchema extends TablesRelationalConfig, TRelations extends RelationsRecord> = {\n\t[K in keyof TRelations]?:\n\t\t| boolean\n\t\t| (DBQueryConfig<\n\t\t\tTRelations[K]['relationType'],\n\t\t\tTSchema,\n\t\t\tFindTargetTableInRelationalConfig<TSchema, TRelations[K]>\n\t\t>)\n\t\t| undefined;\n};\n\nexport type DBQueryConfig<\n\tTRelationType extends 'one' | 'many' = 'one' | 'many',\n\tTSchema extends TablesRelationalConfig = TablesRelationalConfig,\n\tTTableConfig extends TableRelationalConfig = TableRelationalConfig,\n> =\n\t& (TTableConfig['relations'] extends Record<string, never> ? {}\n\t\t: {\n\t\t\twith?:\n\t\t\t\t| DBQueryConfigWith<TSchema, TTableConfig['relations']>\n\t\t\t\t| undefined;\n\t\t})\n\t& {\n\t\tcolumns?: DBQueryConfigColumns<GetTableViewFieldSelection<TTableConfig['table']>> | undefined;\n\t\twhere?: RelationsFilter<TTableConfig, TSchema> | undefined;\n\t\textras?:\n\t\t\t| DBQueryConfigExtras<TTableConfig['table']>\n\t\t\t| undefined;\n\t\torderBy?:\n\t\t\t| DBQueryConfigOrderBy<TTableConfig['table'], GetTableViewFieldSelection<TTableConfig['table']>>\n\t\t\t| undefined;\n\t\toffset?: number | Placeholder | undefined;\n\t}\n\t& (TRelationType extends 'many' ? {\n\t\t\tlimit?: number | Placeholder | undefined;\n\t\t}\n\t\t: {});\n\nexport type AnyDBQueryConfig = {\n\tcolumns?:\n\t\t| DBQueryConfigColumns<GetTableViewFieldSelection<TableRelationalConfig['table']>>\n\t\t| undefined;\n\twhere?: RelationsFilter<TableRelationalConfig, TablesRelationalConfig> | undefined;\n\textras?:\n\t\t| DBQueryConfigExtras<TableRelationalConfig['table']>\n\t\t| undefined;\n\twith?:\n\t\t| Record<string, AnyDBQueryConfig>\n\t\t| undefined;\n\torderBy?:\n\t\t| DBQueryConfigOrderBy<TableRelationalConfig['table'], GetTableViewFieldSelection<TableRelationalConfig['table']>>\n\t\t| undefined;\n\toffset?: number | Placeholder | undefined;\n\tlimit?: number | Placeholder | undefined;\n};\n\nexport interface TableRelationalConfig {\n\ttable: SchemaEntry;\n\tname: string;\n\trelations: RelationsRecord;\n}\n\nexport type TablesRelationalConfig = Record<string, TableRelationalConfig>;\n\nexport type ExtractTablesWithRelations<\n\tTConfig extends AnyRelationsBuilderConfig,\n\tTTables extends Schema,\n> = {\n\t[K in keyof TTables]: {\n\t\ttable: TTables[K];\n\t\tname: K & string;\n\t\trelations: TConfig extends { [CK in K]: Record<string, any> } ? TConfig[K] : {};\n\t};\n};\n\nexport type ExtractTablesWithRelationsParts<\n\tTConfig extends AnyRelationsBuilderConfig,\n\tTTables extends Schema,\n> = {\n\t[K in NonUndefinedKeysOnly<TConfig> & keyof TTables]: {\n\t\ttable: TTables[K & string];\n\t\tname: K & string;\n\t\trelations: TConfig[K] extends Record<string, any> ? TConfig[K] : {};\n\t};\n};\n\nexport type ReturnTypeOrValue<T> = T extends (...args: any[]) => infer R ? R\n\t: T;\n\nexport type RelationResultKind<TResult, TInclude, TRelation extends AnyRelation> = TRelation extends AnyOne ? (\n\t\t| TResult\n\t\t| (Equal<TRelation['optional'], true> extends true ? null\n\t\t\t: TInclude extends Record<string, unknown> ? TInclude['where'] extends Record<string, any> ? null\n\t\t\t\t: never\n\t\t\t: never)\n\t)\n\t: TResult[];\n\nexport type BuildRelationResult<\n\tTConfig extends TablesRelationalConfig,\n\tTInclude,\n\tTRelations extends RelationsRecord,\n> = {\n\t[\n\t\tK in\n\t\t\t& TruthyKeysOnly<TInclude>\n\t\t\t& keyof TRelations\n\t]: TRelations[K] extends infer TRel extends AnyRelation ? RelationResultKind<\n\t\t\tBuildQueryResult<\n\t\t\t\tTConfig,\n\t\t\t\tFindTargetTableInRelationalConfig<TConfig, TRel>,\n\t\t\t\tAssume<TInclude[K], true | Record<string, unknown>>\n\t\t\t>,\n\t\t\tTInclude[K],\n\t\t\tTRel\n\t\t>\n\t\t: TRelations[K] extends AggregatedField<infer TData> ? TData\n\t\t: never;\n};\n\nexport type NonUndefinedKeysOnly<T> = {\n\t[K in keyof T]: T[K] extends undefined ? never : K;\n}[keyof T];\n\nexport type TruthyKeysOnly<T> = {\n\t[K in keyof T]: T[K] extends undefined | false ? never : K;\n}[keyof T];\n\nexport type InferRelationalQueryTableResult<\n\tTRawSelection extends Record<string, unknown>,\n\tTSelectedFields extends Record<string, unknown> | 'Full' = 'Full',\n> = TSelectedFields extends 'Full' ? TRawSelection : {\n\t[\n\t\tK in Equal<\n\t\t\tExclude<\n\t\t\t\tTSelectedFields[\n\t\t\t\t\t& keyof TSelectedFields\n\t\t\t\t\t& keyof TRawSelection\n\t\t\t\t],\n\t\t\t\tundefined\n\t\t\t>,\n\t\t\tfalse\n\t\t> extends true ? Exclude<\n\t\t\t\tkeyof TRawSelection,\n\t\t\t\tNonUndefinedKeysOnly<TSelectedFields>\n\t\t\t>\n\t\t\t:\n\t\t\t\t& {\n\t\t\t\t\t[K in keyof TSelectedFields]: Equal<\n\t\t\t\t\t\tTSelectedFields[K],\n\t\t\t\t\t\ttrue\n\t\t\t\t\t> extends true ? K\n\t\t\t\t\t\t: never;\n\t\t\t\t}[keyof TSelectedFields]\n\t\t\t\t& keyof TRawSelection\n\t]: TRawSelection[K];\n};\n\nexport type BuildQueryResult<\n\tTSchema extends TablesRelationalConfig,\n\tTTableConfig extends TableRelationalConfig,\n\tTFullSelection extends true | Record<string, unknown>,\n\tTModel extends Record<string, unknown> = Assume<\n\t\tTTableConfig['table'],\n\t\t{ $inferSelect: Record<string, unknown> }\n\t>['$inferSelect'],\n> = TFullSelection extends true | Record<string, never> ? TModel\n\t: TFullSelection extends Record<string, unknown> ? Simplify<\n\t\t\t& (InferRelationalQueryTableResult<\n\t\t\t\tTModel,\n\t\t\t\tTFullSelection['columns'] extends Record<string, unknown> ? TFullSelection['columns'] : 'Full'\n\t\t\t>)\n\t\t\t& (TFullSelection['extras'] extends Record<string, SQLWrapper | ((...args: any[]) => SQLWrapper)> ? {\n\t\t\t\t\t[\n\t\t\t\t\t\tK in NonUndefinedKeysOnly<\n\t\t\t\t\t\t\tReturnTypeOrValue<TFullSelection['extras']>\n\t\t\t\t\t\t>\n\t\t\t\t\t]: ReturnType<\n\t\t\t\t\t\tAssume<\n\t\t\t\t\t\t\tReturnTypeOrValue<TFullSelection['extras'][K & string]>,\n\t\t\t\t\t\t\tSQLWrapper\n\t\t\t\t\t\t>['getSQL']\n\t\t\t\t\t>['_']['type'];\n\t\t\t\t}\n\t\t\t\t: {})\n\t\t\t& (TFullSelection['with'] extends Record<string, unknown> ? BuildRelationResult<\n\t\t\t\t\tTSchema,\n\t\t\t\t\tTFullSelection['with'],\n\t\t\t\t\tTTableConfig['relations']\n\t\t\t\t>\n\t\t\t\t: {})\n\t\t>\n\t: never;\n\nexport interface BuildRelationalQueryResult {\n\tselection: {\n\t\tkey: string;\n\t\tfield: Column<any> | Table | View | SQL | SQL.Aliased | SQLWrapper | AggregatedField;\n\t\tisArray?: boolean;\n\t\tselection?: BuildRelationalQueryResult['selection'];\n\t\tisOptional?: boolean;\n\t}[];\n\tsql: SQL;\n}\n\nexport function mapRelationalRow(\n\trow: Record<string, unknown>,\n\tbuildQueryResultSelection: BuildRelationalQueryResult['selection'],\n\tmapColumnValue: (value: unknown) => unknown = (value) => value,\n\t/** Needed for SQLite as it returns JSON values as strings */\n\tparseJson: boolean = false,\n\t/** Needed for SingleStore as it returns JSON arrays as strings */\n\tparseJsonIfString: boolean = false,\n\tpath?: string,\n): Record<string, unknown> {\n\tfor (const selectionItem of buildQueryResultSelection) {\n\t\tif (selectionItem.selection) {\n\t\t\tconst currentPath = `${path ? `${path}.` : ''}${selectionItem.key}`;\n\n\t\t\tif (row[selectionItem.key] === null) continue;\n\n\t\t\tif (parseJson) {\n\t\t\t\trow[selectionItem.key] = JSON.parse(row[selectionItem.key] as string);\n\t\t\t\tif (row[selectionItem.key] === null) continue;\n\t\t\t}\n\t\t\tif (parseJsonIfString && typeof row[selectionItem.key] === 'string') {\n\t\t\t\trow[selectionItem.key] = JSON.parse(row[selectionItem.key] as string);\n\t\t\t}\n\n\t\t\tif (selectionItem.isArray) {\n\t\t\t\tfor (const item of (row[selectionItem.key] as Array<Record<string, unknown>>)) {\n\t\t\t\t\tmapRelationalRow(\n\t\t\t\t\t\titem,\n\t\t\t\t\t\tselectionItem.selection!,\n\t\t\t\t\t\tmapColumnValue,\n\t\t\t\t\t\tfalse,\n\t\t\t\t\t\tparseJsonIfString,\n\t\t\t\t\t\tcurrentPath,\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tmapRelationalRow(\n\t\t\t\trow[selectionItem.key] as Record<string, unknown>,\n\t\t\t\tselectionItem.selection!,\n\t\t\t\tmapColumnValue,\n\t\t\t\tfalse,\n\t\t\t\tparseJsonIfString,\n\t\t\t\tcurrentPath,\n\t\t\t);\n\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst field = selectionItem.field!;\n\t\tconst value = mapColumnValue(row[selectionItem.key]);\n\t\tif (value === null) continue;\n\n\t\tlet decoder;\n\t\tif (is(field, Column)) {\n\t\t\tdecoder = field;\n\t\t} else if (is(field, SQL)) {\n\t\t\tdecoder = field.decoder;\n\t\t} else if (is(field, SQL.Aliased)) {\n\t\t\tdecoder = field.sql.decoder;\n\t\t} else if (is(field, Table) || is(field, View)) {\n\t\t\tdecoder = noopDecoder;\n\t\t} else {\n\t\t\tdecoder = field.getSQL().decoder;\n\t\t}\n\n\t\trow[selectionItem.key] = 'mapFromJsonValue' in decoder\n\t\t\t? (<(value: unknown) => unknown> decoder.mapFromJsonValue)(value)\n\t\t\t: decoder.mapFromDriverValue(value);\n\t}\n\n\treturn row;\n}\n\nexport class RelationsBuilderTable<TTableName extends string = string> {\n\tstatic readonly [entityKind]: string = 'RelationsBuilderTable';\n\n\tprotected readonly _: {\n\t\treadonly name: TTableName;\n\t\treadonly table: SchemaEntry;\n\t};\n\n\tconstructor(table: SchemaEntry, name: TTableName) {\n\t\tthis._ = {\n\t\t\tname,\n\t\t\ttable,\n\t\t};\n\t}\n}\n\nexport interface RelationsBuilderColumnConfig<\n\tTTableName extends string = string,\n> {\n\treadonly tableName: TTableName;\n\treadonly column: FieldValue;\n\treadonly through?: RelationsBuilderColumnBase;\n\treadonly key: string;\n}\n\nexport interface RelationsBuilderColumnBase<\n\tTTableName extends string = string,\n> {\n\t_: RelationsBuilderColumnConfig<TTableName>;\n}\n\nexport class RelationsBuilderColumn<\n\tTTableName extends string = string,\n> implements RelationsBuilderColumnBase<TTableName> {\n\tstatic readonly [entityKind]: string = 'RelationsBuilderColumn';\n\n\treadonly _: {\n\t\treadonly tableName: TTableName;\n\t\treadonly column: FieldValue;\n\t\treadonly key: string;\n\t};\n\n\tconstructor(\n\t\tcolumn: FieldValue,\n\t\ttableName: TTableName,\n\t\tkey: string,\n\t) {\n\t\tthis._ = {\n\t\t\ttableName: tableName,\n\t\t\tcolumn,\n\t\t\tkey,\n\t\t};\n\t}\n\n\tthrough(column: RelationsBuilderColumn): RelationsBuilderJunctionColumn<TTableName> {\n\t\treturn new RelationsBuilderJunctionColumn(\n\t\t\tthis._.column,\n\t\t\tthis._.tableName,\n\t\t\tthis._.key,\n\t\t\tcolumn,\n\t\t);\n\t}\n}\n\nexport class RelationsBuilderJunctionColumn<\n\tTTableName extends string = string,\n> implements RelationsBuilderColumnBase<TTableName> {\n\tstatic readonly [entityKind]: string = 'RelationsBuilderColumn';\n\n\treadonly _: {\n\t\treadonly tableName: TTableName;\n\t\treadonly column: FieldValue;\n\t\treadonly through: RelationsBuilderColumnBase;\n\t\treadonly key: string;\n\t};\n\n\tconstructor(\n\t\tcolumn: FieldValue,\n\t\ttableName: TTableName,\n\t\tkey: string,\n\t\tthrough: RelationsBuilderColumnBase,\n\t) {\n\t\tthis._ = {\n\t\t\ttableName: tableName,\n\t\t\tcolumn,\n\t\t\tthrough,\n\t\t\tkey,\n\t\t};\n\t}\n}\n\nexport interface RelationFieldsFilterInternals<T> {\n\teq?: T | Placeholder | undefined;\n\tne?: T | Placeholder | undefined;\n\tgt?: T | Placeholder | undefined;\n\tgte?: T | Placeholder | undefined;\n\tlt?: T | Placeholder | undefined;\n\tlte?: T | Placeholder | undefined;\n\tin?: (T | Placeholder)[] | Placeholder | undefined;\n\tnotIn?: (T | Placeholder)[] | Placeholder | undefined;\n\tarrayContains?: (T extends Array<infer E> ? (E | Placeholder)[] : (T | Placeholder)[]) | Placeholder | undefined;\n\tarrayContained?: (T extends Array<infer E> ? (E | Placeholder)[] : (T | Placeholder)[]) | Placeholder | undefined;\n\tarrayOverlaps?: (T extends Array<infer E> ? (E | Placeholder)[] : (T | Placeholder)[]) | Placeholder | undefined;\n\tlike?: string | Placeholder | undefined;\n\tilike?: string | Placeholder | undefined;\n\tnotLike?: string | Placeholder | undefined;\n\tnotIlike?: string | Placeholder | undefined;\n\tisNull?: true | undefined;\n\tisNotNull?: true | undefined;\n\tNOT?: RelationsFieldFilter<T> | undefined;\n\tOR?: RelationsFieldFilter<T>[] | undefined;\n\tAND?: RelationsFieldFilter<T>[] | undefined;\n}\n\nexport type RelationsFieldFilter<T = unknown> =\n\t| RelationFieldsFilterInternals<T>\n\t| (\n\t\tunknown extends T ? never : T extends object ? never : T\n\t)\n\t// Bleeds into filters - discuss removal\n\t| Placeholder;\n\nexport interface RelationsFilterCommons<\n\tTTable extends TableRelationalConfig = TableRelationalConfig,\n\tTSchema extends TablesRelationalConfig = TablesRelationalConfig,\n> {\n\tOR?: RelationsFilter<TTable, TSchema>[] | undefined;\n\tNOT?: RelationsFilter<TTable, TSchema> | undefined;\n\tAND?: RelationsFilter<TTable, TSchema>[] | undefined;\n\tRAW?:\n\t\t| SQLWrapper\n\t\t| ((\n\t\t\ttable: TTable['table'],\n\t\t\toperators: Operators,\n\t\t) => SQL)\n\t\t| undefined;\n}\n\nexport type RelationsFilterColumns<\n\tTColumns extends Record<string, unknown>,\n> = {\n\t[K in keyof TColumns]?:\n\t\t| (TColumns[K] extends { _: { data: infer Data } } ? RelationsFieldFilter<Data>\n\t\t\t: RelationsFieldFilter<unknown>)\n\t\t| undefined;\n};\n\nexport type RelationsFilterRelations<\n\tTTable extends TableRelationalConfig,\n\tTSchema extends TablesRelationalConfig,\n\tTRelations extends RelationsRecord = TTable['relations'],\n> = {\n\t[K in keyof TRelations]?:\n\t\t| boolean\n\t\t| RelationsFilter<FindTargetTableInRelationalConfig<TSchema, TRelations[K]>, TSchema>\n\t\t| undefined;\n};\n\nexport type RelationsFilter<\n\tTTable extends TableRelationalConfig,\n\tTSchema extends TablesRelationalConfig,\n\tTColumns extends FieldSelection = GetTableViewFieldSelection<TTable['table']>,\n> = TTable['relations'] extends Record<string, never> ? TableFilter<TTable['table']>\n\t:\n\t\t& RelationsFilterColumns<TColumns>\n\t\t& RelationsFilterRelations<TTable, TSchema>\n\t\t& RelationsFilterCommons<TTable, TSchema>;\n\nexport interface TableFilterCommons<\n\tTTable extends SchemaEntry = SchemaEntry,\n\tTColumns extends Record<string, unknown> = GetTableViewColumns<TTable>,\n> {\n\tOR?: TableFilter<TTable, TColumns>[] | undefined;\n\tNOT?: TableFilter<TTable, TColumns> | undefined;\n\tAND?: TableFilter<TTable, TColumns>[] | undefined;\n\tRAW?:\n\t\t| SQLWrapper\n\t\t| ((\n\t\t\ttable: TTable,\n\t\t\toperators: Operators,\n\t\t) => SQL)\n\t\t| undefined;\n}\n\nexport type TableFilterColumns<\n\tTColumns extends Record<string, unknown>,\n> = {\n\t[K in keyof TColumns]?:\n\t\t| (TColumns[K] extends { _: { data: infer Data } } ? RelationsFieldFilter<Data>\n\t\t\t: RelationsFieldFilter<unknown>)\n\t\t| undefined;\n};\n\nexport type TableFilter<\n\tTTable extends SchemaEntry = SchemaEntry,\n\tTColumns extends Record<string, unknown> = GetTableViewColumns<TTable>,\n> =\n\t& TableFilterColumns<TColumns>\n\t& TableFilterCommons<TTable, TColumns>;\n\nexport type AnyRelationsFilter = RelationsFilter<\n\tTableRelationalConfig,\n\tTablesRelationalConfig,\n\tFieldSelection\n>;\n\nexport type AnyTableFilter = TableFilter<\n\tSchemaEntry,\n\tFieldSelection\n>;\n\nexport interface OneConfig<TTargetTable extends SchemaEntry, TOptional extends boolean> {\n\tfrom?: RelationsBuilderColumnBase | [RelationsBuilderColumnBase, ...RelationsBuilderColumnBase[]];\n\tto?: RelationsBuilderColumnBase | [RelationsBuilderColumnBase, ...RelationsBuilderColumnBase[]];\n\twhere?: TableFilter<TTargetTable>;\n\toptional?: TOptional;\n\talias?: string;\n}\n\nexport type AnyOneConfig = OneConfig<\n\tSchemaEntry,\n\tboolean\n>;\n\nexport interface ManyConfig<TTargetTable extends SchemaEntry> {\n\tfrom?: RelationsBuilderColumnBase | [RelationsBuilderColumnBase, ...RelationsBuilderColumnBase[]];\n\tto?: RelationsBuilderColumnBase | [RelationsBuilderColumnBase, ...RelationsBuilderColumnBase[]];\n\twhere?: TableFilter<TTargetTable>;\n\talias?: string;\n}\n\nexport type AnyManyConfig = ManyConfig<SchemaEntry>;\n\nexport interface OneFn<TTargetTable extends SchemaEntry, TTargetTableName extends string> {\n\t<TOptional extends boolean = true>(config?: OneConfig<TTargetTable, TOptional>): One<TTargetTableName, TOptional>;\n}\n\nexport interface ManyFn<TTargetTable extends SchemaEntry, TTargetTableName extends string> {\n\t(config?: ManyConfig<TTargetTable>): Many<TTargetTableName>;\n}\n\nexport class RelationsHelperStatic<TTables extends Schema> {\n\tstatic readonly [entityKind]: string = 'RelationsHelperStatic';\n\t// declare readonly $brand: 'RelationsHelperStatic';\n\n\tprivate readonly _: {\n\t\treadonly tables: TTables;\n\t};\n\n\tconstructor(tables: TTables) {\n\t\tthis._ = {\n\t\t\ttables,\n\t\t};\n\n\t\tconst one: Record<string, OneFn<TTables[string], string>> = {};\n\t\tconst many: Record<string, ManyFn<TTables[string], string>> = {};\n\n\t\tfor (const [tableName, table] of Object.entries(tables)) {\n\t\t\tone[tableName] = (config) => {\n\t\t\t\treturn new One(tables, table, tableName, config as unknown as AnyOneConfig);\n\t\t\t};\n\n\t\t\tmany[tableName] = (config) => {\n\t\t\t\treturn new Many(tables, table, tableName, config as AnyManyConfig);\n\t\t\t};\n\t\t}\n\n\t\tthis.one = one as any as this['one'];\n\t\tthis.many = many as any as this['many'];\n\t}\n\n\tone: {\n\t\t[K in keyof TTables]: TTables[K] extends FilteredSchemaEntry ? OneFn<TTables[K], K & string>\n\t\t\t: DrizzleTypeError<'Views with nested selections are not supported by the relational query builder'>;\n\t};\n\n\tmany: {\n\t\t[K in keyof TTables]: TTables[K] extends FilteredSchemaEntry ? ManyFn<TTables[K], K & string>\n\t\t\t: DrizzleTypeError<'Views with nested selections are not supported by the relational query builder'>;\n\t};\n\n\t/** @internal - to be reworked */\n\taggs = {\n\t\tcount(): Count {\n\t\t\treturn new Count();\n\t\t},\n\t};\n}\n\nexport type RelationsBuilderColumns<TTable extends SchemaEntry, TTableName extends string> = {\n\t[\n\t\tTColumnName in keyof GetTableViewColumns<TTable>\n\t]: RelationsBuilderColumn<\n\t\tTTableName\n\t>;\n};\n\nexport type RelationsBuilderTables<TSchema extends Schema> = {\n\t[TTableName in keyof TSchema]: TSchema[TTableName] extends FilteredSchemaEntry ? (\n\t\t\t& RelationsBuilderColumns<TSchema[TTableName], TTableName & string>\n\t\t\t& RelationsBuilderTable<TTableName & string>\n\t\t)\n\t\t: DrizzleTypeError<'Views with nested selections are not supported by the relational query builder'>;\n};\n\nexport type RelationsBuilder<TSchema extends Schema> =\n\t& RelationsBuilderTables<TSchema>\n\t& RelationsHelperStatic<TSchema>;\n\nexport type RelationsBuilderConfigValue =\n\t| RelationsRecord\n\t| undefined;\n\nexport type RelationsBuilderConfig<TTables extends Schema> = {\n\t[TTableName in keyof TTables]?: RelationsBuilderConfigValue;\n};\n\nexport type AnyRelationsBuilderConfig = Record<string, RelationsBuilderConfigValue>;\n\nexport type ExtractTablesFromSchema<TSchema extends Record<string, unknown>> = Assume<\n\t{\n\t\t[K in keyof TSchema as TSchema[K] extends SchemaEntry ? K extends string ? K : never : never]: TSchema[K];\n\t},\n\tSchema\n>;\n\nexport function createRelationsHelper<\n\tTTables extends Schema,\n>(tables: TTables): RelationsBuilder<TTables> {\n\tconst helperStatic = new RelationsHelperStatic(tables);\n\tconst relationsTables = Object.entries(tables).reduce<Record<string, RelationsBuilderTable>>((acc, [tKey, value]) => {\n\t\tconst rTable = new RelationsBuilderTable(value, tKey);\n\t\tconst columns = Object.entries(value[TableColumns]).reduce<\n\t\t\tRecord<string, RelationsBuilderColumnBase>\n\t\t>(\n\t\t\t(acc, [cKey, column]) => {\n\t\t\t\tconst rbColumn = new RelationsBuilderColumn(column as FieldValue, tKey, cKey);\n\t\t\t\tacc[cKey] = rbColumn;\n\t\t\t\treturn acc;\n\t\t\t},\n\t\t\t{},\n\t\t);\n\n\t\tacc[tKey] = Object.assign(rTable, columns);\n\n\t\treturn acc;\n\t}, {});\n\n\treturn Object.assign(helperStatic, relationsTables) as any;\n}\n\nexport function extractTablesFromSchema<TSchema extends Record<string, unknown>>(\n\tschema: TSchema,\n): ExtractTablesFromSchema<TSchema> {\n\treturn Object.fromEntries(\n\t\tObject.entries(schema).filter(([_, e]) => is(e, Table) || is(e, View)),\n\t) as ExtractTablesFromSchema<TSchema>;\n}\n\nexport type IncludeEveryTable<TTables extends Schema> = { [K in keyof TTables]: {} };\n\n/** Builds relational config for every table in schema */\nexport function defineRelations<\n\tTSchema extends Record<string, unknown>,\n\tTTables extends Schema = ExtractTablesFromSchema<TSchema>,\n>(\n\tschema: TSchema,\n): ExtractTablesWithRelations<{}, TTables>;\n/** Builds relational config for every table in schema */\nexport function defineRelations<\n\tTSchema extends Record<string, unknown>,\n\tTConfig extends RelationsBuilderConfig<TTables>,\n\tTTables extends Schema = ExtractTablesFromSchema<TSchema>,\n>(\n\tschema: TSchema,\n\trelations: (helpers: RelationsBuilder<TTables>) => TConfig,\n): ExtractTablesWithRelations<TConfig, TTables>;\nexport function defineRelations(\n\tschema: Record<string, unknown>,\n\trelations?: (helpers: RelationsBuilder<Schema>) => AnyRelationsBuilderConfig,\n): TablesRelationalConfig {\n\tconst tables = extractTablesFromSchema(schema);\n\tconst config = relations\n\t\t? relations(\n\t\t\tcreateRelationsHelper(tables) as RelationsBuilder<Schema>,\n\t\t)\n\t\t: {};\n\n\treturn buildRelations(tables, config);\n}\n\n/** Builds relational config for every table in schema */\nexport function defineRelationsPart<\n\tTSchema extends Record<string, unknown>,\n\tTTables extends Schema = ExtractTablesFromSchema<TSchema>,\n>(\n\tschema: TSchema,\n): ExtractTablesWithRelationsParts<IncludeEveryTable<TTables>, TTables>;\n/** Builds relational config only for tables present in relational config */\nexport function defineRelationsPart<\n\tTSchema extends Record<string, unknown>,\n\tTConfig extends RelationsBuilderConfig<TTables>,\n\tTTables extends Schema = ExtractTablesFromSchema<TSchema>,\n>(\n\tschema: TSchema,\n\trelations: (helpers: RelationsBuilder<TTables>) => TConfig,\n): ExtractTablesWithRelationsParts<TConfig, TTables>;\nexport function defineRelationsPart(\n\tschema: Record<string, unknown>,\n\trelations?: (helpers: RelationsBuilder<Schema>) => AnyRelationsBuilderConfig,\n): TablesRelationalConfig {\n\tconst tables = extractTablesFromSchema(schema);\n\tconst config = relations\n\t\t? relations(\n\t\t\tcreateRelationsHelper(tables) as RelationsBuilder<Schema>,\n\t\t)\n\t\t: Object.fromEntries(Object.keys(tables).map((k) => [k, {}])) as AnyRelationsBuilderConfig;\n\n\treturn buildRelationsParts(tables, config);\n}\n\nexport interface WithContainer {\n\twith?: Record<string, boolean | AnyDBQueryConfig | undefined>;\n}\n\nexport interface ColumnWithTSName {\n\tcolumn: Table | View | Column<any> | SQL | SQLWrapper | SQL.Aliased;\n\ttsName: string;\n}\n\nexport type RelationsOrder<TColumns extends FieldSelection> = {\n\t[K in keyof TColumns]?: 'asc' | 'desc';\n};\n\nexport type OrderBy = Exclude<AnyDBQueryConfig['orderBy'], undefined>;\n\nexport type Extras = Exclude<AnyDBQueryConfig['extras'], undefined>;\n\n/** @internal */\nexport function fieldSelectionToSQL(table: SchemaEntry, target: string) {\n\tconst field = table[TableColumns][target];\n\n\treturn field\n\t\t? is(field, Column)\n\t\t\t? field\n\t\t\t: is(field, SQL.Aliased)\n\t\t\t? sql`${table}.${sql.identifier(field.fieldAlias)}`\n\t\t\t: sql`${table}.${sql.identifier(target)}`\n\t\t: sql`${table}.${sql.identifier(target)}`;\n}\n\nfunction relationsFieldFilterToSQL(column: SQLWrapper, filter: RelationsFieldFilter<unknown>): SQL | undefined {\n\tif (typeof filter !== 'object' || is(filter, Placeholder)) return eq(column, filter);\n\n\tconst entries = Object.entries(filter as RelationFieldsFilterInternals<unknown>);\n\tif (!entries.length) return undefined;\n\n\tconst parts: (SQL)[] = [];\n\tfor (const [target, value] of entries) {\n\t\tif (value === undefined) continue;\n\n\t\tswitch (target as keyof RelationFieldsFilterInternals<unknown>) {\n\t\t\tcase 'NOT': {\n\t\t\t\tconst res = relationsFieldFilterToSQL(column, value as RelationsFieldFilter<unknown>);\n\t\t\t\tif (!res) continue;\n\n\t\t\t\tparts.push(not(res));\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tcase 'OR': {\n\t\t\t\tif (!(value as RelationsFieldFilter<unknown>[]).length) continue;\n\n\t\t\t\tparts.push(\n\t\t\t\t\tor(\n\t\t\t\t\t\t...(value as AnyRelationsFilter[]).map((subFilter) => relationsFieldFilterToSQL(column, subFilter)),\n\t\t\t\t\t)!,\n\t\t\t\t);\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tcase 'AND': {\n\t\t\t\tif (!(value as RelationsFieldFilter<unknown>[]).length) continue;\n\n\t\t\t\tparts.push(\n\t\t\t\t\tand(\n\t\t\t\t\t\t...(value as AnyRelationsFilter[]).map((subFilter) => relationsFieldFilterToSQL(column, subFilter)),\n\t\t\t\t\t)!,\n\t\t\t\t);\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tcase 'isNotNull':\n\t\t\tcase 'isNull': {\n\t\t\t\tif (!value) continue;\n\n\t\t\t\tparts.push(operators[target as 'isNull' | 'isNotNull'](column));\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tcase 'in': {\n\t\t\t\tparts.push(operators.inArray(column, value as any[] | Placeholder));\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tcase 'notIn': {\n\t\t\t\tparts.push(operators.notInArray(column, value as any[] | Placeholder));\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tdefault: {\n\t\t\t\tparts.push(\n\t\t\t\t\t(operators[target as keyof typeof operators] as ((col: SQLWrapper, data: any) => SQL | undefined))(\n\t\t\t\t\t\tcolumn,\n\t\t\t\t\t\tvalue,\n\t\t\t\t\t)!,\n\t\t\t\t);\n\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!parts.length) return undefined;\n\n\treturn and(...parts);\n}\n\nexport function relationsFilterToSQL(\n\ttable: SchemaEntry,\n\tfilter: AnyRelationsFilter | AnyTableFilter,\n): SQL | undefined;\nexport function relationsFilterToSQL(\n\ttable: SchemaEntry,\n\tfilter: AnyRelationsFilter | AnyTableFilter,\n\ttableRelations: RelationsRecord,\n\ttablesRelations: TablesRelationalConfig,\n\tcasing: CasingCache,\n\tdepth?: number,\n): SQL | undefined;\nexport function relationsFilterToSQL(\n\ttable: SchemaEntry,\n\tfilter: AnyRelationsFilter | AnyTableFilter,\n\ttableRelations: RelationsRecord = {},\n\ttablesRelations: TablesRelationalConfig = {},\n\tcasing?: CasingCache,\n\tdepth: number = 0,\n): SQL | undefined {\n\tconst entries = Object.entries(filter);\n\tif (!entries.length) return undefined;\n\n\tconst parts: SQL[] = [];\n\tfor (const [target, value] of entries) {\n\t\tif (value === undefined) continue;\n\n\t\tswitch (target) {\n\t\t\tcase 'RAW': {\n\t\t\t\tconst processed = typeof value === 'function'\n\t\t\t\t\t? (value as unknown as (table: FieldSelection, operators: Operators) => SQL)(table as any, operators)\n\t\t\t\t\t: (value as SQLWrapper).getSQL();\n\n\t\t\t\tparts.push(processed);\n\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tcase 'OR': {\n\t\t\t\tif (!(value as AnyRelationsFilter[] | undefined)?.length) continue;\n\n\t\t\t\tparts.push(\n\t\t\t\t\tor(\n\t\t\t\t\t\t...(value as AnyRelationsFilter[]).map((subFilter) =>\n\t\t\t\t\t\t\trelationsFilterToSQL(table, subFilter, tableRelations, tablesRelations, casing!, depth)\n\t\t\t\t\t\t),\n\t\t\t\t\t)!,\n\t\t\t\t);\n\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tcase 'AND': {\n\t\t\t\tif (!(value as AnyRelationsFilter[] | undefined)?.length) continue;\n\n\t\t\t\tparts.push(\n\t\t\t\t\tand(\n\t\t\t\t\t\t...(value as AnyRelationsFilter[]).map((subFilter) =>\n\t\t\t\t\t\t\trelationsFilterToSQL(table, subFilter, tableRelations, tablesRelations, casing!, depth)\n\t\t\t\t\t\t),\n\t\t\t\t\t)!,\n\t\t\t\t);\n\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tcase 'NOT': {\n\t\t\t\tif (value === undefined) continue;\n\n\t\t\t\tconst built = relationsFilterToSQL(\n\t\t\t\t\ttable,\n\t\t\t\t\tvalue as AnyRelationsFilter,\n\t\t\t\t\ttableRelations,\n\t\t\t\t\ttablesRelations,\n\t\t\t\t\tcasing!,\n\t\t\t\t\tdepth,\n\t\t\t\t);\n\t\t\t\tif (!built) continue;\n\n\t\t\t\tparts.push(not(built));\n\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tdefault: {\n\t\t\t\tif (table[TableColumns][target]) {\n\t\t\t\t\tconst column = fieldSelectionToSQL(table, target);\n\n\t\t\t\t\tconst colFilter = relationsFieldFilterToSQL(\n\t\t\t\t\t\tcolumn,\n\t\t\t\t\t\tvalue as RelationsFieldFilter,\n\t\t\t\t\t);\n\t\t\t\t\tif (colFilter) parts.push(colFilter);\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tconst relation = tableRelations[target];\n\t\t\t\tif (!relation) {\n\t\t\t\t\t// Should never trigger unless the types've been violated\n\t\t\t\t\tthrow new DrizzleError({\n\t\t\t\t\t\tmessage: `Unknown relational filter field: \"${target}\"`,\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\tconst targetTable = aliasedTable(relation.targetTable, `f${depth}`);\n\t\t\t\tconst throughTable = relation.throughTable ? aliasedTable(relation.throughTable, `ft${depth}`) : undefined;\n\t\t\t\tconst targetConfig = tablesRelations[relation.targetTableName]!;\n\n\t\t\t\tconst {\n\t\t\t\t\tfilter: relationFilter,\n\t\t\t\t\tjoinCondition,\n\t\t\t\t} = relationToSQL(casing!, relation, table, targetTable, throughTable);\n\t\t\t\tconst subfilter = typeof value === 'boolean' ? undefined : relationsFilterToSQL(\n\t\t\t\t\ttargetTable,\n\t\t\t\t\tvalue as AnyRelationsFilter,\n\t\t\t\t\ttargetConfig.relations,\n\t\t\t\t\ttablesRelations,\n\t\t\t\t\tcasing!,\n\t\t\t\t\tdepth + 1,\n\t\t\t\t);\n\t\t\t\tconst filter = and(\n\t\t\t\t\trelationFilter,\n\t\t\t\t\tsubfilter,\n\t\t\t\t);\n\n\t\t\t\tconst subquery = throughTable\n\t\t\t\t\t? sql`(select * from ${getTableAsAliasSQL(targetTable)} inner join ${\n\t\t\t\t\t\tgetTableAsAliasSQL(throughTable)\n\t\t\t\t\t} on ${joinCondition}${sql` where ${filter}`.if(filter)} limit 1)`\n\t\t\t\t\t: sql`(select * from ${getTableAsAliasSQL(targetTable)}${sql` where ${filter}`.if(filter)} limit 1)`;\n\t\t\t\tif (filter) parts.push((value ? exists : notExists)(subquery));\n\t\t\t}\n\t\t}\n\t}\n\n\treturn and(...parts)!;\n}\n\nexport function relationsOrderToSQL(\n\ttable: SchemaEntry,\n\torders: OrderBy,\n): SQL | undefined {\n\tif (typeof orders === 'function') {\n\t\tconst data = orders(table as any, orderByOperators);\n\n\t\treturn is(data, SQL)\n\t\t\t? data\n\t\t\t: Array.isArray(data)\n\t\t\t? data.length\n\t\t\t\t? sql.join(data.map((o) => is(o, SQL) ? o : asc(o)), sql`, `)\n\t\t\t\t: undefined\n\t\t\t: is(data, Column)\n\t\t\t? asc(data)\n\t\t\t: undefined;\n\t}\n\n\tconst entries = Object.entries(orders).filter(([_, value]) => value);\n\tif (!entries.length) return undefined;\n\n\treturn sql.join(\n\t\tentries.map(([target, value]) => (value === 'asc' ? asc : desc)(fieldSelectionToSQL(table, target))),\n\t\tsql`, `,\n\t);\n}\n\nexport function relationExtrasToSQL(\n\ttable: SchemaEntry,\n\textras: Extras,\n) {\n\tconst subqueries: SQL[] = [];\n\tconst selection: BuildRelationalQueryResult['selection'] = [];\n\n\tfor (\n\t\tconst [key, field] of Object.entries(extras)\n\t) {\n\t\tif (!field) continue;\n\t\tconst extra = typeof field === 'function' ? field(table as any, { sql: operators.sql }) : field;\n\n\t\tconst query = sql`(${extra.getSQL()}) as ${sql.identifier(key)}`;\n\n\t\tquery.decoder = extra.getSQL().decoder;\n\n\t\tsubqueries.push(query);\n\t\tselection.push({\n\t\t\tkey,\n\t\t\tfield: query,\n\t\t});\n\t}\n\n\treturn {\n\t\tsql: subqueries.length ? sql.join(subqueries, sql`, `) : undefined,\n\t\tselection,\n\t};\n}\n\nexport interface BuiltRelationFilters {\n\tfilter?: SQL;\n\tjoinCondition?: SQL;\n}\n\nexport function relationToSQL(\n\tcasing: CasingCache,\n\trelation: Relation,\n\tsourceTable: SchemaEntry,\n\ttargetTable: SchemaEntry,\n\tthroughTable?: SchemaEntry,\n): BuiltRelationFilters {\n\tif (relation.through) {\n\t\tconst outerColumnWhere = relation.sourceColumns.map((s, i) => {\n\t\t\tconst t = relation.through!.source[i]!;\n\n\t\t\treturn eq(\n\t\t\t\tsql`${sourceTable}.${sql.identifier(casing.getColumnCasing(s))}`,\n\t\t\t\tsql`${throughTable!}.${sql.identifier(is(t._.column, Column) ? casing.getColumnCasing(t._.column) : t._.key)}`,\n\t\t\t);\n\t\t});\n\n\t\tconst innerColumnWhere = relation.targetColumns.map((s, i) => {\n\t\t\tconst t = relation.through!.target[i]!;\n\n\t\t\treturn eq(\n\t\t\t\tsql`${throughTable!}.${sql.identifier(is(t._.column, Column) ? casing.getColumnCasing(t._.column) : t._.key)}`,\n\t\t\t\tsql`${targetTable}.${sql.identifier(casing.getColumnCasing(s))}`,\n\t\t\t);\n\t\t});\n\n\t\treturn {\n\t\t\tfilter: and(\n\t\t\t\trelation.where\n\t\t\t\t\t? relationsFilterToSQL(relation.isReversed ? sourceTable : targetTable, relation.where)\n\t\t\t\t\t: undefined,\n\t\t\t\t...outerColumnWhere,\n\t\t\t),\n\t\t\tjoinCondition: and(...innerColumnWhere),\n\t\t};\n\t}\n\n\tconst columnWhere = relation.sourceColumns.map((s, i) => {\n\t\tconst t = relation.targetColumns[i]!;\n\n\t\treturn eq(\n\t\t\tsql`${sourceTable}.${sql.identifier(casing.getColumnCasing(s))}`,\n\t\t\tsql`${targetTable}.${sql.identifier(casing.getColumnCasing(t))}`,\n\t\t);\n\t});\n\n\tconst fullWhere = and(\n\t\t...columnWhere,\n\t\trelation.where\n\t\t\t? relationsFilterToSQL(relation.isReversed ? sourceTable : targetTable, relation.where)\n\t\t\t: undefined,\n\t)!;\n\n\treturn { filter: fullWhere };\n}\n\nexport function getTableAsAliasSQL(table: SchemaEntry) {\n\treturn sql`${\n\t\ttable[IsAlias]\n\t\t\t? sql`${sql`${sql.identifier(table[TableSchema] ?? '')}.`.if(table[TableSchema])}${\n\t\t\t\tsql.identifier(table[OriginalName])\n\t\t\t} as ${table}`\n\t\t\t: table\n\t}`;\n}\n"],"mappings":"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"}