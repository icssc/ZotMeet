{"version":3,"file":"dialect.cjs","names":["entityKind","CasingCache","sql","Table","SQL","chunk: SQLChunk[]","Column","Subquery","joinsArray: SQL[]","SQLiteTable","orderByList: (SQLiteColumn | SQL | SQL.Aliased)[]","View","ViewBaseConfig","SQLiteViewBase","table","groupByList: (SQL | AnyColumn | SQL.Aliased)[]","orderByValues: (SQL<unknown> | Name)[]","SQLiteColumn","valuesSqlList: ((SQLChunk | SQL)[] | SQL)[]","columns: Record<string, SQLiteColumn>","colEntries: [string, SQLiteColumn][]","select","valueList: (SQLChunk | SQL)[]","Param","selection: V1.BuildRelationalQueryResult<SQLiteTable, SQLiteColumn>['selection']","orderBy: SQLiteSelectConfig['orderBy']","joins: SQLiteSelectJoinConfig[]","V1","fieldsSelection: { tsKey: string; value: SQLiteColumn | SQL.Aliased }[]","selectedColumns: string[]","selectedRelations: {\n\t\t\t\ttsKey: string;\n\t\t\t\tqueryConfig: true | V1.DBQueryConfig<'many', false>;\n\t\t\t\trelation: V1.Relation;\n\t\t\t}[]","joinOn","field","DrizzleError","TableColumns","selectedColumns: ColumnWithTSName[]","colSelectionMode: boolean | undefined","columnIdentifiers: SQL[]","selection: BuildRelationalQueryResult['selection']","where: SQL | undefined","joins","isSingle","One","throughJoin"],"sources":["../../src/sqlite-core/dialect.ts"],"sourcesContent":["import * as V1 from '~/_relations.ts';\nimport {\n\taliasedTable,\n\taliasedTableColumn,\n\tgetOriginalColumnFromAlias,\n\tmapColumnsInAliasedSQLToAlias,\n\tmapColumnsInSQLToAlias,\n} from '~/alias.ts';\nimport { CasingCache } from '~/casing.ts';\nimport type { AnyColumn } from '~/column.ts';\nimport { Column } from '~/column.ts';\nimport { entityKind, is } from '~/entity.ts';\nimport { DrizzleError } from '~/errors.ts';\nimport type { MigrationConfig, MigrationMeta, MigratorInitFailResponse } from '~/migrator.ts';\nimport {\n\ttype AnyOne,\n\t// AggregatedField,\n\ttype AnyRelations,\n\ttype BuildRelationalQueryResult,\n\ttype ColumnWithTSName,\n\ttype DBQueryConfig,\n\tgetTableAsAliasSQL,\n\tOne,\n\ttype Relation,\n\trelationExtrasToSQL,\n\trelationsFilterToSQL,\n\trelationsOrderToSQL,\n\trelationToSQL,\n\ttype TableRelationalConfig,\n\ttype TablesRelationalConfig,\n\ttype WithContainer,\n} from '~/relations.ts';\nimport type { Name, Placeholder, SQLWrapper } from '~/sql/index.ts';\nimport { and, eq, isSQLWrapper } from '~/sql/index.ts';\nimport { Param, type QueryWithTypings, SQL, sql, type SQLChunk, View } from '~/sql/sql.ts';\nimport { SQLiteColumn, type SQLiteCustomColumn } from '~/sqlite-core/columns/index.ts';\nimport type {\n\tAnySQLiteSelectQueryBuilder,\n\tSQLiteDeleteConfig,\n\tSQLiteInsertConfig,\n\tSQLiteUpdateConfig,\n} from '~/sqlite-core/query-builders/index.ts';\nimport { SQLiteTable } from '~/sqlite-core/table.ts';\nimport { Subquery } from '~/subquery.ts';\nimport { getTableName, getTableUniqueName, Table, TableColumns } from '~/table.ts';\nimport { type Casing, orderSelectedFields, type UpdateSet } from '~/utils.ts';\nimport { ViewBaseConfig } from '~/view-common.ts';\nimport type {\n\tSelectedFieldsOrdered,\n\tSQLiteSelectConfig,\n\tSQLiteSelectJoinConfig,\n} from './query-builders/select.types.ts';\nimport type { SQLiteSession } from './session.ts';\nimport { SQLiteViewBase } from './view-base.ts';\nimport type { SQLiteView } from './view.ts';\n\nexport interface SQLiteDialectConfig {\n\tcasing?: Casing;\n}\n\nexport abstract class SQLiteDialect {\n\tstatic readonly [entityKind]: string = 'SQLiteDialect';\n\n\t/** @internal */\n\treadonly casing: CasingCache;\n\n\tconstructor(config?: SQLiteDialectConfig) {\n\t\tthis.casing = new CasingCache(config?.casing);\n\t}\n\n\tescapeName(name: string): string {\n\t\treturn `\"${name}\"`;\n\t}\n\n\tescapeParam(_num: number): string {\n\t\treturn '?';\n\t}\n\n\tescapeString(str: string): string {\n\t\treturn `'${str.replace(/'/g, \"''\")}'`;\n\t}\n\n\tprivate buildWithCTE(queries: Subquery[] | undefined): SQL | undefined {\n\t\tif (!queries?.length) return undefined;\n\n\t\tconst withSqlChunks = [sql`with `];\n\t\tfor (const [i, w] of queries.entries()) {\n\t\t\twithSqlChunks.push(sql`${sql.identifier(w._.alias)} as (${w._.sql})`);\n\t\t\tif (i < queries.length - 1) {\n\t\t\t\twithSqlChunks.push(sql`, `);\n\t\t\t}\n\t\t}\n\t\twithSqlChunks.push(sql` `);\n\t\treturn sql.join(withSqlChunks);\n\t}\n\n\tbuildDeleteQuery({ table, where, returning, withList, limit, orderBy }: SQLiteDeleteConfig): SQL {\n\t\tconst withSql = this.buildWithCTE(withList);\n\n\t\tconst returningSql = returning\n\t\t\t? sql` returning ${this.buildSelection(returning, { isSingleTable: true })}`\n\t\t\t: undefined;\n\n\t\tconst whereSql = where ? sql` where ${where}` : undefined;\n\n\t\tconst orderBySql = this.buildOrderBy(orderBy);\n\n\t\tconst limitSql = this.buildLimit(limit);\n\n\t\treturn sql`${withSql}delete from ${table}${whereSql}${returningSql}${orderBySql}${limitSql}`;\n\t}\n\n\tbuildUpdateSet(table: SQLiteTable, set: UpdateSet): SQL {\n\t\tconst tableColumns = table[Table.Symbol.Columns];\n\n\t\tconst columnNames = Object.keys(tableColumns).filter((colName) =>\n\t\t\tset[colName] !== undefined || tableColumns[colName]?.onUpdateFn !== undefined\n\t\t);\n\n\t\tconst setLength = columnNames.length;\n\t\treturn sql.join(columnNames.flatMap((colName, i) => {\n\t\t\tconst col = tableColumns[colName]!;\n\n\t\t\tconst onUpdateFnResult = col.onUpdateFn?.();\n\t\t\tconst value = set[colName] ?? (is(onUpdateFnResult, SQL) ? onUpdateFnResult : sql.param(onUpdateFnResult, col));\n\t\t\tconst res = sql`${sql.identifier(this.casing.getColumnCasing(col))} = ${value}`;\n\n\t\t\tif (i < setLength - 1) {\n\t\t\t\treturn [res, sql.raw(', ')];\n\t\t\t}\n\t\t\treturn [res];\n\t\t}));\n\t}\n\n\tbuildUpdateQuery({ table, set, where, returning, withList, joins, from, limit, orderBy }: SQLiteUpdateConfig): SQL {\n\t\tconst withSql = this.buildWithCTE(withList);\n\n\t\tconst setSql = this.buildUpdateSet(table, set);\n\n\t\tconst fromSql = from && sql.join([sql.raw(' from '), this.buildFromTable(from)]);\n\n\t\tconst joinsSql = this.buildJoins(joins);\n\n\t\tconst returningSql = returning\n\t\t\t? sql` returning ${this.buildSelection(returning, { isSingleTable: true })}`\n\t\t\t: undefined;\n\n\t\tconst whereSql = where ? sql` where ${where}` : undefined;\n\n\t\tconst orderBySql = this.buildOrderBy(orderBy);\n\n\t\tconst limitSql = this.buildLimit(limit);\n\n\t\treturn sql`${withSql}update ${table} set ${setSql}${fromSql}${joinsSql}${whereSql}${returningSql}${orderBySql}${limitSql}`;\n\t}\n\n\t/**\n\t * Builds selection SQL with provided fields/expressions\n\t *\n\t * Examples:\n\t *\n\t * `select <selection> from`\n\t *\n\t * `insert ... returning <selection>`\n\t *\n\t * If `isSingleTable` is true, then columns won't be prefixed with table name\n\t */\n\tprivate buildSelection(\n\t\tfields: SelectedFieldsOrdered,\n\t\t{ isSingleTable = false }: { isSingleTable?: boolean } = {},\n\t): SQL {\n\t\tconst columnsLen = fields.length;\n\n\t\tconst chunks = fields\n\t\t\t.flatMap(({ field }, i) => {\n\t\t\t\tconst chunk: SQLChunk[] = [];\n\n\t\t\t\tif (is(field, SQL.Aliased) && field.isSelectionField) {\n\t\t\t\t\tchunk.push(sql.identifier(field.fieldAlias));\n\t\t\t\t} else if (is(field, SQL.Aliased) || is(field, SQL)) {\n\t\t\t\t\tconst query = is(field, SQL.Aliased) ? field.sql : field;\n\n\t\t\t\t\tif (isSingleTable) {\n\t\t\t\t\t\tconst newSql = new SQL(\n\t\t\t\t\t\t\tquery.queryChunks.map((c) => {\n\t\t\t\t\t\t\t\tif (is(c, Column)) {\n\t\t\t\t\t\t\t\t\treturn sql.identifier(this.casing.getColumnCasing(c));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\treturn c;\n\t\t\t\t\t\t\t}),\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tchunk.push(query.shouldInlineParams ? newSql.inlineParams() : newSql);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tchunk.push(query);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (is(field, SQL.Aliased)) {\n\t\t\t\t\t\tchunk.push(sql` as ${sql.identifier(field.fieldAlias)}`);\n\t\t\t\t\t}\n\t\t\t\t} else if (is(field, Column)) {\n\t\t\t\t\tif (field.columnType === 'SQLiteNumericBigInt') {\n\t\t\t\t\t\tif (isSingleTable) {\n\t\t\t\t\t\t\tchunk.push(\n\t\t\t\t\t\t\t\tfield.isAlias\n\t\t\t\t\t\t\t\t\t? sql`cast(${\n\t\t\t\t\t\t\t\t\t\tsql.identifier(this.casing.getColumnCasing(getOriginalColumnFromAlias(field)))\n\t\t\t\t\t\t\t\t\t} as text) as ${field}`\n\t\t\t\t\t\t\t\t\t: sql`cast(${sql.identifier(this.casing.getColumnCasing(field))} as text)`,\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tchunk.push(\n\t\t\t\t\t\t\t\tfield.isAlias\n\t\t\t\t\t\t\t\t\t? sql`cast(${getOriginalColumnFromAlias(field)} as text) as ${field}`\n\t\t\t\t\t\t\t\t\t: sql`cast(${field} as text)`,\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (isSingleTable) {\n\t\t\t\t\t\t\tchunk.push(\n\t\t\t\t\t\t\t\tfield.isAlias\n\t\t\t\t\t\t\t\t\t? sql`${sql.identifier(this.casing.getColumnCasing(getOriginalColumnFromAlias(field)))} as ${field}`\n\t\t\t\t\t\t\t\t\t: sql.identifier(this.casing.getColumnCasing(field)),\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tchunk.push(field.isAlias ? sql`${getOriginalColumnFromAlias(field)} as ${field}` : field);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else if (is(field, Subquery)) {\n\t\t\t\t\tconst entries = Object.entries(field._.selectedFields) as [string, SQL.Aliased | Column | SQL][];\n\n\t\t\t\t\tif (entries.length === 1) {\n\t\t\t\t\t\tconst entry = entries[0]![1];\n\n\t\t\t\t\t\tconst fieldDecoder = is(entry, SQL)\n\t\t\t\t\t\t\t? entry.decoder\n\t\t\t\t\t\t\t: is(entry, Column)\n\t\t\t\t\t\t\t? { mapFromDriverValue: (v: any) => entry.mapFromDriverValue(v) }\n\t\t\t\t\t\t\t: entry.sql.decoder;\n\t\t\t\t\t\tif (fieldDecoder) field._.sql.decoder = fieldDecoder;\n\t\t\t\t\t}\n\t\t\t\t\tchunk.push(field);\n\t\t\t\t}\n\n\t\t\t\tif (i < columnsLen - 1) {\n\t\t\t\t\tchunk.push(sql`, `);\n\t\t\t\t}\n\n\t\t\t\treturn chunk;\n\t\t\t});\n\n\t\treturn sql.join(chunks);\n\t}\n\n\tprivate buildJoins(joins: SQLiteSelectJoinConfig[] | undefined): SQL | undefined {\n\t\tif (!joins || joins.length === 0) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\tconst joinsArray: SQL[] = [];\n\n\t\tif (joins) {\n\t\t\tfor (const [index, joinMeta] of joins.entries()) {\n\t\t\t\tif (index === 0) {\n\t\t\t\t\tjoinsArray.push(sql` `);\n\t\t\t\t}\n\t\t\t\tconst table = joinMeta.table;\n\t\t\t\tconst onSql = joinMeta.on ? sql` on ${joinMeta.on}` : undefined;\n\n\t\t\t\tif (is(table, SQLiteTable)) {\n\t\t\t\t\tconst tableName = table[SQLiteTable.Symbol.Name];\n\t\t\t\t\tconst tableSchema = table[SQLiteTable.Symbol.Schema];\n\t\t\t\t\tconst origTableName = table[SQLiteTable.Symbol.OriginalName];\n\t\t\t\t\tconst alias = tableName === origTableName ? undefined : joinMeta.alias;\n\t\t\t\t\tjoinsArray.push(\n\t\t\t\t\t\tsql`${sql.raw(joinMeta.joinType)} join ${tableSchema ? sql`${sql.identifier(tableSchema)}.` : undefined}${\n\t\t\t\t\t\t\tsql.identifier(origTableName)\n\t\t\t\t\t\t}${alias && sql` ${sql.identifier(alias)}`}${onSql}`,\n\t\t\t\t\t);\n\t\t\t\t} else {\n\t\t\t\t\tjoinsArray.push(\n\t\t\t\t\t\tsql`${sql.raw(joinMeta.joinType)} join ${table}${onSql}`,\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tif (index < joins.length - 1) {\n\t\t\t\t\tjoinsArray.push(sql` `);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn sql.join(joinsArray);\n\t}\n\n\tprivate buildLimit(limit: number | Placeholder | undefined): SQL | undefined {\n\t\treturn typeof limit === 'object' || (typeof limit === 'number' && limit >= 0)\n\t\t\t? sql` limit ${limit}`\n\t\t\t: undefined;\n\t}\n\n\tprivate buildOrderBy(orderBy: (SQLiteColumn | SQL | SQL.Aliased)[] | undefined): SQL | undefined {\n\t\tconst orderByList: (SQLiteColumn | SQL | SQL.Aliased)[] = [];\n\n\t\tif (orderBy) {\n\t\t\tfor (const [index, orderByValue] of orderBy.entries()) {\n\t\t\t\torderByList.push(orderByValue);\n\n\t\t\t\tif (index < orderBy.length - 1) {\n\t\t\t\t\torderByList.push(sql`, `);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn orderByList.length > 0 ? sql` order by ${sql.join(orderByList)}` : undefined;\n\t}\n\n\tprivate buildFromTable(\n\t\ttable: SQL | Subquery | SQLiteViewBase | SQLiteTable | undefined,\n\t): SQL | Subquery | SQLiteViewBase | SQLiteTable | undefined {\n\t\tif (is(table, Table) && table[Table.Symbol.IsAlias]) {\n\t\t\treturn sql`${sql`${sql.identifier(table[Table.Symbol.Schema] ?? '')}.`.if(table[Table.Symbol.Schema])}${\n\t\t\t\tsql.identifier(table[Table.Symbol.OriginalName])\n\t\t\t} ${sql.identifier(table[Table.Symbol.Name])}`;\n\t\t}\n\n\t\tif (is(table, View) && table[ViewBaseConfig].isAlias) {\n\t\t\tlet fullName = sql`${sql.identifier(table[ViewBaseConfig].originalName)}`;\n\t\t\tif (table[ViewBaseConfig].schema) {\n\t\t\t\tfullName = sql`${sql.identifier(table[ViewBaseConfig].schema)}.${fullName}`;\n\t\t\t}\n\t\t\treturn sql`${fullName} ${sql.identifier(table[ViewBaseConfig].name)}`;\n\t\t}\n\n\t\treturn table;\n\t}\n\n\tbuildSelectQuery(\n\t\t{\n\t\t\twithList,\n\t\t\tfields,\n\t\t\tfieldsFlat,\n\t\t\twhere,\n\t\t\thaving,\n\t\t\ttable,\n\t\t\tjoins,\n\t\t\torderBy,\n\t\t\tgroupBy,\n\t\t\tlimit,\n\t\t\toffset,\n\t\t\tdistinct,\n\t\t\tsetOperators,\n\t\t}: SQLiteSelectConfig,\n\t): SQL {\n\t\tconst fieldsList = fieldsFlat ?? orderSelectedFields<SQLiteColumn>(fields);\n\t\tfor (const f of fieldsList) {\n\t\t\tif (\n\t\t\t\tis(f.field, Column)\n\t\t\t\t&& getTableName(f.field.table)\n\t\t\t\t\t!== (is(table, Subquery)\n\t\t\t\t\t\t? table._.alias\n\t\t\t\t\t\t: is(table, SQLiteViewBase)\n\t\t\t\t\t\t? table[ViewBaseConfig].name\n\t\t\t\t\t\t: is(table, SQL)\n\t\t\t\t\t\t? undefined\n\t\t\t\t\t\t: getTableName(table))\n\t\t\t\t&& !((table) =>\n\t\t\t\t\tjoins?.some(({ alias }) =>\n\t\t\t\t\t\talias === (table[Table.Symbol.IsAlias] ? getTableName(table) : table[Table.Symbol.BaseName])\n\t\t\t\t\t))(f.field.table)\n\t\t\t) {\n\t\t\t\tconst tableName = getTableName(f.field.table);\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`Your \"${\n\t\t\t\t\t\tf.path.join('->')\n\t\t\t\t\t}\" field references a column \"${tableName}\".\"${f.field.name}\", but the table \"${tableName}\" is not part of the query! Did you forget to join it?`,\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\tconst isSingleTable = !joins || joins.length === 0;\n\n\t\tconst withSql = this.buildWithCTE(withList);\n\n\t\tconst distinctSql = distinct ? sql` distinct` : undefined;\n\n\t\tconst selection = this.buildSelection(fieldsList, { isSingleTable });\n\n\t\tconst tableSql = this.buildFromTable(table);\n\n\t\tconst joinsSql = this.buildJoins(joins);\n\n\t\tconst whereSql = where ? sql` where ${where}` : undefined;\n\n\t\tconst havingSql = having ? sql` having ${having}` : undefined;\n\n\t\tconst groupByList: (SQL | AnyColumn | SQL.Aliased)[] = [];\n\t\tif (groupBy) {\n\t\t\tfor (const [index, groupByValue] of groupBy.entries()) {\n\t\t\t\tgroupByList.push(groupByValue);\n\n\t\t\t\tif (index < groupBy.length - 1) {\n\t\t\t\t\tgroupByList.push(sql`, `);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tconst groupBySql = groupByList.length > 0 ? sql` group by ${sql.join(groupByList)}` : undefined;\n\n\t\tconst orderBySql = this.buildOrderBy(orderBy);\n\n\t\tconst limitSql = this.buildLimit(limit);\n\n\t\tconst offsetSql = offset ? sql` offset ${offset}` : undefined;\n\n\t\tconst finalQuery =\n\t\t\tsql`${withSql}select${distinctSql} ${selection} from ${tableSql}${joinsSql}${whereSql}${groupBySql}${havingSql}${orderBySql}${limitSql}${offsetSql}`;\n\n\t\tif (setOperators.length > 0) {\n\t\t\treturn this.buildSetOperations(finalQuery, setOperators);\n\t\t}\n\n\t\treturn finalQuery;\n\t}\n\n\tbuildSetOperations(leftSelect: SQL, setOperators: SQLiteSelectConfig['setOperators']): SQL {\n\t\tconst [setOperator, ...rest] = setOperators;\n\n\t\tif (!setOperator) {\n\t\t\tthrow new Error('Cannot pass undefined values to any set operator');\n\t\t}\n\n\t\tif (rest.length === 0) {\n\t\t\treturn this.buildSetOperationQuery({ leftSelect, setOperator });\n\t\t}\n\n\t\t// Some recursive magic here\n\t\treturn this.buildSetOperations(\n\t\t\tthis.buildSetOperationQuery({ leftSelect, setOperator }),\n\t\t\trest,\n\t\t);\n\t}\n\n\tbuildSetOperationQuery({\n\t\tleftSelect,\n\t\tsetOperator: { type, isAll, rightSelect, limit, orderBy, offset },\n\t}: { leftSelect: SQL; setOperator: SQLiteSelectConfig['setOperators'][number] }): SQL {\n\t\t// SQLite doesn't support parenthesis in set operations\n\t\tconst leftChunk = sql`${leftSelect.getSQL()} `;\n\t\tconst rightChunk = sql`${rightSelect.getSQL()}`;\n\n\t\tlet orderBySql;\n\t\tif (orderBy && orderBy.length > 0) {\n\t\t\tconst orderByValues: (SQL<unknown> | Name)[] = [];\n\n\t\t\t// The next bit is necessary because the sql operator replaces ${table.column} with `table`.`column`\n\t\t\t// which is invalid Sql syntax, Table from one of the SELECTs cannot be used in global ORDER clause\n\t\t\tfor (const singleOrderBy of orderBy) {\n\t\t\t\tif (is(singleOrderBy, SQLiteColumn)) {\n\t\t\t\t\torderByValues.push(sql.identifier(singleOrderBy.name));\n\t\t\t\t} else if (is(singleOrderBy, SQL)) {\n\t\t\t\t\tfor (let i = 0; i < singleOrderBy.queryChunks.length; i++) {\n\t\t\t\t\t\tconst chunk = singleOrderBy.queryChunks[i];\n\n\t\t\t\t\t\tif (is(chunk, SQLiteColumn)) {\n\t\t\t\t\t\t\tsingleOrderBy.queryChunks[i] = sql.identifier(this.casing.getColumnCasing(chunk));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\torderByValues.push(sql`${singleOrderBy}`);\n\t\t\t\t} else {\n\t\t\t\t\torderByValues.push(sql`${singleOrderBy}`);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\torderBySql = sql` order by ${sql.join(orderByValues, sql`, `)}`;\n\t\t}\n\n\t\tconst limitSql = typeof limit === 'object' || (typeof limit === 'number' && limit >= 0)\n\t\t\t? sql` limit ${limit}`\n\t\t\t: undefined;\n\n\t\tconst operatorChunk = sql.raw(`${type} ${isAll ? 'all ' : ''}`);\n\n\t\tconst offsetSql = offset ? sql` offset ${offset}` : undefined;\n\n\t\treturn sql`${leftChunk}${operatorChunk}${rightChunk}${orderBySql}${limitSql}${offsetSql}`;\n\t}\n\n\tbuildInsertQuery(\n\t\t{ table, values: valuesOrSelect, onConflict, returning, withList, select }: SQLiteInsertConfig,\n\t): SQL {\n\t\t// const isSingleValue = values.length === 1;\n\t\tconst valuesSqlList: ((SQLChunk | SQL)[] | SQL)[] = [];\n\t\tconst columns: Record<string, SQLiteColumn> = table[Table.Symbol.Columns];\n\n\t\tconst colEntries: [string, SQLiteColumn][] = Object.entries(columns).filter(([_, col]) =>\n\t\t\t!col.shouldDisableInsert()\n\t\t);\n\t\tconst insertOrder = colEntries.map(([, column]) => sql.identifier(this.casing.getColumnCasing(column)));\n\n\t\tif (select) {\n\t\t\tconst select = valuesOrSelect as AnySQLiteSelectQueryBuilder | SQL;\n\n\t\t\tif (is(select, SQL)) {\n\t\t\t\tvaluesSqlList.push(select);\n\t\t\t} else {\n\t\t\t\tvaluesSqlList.push(select.getSQL());\n\t\t\t}\n\t\t} else {\n\t\t\tconst values = valuesOrSelect as Record<string, Param | SQL>[];\n\t\t\tvaluesSqlList.push(sql.raw('values '));\n\n\t\t\tfor (const [valueIndex, value] of values.entries()) {\n\t\t\t\tconst valueList: (SQLChunk | SQL)[] = [];\n\t\t\t\tfor (const [fieldName, col] of colEntries) {\n\t\t\t\t\tconst colValue = value[fieldName];\n\t\t\t\t\tif (colValue === undefined || (is(colValue, Param) && colValue.value === undefined)) {\n\t\t\t\t\t\tlet defaultValue;\n\t\t\t\t\t\tif (col.default !== null && col.default !== undefined) {\n\t\t\t\t\t\t\tdefaultValue = is(col.default, SQL) ? col.default : sql.param(col.default, col);\n\t\t\t\t\t\t\t// eslint-disable-next-line unicorn/no-negated-condition\n\t\t\t\t\t\t} else if (col.defaultFn !== undefined) {\n\t\t\t\t\t\t\tconst defaultFnResult = col.defaultFn();\n\t\t\t\t\t\t\tdefaultValue = is(defaultFnResult, SQL) ? defaultFnResult : sql.param(defaultFnResult, col);\n\t\t\t\t\t\t\t// eslint-disable-next-line unicorn/no-negated-condition\n\t\t\t\t\t\t} else if (!col.default && col.onUpdateFn !== undefined) {\n\t\t\t\t\t\t\tconst onUpdateFnResult = col.onUpdateFn();\n\t\t\t\t\t\t\tdefaultValue = is(onUpdateFnResult, SQL) ? onUpdateFnResult : sql.param(onUpdateFnResult, col);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tdefaultValue = sql`null`;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tvalueList.push(defaultValue);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvalueList.push(colValue);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tvaluesSqlList.push(valueList);\n\t\t\t\tif (valueIndex < values.length - 1) {\n\t\t\t\t\tvaluesSqlList.push(sql`, `);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tconst withSql = this.buildWithCTE(withList);\n\n\t\tconst valuesSql = sql.join(valuesSqlList);\n\n\t\tconst returningSql = returning\n\t\t\t? sql` returning ${this.buildSelection(returning, { isSingleTable: true })}`\n\t\t\t: undefined;\n\n\t\tconst onConflictSql = onConflict?.length\n\t\t\t? sql.join(onConflict)\n\t\t\t: undefined;\n\n\t\t// if (isSingleValue && valuesSqlList.length === 0){\n\t\t// \treturn sql`insert into ${table} default values ${onConflictSql}${returningSql}`;\n\t\t// }\n\n\t\treturn sql`${withSql}insert into ${table} ${insertOrder} ${valuesSql}${onConflictSql}${returningSql}`;\n\t}\n\n\tsqlToQuery(sql: SQL, invokeSource?: 'indexes' | undefined): QueryWithTypings {\n\t\treturn sql.toQuery({\n\t\t\tcasing: this.casing,\n\t\t\tescapeName: this.escapeName,\n\t\t\tescapeParam: this.escapeParam,\n\t\t\tescapeString: this.escapeString,\n\t\t\tinvokeSource,\n\t\t});\n\t}\n\n\t/** @deprecated */\n\t_buildRelationalQuery({\n\t\tfullSchema,\n\t\tschema,\n\t\ttableNamesMap,\n\t\ttable,\n\t\ttableConfig,\n\t\tqueryConfig: config,\n\t\ttableAlias,\n\t\tnestedQueryRelation,\n\t\tjoinOn,\n\t}: {\n\t\tfullSchema: Record<string, unknown>;\n\t\tschema: V1.TablesRelationalConfig;\n\t\ttableNamesMap: Record<string, string>;\n\t\ttable: SQLiteTable;\n\t\ttableConfig: V1.TableRelationalConfig;\n\t\tqueryConfig: true | V1.DBQueryConfig<'many', true>;\n\t\ttableAlias: string;\n\t\tnestedQueryRelation?: V1.Relation;\n\t\tjoinOn?: SQL;\n\t}): V1.BuildRelationalQueryResult<SQLiteTable, SQLiteColumn> {\n\t\tlet selection: V1.BuildRelationalQueryResult<SQLiteTable, SQLiteColumn>['selection'] = [];\n\t\tlet limit, offset, orderBy: SQLiteSelectConfig['orderBy'] = [], where;\n\t\tconst joins: SQLiteSelectJoinConfig[] = [];\n\n\t\tif (config === true) {\n\t\t\tconst selectionEntries = Object.entries(tableConfig.columns);\n\t\t\tselection = selectionEntries.map((\n\t\t\t\t[key, value],\n\t\t\t) => ({\n\t\t\t\tdbKey: value.name,\n\t\t\t\ttsKey: key,\n\t\t\t\tfield: aliasedTableColumn(value as SQLiteColumn, tableAlias),\n\t\t\t\trelationTableTsKey: undefined,\n\t\t\t\tisJson: false,\n\t\t\t\tselection: [],\n\t\t\t}));\n\t\t} else {\n\t\t\tconst aliasedColumns = Object.fromEntries(\n\t\t\t\tObject.entries(tableConfig.columns).map(([key, value]) => [key, aliasedTableColumn(value, tableAlias)]),\n\t\t\t);\n\n\t\t\tif (config.where) {\n\t\t\t\tconst whereSql = typeof config.where === 'function'\n\t\t\t\t\t? config.where(aliasedColumns, V1.getOperators())\n\t\t\t\t\t: config.where;\n\t\t\t\twhere = whereSql && mapColumnsInSQLToAlias(whereSql, tableAlias);\n\t\t\t}\n\n\t\t\tconst fieldsSelection: { tsKey: string; value: SQLiteColumn | SQL.Aliased }[] = [];\n\t\t\tlet selectedColumns: string[] = [];\n\n\t\t\t// Figure out which columns to select\n\t\t\tif (config.columns) {\n\t\t\t\tlet isIncludeMode = false;\n\n\t\t\t\tfor (const [field, value] of Object.entries(config.columns)) {\n\t\t\t\t\tif (value === undefined) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (field in tableConfig.columns) {\n\t\t\t\t\t\tif (!isIncludeMode && value === true) {\n\t\t\t\t\t\t\tisIncludeMode = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tselectedColumns.push(field);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (selectedColumns.length > 0) {\n\t\t\t\t\tselectedColumns = isIncludeMode\n\t\t\t\t\t\t? selectedColumns.filter((c) => config.columns?.[c] === true)\n\t\t\t\t\t\t: Object.keys(tableConfig.columns).filter((key) => !selectedColumns.includes(key));\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Select all columns if selection is not specified\n\t\t\t\tselectedColumns = Object.keys(tableConfig.columns);\n\t\t\t}\n\n\t\t\tfor (const field of selectedColumns) {\n\t\t\t\tconst column = tableConfig.columns[field]! as SQLiteColumn;\n\t\t\t\tfieldsSelection.push({ tsKey: field, value: column });\n\t\t\t}\n\n\t\t\tlet selectedRelations: {\n\t\t\t\ttsKey: string;\n\t\t\t\tqueryConfig: true | V1.DBQueryConfig<'many', false>;\n\t\t\t\trelation: V1.Relation;\n\t\t\t}[] = [];\n\n\t\t\t// Figure out which relations to select\n\t\t\tif (config.with) {\n\t\t\t\tselectedRelations = Object.entries(config.with)\n\t\t\t\t\t.filter((entry): entry is [typeof entry[0], NonNullable<typeof entry[1]>] => !!entry[1])\n\t\t\t\t\t.map(([tsKey, queryConfig]) => ({ tsKey, queryConfig, relation: tableConfig.relations[tsKey]! }));\n\t\t\t}\n\n\t\t\tlet extras;\n\n\t\t\t// Figure out which extras to select\n\t\t\tif (config.extras) {\n\t\t\t\textras = typeof config.extras === 'function'\n\t\t\t\t\t? config.extras(aliasedColumns, { sql })\n\t\t\t\t\t: config.extras;\n\t\t\t\tfor (const [tsKey, value] of Object.entries(extras)) {\n\t\t\t\t\tfieldsSelection.push({\n\t\t\t\t\t\ttsKey,\n\t\t\t\t\t\tvalue: mapColumnsInAliasedSQLToAlias(value, tableAlias),\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Transform `fieldsSelection` into `selection`\n\t\t\t// `fieldsSelection` shouldn't be used after this point\n\t\t\tfor (const { tsKey, value } of fieldsSelection) {\n\t\t\t\tselection.push({\n\t\t\t\t\tdbKey: is(value, SQL.Aliased) ? value.fieldAlias : tableConfig.columns[tsKey]!.name,\n\t\t\t\t\ttsKey,\n\t\t\t\t\tfield: is(value, Column) ? aliasedTableColumn(value, tableAlias) : value,\n\t\t\t\t\trelationTableTsKey: undefined,\n\t\t\t\t\tisJson: false,\n\t\t\t\t\tselection: [],\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tlet orderByOrig = typeof config.orderBy === 'function'\n\t\t\t\t? config.orderBy(aliasedColumns, V1.getOrderByOperators())\n\t\t\t\t: config.orderBy ?? [];\n\t\t\tif (!Array.isArray(orderByOrig)) {\n\t\t\t\torderByOrig = [orderByOrig];\n\t\t\t}\n\t\t\torderBy = orderByOrig.map((orderByValue) => {\n\t\t\t\tif (is(orderByValue, Column)) {\n\t\t\t\t\treturn aliasedTableColumn(orderByValue, tableAlias) as SQLiteColumn;\n\t\t\t\t}\n\t\t\t\treturn mapColumnsInSQLToAlias(orderByValue, tableAlias);\n\t\t\t});\n\n\t\t\tlimit = config.limit;\n\t\t\toffset = config.offset;\n\n\t\t\t// Process all relations\n\t\t\tfor (\n\t\t\t\tconst {\n\t\t\t\t\ttsKey: selectedRelationTsKey,\n\t\t\t\t\tqueryConfig: selectedRelationConfigValue,\n\t\t\t\t\trelation,\n\t\t\t\t} of selectedRelations\n\t\t\t) {\n\t\t\t\tconst normalizedRelation = V1.normalizeRelation(schema, tableNamesMap, relation);\n\t\t\t\tconst relationTableName = getTableUniqueName(relation.referencedTable);\n\t\t\t\tconst relationTableTsName = tableNamesMap[relationTableName]!;\n\t\t\t\tconst relationTableAlias = `${tableAlias}_${selectedRelationTsKey}`;\n\t\t\t\t// const relationTable = schema[relationTableTsName]!;\n\t\t\t\tconst joinOn = and(\n\t\t\t\t\t...normalizedRelation.fields.map((field, i) =>\n\t\t\t\t\t\teq(\n\t\t\t\t\t\t\taliasedTableColumn(normalizedRelation.references[i]!, relationTableAlias),\n\t\t\t\t\t\t\taliasedTableColumn(field, tableAlias),\n\t\t\t\t\t\t)\n\t\t\t\t\t),\n\t\t\t\t);\n\t\t\t\tconst builtRelation = this._buildRelationalQuery({\n\t\t\t\t\tfullSchema,\n\t\t\t\t\tschema,\n\t\t\t\t\ttableNamesMap,\n\t\t\t\t\ttable: fullSchema[relationTableTsName] as SQLiteTable,\n\t\t\t\t\ttableConfig: schema[relationTableTsName]!,\n\t\t\t\t\tqueryConfig: is(relation, V1.One)\n\t\t\t\t\t\t? (selectedRelationConfigValue === true\n\t\t\t\t\t\t\t? { limit: 1 }\n\t\t\t\t\t\t\t: { ...selectedRelationConfigValue, limit: 1 })\n\t\t\t\t\t\t: selectedRelationConfigValue,\n\t\t\t\t\ttableAlias: relationTableAlias,\n\t\t\t\t\tjoinOn,\n\t\t\t\t\tnestedQueryRelation: relation,\n\t\t\t\t});\n\t\t\t\tconst field = (sql`(${builtRelation.sql})`).as(selectedRelationTsKey);\n\t\t\t\tselection.push({\n\t\t\t\t\tdbKey: selectedRelationTsKey,\n\t\t\t\t\ttsKey: selectedRelationTsKey,\n\t\t\t\t\tfield,\n\t\t\t\t\trelationTableTsKey: relationTableTsName,\n\t\t\t\t\tisJson: true,\n\t\t\t\t\tselection: builtRelation.selection,\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\tif (selection.length === 0) {\n\t\t\tthrow new DrizzleError({\n\t\t\t\tmessage:\n\t\t\t\t\t`No fields selected for table \"${tableConfig.tsName}\" (\"${tableAlias}\"). You need to have at least one item in \"columns\", \"with\" or \"extras\". If you need to select all columns, omit the \"columns\" key or set it to undefined.`,\n\t\t\t});\n\t\t}\n\n\t\tlet result;\n\n\t\twhere = and(joinOn, where);\n\n\t\tif (nestedQueryRelation) {\n\t\t\tlet field = sql`json_array(${\n\t\t\t\tsql.join(\n\t\t\t\t\tselection.map(({ field }) =>\n\t\t\t\t\t\tis(field, SQLiteColumn)\n\t\t\t\t\t\t\t? sql.identifier(this.casing.getColumnCasing(field))\n\t\t\t\t\t\t\t: is(field, SQL.Aliased)\n\t\t\t\t\t\t\t? field.sql\n\t\t\t\t\t\t\t: field\n\t\t\t\t\t),\n\t\t\t\t\tsql`, `,\n\t\t\t\t)\n\t\t\t})`;\n\t\t\tif (is(nestedQueryRelation, V1.Many)) {\n\t\t\t\tfield = sql`coalesce(json_group_array(${field}), json_array())`;\n\t\t\t}\n\t\t\tconst nestedSelection = [{\n\t\t\t\tdbKey: 'data',\n\t\t\t\ttsKey: 'data',\n\t\t\t\tfield: field.as('data'),\n\t\t\t\tisJson: true,\n\t\t\t\trelationTableTsKey: tableConfig.tsName,\n\t\t\t\tselection,\n\t\t\t}];\n\n\t\t\tconst needsSubquery = limit !== undefined || offset !== undefined || orderBy.length > 0;\n\n\t\t\tif (needsSubquery) {\n\t\t\t\tresult = this.buildSelectQuery({\n\t\t\t\t\ttable: aliasedTable(table, tableAlias),\n\t\t\t\t\tfields: {},\n\t\t\t\t\tfieldsFlat: [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tpath: [],\n\t\t\t\t\t\t\tfield: sql.raw('*'),\n\t\t\t\t\t\t},\n\t\t\t\t\t],\n\t\t\t\t\twhere,\n\t\t\t\t\tlimit,\n\t\t\t\t\toffset,\n\t\t\t\t\torderBy,\n\t\t\t\t\tsetOperators: [],\n\t\t\t\t});\n\n\t\t\t\twhere = undefined;\n\t\t\t\tlimit = undefined;\n\t\t\t\toffset = undefined;\n\t\t\t\torderBy = undefined;\n\t\t\t} else {\n\t\t\t\tresult = aliasedTable(table, tableAlias);\n\t\t\t}\n\n\t\t\tresult = this.buildSelectQuery({\n\t\t\t\ttable: is(result, SQLiteTable) ? result : new Subquery(result, {}, tableAlias),\n\t\t\t\tfields: {},\n\t\t\t\tfieldsFlat: nestedSelection.map(({ field }) => ({\n\t\t\t\t\tpath: [],\n\t\t\t\t\tfield: is(field, Column) ? aliasedTableColumn(field, tableAlias) : field,\n\t\t\t\t})),\n\t\t\t\tjoins,\n\t\t\t\twhere,\n\t\t\t\tlimit,\n\t\t\t\toffset,\n\t\t\t\torderBy,\n\t\t\t\tsetOperators: [],\n\t\t\t});\n\t\t} else {\n\t\t\tresult = this.buildSelectQuery({\n\t\t\t\ttable: aliasedTable(table, tableAlias),\n\t\t\t\tfields: {},\n\t\t\t\tfieldsFlat: selection.map(({ field }) => ({\n\t\t\t\t\tpath: [],\n\t\t\t\t\tfield: is(field, Column) ? aliasedTableColumn(field, tableAlias) : field,\n\t\t\t\t})),\n\t\t\t\tjoins,\n\t\t\t\twhere,\n\t\t\t\tlimit,\n\t\t\t\toffset,\n\t\t\t\torderBy,\n\t\t\t\tsetOperators: [],\n\t\t\t});\n\t\t}\n\n\t\treturn {\n\t\t\ttableTsKey: tableConfig.tsName,\n\t\t\tsql: result,\n\t\t\tselection,\n\t\t};\n\t}\n\n\tprivate nestedSelectionerror() {\n\t\tthrow new DrizzleError({\n\t\t\tmessage: `Views with nested selections are not supported by the relational query builder`,\n\t\t});\n\t}\n\n\tprivate buildRqbColumn(table: Table | View, column: unknown, key: string) {\n\t\tif (is(column, Column)) {\n\t\t\tconst name = sql`${table}.${sql.identifier(this.casing.getColumnCasing(column))}`;\n\n\t\t\tswitch (column.columnType) {\n\t\t\t\tcase 'SQLiteBigInt':\n\t\t\t\tcase 'SQLiteBlobJson':\n\t\t\t\tcase 'SQLiteBlobBuffer': {\n\t\t\t\t\treturn sql`hex(${name}) as ${sql.identifier(key)}`;\n\t\t\t\t}\n\n\t\t\t\tcase 'SQLiteNumeric':\n\t\t\t\tcase 'SQLiteNumericNumber':\n\t\t\t\tcase 'SQLiteNumericBigInt': {\n\t\t\t\t\treturn sql`cast(${name} as text) as ${sql.identifier(key)}`;\n\t\t\t\t}\n\n\t\t\t\tcase 'SQLiteCustomColumn': {\n\t\t\t\t\treturn sql`${(<SQLiteCustomColumn<any>> column).jsonSelectIdentifier(name, sql)} as ${sql.identifier(key)}`;\n\t\t\t\t}\n\n\t\t\t\tdefault: {\n\t\t\t\t\treturn sql`${name} as ${sql.identifier(key)}`;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn sql`${table}.${\n\t\t\tis(column, SQL.Aliased)\n\t\t\t\t? sql.identifier(column.fieldAlias)\n\t\t\t\t: isSQLWrapper(column)\n\t\t\t\t? sql.identifier(key)\n\t\t\t\t: this.nestedSelectionerror()\n\t\t} as ${sql.identifier(key)}`;\n\t}\n\n\tprivate unwrapAllColumns = (table: Table | View, selection: BuildRelationalQueryResult['selection']) => {\n\t\treturn sql.join(\n\t\t\tObject.entries(table[TableColumns]).map(([k, v]) => {\n\t\t\t\tselection.push({\n\t\t\t\t\tkey: k,\n\t\t\t\t\tfield: v as Column | SQL | SQLWrapper | SQL.Aliased,\n\t\t\t\t});\n\n\t\t\t\treturn this.buildRqbColumn(table, v, k);\n\t\t\t}),\n\t\t\tsql`, `,\n\t\t);\n\t};\n\n\tprivate getSelectedTableColumns = (table: Table | View, columns: Record<string, boolean | undefined>) => {\n\t\tconst selectedColumns: ColumnWithTSName[] = [];\n\t\tconst columnContainer = table[TableColumns];\n\t\tconst entries = Object.entries(columns);\n\n\t\tlet colSelectionMode: boolean | undefined;\n\t\tfor (const [k, v] of entries) {\n\t\t\tif (v === undefined) continue;\n\t\t\tcolSelectionMode = colSelectionMode || v;\n\n\t\t\tif (v) {\n\t\t\t\tconst column = columnContainer[k]!;\n\n\t\t\t\tselectedColumns.push({\n\t\t\t\t\tcolumn: column as Column | SQL | SQLWrapper | SQL.Aliased,\n\t\t\t\t\ttsName: k,\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\tif (colSelectionMode === false) {\n\t\t\tfor (const [k, v] of Object.entries(columnContainer)) {\n\t\t\t\tif (columns[k] === false) continue;\n\n\t\t\t\tselectedColumns.push({\n\t\t\t\t\tcolumn: v as Column | SQL | SQLWrapper | SQL.Aliased | Table,\n\t\t\t\t\ttsName: k,\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\treturn selectedColumns;\n\t};\n\n\tprivate buildColumns = (\n\t\ttable: SQLiteTable | SQLiteView,\n\t\tselection: BuildRelationalQueryResult['selection'],\n\t\tparams?: DBQueryConfig<'many'>,\n\t) =>\n\t\tparams?.columns\n\t\t\t? (() => {\n\t\t\t\tconst columnIdentifiers: SQL[] = [];\n\n\t\t\t\tconst selectedColumns = this.getSelectedTableColumns(table, params?.columns);\n\n\t\t\t\tfor (const { column, tsName } of selectedColumns) {\n\t\t\t\t\tcolumnIdentifiers.push(this.buildRqbColumn(table, column, tsName));\n\t\t\t\t\tselection.push({\n\t\t\t\t\t\tkey: tsName,\n\t\t\t\t\t\tfield: column,\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\treturn columnIdentifiers.length\n\t\t\t\t\t? sql.join(columnIdentifiers, sql`, `)\n\t\t\t\t\t: undefined;\n\t\t\t})()\n\t\t\t: this.unwrapAllColumns(table, selection);\n\n\tbuildRelationalQuery(\n\t\t{\n\t\t\tschema,\n\t\t\ttable,\n\t\t\ttableConfig,\n\t\t\tqueryConfig: config,\n\t\t\trelationWhere,\n\t\t\tmode,\n\t\t\tisNested,\n\t\t\terrorPath,\n\t\t\tdepth,\n\t\t\tthroughJoin,\n\t\t\tjsonb,\n\t\t}: {\n\t\t\tschema: TablesRelationalConfig;\n\t\t\ttable: SQLiteTable | SQLiteView;\n\t\t\ttableConfig: TableRelationalConfig;\n\t\t\tqueryConfig?: DBQueryConfig<'many'> | true;\n\t\t\trelationWhere?: SQL;\n\t\t\tmode: 'first' | 'many';\n\t\t\tisNested?: boolean;\n\t\t\terrorPath?: string;\n\t\t\tdepth?: number;\n\t\t\tthroughJoin?: SQL;\n\t\t\tjsonb: SQL;\n\t\t},\n\t): BuildRelationalQueryResult {\n\t\tconst selection: BuildRelationalQueryResult['selection'] = [];\n\t\tconst isSingle = mode === 'first';\n\t\tconst params = config === true ? undefined : config;\n\t\tconst currentPath = errorPath ?? '';\n\t\tconst currentDepth = depth ?? 0;\n\t\tif (!currentDepth) table = aliasedTable(table, `d${currentDepth}`);\n\n\t\tconst limit = isSingle ? 1 : params?.limit;\n\t\tconst offset = params?.offset;\n\n\t\tconst columns = this.buildColumns(table, selection, params);\n\n\t\tconst where: SQL | undefined = (params?.where && relationWhere)\n\t\t\t? and(\n\t\t\t\trelationsFilterToSQL(table, params.where, tableConfig.relations, schema, this.casing),\n\t\t\t\trelationWhere,\n\t\t\t)\n\t\t\t: params?.where\n\t\t\t? relationsFilterToSQL(table, params.where, tableConfig.relations, schema, this.casing)\n\t\t\t: relationWhere;\n\t\tconst order = params?.orderBy ? relationsOrderToSQL(table, params.orderBy) : undefined;\n\t\tconst extras = params?.extras ? relationExtrasToSQL(table, params.extras) : undefined;\n\t\tif (extras) selection.push(...extras.selection);\n\n\t\tconst joins = params\n\t\t\t? (() => {\n\t\t\t\tconst { with: joins } = params as WithContainer;\n\t\t\t\tif (!joins) return;\n\n\t\t\t\tconst withEntries = Object.entries(joins).filter(([_, v]) => v);\n\t\t\t\tif (!withEntries.length) return;\n\n\t\t\t\treturn sql.join(\n\t\t\t\t\twithEntries.map(([k, join]) => {\n\t\t\t\t\t\t// if (is(tableConfig.relations[k]!, AggregatedField)) {\n\t\t\t\t\t\t// \tconst relation = tableConfig.relations[k]!;\n\n\t\t\t\t\t\t// \trelation.onTable(table);\n\t\t\t\t\t\t// \tconst query = relation.getSQL();\n\n\t\t\t\t\t\t// \tselection.push({\n\t\t\t\t\t\t// \t\tkey: k,\n\t\t\t\t\t\t// \t\tfield: relation,\n\t\t\t\t\t\t// \t});\n\n\t\t\t\t\t\t// \treturn sql`(${query}) as ${sql.identifier(k)}`;\n\t\t\t\t\t\t// }\n\n\t\t\t\t\t\tconst relation = tableConfig.relations[k]! as Relation;\n\t\t\t\t\t\tconst isSingle = is(relation, One);\n\t\t\t\t\t\tconst targetTable = aliasedTable(relation.targetTable, `d${currentDepth + 1}`);\n\t\t\t\t\t\tconst throughTable = relation.throughTable\n\t\t\t\t\t\t\t? aliasedTable(relation.throughTable, `tr${currentDepth}`)\n\t\t\t\t\t\t\t: undefined;\n\t\t\t\t\t\tconst { filter, joinCondition } = relationToSQL(\n\t\t\t\t\t\t\tthis.casing,\n\t\t\t\t\t\t\trelation,\n\t\t\t\t\t\t\ttable,\n\t\t\t\t\t\t\ttargetTable,\n\t\t\t\t\t\t\tthroughTable,\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tconst throughJoin = throughTable\n\t\t\t\t\t\t\t? sql` inner join ${getTableAsAliasSQL(throughTable)} on ${joinCondition!}`\n\t\t\t\t\t\t\t: undefined;\n\n\t\t\t\t\t\tconst innerQuery = this.buildRelationalQuery({\n\t\t\t\t\t\t\ttable: targetTable as SQLiteTable | SQLiteView,\n\t\t\t\t\t\t\tmode: isSingle ? 'first' : 'many',\n\t\t\t\t\t\t\tschema,\n\t\t\t\t\t\t\tqueryConfig: join as DBQueryConfig,\n\t\t\t\t\t\t\ttableConfig: schema[relation.targetTableName]!,\n\t\t\t\t\t\t\trelationWhere: filter,\n\t\t\t\t\t\t\tisNested: true,\n\t\t\t\t\t\t\terrorPath: `${currentPath.length ? `${currentPath}.` : ''}${k}`,\n\t\t\t\t\t\t\tdepth: currentDepth + 1,\n\t\t\t\t\t\t\tthroughJoin,\n\t\t\t\t\t\t\tjsonb,\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\tselection.push({\n\t\t\t\t\t\t\tfield: targetTable,\n\t\t\t\t\t\t\tkey: k,\n\t\t\t\t\t\t\tselection: innerQuery.selection,\n\t\t\t\t\t\t\tisArray: !isSingle,\n\t\t\t\t\t\t\tisOptional: ((relation as AnyOne).optional ?? false)\n\t\t\t\t\t\t\t\t|| (join !== true && !!(join as Exclude<typeof join, boolean | undefined>).where),\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\tconst jsonColumns = sql.join(\n\t\t\t\t\t\t\tinnerQuery.selection.map((s) => {\n\t\t\t\t\t\t\t\treturn sql`${sql.raw(this.escapeString(s.key))}, ${\n\t\t\t\t\t\t\t\t\ts.selection ? sql`${jsonb}(${sql.identifier(s.key)})` : sql.identifier(s.key)\n\t\t\t\t\t\t\t\t}`;\n\t\t\t\t\t\t\t}),\n\t\t\t\t\t\t\tsql`, `,\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tconst json = isNested ? jsonb : sql`json`;\n\n\t\t\t\t\t\tconst joinQuery = isSingle\n\t\t\t\t\t\t\t? sql`(select ${json}_object(${jsonColumns}) as ${sql.identifier('r')} from (${innerQuery.sql}) as ${\n\t\t\t\t\t\t\t\tsql.identifier('t')\n\t\t\t\t\t\t\t}) as ${sql.identifier(k)}`\n\t\t\t\t\t\t\t: sql`coalesce((select ${json}_group_array(json_object(${jsonColumns})) as ${\n\t\t\t\t\t\t\t\tsql.identifier('r')\n\t\t\t\t\t\t\t} from (${innerQuery.sql}) as ${sql.identifier('t')}), ${jsonb}_array()) as ${sql.identifier(k)}`;\n\n\t\t\t\t\t\treturn joinQuery;\n\t\t\t\t\t}),\n\t\t\t\t\tsql`, `,\n\t\t\t\t);\n\t\t\t})()\n\t\t\t: undefined;\n\n\t\tconst selectionArr = [columns, extras?.sql, joins].filter((e) => e !== undefined);\n\t\tif (!selectionArr.length) {\n\t\t\tthrow new DrizzleError({\n\t\t\t\tmessage: `No fields selected for table \"${tableConfig.name}\"${currentPath ? ` (\"${currentPath}\")` : ''}`,\n\t\t\t});\n\t\t}\n\t\tconst selectionSet = sql.join(selectionArr, sql`, `);\n\n\t\tconst query = sql`select ${selectionSet} from ${getTableAsAliasSQL(table)}${throughJoin}${\n\t\t\tsql` where ${where}`.if(where)\n\t\t}${sql` order by ${order}`.if(order)}${sql` limit ${limit}`.if(limit !== undefined)}${\n\t\t\tsql` offset ${offset}`.if(offset !== undefined)\n\t\t}`;\n\n\t\treturn {\n\t\t\tsql: query,\n\t\t\tselection,\n\t\t};\n\t}\n}\n\nexport class SQLiteSyncDialect extends SQLiteDialect {\n\tstatic override readonly [entityKind]: string = 'SQLiteSyncDialect';\n\n\tmigrate(\n\t\tmigrations: MigrationMeta[],\n\t\tsession: SQLiteSession<\n\t\t\t'sync',\n\t\t\tunknown,\n\t\t\tRecord<string, unknown>,\n\t\t\tAnyRelations,\n\t\t\tV1.TablesRelationalConfig\n\t\t>,\n\t\tconfig?: string | Omit<MigrationConfig, 'migrationsFolder'>,\n\t): void | MigratorInitFailResponse {\n\t\tconst migrationsTable = config === undefined\n\t\t\t? '__drizzle_migrations'\n\t\t\t: typeof config === 'string'\n\t\t\t? '__drizzle_migrations'\n\t\t\t: config.migrationsTable ?? '__drizzle_migrations';\n\n\t\tconst migrationTableCreate = sql`\n\t\t\tCREATE TABLE IF NOT EXISTS ${sql.identifier(migrationsTable)} (\n\t\t\t\tid SERIAL PRIMARY KEY,\n\t\t\t\thash text NOT NULL,\n\t\t\t\tcreated_at numeric\n\t\t\t)\n\t\t`;\n\t\tsession.run(migrationTableCreate);\n\n\t\tconst dbMigrations = session.values<[number, string, string]>(\n\t\t\tsql`SELECT id, hash, created_at FROM ${sql.identifier(migrationsTable)} ORDER BY created_at DESC LIMIT 1`,\n\t\t);\n\n\t\tif (typeof config === 'object' && config.init) {\n\t\t\tif (dbMigrations.length) {\n\t\t\t\treturn { exitCode: 'databaseMigrations' as const };\n\t\t\t}\n\n\t\t\tif (migrations.length > 1) {\n\t\t\t\treturn { exitCode: 'localMigrations' as const };\n\t\t\t}\n\n\t\t\tconst [migration] = migrations;\n\n\t\t\tif (!migration) return;\n\n\t\t\tsession.run(\n\t\t\t\tsql`insert into ${\n\t\t\t\t\tsql.identifier(migrationsTable)\n\t\t\t\t} (\"hash\", \"created_at\") values(${migration.hash}, ${migration.folderMillis})`,\n\t\t\t);\n\n\t\t\treturn;\n\t\t}\n\n\t\tconst lastDbMigration = dbMigrations[0] ?? undefined;\n\t\tsession.run(sql`BEGIN`);\n\n\t\ttry {\n\t\t\tfor (const migration of migrations) {\n\t\t\t\tif (!lastDbMigration || Number(lastDbMigration[2])! < migration.folderMillis) {\n\t\t\t\t\tfor (const stmt of migration.sql) {\n\t\t\t\t\t\tsession.run(sql.raw(stmt));\n\t\t\t\t\t}\n\t\t\t\t\tsession.run(\n\t\t\t\t\t\tsql`INSERT INTO ${\n\t\t\t\t\t\t\tsql.identifier(migrationsTable)\n\t\t\t\t\t\t} (\"hash\", \"created_at\") VALUES(${migration.hash}, ${migration.folderMillis})`,\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tsession.run(sql`COMMIT`);\n\t\t} catch (e) {\n\t\t\tsession.run(sql`ROLLBACK`);\n\t\t\tthrow e;\n\t\t}\n\t}\n}\n\nexport class SQLiteAsyncDialect extends SQLiteDialect {\n\tstatic override readonly [entityKind]: string = 'SQLiteAsyncDialect';\n\n\tasync migrate(\n\t\tmigrations: MigrationMeta[],\n\t\tsession: SQLiteSession<\n\t\t\t'async',\n\t\t\tunknown,\n\t\t\tRecord<string, unknown>,\n\t\t\tAnyRelations,\n\t\t\tV1.TablesRelationalConfig\n\t\t>,\n\t\tconfig?: string | Omit<MigrationConfig, 'migrationsFolder'>,\n\t): Promise<void | MigratorInitFailResponse> {\n\t\tconst migrationsTable = config === undefined\n\t\t\t? '__drizzle_migrations'\n\t\t\t: typeof config === 'string'\n\t\t\t? '__drizzle_migrations'\n\t\t\t: config.migrationsTable ?? '__drizzle_migrations';\n\n\t\tconst migrationTableCreate = sql`\n\t\t\tCREATE TABLE IF NOT EXISTS ${sql.identifier(migrationsTable)} (\n\t\t\t\tid INTEGER PRIMARY KEY,\n\t\t\t\thash text NOT NULL,\n\t\t\t\tcreated_at numeric\n\t\t\t)\n\t\t`;\n\t\tawait session.run(migrationTableCreate);\n\n\t\tconst dbMigrations = await session.values<[number, string, string]>(\n\t\t\tsql`SELECT id, hash, created_at FROM ${sql.identifier(migrationsTable)} ORDER BY created_at DESC LIMIT 1`,\n\t\t);\n\n\t\tif (typeof config === 'object' && config.init) {\n\t\t\tif (dbMigrations.length) {\n\t\t\t\treturn { exitCode: 'databaseMigrations' as const };\n\t\t\t}\n\n\t\t\tif (migrations.length > 1) {\n\t\t\t\treturn { exitCode: 'localMigrations' as const };\n\t\t\t}\n\n\t\t\tconst [migration] = migrations;\n\n\t\t\tif (!migration) return;\n\n\t\t\tawait session.run(\n\t\t\t\tsql`insert into ${\n\t\t\t\t\tsql.identifier(migrationsTable)\n\t\t\t\t} (\"hash\", \"created_at\") values(${migration.hash}, ${migration.folderMillis})`,\n\t\t\t);\n\n\t\t\treturn;\n\t\t}\n\n\t\tconst lastDbMigration = dbMigrations[0] ?? undefined;\n\t\tawait session.transaction(async (tx) => {\n\t\t\tfor (const migration of migrations) {\n\t\t\t\tif (!lastDbMigration || Number(lastDbMigration[2])! < migration.folderMillis) {\n\t\t\t\t\tfor (const stmt of migration.sql) {\n\t\t\t\t\t\tawait tx.run(sql.raw(stmt));\n\t\t\t\t\t}\n\t\t\t\t\tawait tx.run(\n\t\t\t\t\t\tsql`INSERT INTO ${\n\t\t\t\t\t\t\tsql.identifier(migrationsTable)\n\t\t\t\t\t\t} (\"hash\", \"created_at\") VALUES(${migration.hash}, ${migration.folderMillis})`,\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n}\n"],"mappings":"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"}