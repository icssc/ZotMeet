{"version":3,"sources":["../../../../../src/build/webpack/loaders/next-metadata-route-loader.ts"],"sourcesContent":["import type webpack from 'webpack'\nimport fs from 'fs'\nimport path from 'path'\nimport { imageExtMimeTypeMap } from '../../../lib/mime-type'\nimport { getLoaderModuleNamedExports } from './utils'\nimport { installBindings } from '../../swc/install-bindings'\n\nfunction errorOnBadHandler(resourcePath: string) {\n  return `\n  if (typeof handler !== 'function') {\n    throw new Error('Default export is missing in ${JSON.stringify(\n      resourcePath\n    )}')\n  }\n  `\n}\n\n/* re-export the userland route configs */\nasync function createReExportsCode(\n  resourcePath: string,\n  loaderContext: webpack.LoaderContext<any>\n) {\n  const exportNames = await getLoaderModuleNamedExports(\n    resourcePath,\n    loaderContext\n  )\n  // Re-export configs but avoid conflicted exports\n  const reExportNames = exportNames.filter(\n    (name) =>\n      name !== 'default' &&\n      name !== 'generateSitemaps' &&\n      name !== 'dynamicParams'\n  )\n\n  return reExportNames.length > 0\n    ? `export { ${reExportNames.join(', ')} } from ${JSON.stringify(\n        resourcePath\n      )}\\n`\n    : ''\n}\n\nconst CACHE_HEADERS = {\n  NO_CACHE: 'no-cache, no-store',\n  REVALIDATE: 'public, max-age=0, must-revalidate',\n}\n\nexport type MetadataRouteLoaderOptions = {\n  // Using separate argument to avoid json being parsed and hit error\n  // x-ref: https://github.com/vercel/next.js/pull/62615\n  filePath: string\n  isDynamicRouteExtension: '1' | '0'\n}\n\nexport function getFilenameAndExtension(resourcePath: string) {\n  const filename = path.basename(resourcePath)\n  const [name, ext] = filename.split('.', 2)\n  return {\n    name,\n    ext,\n  }\n}\n\nfunction getContentType(resourcePath: string) {\n  let { name, ext } = getFilenameAndExtension(resourcePath)\n  if (ext === 'jpg') ext = 'jpeg'\n\n  if (name === 'favicon' && ext === 'ico') return 'image/x-icon'\n  if (name === 'sitemap') return 'application/xml'\n  if (name === 'robots') return 'text/plain'\n  if (name === 'manifest') return 'application/manifest+json'\n\n  if (ext === 'png' || ext === 'jpeg' || ext === 'ico' || ext === 'svg') {\n    return imageExtMimeTypeMap[ext]\n  }\n  return 'text/plain'\n}\n\nasync function getStaticAssetRouteCode(\n  resourcePath: string,\n  fileBaseName: string\n) {\n  const cache =\n    process.env.NODE_ENV !== 'production'\n      ? CACHE_HEADERS.NO_CACHE\n      : CACHE_HEADERS.REVALIDATE\n\n  const isTwitter = fileBaseName === 'twitter-image'\n  const isOpenGraph = fileBaseName === 'opengraph-image'\n  // Twitter image file size limit is 5MB.\n  // General Open Graph image file size limit is 8MB.\n  // x-ref: https://developer.x.com/en/docs/x-for-websites/cards/overview/summary\n  // x-ref(facebook): https://developers.facebook.com/docs/sharing/webmasters/images\n  const fileSizeLimit = isTwitter ? 5 : 8\n  const imgName = isTwitter ? 'Twitter' : 'Open Graph'\n\n  const code = `\\\n/* static asset route */\nimport { NextResponse } from 'next/server'\n\nconst contentType = ${JSON.stringify(getContentType(resourcePath))}\nconst buffer = Buffer.from(${JSON.stringify(\n    (await fs.promises.readFile(resourcePath)).toString('base64')\n  )}, 'base64'\n  )\n\nif (${isTwitter || isOpenGraph}) {\n  const fileSizeInMB = buffer.byteLength / 1024 / 1024\n  if (fileSizeInMB > ${fileSizeLimit}) {\n    throw new Error('File size for ${imgName} image ${JSON.stringify(resourcePath)} exceeds ${fileSizeLimit}MB. ' +\n    \\`(Current: \\${fileSizeInMB.toFixed(2)}MB)\\n\\` +\n    'Read more: https://nextjs.org/docs/app/api-reference/file-conventions/metadata/opengraph-image#image-files-jpg-png-gif'\n    )\n  }\n}\n\nexport function GET() {\n  return new NextResponse(buffer, {\n    headers: {\n      'Content-Type': contentType,\n      'Cache-Control': ${JSON.stringify(cache)},\n    },\n  })\n}\n\nexport const dynamic = 'force-static'\n`\n  return code\n}\n\nasync function getDynamicTextRouteCode(\n  resourcePath: string,\n  loaderContext: webpack.LoaderContext<any>\n) {\n  return `\\\n/* dynamic asset route */\nimport { NextResponse } from 'next/server'\nimport handler from ${JSON.stringify(resourcePath)}\nimport { resolveRouteData } from 'next/dist/build/webpack/loaders/metadata/resolve-route-data'\n\nconst contentType = ${JSON.stringify(getContentType(resourcePath))}\nconst fileType = ${JSON.stringify(getFilenameAndExtension(resourcePath).name)}\n\n${errorOnBadHandler(resourcePath)}\n${await createReExportsCode(resourcePath, loaderContext)}\n\nexport async function GET() {\n  const data = await handler()\n  const content = resolveRouteData(data, fileType)\n\n  return new NextResponse(content, {\n    headers: {\n      'Content-Type': contentType,\n      'Cache-Control': ${JSON.stringify(CACHE_HEADERS.REVALIDATE)},\n    },\n  })\n}\n`\n}\n\nasync function getDynamicImageRouteCode(\n  resourcePath: string,\n  loaderContext: webpack.LoaderContext<any>\n) {\n  return `\\\n/* dynamic image route with generateImageMetadata */\nimport { NextResponse } from 'next/server'\nimport { default as handler, generateImageMetadata } from ${JSON.stringify(resourcePath)}\n\n${errorOnBadHandler(resourcePath)}\n${await createReExportsCode(resourcePath, loaderContext)}\n\nexport async function GET(_, ctx) {\n  const paramsPromise = ctx.params\n  const idPromise = paramsPromise.then(params => params?.__metadata_id__)\n  const restParamsPromise = paramsPromise.then(params => {\n    if (!params) return undefined\n    const { __metadata_id__, ...rest } = params\n    return rest\n  })\n\n  const restParams = await restParamsPromise\n  const __metadata_id__ = await idPromise\n  const imageMetadata = await generateImageMetadata({ params: restParams })\n  const id = imageMetadata.find((item) => {\n    if (item?.id == null) {\n      throw new Error('id property is required for every item returned from generateImageMetadata')\n    }\n\n    return item.id.toString() === __metadata_id__\n  })?.id\n\n  if (id == null) {\n    return new NextResponse('Not Found', {\n      status: 404,\n    })\n  }\n\n  return handler({ params: restParamsPromise, id: idPromise })\n}\n\nexport async function generateStaticParams({ params }) {\n  const imageMetadata = await generateImageMetadata({ params })\n  const staticParams = []\n\n  for (const item of imageMetadata) {\n    if (item?.id == null) {\n      throw new Error('id property is required for every item returned from generateImageMetadata')\n    }\n    staticParams.push({ __metadata_id__: item.id.toString() })\n  }\n  return staticParams\n}\n`\n}\n\nasync function getSingleImageRouteCode(\n  resourcePath: string,\n  loaderContext: webpack.LoaderContext<any>\n) {\n  return `\\\n/* dynamic image route without generateImageMetadata */\nimport { NextResponse } from 'next/server'\nimport { default as handler } from ${JSON.stringify(resourcePath)}\n\n${errorOnBadHandler(resourcePath)}\n${await createReExportsCode(resourcePath, loaderContext)}\n\nexport async function GET(_, ctx) {\n  return handler({ params: ctx.params })\n}\n`\n}\n\n// <metadata-image>/[id]/route.js\nasync function getImageRouteCode(\n  resourcePath: string,\n  loaderContext: webpack.LoaderContext<any>\n) {\n  const exportNames = await getLoaderModuleNamedExports(\n    resourcePath,\n    loaderContext\n  )\n\n  const hasGenerateParamsExport = exportNames.includes('generateImageMetadata')\n\n  if (hasGenerateParamsExport) {\n    return getDynamicImageRouteCode(resourcePath, loaderContext)\n  } else {\n    return getSingleImageRouteCode(resourcePath, loaderContext)\n  }\n}\n\nasync function getSingleSitemapRouteCode(\n  resourcePath: string,\n  loaderContext: webpack.LoaderContext<any>\n) {\n  return `\\\n/* single sitemap route */\nimport { NextResponse } from 'next/server'\nimport { default as handler } from ${JSON.stringify(resourcePath)}\nimport { resolveRouteData } from 'next/dist/build/webpack/loaders/metadata/resolve-route-data'\n\nconst contentType = ${JSON.stringify(getContentType(resourcePath))}\nconst fileType = ${JSON.stringify(getFilenameAndExtension(resourcePath).name)}\n\n${errorOnBadHandler(resourcePath)}\n${await createReExportsCode(resourcePath, loaderContext)}\n\nexport async function GET() {\n  const data = await handler()\n  const content = resolveRouteData(data, fileType)\n\n  return new NextResponse(content, {\n    headers: {\n      'Content-Type': contentType,\n      'Cache-Control': ${JSON.stringify(CACHE_HEADERS.REVALIDATE)},\n    },\n  })\n}\n`\n}\n\nasync function getDynamicSitemapRouteCode(\n  resourcePath: string,\n  loaderContext: webpack.LoaderContext<any>\n) {\n  const code = `\\\n/* dynamic sitemap route with generateSitemaps */\nimport { NextResponse } from 'next/server'\nimport { default as handler, generateSitemaps } from ${JSON.stringify(resourcePath)}\nimport { resolveRouteData } from 'next/dist/build/webpack/loaders/metadata/resolve-route-data'\n\nconst contentType = ${JSON.stringify(getContentType(resourcePath))}\nconst fileType = ${JSON.stringify(getFilenameAndExtension(resourcePath).name)}\n\n${errorOnBadHandler(resourcePath)}\n${await createReExportsCode(resourcePath, loaderContext)}\n\nexport async function GET(_, ctx) {\n  const paramsPromise = ctx.params\n  const idPromise = paramsPromise.then(params => params?.__metadata_id__)\n\n  const id = await idPromise\n  const hasXmlExtension = id ? id.endsWith('.xml') : false\n  const sitemaps = await generateSitemaps()\n  let foundId\n  for (const item of sitemaps) {\n    if (item?.id == null) {\n      throw new Error('id property is required for every item returned from generateSitemaps')\n    }\n\n    const baseId = id && hasXmlExtension ? id.slice(0, -4) : undefined\n    if (item.id.toString() === baseId) {\n      foundId = item.id\n    }\n  }\n  if (foundId == null) {\n    return new NextResponse('Not Found', {\n      status: 404,\n    })\n  }\n\n  const targetIdPromise = idPromise.then(id => {\n    const hasXmlExtension = id ? id.endsWith('.xml') : false\n    return id && hasXmlExtension ? id.slice(0, -4) : undefined\n  })\n  const data = await handler({ id: targetIdPromise })\n  const content = resolveRouteData(data, fileType)\n\n  return new NextResponse(content, {\n    headers: {\n      'Content-Type': contentType,\n      'Cache-Control': ${JSON.stringify(CACHE_HEADERS.REVALIDATE)},\n    },\n  })\n}\n\nexport async function generateStaticParams() {\n  const sitemaps = await generateSitemaps()\n  const params = []\n\n  for (const item of sitemaps) {\n    if (item?.id == null) {\n      throw new Error('id property is required for every item returned from generateSitemaps')\n    }\n    params.push({ __metadata_id__: item.id.toString() + '.xml' })\n  }\n  return params\n}\n`\n  return code\n}\n\n// <metadata-sitemap>/[id]/route.js\nasync function getSitemapRouteCode(\n  resourcePath: string,\n  loaderContext: webpack.LoaderContext<any>\n) {\n  const exportNames = await getLoaderModuleNamedExports(\n    resourcePath,\n    loaderContext\n  )\n\n  const hasGenerateSitemaps = exportNames.includes('generateSitemaps')\n\n  if (hasGenerateSitemaps) {\n    return getDynamicSitemapRouteCode(resourcePath, loaderContext)\n  } else {\n    return getSingleSitemapRouteCode(resourcePath, loaderContext)\n  }\n}\n\n// When it's static route, it could be favicon.ico, sitemap.xml, robots.txt etc.\n// TODO-METADATA: improve the cache control strategy\nconst nextMetadataRouterLoader: webpack.LoaderDefinitionFunction<MetadataRouteLoaderOptions> =\n  async function () {\n    // Install bindings early so they are definitely available to the loader.\n    // When run by webpack in next this is already done with correct configuration so this is a no-op.\n    // In turbopack loaders are run in a subprocess so it may or may not be done.\n    await installBindings()\n    const { isDynamicRouteExtension, filePath } = this.getOptions()\n    const { name: fileBaseName } = getFilenameAndExtension(filePath)\n    this.addDependency(filePath)\n\n    let code = ''\n    if (isDynamicRouteExtension === '1') {\n      if (fileBaseName === 'robots' || fileBaseName === 'manifest') {\n        code = await getDynamicTextRouteCode(filePath, this)\n      } else if (fileBaseName === 'sitemap') {\n        code = await getSitemapRouteCode(filePath, this)\n      } else {\n        code = await getImageRouteCode(filePath, this)\n      }\n    } else {\n      code = await getStaticAssetRouteCode(filePath, fileBaseName)\n    }\n\n    return code\n  }\n\nexport default nextMetadataRouterLoader\n"],"names":["fs","path","imageExtMimeTypeMap","getLoaderModuleNamedExports","installBindings","errorOnBadHandler","resourcePath","JSON","stringify","createReExportsCode","loaderContext","exportNames","reExportNames","filter","name","length","join","CACHE_HEADERS","NO_CACHE","REVALIDATE","getFilenameAndExtension","filename","basename","ext","split","getContentType","getStaticAssetRouteCode","fileBaseName","cache","process","env","NODE_ENV","isTwitter","isOpenGraph","fileSizeLimit","imgName","code","promises","readFile","toString","getDynamicTextRouteCode","getDynamicImageRouteCode","getSingleImageRouteCode","getImageRouteCode","hasGenerateParamsExport","includes","getSingleSitemapRouteCode","getDynamicSitemapRouteCode","getSitemapRouteCode","hasGenerateSitemaps","nextMetadataRouterLoader","isDynamicRouteExtension","filePath","getOptions","addDependency"],"mappings":"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","ignoreList":[0]}