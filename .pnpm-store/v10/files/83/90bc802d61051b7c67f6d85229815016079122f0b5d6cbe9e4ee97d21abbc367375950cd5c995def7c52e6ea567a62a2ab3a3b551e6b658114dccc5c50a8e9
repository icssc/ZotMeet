{"version":3,"file":"testing.js","names":["searchParams"],"sources":["../../src/adapters/testing.ts"],"sourcesContent":["import {\n  createElement,\n  useCallback,\n  useEffect,\n  useRef,\n  useState,\n  type ReactElement,\n  type ReactNode\n} from 'react'\nimport { resetQueues } from '../lib/queues/reset'\nimport { renderQueryString } from './custom'\nimport { context, type AdapterProps } from './lib/context'\nimport type { AdapterInterface, AdapterOptions } from './lib/defs'\n\nexport type UrlUpdateEvent = {\n  searchParams: URLSearchParams\n  queryString: string\n  options: Required<AdapterOptions>\n}\n\nexport type OnUrlUpdateFunction = (event: UrlUpdateEvent) => void\n\ntype TestingAdapterProps = Pick<AdapterInterface, 'autoResetQueueOnUpdate'> & {\n  /**\n   * An initial value for the search params.\n   */\n  searchParams?: string | Record<string, string> | URLSearchParams\n\n  /**\n   * A function that will be called whenever the URL is updated.\n   * Connect that to a spy in your tests to assert the URL updates.\n   */\n  onUrlUpdate?: OnUrlUpdateFunction\n\n  /**\n   * Internal: enable throttling during tests.\n   *\n   * @default 0 (no throttling)\n   */\n  rateLimitFactor?: number\n\n  /**\n   * Internal: Whether to reset the url update queue on mount.\n   *\n   * Since the update queue is a shared global, each test clears\n   * it on mount to avoid interference between tests.\n   *\n   * @default true\n   */\n  resetUrlUpdateQueueOnMount?: boolean\n\n  /**\n   * If true, the adapter will store the search params in memory and\n   * update that memory on each updateUrl call, to simulate a real adapter.\n   *\n   * Otherwise, the search params will be frozen to the initial value.\n   *\n   * @default false\n   */\n  hasMemory?: boolean\n\n  children: ReactNode\n} & AdapterProps\n\nfunction renderInitialSearchParams(\n  searchParams: TestingAdapterProps['searchParams']\n): string {\n  if (!searchParams) {\n    return ''\n  }\n  if (typeof searchParams === 'string') {\n    return searchParams\n  }\n  if (searchParams instanceof URLSearchParams) {\n    return searchParams.toString()\n  }\n  return new URLSearchParams(searchParams).toString()\n}\n\nexport function NuqsTestingAdapter({\n  resetUrlUpdateQueueOnMount = true,\n  autoResetQueueOnUpdate = true,\n  defaultOptions,\n  processUrlSearchParams,\n  rateLimitFactor = 0,\n  hasMemory = false,\n  onUrlUpdate,\n  children,\n  searchParams: initialSearchParams = ''\n}: TestingAdapterProps): ReactElement {\n  const renderedInitialSearchParams =\n    renderInitialSearchParams(initialSearchParams)\n  // Simulate a central location.search in memory\n  // for the getSearchParamsSnapshot to be referentially stable.\n  const locationSearchRef = useRef(renderedInitialSearchParams)\n  if (resetUrlUpdateQueueOnMount) {\n    resetQueues()\n  }\n  const [searchParams, setSearchParams] = useState(\n    () => new URLSearchParams(locationSearchRef.current)\n  )\n  useEffect(() => {\n    if (!hasMemory) {\n      return\n    }\n    const synced = new URLSearchParams(initialSearchParams)\n    setSearchParams(synced)\n    locationSearchRef.current = synced.toString()\n  }, [hasMemory, renderedInitialSearchParams])\n  const updateUrl = useCallback<AdapterInterface['updateUrl']>(\n    (search, options) => {\n      const queryString = renderQueryString(search)\n      const searchParams = new URLSearchParams(search) // make a copy\n      if (hasMemory) {\n        setSearchParams(searchParams)\n        locationSearchRef.current = queryString\n      }\n      onUrlUpdate?.({\n        searchParams,\n        queryString,\n        options\n      })\n    },\n    [onUrlUpdate, hasMemory]\n  )\n  const getSearchParamsSnapshot = useCallback(() => {\n    return new URLSearchParams(locationSearchRef.current)\n  }, [renderedInitialSearchParams])\n  const useAdapter = (): AdapterInterface => ({\n    searchParams,\n    updateUrl,\n    getSearchParamsSnapshot,\n    rateLimitFactor,\n    autoResetQueueOnUpdate\n  })\n  return createElement(\n    context.Provider,\n    { value: { useAdapter, defaultOptions, processUrlSearchParams } },\n    children\n  )\n}\n\n/**\n * A higher order component that wraps the children with the NuqsTestingAdapter\n *\n * It allows creating wrappers for testing purposes by providing only the\n * necessary props to the NuqsTestingAdapter.\n *\n * Usage:\n * ```tsx\n * render(<MyComponent />, {\n *   wrapper: withNuqsTestingAdapter({ searchParams: '?foo=bar' })\n * })\n * ```\n */\nexport function withNuqsTestingAdapter(\n  props: Omit<TestingAdapterProps, 'children'> = {}\n) {\n  return function NuqsTestingAdapterWrapper({\n    children\n  }: {\n    children: ReactNode\n  }): ReactElement {\n    return createElement(\n      NuqsTestingAdapter,\n      // @ts-expect-error - Ignore missing children error\n      props,\n      children\n    )\n  }\n}\n"],"mappings":";;;;;;;;;AAgEA,SAAS,0BACP,cACQ;AACR,KAAI,CAAC,aACH,QAAO;AAET,KAAI,OAAO,iBAAiB,SAC1B,QAAO;AAET,KAAI,wBAAwB,gBAC1B,QAAO,aAAa,UAAU;AAEhC,QAAO,IAAI,gBAAgB,aAAa,CAAC,UAAU;;AAGrD,SAAgB,mBAAmB,EACjC,6BAA6B,MAC7B,yBAAyB,MACzB,gBACA,wBACA,kBAAkB,GAClB,YAAY,OACZ,aACA,UACA,cAAc,sBAAsB,MACA;CACpC,MAAM,8BACJ,0BAA0B,oBAAoB;CAGhD,MAAM,oBAAoB,OAAO,4BAA4B;AAC7D,KAAI,2BACF,cAAa;CAEf,MAAM,CAAC,cAAc,mBAAmB,eAChC,IAAI,gBAAgB,kBAAkB,QAAQ,CACrD;AACD,iBAAgB;AACd,MAAI,CAAC,UACH;EAEF,MAAM,SAAS,IAAI,gBAAgB,oBAAoB;AACvD,kBAAgB,OAAO;AACvB,oBAAkB,UAAU,OAAO,UAAU;IAC5C,CAAC,WAAW,4BAA4B,CAAC;CAC5C,MAAM,YAAY,aACf,QAAQ,YAAY;EACnB,MAAM,cAAc,kBAAkB,OAAO;EAC7C,MAAMA,iBAAe,IAAI,gBAAgB,OAAO;AAChD,MAAI,WAAW;AACb,mBAAgBA,eAAa;AAC7B,qBAAkB,UAAU;;AAE9B,gBAAc;GACZ;GACA;GACA;GACD,CAAC;IAEJ,CAAC,aAAa,UAAU,CACzB;CACD,MAAM,0BAA0B,kBAAkB;AAChD,SAAO,IAAI,gBAAgB,kBAAkB,QAAQ;IACpD,CAAC,4BAA4B,CAAC;CACjC,MAAM,oBAAsC;EAC1C;EACA;EACA;EACA;EACA;EACD;AACD,QAAO,cACL,QAAQ,UACR,EAAE,OAAO;EAAE;EAAY;EAAgB;EAAwB,EAAE,EACjE,SACD;;;;;;;;;;;;;;;AAgBH,SAAgB,uBACd,QAA+C,EAAE,EACjD;AACA,QAAO,SAAS,0BAA0B,EACxC,YAGe;AACf,SAAO,cACL,oBAEA,OACA,SACD"}