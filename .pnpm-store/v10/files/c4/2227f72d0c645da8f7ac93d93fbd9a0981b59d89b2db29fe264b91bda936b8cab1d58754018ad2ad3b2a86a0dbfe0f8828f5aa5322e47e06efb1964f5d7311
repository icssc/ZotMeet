{"version":3,"file":"cache-effect.cjs","names":["entityKind","wrapped: Wrapped","Effect","NoopCache"],"sources":["../../../src/cache/core/cache-effect.ts"],"sourcesContent":["import { Effect } from 'effect';\nimport { entityKind } from '~/entity.ts';\nimport { type Cache as Wrapped, type MutationOption, NoopCache } from './cache.ts';\nimport type { CacheConfig } from './types.ts';\n\nexport class EffectCache {\n\tstatic readonly [entityKind]: string = 'EffectCache';\n\n\tconstructor(readonly wrapped: Wrapped) {}\n\n\tstrategy = () => this.wrapped.strategy();\n\n\tget(\n\t\tkey: string,\n\t\ttables: string[],\n\t\tisTag: boolean,\n\t\tisAutoInvalidate?: boolean,\n\t): Effect.Effect<any[] | undefined, unknown, never> {\n\t\treturn Effect.tryPromise(() => this.wrapped.get(key, tables, isTag, isAutoInvalidate));\n\t}\n\n\tput(\n\t\thashedQuery: string,\n\t\tresponse: any,\n\t\ttables: string[],\n\t\tisTag: boolean,\n\t\tconfig?: CacheConfig,\n\t): Effect.Effect<void, unknown, never> {\n\t\treturn Effect.tryPromise(() => this.wrapped.put(hashedQuery, response, tables, isTag, config));\n\t}\n\n\tonMutate(params: MutationOption): Effect.Effect<void, unknown, never> {\n\t\treturn Effect.tryPromise(() => this.wrapped.onMutate(params));\n\t}\n}\n\nexport const EffectNoopCache = new EffectCache(new NoopCache());\n"],"mappings":";;;;;;AAKA,IAAa,cAAb,MAAyB;CACxB,QAAiBA,0BAAsB;CAEvC,YAAY,AAASC,SAAkB;EAAlB;;CAErB,iBAAiB,KAAK,QAAQ,UAAU;CAExC,IACC,KACA,QACA,OACA,kBACmD;AACnD,SAAOC,cAAO,iBAAiB,KAAK,QAAQ,IAAI,KAAK,QAAQ,OAAO,iBAAiB,CAAC;;CAGvF,IACC,aACA,UACA,QACA,OACA,QACsC;AACtC,SAAOA,cAAO,iBAAiB,KAAK,QAAQ,IAAI,aAAa,UAAU,QAAQ,OAAO,OAAO,CAAC;;CAG/F,SAAS,QAA6D;AACrE,SAAOA,cAAO,iBAAiB,KAAK,QAAQ,SAAS,OAAO,CAAC;;;AAI/D,MAAa,kBAAkB,IAAI,YAAY,IAAIC,oCAAW,CAAC"}