{"version":3,"sources":["../../../src/server/revalidation-utils.ts"],"sourcesContent":["import type { WorkStore } from './app-render/work-async-storage.external'\nimport type { IncrementalCache } from './lib/incremental-cache'\nimport { getCacheHandlers } from './use-cache/handlers'\n\n/** Run a callback, and execute any *new* revalidations added during its runtime. */\nexport async function withExecuteRevalidates<T>(\n  store: WorkStore | undefined,\n  callback: () => Promise<T>\n): Promise<T> {\n  if (!store) {\n    return callback()\n  }\n  // If we executed any revalidates during the request, then we don't want to execute them again.\n  // save the state so we can check if anything changed after we're done running callbacks.\n  const savedRevalidationState = cloneRevalidationState(store)\n  try {\n    return await callback()\n  } finally {\n    // Check if we have any new revalidates, and if so, wait until they are all resolved.\n    const newRevalidates = diffRevalidationState(\n      savedRevalidationState,\n      cloneRevalidationState(store)\n    )\n    await executeRevalidates(store, newRevalidates)\n  }\n}\n\ntype RevalidationState = Required<\n  Pick<\n    WorkStore,\n    'pendingRevalidatedTags' | 'pendingRevalidates' | 'pendingRevalidateWrites'\n  >\n>\n\nfunction cloneRevalidationState(store: WorkStore): RevalidationState {\n  return {\n    pendingRevalidatedTags: store.pendingRevalidatedTags\n      ? [...store.pendingRevalidatedTags]\n      : [],\n    pendingRevalidates: { ...store.pendingRevalidates },\n    pendingRevalidateWrites: store.pendingRevalidateWrites\n      ? [...store.pendingRevalidateWrites]\n      : [],\n  }\n}\n\nfunction diffRevalidationState(\n  prev: RevalidationState,\n  curr: RevalidationState\n): RevalidationState {\n  const prevTagsWithProfile = new Set(\n    prev.pendingRevalidatedTags.map((item) => {\n      const profileKey =\n        typeof item.profile === 'object'\n          ? JSON.stringify(item.profile)\n          : item.profile || ''\n      return `${item.tag}:${profileKey}`\n    })\n  )\n  const prevRevalidateWrites = new Set(prev.pendingRevalidateWrites)\n  return {\n    pendingRevalidatedTags: curr.pendingRevalidatedTags.filter((item) => {\n      const profileKey =\n        typeof item.profile === 'object'\n          ? JSON.stringify(item.profile)\n          : item.profile || ''\n      return !prevTagsWithProfile.has(`${item.tag}:${profileKey}`)\n    }),\n    pendingRevalidates: Object.fromEntries(\n      Object.entries(curr.pendingRevalidates).filter(\n        ([key]) => !(key in prev.pendingRevalidates)\n      )\n    ),\n    pendingRevalidateWrites: curr.pendingRevalidateWrites.filter(\n      (promise) => !prevRevalidateWrites.has(promise)\n    ),\n  }\n}\n\nasync function revalidateTags(\n  tagsWithProfile: Array<{\n    tag: string\n    profile?: string | { expire?: number }\n  }>,\n  incrementalCache: IncrementalCache | undefined,\n  workStore?: WorkStore\n): Promise<void> {\n  if (tagsWithProfile.length === 0) {\n    return\n  }\n\n  const handlers = getCacheHandlers()\n  const promises: Promise<void>[] = []\n\n  // Group tags by profile for batch processing\n  const tagsByProfile = new Map<\n    | string\n    | { stale?: number; revalidate?: number; expire?: number }\n    | undefined,\n    string[]\n  >()\n\n  for (const item of tagsWithProfile) {\n    const profile = item.profile\n    // Find existing profile by comparing values\n    let existingKey = undefined\n    for (const [key] of tagsByProfile) {\n      if (\n        typeof key === 'string' &&\n        typeof profile === 'string' &&\n        key === profile\n      ) {\n        existingKey = key\n        break\n      }\n      if (\n        typeof key === 'object' &&\n        typeof profile === 'object' &&\n        JSON.stringify(key) === JSON.stringify(profile)\n      ) {\n        existingKey = key\n        break\n      }\n      if (key === profile) {\n        existingKey = key\n        break\n      }\n    }\n\n    const profileKey = existingKey || profile\n    if (!tagsByProfile.has(profileKey)) {\n      tagsByProfile.set(profileKey, [])\n    }\n    tagsByProfile.get(profileKey)!.push(item.tag)\n  }\n\n  // Process each profile group\n  for (const [profile, tagsForProfile] of tagsByProfile) {\n    // Look up the cache profile from workStore if available\n    let durations: { expire?: number } | undefined\n\n    if (profile) {\n      let cacheLife:\n        | { stale?: number; revalidate?: number; expire?: number }\n        | undefined\n\n      if (typeof profile === 'object') {\n        // Profile is already a cacheLife configuration object\n        cacheLife = profile\n      } else if (typeof profile === 'string') {\n        // Profile is a string key, look it up in workStore\n        cacheLife = workStore?.cacheLifeProfiles?.[profile]\n\n        if (!cacheLife) {\n          throw new Error(\n            `Invalid profile provided \"${profile}\" must be configured under cacheLife in next.config or be \"max\"`\n          )\n        }\n      }\n\n      if (cacheLife) {\n        durations = {\n          expire: cacheLife.expire,\n        }\n      }\n    }\n    // If profile is not found and not 'max', durations will be undefined\n    // which will trigger immediate expiration in the cache handler\n\n    for (const handler of handlers || []) {\n      if (profile) {\n        promises.push(handler.updateTags?.(tagsForProfile, durations))\n      } else {\n        promises.push(handler.updateTags?.(tagsForProfile))\n      }\n    }\n\n    if (incrementalCache) {\n      promises.push(incrementalCache.revalidateTag(tagsForProfile, durations))\n    }\n  }\n\n  await Promise.all(promises)\n}\n\nexport async function executeRevalidates(\n  workStore: WorkStore,\n  state?: RevalidationState\n) {\n  const pendingRevalidatedTags =\n    state?.pendingRevalidatedTags ?? workStore.pendingRevalidatedTags ?? []\n\n  const pendingRevalidates =\n    state?.pendingRevalidates ?? workStore.pendingRevalidates ?? {}\n\n  const pendingRevalidateWrites =\n    state?.pendingRevalidateWrites ?? workStore.pendingRevalidateWrites ?? []\n\n  return Promise.all([\n    revalidateTags(\n      pendingRevalidatedTags,\n      workStore.incrementalCache,\n      workStore\n    ),\n    ...Object.values(pendingRevalidates),\n    ...pendingRevalidateWrites,\n  ])\n}\n"],"names":["getCacheHandlers","withExecuteRevalidates","store","callback","savedRevalidationState","cloneRevalidationState","newRevalidates","diffRevalidationState","executeRevalidates","pendingRevalidatedTags","pendingRevalidates","pendingRevalidateWrites","prev","curr","prevTagsWithProfile","Set","map","item","profileKey","profile","JSON","stringify","tag","prevRevalidateWrites","filter","has","Object","fromEntries","entries","key","promise","revalidateTags","tagsWithProfile","incrementalCache","workStore","length","handlers","promises","tagsByProfile","Map","existingKey","undefined","set","get","push","tagsForProfile","durations","cacheLife","cacheLifeProfiles","Error","expire","handler","updateTags","revalidateTag","Promise","all","state","values"],"mappings":"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","ignoreList":[0]}