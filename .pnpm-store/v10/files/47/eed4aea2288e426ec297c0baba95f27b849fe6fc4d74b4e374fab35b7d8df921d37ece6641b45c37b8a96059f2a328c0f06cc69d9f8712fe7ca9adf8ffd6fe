{"version":3,"file":"select.js","names":["fields: SelectedFields"],"sources":["../../../src/mssql-core/query-builders/select.ts"],"sourcesContent":["import { entityKind, is } from '~/entity.ts';\nimport type { MsSqlColumn } from '~/mssql-core/columns/index.ts';\nimport type { MsSqlDialect } from '~/mssql-core/dialect.ts';\nimport type { MsSqlSession, PreparedQueryConfig, PreparedQueryHKTBase } from '~/mssql-core/session.ts';\nimport type { SubqueryWithSelection } from '~/mssql-core/subquery.ts';\nimport type { MsSqlTable } from '~/mssql-core/table.ts';\nimport { TypedQueryBuilder } from '~/query-builders/query-builder.ts';\nimport type {\n\tBuildSubquerySelection,\n\tGetSelectTableName,\n\tGetSelectTableSelection,\n\tJoinNullability,\n\tJoinType,\n\tSelectMode,\n\tSelectResult,\n\tSetOperator,\n} from '~/query-builders/select.types.ts';\nimport { QueryPromise } from '~/query-promise.ts';\nimport { SelectionProxyHandler } from '~/selection-proxy.ts';\nimport type { ColumnsSelection, Placeholder, Query } from '~/sql/sql.ts';\nimport { SQL, View } from '~/sql/sql.ts';\nimport { Subquery } from '~/subquery.ts';\nimport { Table } from '~/table.ts';\nimport {\n\tapplyMixins,\n\tgetTableColumns,\n\tgetTableLikeName,\n\thaveSameKeys,\n\torderSelectedFields,\n\ttype ValueOrArray,\n} from '~/utils.ts';\nimport { ViewBaseConfig } from '~/view-common.ts';\nimport { MsSqlViewBase } from '../view-base.ts';\nimport type {\n\tAnyMsSqlSelect,\n\tCreateMsSqlSelectFromBuilderMode,\n\tGetMsSqlSetOperators,\n\tMsSqlCreateSetOperatorFn,\n\tMsSqlJoinFn,\n\tMsSqlSelectConfig,\n\tMsSqlSelectDynamic,\n\tMsSqlSelectHKT,\n\tMsSqlSelectHKTBase,\n\tMsSqlSelectPrepare,\n\tMsSqlSelectReplace,\n\tMsSqlSelectWithout,\n\tMsSqlSetOperatorExcludedMethods,\n\tMsSqlSetOperatorWithResult,\n\tSelectedFields,\n\tSetOperatorRightSelect,\n} from './select.types.ts';\n\n// Shared base class for `from()`\nclass MsSqlSelectFromBuilderBase<\n\tTSelection extends SelectedFields | undefined,\n\tTPreparedQueryHKT extends PreparedQueryHKTBase,\n\tTBuilderMode extends 'db' | 'qb',\n\tTBranch extends 'from' | 'top',\n> {\n\tstatic readonly [entityKind]: string = 'MsSqlSelectFromBuilderBase';\n\n\tprotected fields: TSelection;\n\tprotected session: MsSqlSession | undefined;\n\tprotected dialect: MsSqlDialect;\n\tprotected withList: Subquery[] = [];\n\tprotected distinct: boolean | undefined;\n\tprotected topValue?: number | Placeholder;\n\n\tconstructor(config: {\n\t\tfields: TSelection;\n\t\tsession: MsSqlSession | undefined;\n\t\tdialect: MsSqlDialect;\n\t\twithList?: Subquery[];\n\t\tdistinct?: boolean;\n\t\ttopValue?: number | Placeholder;\n\t}) {\n\t\tthis.fields = config.fields;\n\t\tthis.session = config.session;\n\t\tthis.dialect = config.dialect;\n\t\tif (config.withList) {\n\t\t\tthis.withList = config.withList;\n\t\t}\n\t\tthis.distinct = config.distinct;\n\t\tthis.topValue = config.topValue;\n\t}\n\n\tfrom<TFrom extends MsSqlTable | Subquery | MsSqlViewBase | SQL>(\n\t\tsource: TFrom,\n\t): Omit<\n\t\tCreateMsSqlSelectFromBuilderMode<\n\t\t\tTBuilderMode,\n\t\t\tGetSelectTableName<TFrom>,\n\t\t\tTSelection extends undefined ? GetSelectTableSelection<TFrom> : TSelection,\n\t\t\tTSelection extends undefined ? 'single' : 'partial',\n\t\t\tTPreparedQueryHKT,\n\t\t\tTBranch\n\t\t>,\n\t\t'fetch' | 'offset'\n\t> {\n\t\tconst isPartialSelect = !!this.fields;\n\t\tlet fields: SelectedFields;\n\t\tif (this.fields) {\n\t\t\tfields = this.fields;\n\t\t} else if (is(source, Subquery)) {\n\t\t\t// This is required to use the proxy handler to get the correct field values from the subquery\n\t\t\tfields = Object.fromEntries(\n\t\t\t\tObject.keys(source._.selectedFields).map((\n\t\t\t\t\tkey,\n\t\t\t\t) => [key, source[key as unknown as keyof typeof source] as unknown as SelectedFields[string]]),\n\t\t\t);\n\t\t} else if (is(source, MsSqlViewBase)) {\n\t\t\tfields = source[ViewBaseConfig].selectedFields as SelectedFields;\n\t\t} else if (is(source, SQL)) {\n\t\t\tfields = {};\n\t\t} else {\n\t\t\tfields = getTableColumns<MsSqlTable>(source);\n\t\t}\n\n\t\treturn new MsSqlSelectBase({\n\t\t\ttable: source,\n\t\t\tfields,\n\t\t\tisPartialSelect,\n\t\t\tsession: this.session,\n\t\t\tdialect: this.dialect,\n\t\t\twithList: this.withList,\n\t\t\tdistinct: this.distinct,\n\t\t\ttopValue: this.topValue,\n\t\t}) as any;\n\t}\n}\n\nexport class MsSqlSelectBuilder<\n\tTSelection extends SelectedFields | undefined,\n\tTPreparedQueryHKT extends PreparedQueryHKTBase,\n\tTBuilderMode extends 'db' | 'qb' = 'db',\n> extends MsSqlSelectFromBuilderBase<TSelection, TPreparedQueryHKT, TBuilderMode, 'from'> {\n\tstatic override readonly [entityKind]: string = 'MsSqlSelectFromBuilderBase';\n\n\ttop(top: number | Placeholder): MsSqlSelectFromBuilderBase<TSelection, TPreparedQueryHKT, TBuilderMode, 'top'> {\n\t\treturn new MsSqlSelectFromBuilderBase({\n\t\t\tfields: this.fields,\n\t\t\tsession: this.session,\n\t\t\tdialect: this.dialect,\n\t\t\twithList: this.withList,\n\t\t\tdistinct: this.distinct,\n\t\t\ttopValue: top,\n\t\t});\n\t}\n}\n\nexport abstract class MsSqlSelectQueryBuilderBase<\n\tTHKT extends MsSqlSelectHKTBase,\n\tTTableName extends string | undefined,\n\tTSelection extends ColumnsSelection,\n\tTSelectMode extends SelectMode,\n\tTPreparedQueryHKT extends PreparedQueryHKTBase,\n\tTBranch extends 'from' | 'top',\n\tTNullabilityMap extends Record<string, JoinNullability> = TTableName extends string ? Record<TTableName, 'not-null'>\n\t\t: {},\n\tTDynamic extends boolean = false,\n\tTExcludedMethods extends string = 'offset' | 'fetch',\n\tTResult extends any[] = SelectResult<TSelection, TSelectMode, TNullabilityMap>[],\n\tTSelectedFields extends ColumnsSelection = BuildSubquerySelection<TSelection, TNullabilityMap>,\n> extends TypedQueryBuilder<TSelectedFields, TResult> {\n\tstatic override readonly [entityKind]: string = 'MsSqlSelectQueryBuilderBase';\n\n\toverride readonly _: {\n\t\treadonly hkt: THKT;\n\t\treadonly tableName: TTableName;\n\t\treadonly selection: TSelection;\n\t\treadonly selectMode: TSelectMode;\n\t\treadonly preparedQueryHKT: TPreparedQueryHKT;\n\t\treadonly nullabilityMap: TNullabilityMap;\n\t\treadonly dynamic: TDynamic;\n\t\treadonly excludedMethods: TExcludedMethods;\n\t\treadonly result: TResult;\n\t\treadonly selectedFields: TSelectedFields;\n\t\treadonly branch: TBranch;\n\t};\n\n\tprotected config: MsSqlSelectConfig;\n\tprotected joinsNotNullableMap: Record<string, boolean>;\n\tprivate tableName: string | undefined;\n\tprivate isPartialSelect: boolean;\n\t/** @internal */\n\treadonly session: MsSqlSession | undefined;\n\tprotected dialect: MsSqlDialect;\n\n\tconstructor(\n\t\t{ table, fields, isPartialSelect, session, dialect, withList, distinct, topValue }: {\n\t\t\ttable: MsSqlSelectConfig['table'];\n\t\t\tfields: MsSqlSelectConfig['fields'];\n\t\t\tisPartialSelect: boolean;\n\t\t\tsession: MsSqlSession | undefined;\n\t\t\tdialect: MsSqlDialect;\n\t\t\twithList: Subquery[];\n\t\t\tdistinct: boolean | undefined;\n\t\t\ttopValue: number | undefined | Placeholder;\n\t\t},\n\t) {\n\t\tsuper();\n\t\tthis.config = {\n\t\t\twithList,\n\t\t\ttable,\n\t\t\tfields: { ...fields },\n\t\t\tdistinct,\n\t\t\tsetOperators: [],\n\t\t\ttop: topValue,\n\t\t};\n\t\tthis.isPartialSelect = isPartialSelect;\n\t\tthis.session = session;\n\t\tthis.dialect = dialect;\n\t\tthis._ = {\n\t\t\tselectedFields: fields as TSelectedFields,\n\t\t} as this['_'];\n\t\tthis.tableName = getTableLikeName(table);\n\t\tthis.joinsNotNullableMap = typeof this.tableName === 'string' ? { [this.tableName]: true } : {};\n\t}\n\n\tprivate createJoin<TJoinType extends JoinType>(\n\t\tjoinType: TJoinType,\n\t): MsSqlJoinFn<this, TDynamic, TJoinType> {\n\t\treturn (\n\t\t\ttable: MsSqlTable | Subquery | MsSqlViewBase | SQL,\n\t\t\ton: ((aliases: TSelection) => SQL | undefined) | SQL | undefined,\n\t\t) => {\n\t\t\tconst baseTableName = this.tableName;\n\t\t\tconst tableName = getTableLikeName(table);\n\n\t\t\tif (typeof tableName === 'string' && this.config.joins?.some((join) => join.alias === tableName)) {\n\t\t\t\tthrow new Error(`Alias \"${tableName}\" is already used in this query`);\n\t\t\t}\n\n\t\t\tif (!this.isPartialSelect) {\n\t\t\t\t// If this is the first join and this is not a partial select and we're not selecting from raw SQL, \"move\" the fields from the main table to the nested object\n\t\t\t\tif (Object.keys(this.joinsNotNullableMap).length === 1 && typeof baseTableName === 'string') {\n\t\t\t\t\tthis.config.fields = {\n\t\t\t\t\t\t[baseTableName]: this.config.fields,\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\tif (typeof tableName === 'string' && !is(table, SQL)) {\n\t\t\t\t\tconst selection = is(table, Subquery)\n\t\t\t\t\t\t? table._.selectedFields\n\t\t\t\t\t\t: is(table, View)\n\t\t\t\t\t\t? table[ViewBaseConfig].selectedFields\n\t\t\t\t\t\t: table[Table.Symbol.Columns];\n\t\t\t\t\tthis.config.fields[tableName] = selection;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (typeof on === 'function') {\n\t\t\t\ton = on(\n\t\t\t\t\tnew Proxy(\n\t\t\t\t\t\tthis.config.fields,\n\t\t\t\t\t\tnew SelectionProxyHandler({ sqlAliasedBehavior: 'sql', sqlBehavior: 'sql' }),\n\t\t\t\t\t) as TSelection,\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tif (!this.config.joins) {\n\t\t\t\tthis.config.joins = [];\n\t\t\t}\n\n\t\t\tthis.config.joins.push({ on, table, joinType, alias: tableName });\n\n\t\t\tif (typeof tableName === 'string') {\n\t\t\t\tswitch (joinType) {\n\t\t\t\t\tcase 'left': {\n\t\t\t\t\t\tthis.joinsNotNullableMap[tableName] = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcase 'right': {\n\t\t\t\t\t\tthis.joinsNotNullableMap = Object.fromEntries(\n\t\t\t\t\t\t\tObject.entries(this.joinsNotNullableMap).map(([key]) => [key, false]),\n\t\t\t\t\t\t);\n\t\t\t\t\t\tthis.joinsNotNullableMap[tableName] = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcase 'inner': {\n\t\t\t\t\t\tthis.joinsNotNullableMap[tableName] = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcase 'full': {\n\t\t\t\t\t\tthis.joinsNotNullableMap = Object.fromEntries(\n\t\t\t\t\t\t\tObject.entries(this.joinsNotNullableMap).map(([key]) => [key, false]),\n\t\t\t\t\t\t);\n\t\t\t\t\t\tthis.joinsNotNullableMap[tableName] = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn this as any;\n\t\t};\n\t}\n\n\t/**\n\t * Executes a `left join` operation by adding another table to the current query.\n\t *\n\t * Calling this method associates each row of the table with the corresponding row from the joined table, if a match is found. If no matching row exists, it sets all columns of the joined table to null.\n\t *\n\t * See docs: {@link https://orm.drizzle.team/docs/joins#left-join}\n\t *\n\t * @param table the table to join.\n\t * @param on the `on` clause.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * // Select all users and their pets\n\t * const usersWithPets: { user: User; pets: Pet | null }[] = await db.select()\n\t *   .from(users)\n\t *   .leftJoin(pets, eq(users.id, pets.ownerId))\n\t *\n\t * // Select userId and petId\n\t * const usersIdsAndPetIds: { userId: number; petId: number | null }[] = await db.select({\n\t *   userId: users.id,\n\t *   petId: pets.id,\n\t * })\n\t *   .from(users)\n\t *   .leftJoin(pets, eq(users.id, pets.ownerId))\n\t * ```\n\t */\n\tleftJoin = this.createJoin('left');\n\n\t/**\n\t * Executes a `right join` operation by adding another table to the current query.\n\t *\n\t * Calling this method associates each row of the joined table with the corresponding row from the main table, if a match is found. If no matching row exists, it sets all columns of the main table to null.\n\t *\n\t * See docs: {@link https://orm.drizzle.team/docs/joins#right-join}\n\t *\n\t * @param table the table to join.\n\t * @param on the `on` clause.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * // Select all users and their pets\n\t * const usersWithPets: { user: User | null; pets: Pet }[] = await db.select()\n\t *   .from(users)\n\t *   .rightJoin(pets, eq(users.id, pets.ownerId))\n\t *\n\t * // Select userId and petId\n\t * const usersIdsAndPetIds: { userId: number | null; petId: number }[] = await db.select({\n\t *   userId: users.id,\n\t *   petId: pets.id,\n\t * })\n\t *   .from(users)\n\t *   .rightJoin(pets, eq(users.id, pets.ownerId))\n\t * ```\n\t */\n\trightJoin = this.createJoin('right');\n\n\t/**\n\t * Executes an `inner join` operation, creating a new table by combining rows from two tables that have matching values.\n\t *\n\t * Calling this method retrieves rows that have corresponding entries in both joined tables. Rows without matching entries in either table are excluded, resulting in a table that includes only matching pairs.\n\t *\n\t * See docs: {@link https://orm.drizzle.team/docs/joins#inner-join}\n\t *\n\t * @param table the table to join.\n\t * @param on the `on` clause.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * // Select all users and their pets\n\t * const usersWithPets: { user: User; pets: Pet }[] = await db.select()\n\t *   .from(users)\n\t *   .innerJoin(pets, eq(users.id, pets.ownerId))\n\t *\n\t * // Select userId and petId\n\t * const usersIdsAndPetIds: { userId: number; petId: number }[] = await db.select({\n\t *   userId: users.id,\n\t *   petId: pets.id,\n\t * })\n\t *   .from(users)\n\t *   .innerJoin(pets, eq(users.id, pets.ownerId))\n\t * ```\n\t */\n\tinnerJoin = this.createJoin('inner');\n\n\t/**\n\t * Executes a `full join` operation by combining rows from two tables into a new table.\n\t *\n\t * Calling this method retrieves all rows from both main and joined tables, merging rows with matching values and filling in `null` for non-matching columns.\n\t *\n\t * See docs: {@link https://orm.drizzle.team/docs/joins#full-join}\n\t *\n\t * @param table the table to join.\n\t * @param on the `on` clause.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * // Select all users and their pets\n\t * const usersWithPets: { user: User | null; pets: Pet | null }[] = await db.select()\n\t *   .from(users)\n\t *   .fullJoin(pets, eq(users.id, pets.ownerId))\n\t *\n\t * // Select userId and petId\n\t * const usersIdsAndPetIds: { userId: number | null; petId: number | null }[] = await db.select({\n\t *   userId: users.id,\n\t *   petId: pets.id,\n\t * })\n\t *   .from(users)\n\t *   .fullJoin(pets, eq(users.id, pets.ownerId))\n\t * ```\n\t */\n\tfullJoin = this.createJoin('full');\n\n\tprivate createSetOperator(\n\t\ttype: SetOperator,\n\t\tisAll: boolean,\n\t): <TValue extends MsSqlSetOperatorWithResult<TResult>>(\n\t\trightSelection:\n\t\t\t| ((setOperators: GetMsSqlSetOperators) => SetOperatorRightSelect<TValue, TResult>)\n\t\t\t| SetOperatorRightSelect<TValue, TResult>,\n\t) => MsSqlSelectWithout<\n\t\tthis,\n\t\tTDynamic,\n\t\tMsSqlSetOperatorExcludedMethods,\n\t\ttrue\n\t> {\n\t\treturn (rightSelection) => {\n\t\t\tconst rightSelect = (typeof rightSelection === 'function'\n\t\t\t\t? rightSelection(getMsSqlSetOperators())\n\t\t\t\t: rightSelection) as TypedQueryBuilder<\n\t\t\t\t\tany,\n\t\t\t\t\tTResult\n\t\t\t\t>;\n\n\t\t\tif (!haveSameKeys(this.getSelectedFields(), rightSelect.getSelectedFields())) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t'Set operator error (union / intersect / except): selected fields are not the same or are in a different order',\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tthis.config.setOperators.push({ type, isAll, rightSelect });\n\t\t\treturn this as any;\n\t\t};\n\t}\n\n\t/**\n\t * Adds `union` set operator to the query.\n\t *\n\t * Calling this method will combine the result sets of the `select` statements and remove any duplicate rows that appear across them.\n\t *\n\t * See docs: {@link https://orm.drizzle.team/docs/set-operations#union}\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * // Select all unique names from customers and users tables\n\t * await db.select({ name: users.name })\n\t *   .from(users)\n\t *   .union(\n\t *     db.select({ name: customers.name }).from(customers)\n\t *   );\n\t * // or\n\t * import { union } from 'drizzle-orm/mssql-core'\n\t *\n\t * await union(\n\t *   db.select({ name: users.name }).from(users),\n\t *   db.select({ name: customers.name }).from(customers)\n\t * );\n\t * ```\n\t */\n\tunion = this.createSetOperator('union', false);\n\n\t/**\n\t * Adds `union all` set operator to the query.\n\t *\n\t * Calling this method will combine the result-set of the `select` statements and keep all duplicate rows that appear across them.\n\t *\n\t * See docs: {@link https://orm.drizzle.team/docs/set-operations#union-all}\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * // Select all transaction ids from both online and in-store sales\n\t * await db.select({ transaction: onlineSales.transactionId })\n\t *   .from(onlineSales)\n\t *   .unionAll(\n\t *     db.select({ transaction: inStoreSales.transactionId }).from(inStoreSales)\n\t *   );\n\t * // or\n\t * import { unionAll } from 'drizzle-orm/mssql-core'\n\t *\n\t * await unionAll(\n\t *   db.select({ transaction: onlineSales.transactionId }).from(onlineSales),\n\t *   db.select({ transaction: inStoreSales.transactionId }).from(inStoreSales)\n\t * );\n\t * ```\n\t */\n\tunionAll = this.createSetOperator('union', true);\n\n\t/**\n\t * Adds `intersect` set operator to the query.\n\t *\n\t * Calling this method will retain only the rows that are present in both result sets and eliminate duplicates.\n\t *\n\t * See docs: {@link https://orm.drizzle.team/docs/set-operations#intersect}\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * // Select course names that are offered in both departments A and B\n\t * await db.select({ courseName: depA.courseName })\n\t *   .from(depA)\n\t *   .intersect(\n\t *     db.select({ courseName: depB.courseName }).from(depB)\n\t *   );\n\t * // or\n\t * import { intersect } from 'drizzle-orm/mssql-core'\n\t *\n\t * await intersect(\n\t *   db.select({ courseName: depA.courseName }).from(depA),\n\t *   db.select({ courseName: depB.courseName }).from(depB)\n\t * );\n\t * ```\n\t */\n\tintersect = this.createSetOperator('intersect', false);\n\n\t/**\n\t * Adds `except` set operator to the query.\n\t *\n\t * Calling this method will retrieve all unique rows from the left query, except for the rows that are present in the result set of the right query.\n\t *\n\t * See docs: {@link https://orm.drizzle.team/docs/set-operations#except}\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * // Select all courses offered in department A but not in department B\n\t * await db.select({ courseName: depA.courseName })\n\t *   .from(depA)\n\t *   .except(\n\t *     db.select({ courseName: depB.courseName }).from(depB)\n\t *   );\n\t * // or\n\t * import { except } from 'drizzle-orm/mssql-core'\n\t *\n\t * await except(\n\t *   db.select({ courseName: depA.courseName }).from(depA),\n\t *   db.select({ courseName: depB.courseName }).from(depB)\n\t * );\n\t * ```\n\t */\n\texcept = this.createSetOperator('except', false);\n\n\t/** @internal */\n\taddSetOperators(setOperators: MsSqlSelectConfig['setOperators']): MsSqlSelectWithout<\n\t\tthis,\n\t\tTDynamic,\n\t\tMsSqlSetOperatorExcludedMethods,\n\t\ttrue\n\t> {\n\t\tthis.config.setOperators.push(...setOperators);\n\t\treturn this as any;\n\t}\n\n\t/**\n\t * Adds a `where` clause to the query.\n\t *\n\t * Calling this method will select only those rows that fulfill a specified condition.\n\t *\n\t * See docs: {@link https://orm.drizzle.team/docs/select#filtering}\n\t *\n\t * @param where the `where` clause.\n\t *\n\t * @example\n\t * You can use conditional operators and `sql function` to filter the rows to be selected.\n\t *\n\t * ```ts\n\t * // Select all cars with green color\n\t * await db.select().from(cars).where(eq(cars.color, 'green'));\n\t * // or\n\t * await db.select().from(cars).where(sql`${cars.color} = 'green'`)\n\t * ```\n\t *\n\t * You can logically combine conditional operators with `and()` and `or()` operators:\n\t *\n\t * ```ts\n\t * // Select all BMW cars with a green color\n\t * await db.select().from(cars).where(and(eq(cars.color, 'green'), eq(cars.brand, 'BMW')));\n\t *\n\t * // Select all cars with the green or blue color\n\t * await db.select().from(cars).where(or(eq(cars.color, 'green'), eq(cars.color, 'blue')));\n\t * ```\n\t */\n\twhere(\n\t\twhere: ((aliases: this['_']['selection']) => SQL | undefined) | SQL | undefined,\n\t): MsSqlSelectWithout<this, TDynamic, 'where'> {\n\t\tif (typeof where === 'function') {\n\t\t\twhere = where(\n\t\t\t\tnew Proxy(\n\t\t\t\t\tthis.config.fields,\n\t\t\t\t\tnew SelectionProxyHandler({ sqlAliasedBehavior: 'sql', sqlBehavior: 'sql' }),\n\t\t\t\t) as TSelection,\n\t\t\t);\n\t\t}\n\t\tthis.config.where = where;\n\t\treturn this as any;\n\t}\n\n\t/**\n\t * Adds a `having` clause to the query.\n\t *\n\t * Calling this method will select only those rows that fulfill a specified condition. It is typically used with aggregate functions to filter the aggregated data based on a specified condition.\n\t *\n\t * See docs: {@link https://orm.drizzle.team/docs/select#aggregations}\n\t *\n\t * @param having the `having` clause.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * // Select all brands with more than one car\n\t * await db.select({\n\t *  brand: cars.brand,\n\t *  count: sql<number>`cast(count(${cars.id}) as int)`,\n\t * })\n\t *   .from(cars)\n\t *   .groupBy(cars.brand)\n\t *   .having(({ count }) => gt(count, 1));\n\t * ```\n\t */\n\thaving(\n\t\thaving: ((aliases: this['_']['selection']) => SQL | undefined) | SQL | undefined,\n\t): MsSqlSelectWithout<this, TDynamic, 'having'> {\n\t\tif (typeof having === 'function') {\n\t\t\thaving = having(\n\t\t\t\tnew Proxy(\n\t\t\t\t\tthis.config.fields,\n\t\t\t\t\tnew SelectionProxyHandler({ sqlAliasedBehavior: 'sql', sqlBehavior: 'sql' }),\n\t\t\t\t) as TSelection,\n\t\t\t);\n\t\t}\n\t\tthis.config.having = having;\n\t\treturn this as any;\n\t}\n\n\t/**\n\t * Adds a `group by` clause to the query.\n\t *\n\t * Calling this method will group rows that have the same values into summary rows, often used for aggregation purposes.\n\t *\n\t * See docs: {@link https://orm.drizzle.team/docs/select#aggregations}\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * // Group and count people by their last names\n\t * await db.select({\n\t *    lastName: people.lastName,\n\t *    count: sql<number>`cast(count(*) as int)`\n\t * })\n\t *   .from(people)\n\t *   .groupBy(people.lastName);\n\t * ```\n\t */\n\tgroupBy(\n\t\tbuilder: (aliases: this['_']['selection']) => ValueOrArray<MsSqlColumn | SQL | SQL.Aliased>,\n\t): MsSqlSelectWithout<this, TDynamic, 'groupBy'>;\n\tgroupBy(...columns: (MsSqlColumn | SQL | SQL.Aliased)[]): MsSqlSelectWithout<this, TDynamic, 'groupBy'>;\n\tgroupBy(\n\t\t...columns:\n\t\t\t| [(aliases: this['_']['selection']) => ValueOrArray<MsSqlColumn | SQL | SQL.Aliased>]\n\t\t\t| (MsSqlColumn | SQL | SQL.Aliased)[]\n\t): MsSqlSelectWithout<this, TDynamic, 'groupBy'> {\n\t\tif (typeof columns[0] === 'function') {\n\t\t\tconst groupBy = columns[0](\n\t\t\t\tnew Proxy(\n\t\t\t\t\tthis.config.fields,\n\t\t\t\t\tnew SelectionProxyHandler({ sqlAliasedBehavior: 'alias', sqlBehavior: 'sql' }),\n\t\t\t\t) as TSelection,\n\t\t\t);\n\t\t\tthis.config.groupBy = Array.isArray(groupBy) ? groupBy : [groupBy];\n\t\t} else {\n\t\t\tthis.config.groupBy = columns as (MsSqlColumn | SQL | SQL.Aliased)[];\n\t\t}\n\t\treturn this as any;\n\t}\n\n\t/**\n\t * Adds an `order by` clause to the query.\n\t *\n\t * Calling this method will sort the result-set in ascending or descending order. By default, the sort order is ascending.\n\t *\n\t * See docs: {@link https://orm.drizzle.team/docs/select#order-by}\n\t *\n\t * @example\n\t *\n\t * ```\n\t * // Select cars ordered by year\n\t * await db.select().from(cars).orderBy(cars.year);\n\t * ```\n\t *\n\t * You can specify whether results are in ascending or descending order with the `asc()` and `desc()` operators.\n\t *\n\t * ```ts\n\t * // Select cars ordered by year in descending order\n\t * await db.select().from(cars).orderBy(desc(cars.year));\n\t *\n\t * // Select cars ordered by year and price\n\t * await db.select().from(cars).orderBy(asc(cars.year), desc(cars.price));\n\t * ```\n\t */\n\torderBy(\n\t\tbuilder: (aliases: this['_']['selection']) => ValueOrArray<MsSqlColumn | SQL | SQL.Aliased>,\n\t): TBranch extends 'from' ? MsSqlSelectReplace<this, TDynamic, 'orderBy', 'offset'>\n\t\t: MsSqlSelectWithout<this, TDynamic, 'orderBy'>;\n\torderBy(\n\t\t...columns: (MsSqlColumn | SQL | SQL.Aliased)[]\n\t): TBranch extends 'from' ? MsSqlSelectReplace<this, TDynamic, 'orderBy', 'offset'>\n\t\t: MsSqlSelectWithout<this, TDynamic, 'orderBy'>;\n\torderBy(\n\t\t...columns:\n\t\t\t| [(aliases: this['_']['selection']) => ValueOrArray<MsSqlColumn | SQL | SQL.Aliased>]\n\t\t\t| (MsSqlColumn | SQL | SQL.Aliased)[]\n\t): TBranch extends 'from' ? MsSqlSelectReplace<this, TDynamic, 'orderBy', 'offset'>\n\t\t: MsSqlSelectWithout<this, TDynamic, 'orderBy'>\n\t{\n\t\tif (typeof columns[0] === 'function') {\n\t\t\tconst orderBy = columns[0](\n\t\t\t\tnew Proxy(\n\t\t\t\t\tthis.config.fields,\n\t\t\t\t\tnew SelectionProxyHandler({ sqlAliasedBehavior: 'alias', sqlBehavior: 'sql' }),\n\t\t\t\t) as TSelection,\n\t\t\t);\n\n\t\t\tconst orderByArray = Array.isArray(orderBy) ? orderBy : [orderBy];\n\n\t\t\tif (this.config.setOperators.length > 0) {\n\t\t\t\tthis.config.setOperators.at(-1)!.orderBy = orderByArray;\n\t\t\t} else {\n\t\t\t\tthis.config.orderBy = orderByArray;\n\t\t\t}\n\t\t} else {\n\t\t\tconst orderByArray = columns as (MsSqlColumn | SQL | SQL.Aliased)[];\n\n\t\t\tif (this.config.setOperators.length > 0) {\n\t\t\t\tthis.config.setOperators.at(-1)!.orderBy = orderByArray;\n\t\t\t} else {\n\t\t\t\tthis.config.orderBy = orderByArray;\n\t\t\t}\n\t\t}\n\t\treturn this as any;\n\t}\n\n\t/**\n\t * Adds an `OFFSET` clause to the query.\n\t *\n\t * Calling this method will skip the first N rows of the result set. This is commonly used for pagination, often in combination with `FETCH NEXT` (e.g., `.fetch()`).\n\t *\n\t *  * ⚠️ **Note:** This method can only be used after calling `.orderBy()`, as SQL Server requires `ORDER BY` to be present with `OFFSET`.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * // Skip the first 10 results\n\t * await db.select().from(cars).orderBy(cars.year).offset(10);\n\t * ```\n\t *\n\t * `OFFSET` is zero-based — `offset(0)` will include all rows, while `offset(10)` will skip the first 10.\n\t *\n\t * Typically used with `.fetch()` to implement pagination:\n\t *\n\t * ```ts\n\t * // Get 10 cars, skipping the first 20\n\t * await db.select().from(cars).orderBy(cars.year).offset(20).fetch(10);\n\t * ```\n\t *\n\t * @param offset The number of rows to skip\n\t */\n\toffset(offset: number | Placeholder): MsSqlSelectReplace<this, TDynamic, 'offset', 'fetch'> {\n\t\tif (this.config.setOperators.length > 0) {\n\t\t\tthis.config.setOperators.at(-1)!.offset = offset;\n\t\t} else {\n\t\t\tthis.config.offset = offset;\n\t\t}\n\t\treturn this as any;\n\t}\n\n\t/**\n\t * Adds a `FETCH NEXT` clause to the query (commonly known as `LIMIT`).\n\t *\n\t * Limits the number of rows returned — used after `.offset()`.\n\t *\n\t * @example\n\t * ```ts\n\t * // Get only 10 rows, skipping 5 rows\n\t * await db.select().from(cars).orderBy(cars.year).offset(5).fetch(10);\n\t * ```\n\t *\n\t * @example\n\t * ```ts\n\t * // Pagination: skip 20 cars, then fetch 10\n\t * await db.select().from(cars).orderBy(cars.year).offset(20).fetch(10);\n\t * ```\n\t *\n\t * @param fetch The number of rows to fetch\n\t */\n\tfetch(fetch: number | Placeholder): MsSqlSelectWithout<this, TDynamic, 'fetch'> {\n\t\tif (this.config.setOperators.length > 0) {\n\t\t\tthis.config.setOperators.at(-1)!.fetch = fetch;\n\t\t} else {\n\t\t\tthis.config.fetch = fetch;\n\t\t}\n\t\treturn this as any;\n\t}\n\n\t/** @internal */\n\tgetSQL(): SQL {\n\t\treturn this.dialect.buildSelectQuery(this.config);\n\t}\n\n\ttoSQL(): Query {\n\t\tconst { typings: _typings, ...rest } = this.dialect.sqlToQuery(this.getSQL());\n\t\treturn rest;\n\t}\n\n\tas<TAlias extends string>(\n\t\talias: TAlias,\n\t): SubqueryWithSelection<this['_']['selectedFields'], TAlias> {\n\t\treturn new Proxy(\n\t\t\tnew Subquery(this.getSQL(), this.config.fields, alias),\n\t\t\tnew SelectionProxyHandler({ alias, sqlAliasedBehavior: 'alias', sqlBehavior: 'error' }),\n\t\t) as SubqueryWithSelection<this['_']['selectedFields'], TAlias>;\n\t}\n\n\t/** @internal */\n\toverride getSelectedFields(): this['_']['selectedFields'] {\n\t\treturn new Proxy(\n\t\t\tthis.config.fields,\n\t\t\tnew SelectionProxyHandler({ alias: this.tableName, sqlAliasedBehavior: 'alias', sqlBehavior: 'error' }),\n\t\t) as this['_']['selectedFields'];\n\t}\n\n\t$dynamic(): MsSqlSelectDynamic<this> {\n\t\treturn this as any;\n\t}\n}\n\nexport interface MsSqlSelectBase<\n\tTTableName extends string | undefined,\n\tTSelection extends ColumnsSelection,\n\tTSelectMode extends SelectMode,\n\tTPreparedQueryHKT extends PreparedQueryHKTBase,\n\tTBranch extends 'from' | 'top',\n\tTNullabilityMap extends Record<string, JoinNullability> = TTableName extends string ? Record<TTableName, 'not-null'>\n\t\t: {},\n\tTDynamic extends boolean = false,\n\tTExcludedMethods extends string = 'offset' | 'fetch',\n\tTResult extends any[] = SelectResult<TSelection, TSelectMode, TNullabilityMap>[],\n\tTSelectedFields extends ColumnsSelection = BuildSubquerySelection<TSelection, TNullabilityMap>,\n> extends\n\tMsSqlSelectQueryBuilderBase<\n\t\tMsSqlSelectHKT,\n\t\tTTableName,\n\t\tTSelection,\n\t\tTSelectMode,\n\t\tTPreparedQueryHKT,\n\t\tTBranch,\n\t\tTNullabilityMap,\n\t\tTDynamic,\n\t\tTExcludedMethods,\n\t\tTResult,\n\t\tTSelectedFields\n\t>,\n\tQueryPromise<TResult>\n{}\n\nexport class MsSqlSelectBase<\n\tTTableName extends string | undefined,\n\tTSelection,\n\tTSelectMode extends SelectMode,\n\tTPreparedQueryHKT extends PreparedQueryHKTBase,\n\tTBranch extends 'from' | 'top',\n\tTNullabilityMap extends Record<string, JoinNullability> = TTableName extends string ? Record<TTableName, 'not-null'>\n\t\t: {},\n\tTDynamic extends boolean = false,\n\tTExcludedMethods extends string = 'offset' | 'fetch',\n\tTResult = SelectResult<TSelection, TSelectMode, TNullabilityMap>[],\n\tTSelectedFields = BuildSubquerySelection<TSelection, TNullabilityMap>,\n> extends MsSqlSelectQueryBuilderBase<\n\tMsSqlSelectHKT,\n\tTTableName,\n\tTSelection,\n\tTSelectMode,\n\tTPreparedQueryHKT,\n\tTBranch,\n\tTNullabilityMap,\n\tTDynamic,\n\tTExcludedMethods,\n\tTResult,\n\tTSelectedFields\n> {\n\tstatic override readonly [entityKind]: string = 'MsSqlSelect';\n\n\tprepare(): MsSqlSelectPrepare<this> {\n\t\tif (!this.session) {\n\t\t\tthrow new Error('Cannot execute a query on a query builder. Please use a database instance instead.');\n\t\t}\n\t\tconst fieldsList = orderSelectedFields<MsSqlColumn>(this.config.fields);\n\t\tconst query = this.session.prepareQuery<\n\t\t\tPreparedQueryConfig & { execute: SelectResult<TSelection, TSelectMode, TNullabilityMap>[] },\n\t\t\tTPreparedQueryHKT\n\t\t>(this.dialect.sqlToQuery(this.getSQL()), fieldsList);\n\t\tquery.joinsNotNullableMap = this.joinsNotNullableMap;\n\t\treturn query as MsSqlSelectPrepare<this>;\n\t}\n\n\texecute = ((placeholderValues) => {\n\t\treturn this.prepare().execute(placeholderValues);\n\t}) as ReturnType<this['prepare']>['execute'];\n\n\tprivate createIterator = (): ReturnType<this['prepare']>['iterator'] => {\n\t\tconst self = this;\n\t\treturn async function*(placeholderValues) {\n\t\t\tyield* self.prepare().iterator(placeholderValues);\n\t\t};\n\t};\n\n\titerator = this.createIterator();\n}\n\napplyMixins(MsSqlSelectBase, [QueryPromise]);\n\nfunction createSetOperator(type: SetOperator, isAll: boolean): MsSqlCreateSetOperatorFn {\n\treturn (leftSelect, rightSelect, ...restSelects) => {\n\t\tconst setOperators = [rightSelect, ...restSelects].map((select) => ({\n\t\t\ttype,\n\t\t\tisAll,\n\t\t\trightSelect: select as AnyMsSqlSelect,\n\t\t}));\n\n\t\tfor (const setOperator of setOperators) {\n\t\t\tif (!haveSameKeys((leftSelect as any).getSelectedFields(), setOperator.rightSelect.getSelectedFields())) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t'Set operator error (union / intersect / except): selected fields are not the same or are in a different order',\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\treturn (leftSelect as AnyMsSqlSelect).addSetOperators(setOperators) as any;\n\t};\n}\n\nconst getMsSqlSetOperators = () => ({\n\tunion,\n\tunionAll,\n\tintersect,\n\texcept,\n});\n\n/**\n * Adds `union` set operator to the query.\n *\n * Calling this method will combine the result sets of the `select` statements and remove any duplicate rows that appear across them.\n *\n * See docs: {@link https://orm.drizzle.team/docs/set-operations#union}\n *\n * @example\n *\n * ```ts\n * // Select all unique names from customers and users tables\n * import { union } from 'drizzle-orm/mssql-core'\n *\n * await union(\n *   db.select({ name: users.name }).from(users),\n *   db.select({ name: customers.name }).from(customers)\n * );\n * // or\n * await db.select({ name: users.name })\n *   .from(users)\n *   .union(\n *     db.select({ name: customers.name }).from(customers)\n *   );\n * ```\n */\nexport const union = createSetOperator('union', false);\n\n/**\n * Adds `union all` set operator to the query.\n *\n * Calling this method will combine the result-set of the `select` statements and keep all duplicate rows that appear across them.\n *\n * See docs: {@link https://orm.drizzle.team/docs/set-operations#union-all}\n *\n * @example\n *\n * ```ts\n * // Select all transaction ids from both online and in-store sales\n * import { unionAll } from 'drizzle-orm/mssql-core'\n *\n * await unionAll(\n *   db.select({ transaction: onlineSales.transactionId }).from(onlineSales),\n *   db.select({ transaction: inStoreSales.transactionId }).from(inStoreSales)\n * );\n * // or\n * await db.select({ transaction: onlineSales.transactionId })\n *   .from(onlineSales)\n *   .unionAll(\n *     db.select({ transaction: inStoreSales.transactionId }).from(inStoreSales)\n *   );\n * ```\n */\nexport const unionAll = createSetOperator('union', true);\n\n/**\n * Adds `intersect` set operator to the query.\n *\n * Calling this method will retain only the rows that are present in both result sets and eliminate duplicates.\n *\n * See docs: {@link https://orm.drizzle.team/docs/set-operations#intersect}\n *\n * @example\n *\n * ```ts\n * // Select course names that are offered in both departments A and B\n * import { intersect } from 'drizzle-orm/mssql-core'\n *\n * await intersect(\n *   db.select({ courseName: depA.courseName }).from(depA),\n *   db.select({ courseName: depB.courseName }).from(depB)\n * );\n * // or\n * await db.select({ courseName: depA.courseName })\n *   .from(depA)\n *   .intersect(\n *     db.select({ courseName: depB.courseName }).from(depB)\n *   );\n * ```\n */\nexport const intersect = createSetOperator('intersect', false);\n\n/**\n * Adds `except` set operator to the query.\n *\n * Calling this method will retrieve all unique rows from the left query, except for the rows that are present in the result set of the right query.\n *\n * See docs: {@link https://orm.drizzle.team/docs/set-operations#except}\n *\n * @example\n *\n * ```ts\n * // Select all courses offered in department A but not in department B\n * import { except } from 'drizzle-orm/mssql-core'\n *\n * await except(\n *   db.select({ courseName: depA.courseName }).from(depA),\n *   db.select({ courseName: depB.courseName }).from(depB)\n * );\n * // or\n * await db.select({ courseName: depA.courseName })\n *   .from(depA)\n *   .except(\n *     db.select({ courseName: depB.courseName }).from(depB)\n *   );\n * ```\n */\nexport const except = createSetOperator('except', false);\n"],"mappings":"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"}