{"version":3,"file":"index.js","names":["decoder: { mapFromDriverValue: (v: unknown) => unknown; mapFromJsonValue?: (v: unknown) => unknown }","props: string[]","nestedCode: string","jitRowMapper: RowMapperGenerator","decoders: ((value: unknown) => unknown)[]","result: Record<string, unknown>","mapped: Record<string, unknown>[]","interpretedRowMapper: RowMapperGenerator","defaultRowMapper: RowMapperGenerator","jitArrayRowMapper: RowMapperGenerator"],"sources":["../../src/row-mappers/index.ts"],"sourcesContent":["import { Column } from '~/column.ts';\nimport { is } from '~/entity.ts';\nimport type { BuildRelationalQueryResult } from '~/relations.ts';\nimport { noopDecoder, SQL, type SQLWrapper, View } from '~/sql/sql.ts';\nimport { Table } from '~/table.ts';\n\n/**\n * Type for the selection structure used by row mappers.\n */\nexport type RowMapperSelection = BuildRelationalQueryResult['selection'];\n\n/**\n * Result of a row mapper generator.\n * Contains the mapper function and metadata about the expected input format.\n */\nexport interface RowMapperResult {\n\t/** The mapper function that transforms ALL raw rows into typed objects in a single call */\n\tmapper:\n\t\t| ((rows: Record<string, unknown>[]) => Record<string, unknown>[])\n\t\t| ((rows: unknown[][]) => Record<string, unknown>[]);\n\t/** Whether this mapper expects array-mode input (from .values()) */\n\tisArrayMode: boolean;\n\t/** The generated function body code (for debugging purposes) */\n\tcode?: string;\n}\n\n/**\n * A function that generates a row mapper for a given selection.\n * The row mapper transforms raw database rows into properly typed objects.\n */\nexport type RowMapperGenerator = (\n\tselection: RowMapperSelection,\n\tparseJson: boolean,\n) => RowMapperResult;\n\n// ============================================================================\n// JIT Row Mapper (uses new Function for best performance)\n// ============================================================================\n\nfunction resolveDecoder(\n\tfield: RowMapperSelection[number]['field'],\n): ((value: unknown) => unknown) | null {\n\tlet decoder: { mapFromDriverValue: (v: unknown) => unknown; mapFromJsonValue?: (v: unknown) => unknown };\n\n\tif (is(field, Column)) {\n\t\tdecoder = field;\n\t} else if (is(field, SQL)) {\n\t\tdecoder = field.decoder;\n\t} else if (is(field, SQL.Aliased)) {\n\t\tdecoder = field.sql.decoder;\n\t} else if (is(field, Table) || is(field, View)) {\n\t\treturn null;\n\t} else {\n\t\tdecoder = (field as SQLWrapper).getSQL().decoder;\n\t}\n\n\tif (decoder.mapFromDriverValue === noopDecoder.mapFromDriverValue) {\n\t\treturn null;\n\t}\n\n\treturn 'mapFromJsonValue' in decoder && decoder.mapFromJsonValue\n\t\t? (decoder.mapFromJsonValue as (value: unknown) => unknown).bind(decoder)\n\t\t: decoder.mapFromDriverValue.bind(decoder);\n}\n\nfunction generateObjectCode(\n\tselection: RowMapperSelection,\n\tdecoders: ((value: unknown) => unknown)[],\n\trowVar: string,\n\tparseJson: boolean,\n): string {\n\tconst props: string[] = [];\n\n\tfor (const item of selection) {\n\t\tconst key = item.key;\n\t\tconst keyLiteral = JSON.stringify(key);\n\t\tconst accessor = `${rowVar}[${keyLiteral}]`;\n\n\t\tif (item.selection) {\n\t\t\tconst innerVar = `i${decoders.length}`;\n\t\t\tconst innerObject = generateObjectCode(item.selection, decoders, innerVar, false);\n\n\t\t\tlet nestedCode: string;\n\t\t\tif (item.isArray) {\n\t\t\t\tnestedCode = `((a) => {\n          const l = a.length, r = Array.from({ length: l });\n          for (let j = 0; j < l; j++) { const ${innerVar} = a[j]; r[j] = ${innerObject}; }\n          return r;\n        })`;\n\t\t\t} else {\n\t\t\t\tnestedCode = `((${innerVar}) => (${innerObject}))`;\n\t\t\t}\n\n\t\t\tif (parseJson) {\n\t\t\t\tprops.push(`${keyLiteral}: ${accessor} === null ? null : ((v) => {\n          const p = JSON.parse(v);\n          return p === null ? null : ${nestedCode}(p);\n        })(${accessor})`);\n\t\t\t} else {\n\t\t\t\tprops.push(`${keyLiteral}: ${accessor} === null ? null : ${nestedCode}(${accessor})`);\n\t\t\t}\n\t\t} else {\n\t\t\tconst decoder = resolveDecoder(item.field);\n\t\t\tif (decoder === null) {\n\t\t\t\tprops.push(`${keyLiteral}: ${accessor}`);\n\t\t\t} else {\n\t\t\t\tconst idx = decoders.length;\n\t\t\t\tdecoders.push(decoder);\n\t\t\t\tprops.push(`${keyLiteral}: d[${idx}](${accessor})`);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn `{ ${props.join(', ')} }`;\n}\n\n/**\n * JIT-compiled row mapper generator.\n * Uses `new Function()` to generate optimized mapping code at prepare time.\n *\n * **Note:** This mapper does NOT work in environments that restrict dynamic code evaluation,\n * such as Cloudflare Workers, Deno Deploy, or Vercel Edge Functions.\n * Use `interpretedRowMapper` in those environments.\n *\n * @example\n * ```ts\n * import { jitRowMapper } from 'drizzle-orm/row-mappers';\n *\n * const db = drizzle({\n *   client,\n *   schema,\n *   relations,\n *   rowMapperGenerator: jitRowMapper,\n * });\n * ```\n */\nexport const jitRowMapper: RowMapperGenerator = (\n\tselection: RowMapperSelection,\n\tparseJson: boolean,\n): RowMapperResult => {\n\tconst decoders: ((value: unknown) => unknown)[] = [];\n\tconst objectCode = generateObjectCode(selection, decoders, 'r', parseJson);\n\n\t// Generate batch processing code - mutates rows in-place to avoid allocation\n\tconst batchCode = `const l = rows.length;\nfor (let i = 0; i < l; i++) {\n  const r = rows[i];\n  rows[i] = ${objectCode};\n}\nreturn rows;`;\n\n\tconst fn = decoders.length > 0\n\t\t? new Function('rows', 'd', batchCode) as (\n\t\t\trows: Record<string, unknown>[],\n\t\t\tdecoders: ((v: unknown) => unknown)[],\n\t\t) => Record<string, unknown>[]\n\t\t: new Function('rows', batchCode) as (rows: Record<string, unknown>[]) => Record<string, unknown>[];\n\n\treturn {\n\t\tmapper: decoders.length > 0\n\t\t\t? (rows: Record<string, unknown>[]) =>\n\t\t\t\t(fn as (rows: Record<string, unknown>[], d: ((v: unknown) => unknown)[]) => Record<string, unknown>[])(\n\t\t\t\t\trows,\n\t\t\t\t\tdecoders,\n\t\t\t\t)\n\t\t\t: fn as (rows: Record<string, unknown>[]) => Record<string, unknown>[],\n\t\tisArrayMode: false,\n\t\tcode: batchCode,\n\t};\n};\n\n// ============================================================================\n// Interpreted Row Mapper (works in all environments)\n// ============================================================================\n\nfunction mapRowInterpreted(\n\trow: Record<string, unknown>,\n\tselection: RowMapperSelection,\n\tparseJson: boolean,\n): Record<string, unknown> {\n\tconst result: Record<string, unknown> = {};\n\n\tfor (const item of selection) {\n\t\tconst key = item.key;\n\t\tlet value = row[key];\n\n\t\tif (item.selection) {\n\t\t\t// Nested relation\n\t\t\tif (value === null) {\n\t\t\t\tresult[key] = null;\n\t\t\t} else {\n\t\t\t\tif (parseJson && typeof value === 'string') {\n\t\t\t\t\tvalue = JSON.parse(value);\n\t\t\t\t\tif (value === null) {\n\t\t\t\t\t\tresult[key] = null;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (item.isArray) {\n\t\t\t\t\tconst arr = value as Record<string, unknown>[];\n\t\t\t\t\tconst mapped: Record<string, unknown>[] = [];\n\t\t\t\t\tfor (let i = 0; i < arr.length; i++) {\n\t\t\t\t\t\tmapped[i] = mapRowInterpreted(arr[i]!, item.selection, false);\n\t\t\t\t\t}\n\t\t\t\t\tresult[key] = mapped;\n\t\t\t\t} else {\n\t\t\t\t\tresult[key] = mapRowInterpreted(value as Record<string, unknown>, item.selection, false);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\t// Leaf field\n\t\t\tif (value === null) {\n\t\t\t\tresult[key] = null;\n\t\t\t} else {\n\t\t\t\tconst decoder = resolveDecoder(item.field);\n\t\t\t\tresult[key] = decoder ? decoder(value) : value;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn result;\n}\n\n/**\n * Interpreted row mapper generator.\n * Uses a recursive function to map rows at runtime.\n *\n * This mapper works in ALL JavaScript environments, including those that\n * restrict dynamic code evaluation (Cloudflare Workers, Deno Deploy, Vercel Edge Functions).\n *\n * Performance is slightly slower than `jitRowMapper`, but the difference\n * is negligible for most use cases.\n *\n * @example\n * ```ts\n * import { interpretedRowMapper } from 'drizzle-orm/row-mappers';\n *\n * const db = drizzle({\n *   client,\n *   schema,\n *   relations,\n *   rowMapperGenerator: interpretedRowMapper,\n * });\n * ```\n */\nexport const interpretedRowMapper: RowMapperGenerator = (\n\tselection: RowMapperSelection,\n\tparseJson: boolean,\n): RowMapperResult => {\n\treturn {\n\t\tmapper: (rows: Record<string, unknown>[]) => {\n\t\t\tconst l = rows.length;\n\t\t\tfor (let i = 0; i < l; i++) {\n\t\t\t\trows[i] = mapRowInterpreted(rows[i]!, selection, parseJson);\n\t\t\t}\n\t\t\treturn rows;\n\t\t},\n\t\tisArrayMode: false,\n\t\tcode: '[interpreted mode - no generated code]',\n\t};\n};\n\n/**\n * Default row mapper generator.\n * Currently uses the JIT mapper for best performance.\n */\nexport const defaultRowMapper: RowMapperGenerator = jitRowMapper;\n\n// ============================================================================\n// JIT Array-Mode Row Mapper (uses new Function + .values() for best performance)\n// ============================================================================\n\nfunction generateArrayObjectCode(\n\tselection: RowMapperSelection,\n\tdecoders: ((value: unknown) => unknown)[],\n\trowVar: string,\n\tindexRef: { value: number },\n\tparseJson: boolean,\n): string {\n\tconst props: string[] = [];\n\n\tfor (const item of selection) {\n\t\tconst key = item.key;\n\t\tconst keyLiteral = JSON.stringify(key);\n\n\t\tif (item.selection) {\n\t\t\t// Nested relations are still accessed by key (they come as JSON objects)\n\t\t\tconst idx = indexRef.value++;\n\t\t\tconst accessor = `${rowVar}[${idx}]`;\n\t\t\tconst innerVar = `i${decoders.length}`;\n\t\t\t// Nested objects still use key-based access since they're parsed JSON\n\t\t\tconst innerObject = generateObjectCode(item.selection, decoders, innerVar, false);\n\n\t\t\tlet nestedCode: string;\n\t\t\tif (item.isArray) {\n\t\t\t\tnestedCode = `((a) => {\n          const l = a.length, r = Array.from({ length: l });\n          for (let j = 0; j < l; j++) { const ${innerVar} = a[j]; r[j] = ${innerObject}; }\n          return r;\n        })`;\n\t\t\t} else {\n\t\t\t\tnestedCode = `((${innerVar}) => (${innerObject}))`;\n\t\t\t}\n\n\t\t\tif (parseJson) {\n\t\t\t\tprops.push(`${keyLiteral}: ${accessor} === null ? null : ((v) => {\n          const p = JSON.parse(v);\n          return p === null ? null : ${nestedCode}(p);\n        })(${accessor})`);\n\t\t\t} else {\n\t\t\t\tprops.push(`${keyLiteral}: ${accessor} === null ? null : ${nestedCode}(${accessor})`);\n\t\t\t}\n\t\t} else {\n\t\t\t// Leaf field - access by index\n\t\t\tconst idx = indexRef.value++;\n\t\t\tconst accessor = `${rowVar}[${idx}]`;\n\t\t\tconst decoder = resolveDecoder(item.field);\n\t\t\tif (decoder === null) {\n\t\t\t\tprops.push(`${keyLiteral}: ${accessor}`);\n\t\t\t} else {\n\t\t\t\tconst decoderIdx = decoders.length;\n\t\t\t\tdecoders.push(decoder);\n\t\t\t\tprops.push(`${keyLiteral}: d[${decoderIdx}](${accessor})`);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn `{ ${props.join(', ')} }`;\n}\n\n/**\n * JIT-compiled array-mode row mapper generator.\n * Uses `new Function()` to generate optimized mapping code that works with\n * array-based rows from `.values()` queries for maximum performance.\n *\n * This mapper expects the driver to return rows as arrays (e.g., `[1, \"John\", \"2024-01-01\"]`)\n * instead of objects (e.g., `{id: 1, name: \"John\", createdAt: \"2024-01-01\"}`).\n *\n * **Note:** This mapper does NOT work in environments that restrict dynamic code evaluation,\n * such as Cloudflare Workers, Deno Deploy, or Vercel Edge Functions.\n *\n * @example\n * ```ts\n * import { jitArrayRowMapper } from 'drizzle-orm/row-mappers';\n *\n * const db = drizzle({\n *   client,\n *   schema,\n *   relations,\n *   rowMapperGenerator: jitArrayRowMapper,\n * });\n * ```\n */\nexport const jitArrayRowMapper: RowMapperGenerator = (\n\tselection: RowMapperSelection,\n\tparseJson: boolean,\n): RowMapperResult => {\n\tconst decoders: ((value: unknown) => unknown)[] = [];\n\tconst indexRef = { value: 0 };\n\tconst objectCode = generateArrayObjectCode(selection, decoders, 'r', indexRef, parseJson);\n\n\t// Generate batch processing code - mutates rows in-place to avoid allocation\n\tconst batchCode = `const l = rows.length;\nfor (let i = 0; i < l; i++) {\n  const r = rows[i];\n  rows[i] = ${objectCode};\n}\nreturn rows;`;\n\n\tconst fn = decoders.length > 0\n\t\t? new Function('rows', 'd', batchCode) as (\n\t\t\trows: unknown[][],\n\t\t\tdecoders: ((v: unknown) => unknown)[],\n\t\t) => Record<string, unknown>[]\n\t\t: new Function('rows', batchCode) as (rows: unknown[][]) => Record<string, unknown>[];\n\n\treturn {\n\t\tmapper: decoders.length > 0\n\t\t\t? (rows: unknown[][]) =>\n\t\t\t\t(fn as (rows: unknown[][], d: ((v: unknown) => unknown)[]) => Record<string, unknown>[])(rows, decoders)\n\t\t\t: fn as (rows: unknown[][]) => Record<string, unknown>[],\n\t\tisArrayMode: true,\n\t\tcode: batchCode,\n\t};\n};\n"],"mappings":"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"}