{"version":3,"file":"session.js","names":["cache: EffectCache | undefined","queryMetadata: {\n\t\t\ttype: 'select' | 'update' | 'delete' | 'insert';\n\t\t\ttables: string[];\n\t\t} | undefined","cacheConfig?: WithCacheConfig","cacheStrat: Awaited<ReturnType<typeof strategyFor>>","fromCache: any[] | undefined","relations: TRelations","schema: {\n\t\t\tfullSchema: Record<string, unknown>;\n\t\t\tschema: TSchema;\n\t\t\ttableNamesMap: Record<string, string>;\n\t\t} | undefined","chunks: string[]"],"sources":["../../../src/pg-core/effect/session.ts"],"sourcesContent":["import type { SqlError } from '@effect/sql/SqlError';\nimport { Effect } from 'effect';\nimport type * as V1 from '~/_relations.ts';\nimport type { EffectCache } from '~/cache/core/cache-effect.ts';\nimport { NoopCache, strategyFor } from '~/cache/core/cache.ts';\nimport type { WithCacheConfig } from '~/cache/core/types.ts';\nimport { TaggedDrizzleQueryError, TaggedTransactionRollbackError } from '~/effect-core/errors.ts';\nimport { entityKind, is } from '~/entity.ts';\nimport type { MigrationConfig, MigrationMeta, MigratorInitFailResponse } from '~/migrator.ts';\nimport type { AnyRelations, EmptyRelations } from '~/relations.ts';\nimport { type Query, type SQL, sql } from '~/sql/sql.ts';\nimport { assertUnreachable } from '~/utils.ts';\nimport type { PgDialect } from '../dialect.ts';\nimport type { SelectedFieldsOrdered } from '../query-builders/select.types.ts';\nimport {\n\tPgBasePreparedQuery,\n\ttype PgQueryResultHKT,\n\tPgSession,\n\ttype PgTransactionConfig,\n\ttype PreparedQueryConfig,\n} from '../session.ts';\nimport { PgEffectDatabase } from './db.ts';\n\nexport abstract class PgEffectPreparedQuery<T extends PreparedQueryConfig> extends PgBasePreparedQuery {\n\tstatic override readonly [entityKind]: string = 'PgEffectPreparedQuery';\n\n\tconstructor(\n\t\tquery: Query,\n\t\tprivate cache: EffectCache | undefined,\n\t\tprivate queryMetadata: {\n\t\t\ttype: 'select' | 'update' | 'delete' | 'insert';\n\t\t\ttables: string[];\n\t\t} | undefined,\n\t\tprivate cacheConfig?: WithCacheConfig,\n\t) {\n\t\tsuper(query);\n\n\t\tif (cache && cache.strategy() === 'all' && cacheConfig === undefined) {\n\t\t\tthis.cacheConfig = { enabled: true, autoInvalidate: true };\n\t\t}\n\t\tif (!this.cacheConfig?.enabled) {\n\t\t\tthis.cacheConfig = undefined;\n\t\t}\n\t}\n\n\tprotected override queryWithCache<T>(\n\t\tqueryString: string,\n\t\tparams: any[],\n\t\tquery: Effect.Effect<T, SqlError>,\n\t): Effect.Effect<T, TaggedDrizzleQueryError> {\n\t\tconst { cache, cacheConfig, queryMetadata } = this;\n\t\treturn Effect.gen(function*() {\n\t\t\tconst cacheStrat: Awaited<ReturnType<typeof strategyFor>> = cache && !is(cache.wrapped, NoopCache)\n\t\t\t\t? yield* Effect.tryPromise(\n\t\t\t\t\t() => strategyFor(queryString, params, queryMetadata, cacheConfig),\n\t\t\t\t)\n\t\t\t\t: { type: 'skip' as const };\n\n\t\t\tif (cacheStrat.type === 'skip') {\n\t\t\t\treturn yield* query;\n\t\t\t}\n\n\t\t\t// For mutate queries, we should query the database, wait for a response, and then perform invalidation\n\t\t\tif (cacheStrat.type === 'invalidate') {\n\t\t\t\tconst result = yield* query;\n\t\t\t\tyield* cache!.onMutate({ tables: cacheStrat.tables });\n\n\t\t\t\treturn result;\n\t\t\t}\n\n\t\t\tif (cacheStrat.type === 'try') {\n\t\t\t\tconst { tables, key, isTag, autoInvalidate, config } = cacheStrat;\n\t\t\t\tconst fromCache: any[] | undefined = yield* cache!.get(\n\t\t\t\t\tkey,\n\t\t\t\t\ttables,\n\t\t\t\t\tisTag,\n\t\t\t\t\tautoInvalidate,\n\t\t\t\t);\n\n\t\t\t\tif (typeof fromCache !== 'undefined') return fromCache as unknown as T;\n\n\t\t\t\tconst result = yield* query;\n\n\t\t\t\tyield* cache!.put(\n\t\t\t\t\tkey,\n\t\t\t\t\tresult,\n\t\t\t\t\tautoInvalidate ? tables : [],\n\t\t\t\t\tisTag,\n\t\t\t\t\tconfig,\n\t\t\t\t);\n\n\t\t\t\treturn result;\n\t\t\t}\n\n\t\t\tassertUnreachable(cacheStrat);\n\t\t}).pipe(Effect.catchAll((e) => {\n\t\t\t// eslint-disable-next-line @drizzle-internal/no-instanceof\n\t\t\treturn Effect.fail(new TaggedDrizzleQueryError(queryString, params, e instanceof Error ? e : undefined));\n\t\t}));\n\t}\n\n\tabstract override execute(\n\t\tplaceholderValues?: Record<string, unknown>,\n\t): Effect.Effect<T['execute'], TaggedDrizzleQueryError>;\n\n\t/** @internal */\n\tabstract override all(placeholderValues?: Record<string, unknown>): Effect.Effect<T['all'], TaggedDrizzleQueryError>;\n}\n\nexport abstract class PgEffectSession<\n\tTQueryResult extends PgQueryResultHKT = PgQueryResultHKT,\n\tTFullSchema extends Record<string, unknown> = Record<string, never>,\n\tTRelations extends AnyRelations = EmptyRelations,\n\tTSchema extends V1.TablesRelationalConfig = V1.ExtractTablesWithRelations<TFullSchema>,\n> extends PgSession {\n\tstatic override readonly [entityKind]: string = 'PgEffectSession';\n\n\tconstructor(dialect: PgDialect) {\n\t\tsuper(dialect);\n\t}\n\n\tabstract override prepareQuery<T extends PreparedQueryConfig = PreparedQueryConfig>(\n\t\tquery: Query,\n\t\tfields: SelectedFieldsOrdered | undefined,\n\t\tname: string | undefined,\n\t\tisResponseInArrayMode: boolean,\n\t\tcustomResultMapper?: (rows: unknown[][], mapColumnValue?: (value: unknown) => unknown) => T['execute'],\n\t\tqueryMetadata?: {\n\t\t\ttype: 'select' | 'update' | 'delete' | 'insert';\n\t\t\ttables: string[];\n\t\t},\n\t\tcacheConfig?: WithCacheConfig,\n\t): PgEffectPreparedQuery<T>;\n\n\tabstract override prepareRelationalQuery<T extends PreparedQueryConfig = PreparedQueryConfig>(\n\t\tquery: Query,\n\t\tfields: SelectedFieldsOrdered | undefined,\n\t\tname: string | undefined,\n\t\tcustomResultMapper: (\n\t\t\trows: Record<string, unknown>[],\n\t\t\tmapColumnValue?: (value: unknown) => unknown,\n\t\t) => T['execute'],\n\t): PgEffectPreparedQuery<T>;\n\n\toverride execute<T>(query: SQL): Effect.Effect<T, TaggedDrizzleQueryError> {\n\t\tconst { sql, params } = this.dialect.sqlToQuery(query);\n\t\treturn this.prepareQuery<PreparedQueryConfig & { execute: T }>({ sql, params }, undefined, undefined, false)\n\t\t\t.execute();\n\t}\n\n\toverride all<T>(query: SQL): Effect.Effect<T[], TaggedDrizzleQueryError> {\n\t\tconst { sql, params } = this.dialect.sqlToQuery(query);\n\t\treturn this.prepareQuery<PreparedQueryConfig & { all: T[] }>({ sql, params }, undefined, undefined, false)\n\t\t\t.all();\n\t}\n\n\tabstract transaction<T>(\n\t\ttransaction: (\n\t\t\ttx: PgEffectTransaction<TQueryResult, TFullSchema, TRelations, TSchema>,\n\t\t) => Effect.Effect<T, TaggedDrizzleQueryError | TaggedTransactionRollbackError>,\n\t): Effect.Effect<T, TaggedDrizzleQueryError | TaggedTransactionRollbackError>;\n}\n\nexport abstract class PgEffectTransaction<\n\tTQueryResult extends PgQueryResultHKT,\n\tTFullSchema extends Record<string, unknown> = Record<string, never>,\n\tTRelations extends AnyRelations = EmptyRelations,\n\tTSchema extends V1.TablesRelationalConfig = V1.ExtractTablesWithRelations<TFullSchema>,\n> extends PgEffectDatabase<TQueryResult, TFullSchema, TRelations, TSchema> {\n\tstatic override readonly [entityKind]: string = 'PgEffectTransaction';\n\n\tconstructor(\n\t\tdialect: PgDialect,\n\t\tsession: PgEffectSession<any, any, any, any>,\n\t\tprotected relations: TRelations,\n\t\tprotected schema: {\n\t\t\tfullSchema: Record<string, unknown>;\n\t\t\tschema: TSchema;\n\t\t\ttableNamesMap: Record<string, string>;\n\t\t} | undefined,\n\t\tprotected readonly nestedIndex = 0,\n\t\tparseRqbJson?: boolean,\n\t) {\n\t\tsuper(dialect, session, relations, schema, parseRqbJson);\n\t}\n\n\trollback(): Effect.Effect<never, TaggedTransactionRollbackError> {\n\t\treturn Effect.fail(new TaggedTransactionRollbackError());\n\t}\n\n\t/** @internal */\n\tgetTransactionConfigSQL(config: PgTransactionConfig): SQL {\n\t\tconst chunks: string[] = [];\n\t\tif (config.isolationLevel) {\n\t\t\tchunks.push(`isolation level ${config.isolationLevel}`);\n\t\t}\n\t\tif (config.accessMode) {\n\t\t\tchunks.push(config.accessMode);\n\t\t}\n\t\tif (typeof config.deferrable === 'boolean') {\n\t\t\tchunks.push(config.deferrable ? 'deferrable' : 'not deferrable');\n\t\t}\n\t\treturn sql.raw(chunks.join(' '));\n\t}\n\n\tsetTransaction(config: PgTransactionConfig): Effect.Effect<void, TaggedDrizzleQueryError> {\n\t\treturn this.session.execute(sql`set transaction ${this.getTransactionConfigSQL(config)}`);\n\t}\n\n\tabstract override transaction<T>(\n\t\ttransaction: (\n\t\t\ttx: PgEffectTransaction<TQueryResult, TFullSchema, TRelations, TSchema>,\n\t\t) => Effect.Effect<T, TaggedDrizzleQueryError | TaggedTransactionRollbackError>,\n\t): Effect.Effect<T, TaggedDrizzleQueryError | TaggedTransactionRollbackError>;\n}\n\nexport function migrate(\n\tmigrations: MigrationMeta[],\n\tsession: PgEffectSession,\n\tconfig: string | MigrationConfig,\n): Effect.Effect<void | MigratorInitFailResponse, TaggedDrizzleQueryError, never> {\n\treturn Effect.gen(function*() {\n\t\tconst migrationsTable = typeof config === 'string'\n\t\t\t? '__drizzle_migrations'\n\t\t\t: config.migrationsTable ?? '__drizzle_migrations';\n\t\tconst migrationsSchema = typeof config === 'string' ? 'drizzle' : config.migrationsSchema ?? 'drizzle';\n\t\tconst migrationTableCreate = sql`\n\t\t\tCREATE TABLE IF NOT EXISTS ${sql.identifier(migrationsSchema)}.${sql.identifier(migrationsTable)} (\n\t\t\t\tid SERIAL PRIMARY KEY,\n\t\t\t\thash text NOT NULL,\n\t\t\t\tcreated_at bigint\n\t\t\t)\n\t\t`;\n\t\tyield* session.execute(sql`CREATE SCHEMA IF NOT EXISTS ${sql.identifier(migrationsSchema)}`);\n\t\tyield* session.execute(migrationTableCreate);\n\n\t\tconst dbMigrations = yield* session.all<{ id: number; hash: string; created_at: string }>(\n\t\t\tsql`select id, hash, created_at from ${sql.identifier(migrationsSchema)}.${\n\t\t\t\tsql.identifier(migrationsTable)\n\t\t\t} order by created_at desc limit 1`,\n\t\t);\n\n\t\tif (typeof config === 'object' && config.init) {\n\t\t\tif (dbMigrations.length) {\n\t\t\t\treturn { exitCode: 'databaseMigrations' as const };\n\t\t\t}\n\n\t\t\tif (migrations.length > 1) {\n\t\t\t\treturn { exitCode: 'localMigrations' as const };\n\t\t\t}\n\n\t\t\tconst [migration] = migrations;\n\n\t\t\tif (!migration) return;\n\n\t\t\tyield* session.execute(\n\t\t\t\tsql`insert into ${sql.identifier(migrationsSchema)}.${\n\t\t\t\t\tsql.identifier(migrationsTable)\n\t\t\t\t} (\"hash\", \"created_at\") values(${migration.hash}, ${migration.folderMillis})`,\n\t\t\t);\n\n\t\t\treturn;\n\t\t}\n\n\t\tconst lastDbMigration = dbMigrations[0];\n\t\tyield* session.transaction((tx) =>\n\t\t\tEffect.gen(function*() {\n\t\t\t\tfor (const migration of migrations) {\n\t\t\t\t\tif (\n\t\t\t\t\t\t!lastDbMigration\n\t\t\t\t\t\t|| Number(lastDbMigration.created_at) < migration.folderMillis\n\t\t\t\t\t) {\n\t\t\t\t\t\tfor (const stmt of migration.sql) {\n\t\t\t\t\t\t\tyield* tx.execute(sql.raw(stmt));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tyield* tx.execute(\n\t\t\t\t\t\t\tsql`insert into ${sql.identifier(migrationsSchema)}.${\n\t\t\t\t\t\t\t\tsql.identifier(migrationsTable)\n\t\t\t\t\t\t\t} (\"hash\", \"created_at\") values(${migration.hash}, ${migration.folderMillis})`,\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t})\n\t\t);\n\n\t\treturn;\n\t}) as Effect.Effect<void | MigratorInitFailResponse, TaggedDrizzleQueryError, never>;\n}\n"],"mappings":"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"}