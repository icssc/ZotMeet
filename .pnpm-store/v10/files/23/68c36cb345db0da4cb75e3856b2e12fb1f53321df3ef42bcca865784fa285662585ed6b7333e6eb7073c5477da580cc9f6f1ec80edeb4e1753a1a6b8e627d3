{"version":3,"sources":["../../../src/lib/generate-interception-routes-rewrites.ts"],"sourcesContent":["import { NEXT_URL } from '../client/components/app-router-headers'\nimport {\n  extractInterceptionRouteInformation,\n  isInterceptionRouteAppPath,\n} from '../shared/lib/router/utils/interception-routes'\nimport type { Rewrite } from './load-custom-routes'\nimport type { DeepReadonly } from '../shared/lib/deep-readonly'\nimport { getNamedRouteRegex } from '../shared/lib/router/utils/route-regex'\n\nexport function generateInterceptionRoutesRewrites(\n  appPaths: string[],\n  basePath = ''\n): Rewrite[] {\n  const rewrites: Rewrite[] = []\n\n  for (const appPath of appPaths) {\n    if (isInterceptionRouteAppPath(appPath)) {\n      const { interceptingRoute, interceptedRoute } =\n        extractInterceptionRouteInformation(appPath)\n\n      const destination = getNamedRouteRegex(basePath + appPath, {\n        prefixRouteKeys: true,\n      })\n\n      const header = getNamedRouteRegex(interceptingRoute, {\n        prefixRouteKeys: true,\n        reference: destination.reference,\n      })\n\n      const source = getNamedRouteRegex(basePath + interceptedRoute, {\n        prefixRouteKeys: true,\n        reference: header.reference,\n      })\n\n      const headerRegex = header.namedRegex\n        // Strip ^ and $ anchors since matchHas() will add them automatically\n        .replace(/^\\^/, '')\n        .replace(/\\$$/, '')\n        // Replace matching the `/` with matching any route segment.\n        .replace(/^\\/\\(\\?:\\/\\)\\?$/, '/.*')\n        // Replace the optional trailing with slash capture group with one that\n        // will match any descendants.\n        .replace(/\\(\\?:\\/\\)\\?$/, '(?:/.*)?')\n\n      rewrites.push({\n        source: source.pathToRegexpPattern,\n        destination: destination.pathToRegexpPattern,\n        has: [\n          {\n            type: 'header',\n            key: NEXT_URL,\n            value: headerRegex,\n          },\n        ],\n        regex: source.namedRegex,\n      })\n    }\n  }\n\n  return rewrites\n}\n\nexport function isInterceptionRouteRewrite(route: DeepReadonly<Rewrite>) {\n  // When we generate interception rewrites in the above implementation, we always do so with only a single `has` condition.\n  return route.has?.[0]?.key === NEXT_URL\n}\n"],"names":["NEXT_URL","extractInterceptionRouteInformation","isInterceptionRouteAppPath","getNamedRouteRegex","generateInterceptionRoutesRewrites","appPaths","basePath","rewrites","appPath","interceptingRoute","interceptedRoute","destination","prefixRouteKeys","header","reference","source","headerRegex","namedRegex","replace","push","pathToRegexpPattern","has","type","key","value","regex","isInterceptionRouteRewrite","route"],"mappings":"AAAA,SAASA,QAAQ,QAAQ,0CAAyC;AAClE,SACEC,mCAAmC,EACnCC,0BAA0B,QACrB,iDAAgD;AAGvD,SAASC,kBAAkB,QAAQ,yCAAwC;AAE3E,OAAO,SAASC,mCACdC,QAAkB,EAClBC,WAAW,EAAE;IAEb,MAAMC,WAAsB,EAAE;IAE9B,KAAK,MAAMC,WAAWH,SAAU;QAC9B,IAAIH,2BAA2BM,UAAU;YACvC,MAAM,EAAEC,iBAAiB,EAAEC,gBAAgB,EAAE,GAC3CT,oCAAoCO;YAEtC,MAAMG,cAAcR,mBAAmBG,WAAWE,SAAS;gBACzDI,iBAAiB;YACnB;YAEA,MAAMC,SAASV,mBAAmBM,mBAAmB;gBACnDG,iBAAiB;gBACjBE,WAAWH,YAAYG,SAAS;YAClC;YAEA,MAAMC,SAASZ,mBAAmBG,WAAWI,kBAAkB;gBAC7DE,iBAAiB;gBACjBE,WAAWD,OAAOC,SAAS;YAC7B;YAEA,MAAME,cAAcH,OAAOI,UAAU,AACnC,qEAAqE;aACpEC,OAAO,CAAC,OAAO,IACfA,OAAO,CAAC,OAAO,GAChB,4DAA4D;aAC3DA,OAAO,CAAC,mBAAmB,MAC5B,uEAAuE;YACvE,8BAA8B;aAC7BA,OAAO,CAAC,gBAAgB;YAE3BX,SAASY,IAAI,CAAC;gBACZJ,QAAQA,OAAOK,mBAAmB;gBAClCT,aAAaA,YAAYS,mBAAmB;gBAC5CC,KAAK;oBACH;wBACEC,MAAM;wBACNC,KAAKvB;wBACLwB,OAAOR;oBACT;iBACD;gBACDS,OAAOV,OAAOE,UAAU;YAC1B;QACF;IACF;IAEA,OAAOV;AACT;AAEA,OAAO,SAASmB,2BAA2BC,KAA4B;QAE9DA,aAAAA;IADP,0HAA0H;IAC1H,OAAOA,EAAAA,aAAAA,MAAMN,GAAG,sBAATM,cAAAA,UAAW,CAAC,EAAE,qBAAdA,YAAgBJ,GAAG,MAAKvB;AACjC","ignoreList":[0]}