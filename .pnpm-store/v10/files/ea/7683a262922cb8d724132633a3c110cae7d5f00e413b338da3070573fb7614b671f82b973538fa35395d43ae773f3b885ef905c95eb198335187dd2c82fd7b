{"version":3,"sources":["../../../../src/client/components/app-router-instance.ts"],"sourcesContent":["import {\n  type AppRouterState,\n  type ReducerActions,\n  type ReducerState,\n  ACTION_REFRESH,\n  ACTION_SERVER_ACTION,\n  ACTION_NAVIGATE,\n  ACTION_RESTORE,\n  type NavigateAction,\n  ACTION_HMR_REFRESH,\n  PrefetchKind,\n  type AppHistoryState,\n} from './router-reducer/router-reducer-types'\nimport { reducer } from './router-reducer/router-reducer'\nimport { startTransition } from 'react'\nimport { isThenable } from '../../shared/lib/is-thenable'\nimport {\n  FetchStrategy,\n  type PrefetchTaskFetchStrategy,\n} from './segment-cache/types'\nimport { prefetch as prefetchWithSegmentCache } from './segment-cache/prefetch'\nimport { dispatchAppRouterAction } from './use-action-queue'\nimport { addBasePath } from '../add-base-path'\nimport { isExternalURL } from './app-router-utils'\nimport type {\n  AppRouterInstance,\n  NavigateOptions,\n  PrefetchOptions,\n} from '../../shared/lib/app-router-context.shared-runtime'\nimport { setLinkForCurrentNavigation, type LinkInstance } from './links'\nimport type { ClientInstrumentationHooks } from '../app-index'\nimport type { GlobalErrorComponent } from './builtin/global-error'\n\nexport type DispatchStatePromise = React.Dispatch<ReducerState>\n\nexport type AppRouterActionQueue = {\n  state: AppRouterState\n  dispatch: (payload: ReducerActions, setState: DispatchStatePromise) => void\n  action: (state: AppRouterState, action: ReducerActions) => ReducerState\n\n  onRouterTransitionStart:\n    | ((url: string, type: 'push' | 'replace' | 'traverse') => void)\n    | null\n\n  pending: ActionQueueNode | null\n  needsRefresh?: boolean\n  last: ActionQueueNode | null\n}\n\nexport type GlobalErrorState = [\n  GlobalError: GlobalErrorComponent,\n  styles: React.ReactNode,\n]\n\nexport type ActionQueueNode = {\n  payload: ReducerActions\n  next: ActionQueueNode | null\n  resolve: (value: ReducerState) => void\n  reject: (err: Error) => void\n  discarded?: boolean\n}\n\nfunction runRemainingActions(\n  actionQueue: AppRouterActionQueue,\n  setState: DispatchStatePromise\n) {\n  if (actionQueue.pending !== null) {\n    actionQueue.pending = actionQueue.pending.next\n    if (actionQueue.pending !== null) {\n      runAction({\n        actionQueue,\n        action: actionQueue.pending,\n        setState,\n      })\n    }\n  } else {\n    // Check for refresh when pending is already null\n    // This handles the case where a discarded server action completes\n    // after the navigation has already finished and the queue is empty\n    if (actionQueue.needsRefresh) {\n      actionQueue.needsRefresh = false\n      actionQueue.dispatch({ type: ACTION_REFRESH }, setState)\n    }\n  }\n}\n\nasync function runAction({\n  actionQueue,\n  action,\n  setState,\n}: {\n  actionQueue: AppRouterActionQueue\n  action: ActionQueueNode\n  setState: DispatchStatePromise\n}) {\n  const prevState = actionQueue.state\n\n  actionQueue.pending = action\n\n  const payload = action.payload\n  const actionResult = actionQueue.action(prevState, payload)\n\n  function handleResult(nextState: AppRouterState) {\n    // if we discarded this action, the state should also be discarded\n    if (action.discarded) {\n      // Check if the discarded server action revalidated data\n      if (\n        action.payload.type === ACTION_SERVER_ACTION &&\n        action.payload.didRevalidate\n      ) {\n        // The server action was discarded but it revalidated data,\n        // mark that we need to refresh after all actions complete\n        actionQueue.needsRefresh = true\n      }\n      // Still need to run remaining actions even for discarded actions\n      // to potentially trigger the refresh\n      runRemainingActions(actionQueue, setState)\n      return\n    }\n\n    actionQueue.state = nextState\n\n    runRemainingActions(actionQueue, setState)\n    action.resolve(nextState)\n  }\n\n  // if the action is a promise, set up a callback to resolve it\n  if (isThenable(actionResult)) {\n    actionResult.then(handleResult, (err) => {\n      runRemainingActions(actionQueue, setState)\n      action.reject(err)\n    })\n  } else {\n    handleResult(actionResult)\n  }\n}\n\nfunction dispatchAction(\n  actionQueue: AppRouterActionQueue,\n  payload: ReducerActions,\n  setState: DispatchStatePromise\n) {\n  let resolvers: {\n    resolve: (value: ReducerState) => void\n    reject: (reason: any) => void\n  } = { resolve: setState, reject: () => {} }\n\n  // most of the action types are async with the exception of restore\n  // it's important that restore is handled quickly since it's fired on the popstate event\n  // and we don't want to add any delay on a back/forward nav\n  // this only creates a promise for the async actions\n  if (payload.type !== ACTION_RESTORE) {\n    // Create the promise and assign the resolvers to the object.\n    const deferredPromise = new Promise<AppRouterState>((resolve, reject) => {\n      resolvers = { resolve, reject }\n    })\n\n    startTransition(() => {\n      // we immediately notify React of the pending promise -- the resolver is attached to the action node\n      // and will be called when the associated action promise resolves\n      setState(deferredPromise)\n    })\n  }\n\n  const newAction: ActionQueueNode = {\n    payload,\n    next: null,\n    resolve: resolvers.resolve,\n    reject: resolvers.reject,\n  }\n\n  // Check if the queue is empty\n  if (actionQueue.pending === null) {\n    // The queue is empty, so add the action and start it immediately\n    // Mark this action as the last in the queue\n    actionQueue.last = newAction\n\n    runAction({\n      actionQueue,\n      action: newAction,\n      setState,\n    })\n  } else if (\n    payload.type === ACTION_NAVIGATE ||\n    payload.type === ACTION_RESTORE\n  ) {\n    // Navigations (including back/forward) take priority over any pending actions.\n    // Mark the pending action as discarded (so the state is never applied) and start the navigation action immediately.\n    actionQueue.pending.discarded = true\n\n    // The rest of the current queue should still execute after this navigation.\n    // (Note that it can't contain any earlier navigations, because we always put those into `actionQueue.pending` by calling `runAction`)\n    newAction.next = actionQueue.pending.next\n\n    runAction({\n      actionQueue,\n      action: newAction,\n      setState,\n    })\n  } else {\n    // The queue is not empty, so add the action to the end of the queue\n    // It will be started by runRemainingActions after the previous action finishes\n    if (actionQueue.last !== null) {\n      actionQueue.last.next = newAction\n    }\n    actionQueue.last = newAction\n  }\n}\n\nlet globalActionQueue: AppRouterActionQueue | null = null\n\nexport function createMutableActionQueue(\n  initialState: AppRouterState,\n  instrumentationHooks: ClientInstrumentationHooks | null\n): AppRouterActionQueue {\n  const actionQueue: AppRouterActionQueue = {\n    state: initialState,\n    dispatch: (payload: ReducerActions, setState: DispatchStatePromise) =>\n      dispatchAction(actionQueue, payload, setState),\n    action: async (state: AppRouterState, action: ReducerActions) => {\n      const result = reducer(state, action)\n      return result\n    },\n    pending: null,\n    last: null,\n    onRouterTransitionStart:\n      instrumentationHooks !== null &&\n      typeof instrumentationHooks.onRouterTransitionStart === 'function'\n        ? // This profiling hook will be called at the start of every navigation.\n          instrumentationHooks.onRouterTransitionStart\n        : null,\n  }\n\n  if (typeof window !== 'undefined') {\n    // The action queue is lazily created on hydration, but after that point\n    // it doesn't change. So we can store it in a global rather than pass\n    // it around everywhere via props/context.\n    if (globalActionQueue !== null) {\n      throw new Error(\n        'Internal Next.js Error: createMutableActionQueue was called more ' +\n          'than once'\n      )\n    }\n    globalActionQueue = actionQueue\n  }\n\n  return actionQueue\n}\n\nexport function getCurrentAppRouterState(): AppRouterState | null {\n  return globalActionQueue !== null ? globalActionQueue.state : null\n}\n\nfunction getAppRouterActionQueue(): AppRouterActionQueue {\n  if (globalActionQueue === null) {\n    throw new Error(\n      'Internal Next.js error: Router action dispatched before initialization.'\n    )\n  }\n  return globalActionQueue\n}\n\nfunction getProfilingHookForOnNavigationStart() {\n  if (globalActionQueue !== null) {\n    return globalActionQueue.onRouterTransitionStart\n  }\n  return null\n}\n\nexport function dispatchNavigateAction(\n  href: string,\n  navigateType: NavigateAction['navigateType'],\n  shouldScroll: boolean,\n  linkInstanceRef: LinkInstance | null\n): void {\n  // TODO: This stuff could just go into the reducer. Leaving as-is for now\n  // since we're about to rewrite all the router reducer stuff anyway.\n  const url = new URL(addBasePath(href), location.href)\n  if (process.env.__NEXT_APP_NAV_FAIL_HANDLING) {\n    window.next.__pendingUrl = url\n  }\n\n  setLinkForCurrentNavigation(linkInstanceRef)\n\n  const onRouterTransitionStart = getProfilingHookForOnNavigationStart()\n  if (onRouterTransitionStart !== null) {\n    onRouterTransitionStart(href, navigateType)\n  }\n\n  dispatchAppRouterAction({\n    type: ACTION_NAVIGATE,\n    url,\n    isExternalUrl: isExternalURL(url),\n    locationSearch: location.search,\n    shouldScroll,\n    navigateType,\n  })\n}\n\nexport function dispatchTraverseAction(\n  href: string,\n  historyState: AppHistoryState | undefined\n) {\n  const onRouterTransitionStart = getProfilingHookForOnNavigationStart()\n  if (onRouterTransitionStart !== null) {\n    onRouterTransitionStart(href, 'traverse')\n  }\n  dispatchAppRouterAction({\n    type: ACTION_RESTORE,\n    url: new URL(href),\n    historyState,\n  })\n}\n\n/**\n * The app router that is exposed through `useRouter`. These are public API\n * methods. Internal Next.js code should call the lower level methods directly\n * (although there's lots of existing code that doesn't do that).\n */\nexport const publicAppRouterInstance: AppRouterInstance = {\n  back: () => window.history.back(),\n  forward: () => window.history.forward(),\n  prefetch:\n    // Unlike the old implementation, the Segment Cache doesn't store its\n    // data in the router reducer state; it writes into a global mutable\n    // cache. So we don't need to dispatch an action.\n    (href: string, options?: PrefetchOptions) => {\n      const actionQueue = getAppRouterActionQueue()\n      const prefetchKind = options?.kind ?? PrefetchKind.AUTO\n\n      // We don't currently offer a way to issue a runtime prefetch via `router.prefetch()`.\n      // This will be possible when we update its API to not take a PrefetchKind.\n      let fetchStrategy: PrefetchTaskFetchStrategy\n      switch (prefetchKind) {\n        case PrefetchKind.AUTO: {\n          // We default to PPR. We'll discover whether or not the route supports it with the initial prefetch.\n          fetchStrategy = FetchStrategy.PPR\n          break\n        }\n        case PrefetchKind.FULL: {\n          fetchStrategy = FetchStrategy.Full\n          break\n        }\n        default: {\n          prefetchKind satisfies never\n          // Despite typescript thinking that this can't happen,\n          // we might get an unexpected value from user code.\n          // We don't know what they want, but we know they want a prefetch,\n          // so use the default.\n          fetchStrategy = FetchStrategy.PPR\n        }\n      }\n\n      prefetchWithSegmentCache(\n        href,\n        actionQueue.state.nextUrl,\n        actionQueue.state.tree,\n        fetchStrategy,\n        options?.onInvalidate ?? null\n      )\n    },\n  replace: (href: string, options?: NavigateOptions) => {\n    startTransition(() => {\n      dispatchNavigateAction(href, 'replace', options?.scroll ?? true, null)\n    })\n  },\n  push: (href: string, options?: NavigateOptions) => {\n    startTransition(() => {\n      dispatchNavigateAction(href, 'push', options?.scroll ?? true, null)\n    })\n  },\n  refresh: () => {\n    startTransition(() => {\n      dispatchAppRouterAction({\n        type: ACTION_REFRESH,\n      })\n    })\n  },\n  hmrRefresh: () => {\n    if (process.env.NODE_ENV !== 'development') {\n      throw new Error(\n        'hmrRefresh can only be used in development mode. Please use refresh instead.'\n      )\n    } else {\n      startTransition(() => {\n        dispatchAppRouterAction({\n          type: ACTION_HMR_REFRESH,\n        })\n      })\n    }\n  },\n}\n\n// Exists for debugging purposes. Don't use in application code.\nif (typeof window !== 'undefined' && window.next) {\n  window.next.router = publicAppRouterInstance\n}\n"],"names":["ACTION_REFRESH","ACTION_SERVER_ACTION","ACTION_NAVIGATE","ACTION_RESTORE","ACTION_HMR_REFRESH","PrefetchKind","reducer","startTransition","isThenable","FetchStrategy","prefetch","prefetchWithSegmentCache","dispatchAppRouterAction","addBasePath","isExternalURL","setLinkForCurrentNavigation","runRemainingActions","actionQueue","setState","pending","next","runAction","action","needsRefresh","dispatch","type","prevState","state","payload","actionResult","handleResult","nextState","discarded","didRevalidate","resolve","then","err","reject","dispatchAction","resolvers","deferredPromise","Promise","newAction","last","globalActionQueue","createMutableActionQueue","initialState","instrumentationHooks","result","onRouterTransitionStart","window","Error","getCurrentAppRouterState","getAppRouterActionQueue","getProfilingHookForOnNavigationStart","dispatchNavigateAction","href","navigateType","shouldScroll","linkInstanceRef","url","URL","location","process","env","__NEXT_APP_NAV_FAIL_HANDLING","__pendingUrl","isExternalUrl","locationSearch","search","dispatchTraverseAction","historyState","publicAppRouterInstance","back","history","forward","options","prefetchKind","kind","AUTO","fetchStrategy","PPR","FULL","Full","nextUrl","tree","onInvalidate","replace","scroll","push","refresh","hmrRefresh","NODE_ENV","router"],"mappings":"AAAA,SAIEA,cAAc,EACdC,oBAAoB,EACpBC,eAAe,EACfC,cAAc,EAEdC,kBAAkB,EAClBC,YAAY,QAEP,wCAAuC;AAC9C,SAASC,OAAO,QAAQ,kCAAiC;AACzD,SAASC,eAAe,QAAQ,QAAO;AACvC,SAASC,UAAU,QAAQ,+BAA8B;AACzD,SACEC,aAAa,QAER,wBAAuB;AAC9B,SAASC,YAAYC,wBAAwB,QAAQ,2BAA0B;AAC/E,SAASC,uBAAuB,QAAQ,qBAAoB;AAC5D,SAASC,WAAW,QAAQ,mBAAkB;AAC9C,SAASC,aAAa,QAAQ,qBAAoB;AAMlD,SAASC,2BAA2B,QAA2B,UAAS;AAiCxE,SAASC,oBACPC,WAAiC,EACjCC,QAA8B;IAE9B,IAAID,YAAYE,OAAO,KAAK,MAAM;QAChCF,YAAYE,OAAO,GAAGF,YAAYE,OAAO,CAACC,IAAI;QAC9C,IAAIH,YAAYE,OAAO,KAAK,MAAM;YAChCE,UAAU;gBACRJ;gBACAK,QAAQL,YAAYE,OAAO;gBAC3BD;YACF;QACF;IACF,OAAO;QACL,iDAAiD;QACjD,kEAAkE;QAClE,mEAAmE;QACnE,IAAID,YAAYM,YAAY,EAAE;YAC5BN,YAAYM,YAAY,GAAG;YAC3BN,YAAYO,QAAQ,CAAC;gBAAEC,MAAMzB;YAAe,GAAGkB;QACjD;IACF;AACF;AAEA,eAAeG,UAAU,EACvBJ,WAAW,EACXK,MAAM,EACNJ,QAAQ,EAKT;IACC,MAAMQ,YAAYT,YAAYU,KAAK;IAEnCV,YAAYE,OAAO,GAAGG;IAEtB,MAAMM,UAAUN,OAAOM,OAAO;IAC9B,MAAMC,eAAeZ,YAAYK,MAAM,CAACI,WAAWE;IAEnD,SAASE,aAAaC,SAAyB;QAC7C,kEAAkE;QAClE,IAAIT,OAAOU,SAAS,EAAE;YACpB,wDAAwD;YACxD,IACEV,OAAOM,OAAO,CAACH,IAAI,KAAKxB,wBACxBqB,OAAOM,OAAO,CAACK,aAAa,EAC5B;gBACA,2DAA2D;gBAC3D,0DAA0D;gBAC1DhB,YAAYM,YAAY,GAAG;YAC7B;YACA,iEAAiE;YACjE,qCAAqC;YACrCP,oBAAoBC,aAAaC;YACjC;QACF;QAEAD,YAAYU,KAAK,GAAGI;QAEpBf,oBAAoBC,aAAaC;QACjCI,OAAOY,OAAO,CAACH;IACjB;IAEA,8DAA8D;IAC9D,IAAIvB,WAAWqB,eAAe;QAC5BA,aAAaM,IAAI,CAACL,cAAc,CAACM;YAC/BpB,oBAAoBC,aAAaC;YACjCI,OAAOe,MAAM,CAACD;QAChB;IACF,OAAO;QACLN,aAAaD;IACf;AACF;AAEA,SAASS,eACPrB,WAAiC,EACjCW,OAAuB,EACvBV,QAA8B;IAE9B,IAAIqB,YAGA;QAAEL,SAAShB;QAAUmB,QAAQ,KAAO;IAAE;IAE1C,mEAAmE;IACnE,wFAAwF;IACxF,2DAA2D;IAC3D,oDAAoD;IACpD,IAAIT,QAAQH,IAAI,KAAKtB,gBAAgB;QACnC,6DAA6D;QAC7D,MAAMqC,kBAAkB,IAAIC,QAAwB,CAACP,SAASG;YAC5DE,YAAY;gBAAEL;gBAASG;YAAO;QAChC;QAEA9B,gBAAgB;YACd,oGAAoG;YACpG,iEAAiE;YACjEW,SAASsB;QACX;IACF;IAEA,MAAME,YAA6B;QACjCd;QACAR,MAAM;QACNc,SAASK,UAAUL,OAAO;QAC1BG,QAAQE,UAAUF,MAAM;IAC1B;IAEA,8BAA8B;IAC9B,IAAIpB,YAAYE,OAAO,KAAK,MAAM;QAChC,iEAAiE;QACjE,4CAA4C;QAC5CF,YAAY0B,IAAI,GAAGD;QAEnBrB,UAAU;YACRJ;YACAK,QAAQoB;YACRxB;QACF;IACF,OAAO,IACLU,QAAQH,IAAI,KAAKvB,mBACjB0B,QAAQH,IAAI,KAAKtB,gBACjB;QACA,+EAA+E;QAC/E,oHAAoH;QACpHc,YAAYE,OAAO,CAACa,SAAS,GAAG;QAEhC,4EAA4E;QAC5E,sIAAsI;QACtIU,UAAUtB,IAAI,GAAGH,YAAYE,OAAO,CAACC,IAAI;QAEzCC,UAAU;YACRJ;YACAK,QAAQoB;YACRxB;QACF;IACF,OAAO;QACL,oEAAoE;QACpE,+EAA+E;QAC/E,IAAID,YAAY0B,IAAI,KAAK,MAAM;YAC7B1B,YAAY0B,IAAI,CAACvB,IAAI,GAAGsB;QAC1B;QACAzB,YAAY0B,IAAI,GAAGD;IACrB;AACF;AAEA,IAAIE,oBAAiD;AAErD,OAAO,SAASC,yBACdC,YAA4B,EAC5BC,oBAAuD;IAEvD,MAAM9B,cAAoC;QACxCU,OAAOmB;QACPtB,UAAU,CAACI,SAAyBV,WAClCoB,eAAerB,aAAaW,SAASV;QACvCI,QAAQ,OAAOK,OAAuBL;YACpC,MAAM0B,SAAS1C,QAAQqB,OAAOL;YAC9B,OAAO0B;QACT;QACA7B,SAAS;QACTwB,MAAM;QACNM,yBACEF,yBAAyB,QACzB,OAAOA,qBAAqBE,uBAAuB,KAAK,aAEpDF,qBAAqBE,uBAAuB,GAC5C;IACR;IAEA,IAAI,OAAOC,WAAW,aAAa;QACjC,wEAAwE;QACxE,qEAAqE;QACrE,0CAA0C;QAC1C,IAAIN,sBAAsB,MAAM;YAC9B,MAAM,qBAGL,CAHK,IAAIO,MACR,sEACE,cAFE,qBAAA;uBAAA;4BAAA;8BAAA;YAGN;QACF;QACAP,oBAAoB3B;IACtB;IAEA,OAAOA;AACT;AAEA,OAAO,SAASmC;IACd,OAAOR,sBAAsB,OAAOA,kBAAkBjB,KAAK,GAAG;AAChE;AAEA,SAAS0B;IACP,IAAIT,sBAAsB,MAAM;QAC9B,MAAM,qBAEL,CAFK,IAAIO,MACR,4EADI,qBAAA;mBAAA;wBAAA;0BAAA;QAEN;IACF;IACA,OAAOP;AACT;AAEA,SAASU;IACP,IAAIV,sBAAsB,MAAM;QAC9B,OAAOA,kBAAkBK,uBAAuB;IAClD;IACA,OAAO;AACT;AAEA,OAAO,SAASM,uBACdC,IAAY,EACZC,YAA4C,EAC5CC,YAAqB,EACrBC,eAAoC;IAEpC,yEAAyE;IACzE,oEAAoE;IACpE,MAAMC,MAAM,IAAIC,IAAIhD,YAAY2C,OAAOM,SAASN,IAAI;IACpD,IAAIO,QAAQC,GAAG,CAACC,4BAA4B,EAAE;QAC5Cf,OAAO9B,IAAI,CAAC8C,YAAY,GAAGN;IAC7B;IAEA7C,4BAA4B4C;IAE5B,MAAMV,0BAA0BK;IAChC,IAAIL,4BAA4B,MAAM;QACpCA,wBAAwBO,MAAMC;IAChC;IAEA7C,wBAAwB;QACtBa,MAAMvB;QACN0D;QACAO,eAAerD,cAAc8C;QAC7BQ,gBAAgBN,SAASO,MAAM;QAC/BX;QACAD;IACF;AACF;AAEA,OAAO,SAASa,uBACdd,IAAY,EACZe,YAAyC;IAEzC,MAAMtB,0BAA0BK;IAChC,IAAIL,4BAA4B,MAAM;QACpCA,wBAAwBO,MAAM;IAChC;IACA5C,wBAAwB;QACtBa,MAAMtB;QACNyD,KAAK,IAAIC,IAAIL;QACbe;IACF;AACF;AAEA;;;;CAIC,GACD,OAAO,MAAMC,0BAA6C;IACxDC,MAAM,IAAMvB,OAAOwB,OAAO,CAACD,IAAI;IAC/BE,SAAS,IAAMzB,OAAOwB,OAAO,CAACC,OAAO;IACrCjE,UACE,qEAAqE;IACrE,oEAAoE;IACpE,iDAAiD;IACjD,CAAC8C,MAAcoB;QACb,MAAM3D,cAAcoC;QACpB,MAAMwB,eAAeD,SAASE,QAAQzE,aAAa0E,IAAI;QAEvD,sFAAsF;QACtF,2EAA2E;QAC3E,IAAIC;QACJ,OAAQH;YACN,KAAKxE,aAAa0E,IAAI;gBAAE;oBACtB,oGAAoG;oBACpGC,gBAAgBvE,cAAcwE,GAAG;oBACjC;gBACF;YACA,KAAK5E,aAAa6E,IAAI;gBAAE;oBACtBF,gBAAgBvE,cAAc0E,IAAI;oBAClC;gBACF;YACA;gBAAS;oBACPN;oBACA,sDAAsD;oBACtD,mDAAmD;oBACnD,kEAAkE;oBAClE,sBAAsB;oBACtBG,gBAAgBvE,cAAcwE,GAAG;gBACnC;QACF;QAEAtE,yBACE6C,MACAvC,YAAYU,KAAK,CAACyD,OAAO,EACzBnE,YAAYU,KAAK,CAAC0D,IAAI,EACtBL,eACAJ,SAASU,gBAAgB;IAE7B;IACFC,SAAS,CAAC/B,MAAcoB;QACtBrE,gBAAgB;YACdgD,uBAAuBC,MAAM,WAAWoB,SAASY,UAAU,MAAM;QACnE;IACF;IACAC,MAAM,CAACjC,MAAcoB;QACnBrE,gBAAgB;YACdgD,uBAAuBC,MAAM,QAAQoB,SAASY,UAAU,MAAM;QAChE;IACF;IACAE,SAAS;QACPnF,gBAAgB;YACdK,wBAAwB;gBACtBa,MAAMzB;YACR;QACF;IACF;IACA2F,YAAY;QACV,IAAI5B,QAAQC,GAAG,CAAC4B,QAAQ,KAAK,eAAe;YAC1C,MAAM,qBAEL,CAFK,IAAIzC,MACR,iFADI,qBAAA;uBAAA;4BAAA;8BAAA;YAEN;QACF,OAAO;YACL5C,gBAAgB;gBACdK,wBAAwB;oBACtBa,MAAMrB;gBACR;YACF;QACF;IACF;AACF,EAAC;AAED,gEAAgE;AAChE,IAAI,OAAO8C,WAAW,eAAeA,OAAO9B,IAAI,EAAE;IAChD8B,OAAO9B,IAAI,CAACyE,MAAM,GAAGrB;AACvB","ignoreList":[0]}