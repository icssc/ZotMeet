import { QueryBuilder } from "../query-builders/query-builder.js";
import { PgUpdateBuilder } from "../query-builders/update.js";
import { PgEffectDeleteBase } from "./delete.js";
import { PgEffectRelationalQuery } from "./query.js";
import { PgEffectRaw } from "./raw.js";
import { PgEffectRefreshMaterializedView } from "./refresh-materialized-view.js";
import { PgEffectUpdateBase } from "./update.js";
import { entityKind } from "../../entity.js";
import { WithSubquery } from "../../subquery.js";
import { sql } from "../../sql/sql.js";
import { Effect } from "effect";
import { SelectionProxyHandler } from "../../selection-proxy.js";
import { PgEffectCountBuilder } from "./count.js";
import { PgEffectInsertBase } from "./insert.js";
import { PgEffectSelectBase } from "./select.js";
import { PgInsertBuilder } from "../query-builders/insert.js";
import { RelationalQueryBuilder } from "../query-builders/query.js";

//#region src/pg-core/effect/db.ts
var PgEffectDatabase = class {
	static [entityKind] = "EffectPgDatabase";
	query;
	constructor(dialect, session, relations, schema, parseRqbJson = false) {
		this.dialect = dialect;
		this.session = session;
		this._ = schema ? {
			schema: schema.schema,
			fullSchema: schema.fullSchema,
			tableNamesMap: schema.tableNamesMap,
			relations,
			session
		} : {
			schema: void 0,
			fullSchema: {},
			tableNamesMap: {},
			relations,
			session
		};
		this.query = {};
		for (const [tableName, relation] of Object.entries(relations)) this.query[tableName] = new RelationalQueryBuilder(relations, relations[relation.name].table, relation, dialect, session, parseRqbJson, PgEffectRelationalQuery);
		this.$cache = { invalidate: (_params) => Effect.async(() => {}) };
	}
	/**
	* Creates a subquery that defines a temporary named result set as a CTE.
	*
	* It is useful for breaking down complex queries into simpler parts and for reusing the result set in subsequent parts of the query.
	*
	* See docs: {@link https://orm.drizzle.team/docs/select#with-clause}
	*
	* @param alias The alias for the subquery.
	*
	* Failure to provide an alias will result in a DrizzleTypeError, preventing the subquery from being referenced in other queries.
	*
	* @example
	*
	* ```ts
	* // Create a subquery with alias 'sq' and use it in the select query
	* const sq = db.$with('sq').as(db.select().from(users).where(eq(users.id, 42)));
	*
	* const result = yield* db.with(sq).select().from(sq);
	* ```
	*
	* To select arbitrary SQL values as fields in a CTE and reference them in other CTEs or in the main query, you need to add aliases to them:
	*
	* ```ts
	* // Select an arbitrary SQL value as a field in a CTE and reference it in the main query
	* const sq = db.$with('sq').as(db.select({
	*   name: sql<string>`upper(${users.name})`.as('name'),
	* })
	* .from(users));
	*
	* const result = yield* db.with(sq).select({ name: sq.name }).from(sq);
	* ```
	*/
	$with = (alias, selection) => {
		const self = this;
		const as = (qb) => {
			if (typeof qb === "function") qb = qb(new QueryBuilder(self.dialect));
			return new Proxy(new WithSubquery(qb.getSQL(), selection ?? ("getSelectedFields" in qb ? qb.getSelectedFields() ?? {} : {}), alias, true), new SelectionProxyHandler({
				alias,
				sqlAliasedBehavior: "alias",
				sqlBehavior: "error"
			}));
		};
		return { as };
	};
	$cache;
	$count(source, filters) {
		return new PgEffectCountBuilder({
			source,
			filters,
			session: this.session,
			dialect: this.dialect
		});
	}
	/**
	* Incorporates a previously defined CTE (using `$with`) into the main query.
	*
	* This method allows the main query to reference a temporary named result set.
	*
	* See docs: {@link https://orm.drizzle.team/docs/select#with-clause}
	*
	* @param queries The CTEs to incorporate into the main query.
	*
	* @example
	*
	* ```ts
	* // Define a subquery 'sq' as a CTE using $with
	* const sq = db.$with('sq').as(db.select().from(users).where(eq(users.id, 42)));
	*
	* // Incorporate the CTE 'sq' into the main query and select from it
	* const result = yield* db.with(sq).select().from(sq);
	* ```
	*/
	with(...queries) {
		const self = this;
		function select(fields) {
			return new PgEffectSelectBase({
				fields: fields ?? void 0,
				session: self.session,
				dialect: self.dialect,
				withList: queries
			});
		}
		function selectDistinct(fields) {
			return new PgEffectSelectBase({
				fields: fields ?? void 0,
				session: self.session,
				dialect: self.dialect,
				withList: queries,
				distinct: true
			});
		}
		function selectDistinctOn(on, fields) {
			return new PgEffectSelectBase({
				fields: fields ?? void 0,
				session: self.session,
				dialect: self.dialect,
				withList: queries,
				distinct: { on }
			});
		}
		/**
		* Creates an update query.
		*
		* Calling this method without `.where()` clause will update all rows in a table. The `.where()` clause specifies which rows should be updated.
		*
		* Use `.set()` method to specify which values to update.
		*
		* See docs: {@link https://orm.drizzle.team/docs/update}
		*
		* @param table The table to update.
		*
		* @example
		*
		* ```ts
		* // Update all rows in the 'cars' table
		* yield* db.update(cars).set({ color: 'red' });
		*
		* // Update rows with filters and conditions
		* yield* db.update(cars).set({ color: 'red' }).where(eq(cars.brand, 'BMW'));
		*
		* // Update with returning clause
		* const updatedCar: Car[] = yield* db.update(cars)
		*   .set({ color: 'red' })
		*   .where(eq(cars.id, 1))
		*   .returning();
		* ```
		*/
		function update(table) {
			return new PgUpdateBuilder(table, self.session, self.dialect, queries, PgEffectUpdateBase);
		}
		/**
		* Creates an insert query.
		*
		* Calling this method will create new rows in a table. Use `.values()` method to specify which values to insert.
		*
		* See docs: {@link https://orm.drizzle.team/docs/insert}
		*
		* @param table The table to insert into.
		*
		* @example
		*
		* ```ts
		* // Insert one row
		* yield* db.insert(cars).values({ brand: 'BMW' });
		*
		* // Insert multiple rows
		* yield* db.insert(cars).values([{ brand: 'BMW' }, { brand: 'Porsche' }]);
		*
		* // Insert with returning clause
		* const insertedCar: Car[] = yield* db.insert(cars)
		*   .values({ brand: 'BMW' })
		*   .returning();
		* ```
		*/
		function insert(table) {
			return new PgInsertBuilder(table, self.session, self.dialect, queries, void 0, PgEffectInsertBase);
		}
		/**
		* Creates a delete query.
		*
		* Calling this method without `.where()` clause will delete all rows in a table. The `.where()` clause specifies which rows should be deleted.
		*
		* See docs: {@link https://orm.drizzle.team/docs/delete}
		*
		* @param table The table to delete from.
		*
		* @example
		*
		* ```ts
		* // Delete all rows in the 'cars' table
		* yield* db.delete(cars);
		*
		* // Delete rows with filters and conditions
		* yield* db.delete(cars).where(eq(cars.color, 'green'));
		*
		* // Delete with returning clause
		* const deletedCar: Car[] = yield* db.delete(cars)
		*   .where(eq(cars.id, 1))
		*   .returning();
		* ```
		*/
		function delete_(table) {
			return new PgEffectDeleteBase(table, self.session, self.dialect, queries);
		}
		return {
			select,
			selectDistinct,
			selectDistinctOn,
			update,
			insert,
			delete: delete_
		};
	}
	select(fields) {
		return new PgEffectSelectBase({
			fields: fields ?? void 0,
			session: this.session,
			dialect: this.dialect
		});
	}
	selectDistinct(fields) {
		return new PgEffectSelectBase({
			fields: fields ?? void 0,
			session: this.session,
			dialect: this.dialect,
			distinct: true
		});
	}
	selectDistinctOn(on, fields) {
		return new PgEffectSelectBase({
			fields: fields ?? void 0,
			session: this.session,
			dialect: this.dialect,
			distinct: { on }
		});
	}
	/**
	* Creates an update query.
	*
	* Calling this method without `.where()` clause will update all rows in a table. The `.where()` clause specifies which rows should be updated.
	*
	* Use `.set()` method to specify which values to update.
	*
	* See docs: {@link https://orm.drizzle.team/docs/update}
	*
	* @param table The table to update.
	*
	* @example
	*
	* ```ts
	* // Update all rows in the 'cars' table
	* yield* db.update(cars).set({ color: 'red' });
	*
	* // Update rows with filters and conditions
	* yield* db.update(cars).set({ color: 'red' }).where(eq(cars.brand, 'BMW'));
	*
	* // Update with returning clause
	* const updatedCar: Car[] = yield* db.update(cars)
	*   .set({ color: 'red' })
	*   .where(eq(cars.id, 1))
	*   .returning();
	* ```
	*/
	update(table) {
		return new PgUpdateBuilder(table, this.session, this.dialect, void 0, PgEffectUpdateBase);
	}
	/**
	* Creates an insert query.
	*
	* Calling this method will create new rows in a table. Use `.values()` method to specify which values to insert.
	*
	* See docs: {@link https://orm.drizzle.team/docs/insert}
	*
	* @param table The table to insert into.
	*
	* @example
	*
	* ```ts
	* // Insert one row
	* yield* db.insert(cars).values({ brand: 'BMW' });
	*
	* // Insert multiple rows
	* yield* db.insert(cars).values([{ brand: 'BMW' }, { brand: 'Porsche' }]);
	*
	* // Insert with returning clause
	* const insertedCar: Car[] = yield* db.insert(cars)
	*   .values({ brand: 'BMW' })
	*   .returning();
	* ```
	*/
	insert(table) {
		return new PgInsertBuilder(table, this.session, this.dialect, void 0, void 0, PgEffectInsertBase);
	}
	/**
	* Creates a delete query.
	*
	* Calling this method without `.where()` clause will delete all rows in a table. The `.where()` clause specifies which rows should be deleted.
	*
	* See docs: {@link https://orm.drizzle.team/docs/delete}
	*
	* @param table The table to delete from.
	*
	* @example
	*
	* ```ts
	* // Delete all rows in the 'cars' table
	* yield* db.delete(cars);
	*
	* // Delete rows with filters and conditions
	* yield* db.delete(cars).where(eq(cars.color, 'green'));
	*
	* // Delete with returning clause
	* const deletedCar: Car[] = yield* db.delete(cars)
	*   .where(eq(cars.id, 1))
	*   .returning();
	* ```
	*/
	delete(table) {
		return new PgEffectDeleteBase(table, this.session, this.dialect);
	}
	refreshMaterializedView(view) {
		return new PgEffectRefreshMaterializedView(view, this.session, this.dialect);
	}
	execute(query) {
		const sequel = typeof query === "string" ? sql.raw(query) : query.getSQL();
		const builtQuery = this.dialect.sqlToQuery(sequel);
		const prepared = this.session.prepareQuery(builtQuery, void 0, void 0, false);
		return new PgEffectRaw(() => prepared.execute(), sequel, builtQuery, (result) => prepared.mapResult(result, true));
	}
	transaction(transaction) {
		return this.session.transaction(transaction);
	}
};
const withReplicas = (primary, replicas, getReplica = () => replicas[Math.floor(Math.random() * replicas.length)]) => {
	const select = (...args) => getReplica(replicas).select(...args);
	const selectDistinct = (...args) => getReplica(replicas).selectDistinct(...args);
	const selectDistinctOn = (...args) => getReplica(replicas).selectDistinctOn(...args);
	const $count = (...args) => getReplica(replicas).$count(...args);
	const _with = (...args) => getReplica(replicas).with(...args);
	const $with = (arg) => getReplica(replicas).$with(arg);
	const update = (...args) => primary.update(...args);
	const insert = (...args) => primary.insert(...args);
	const $delete = (...args) => primary.delete(...args);
	const execute = (...args) => primary.execute(...args);
	const refreshMaterializedView = (...args) => primary.refreshMaterializedView(...args);
	return {
		...primary,
		update,
		insert,
		delete: $delete,
		execute,
		refreshMaterializedView,
		$primary: primary,
		$replicas: replicas,
		select,
		selectDistinct,
		selectDistinctOn,
		$count,
		$with,
		with: _with,
		get query() {
			return getReplica(replicas).query;
		}
	};
};

//#endregion
export { PgEffectDatabase, withReplicas };
//# sourceMappingURL=db.js.map