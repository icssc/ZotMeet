import { SelectedFieldsOrdered } from "../query-builders/select.types.js";
import { PgDialect } from "../dialect.js";
import { PgBasePreparedQuery, PgQueryResultHKT, PgSession, PgTransactionConfig, PreparedQueryConfig } from "../session.js";
import { PgEffectDatabase } from "./db.js";
import { entityKind } from "../../entity.js";
import { Query, SQL } from "../../sql/sql.js";
import * as V1 from "../../_relations.js";
import { MigrationConfig, MigrationMeta, MigratorInitFailResponse } from "../../migrator.js";
import { Effect } from "effect";
import { TaggedDrizzleQueryError, TaggedTransactionRollbackError } from "../../effect-core/errors.js";
import { AnyRelations, EmptyRelations } from "../../relations.js";
import { WithCacheConfig } from "../../cache/core/types.js";
import { EffectCache } from "../../cache/core/cache-effect.js";
import { SqlError } from "@effect/sql/SqlError";

//#region src/pg-core/effect/session.d.ts
declare abstract class PgEffectPreparedQuery<T extends PreparedQueryConfig> extends PgBasePreparedQuery {
  private cache;
  private queryMetadata;
  private cacheConfig?;
  static readonly [entityKind]: string;
  constructor(query: Query, cache: EffectCache | undefined, queryMetadata: {
    type: 'select' | 'update' | 'delete' | 'insert';
    tables: string[];
  } | undefined, cacheConfig?: WithCacheConfig | undefined);
  protected queryWithCache<T>(queryString: string, params: any[], query: Effect.Effect<T, SqlError>): Effect.Effect<T, TaggedDrizzleQueryError>;
  abstract execute(placeholderValues?: Record<string, unknown>): Effect.Effect<T['execute'], TaggedDrizzleQueryError>;
}
declare abstract class PgEffectSession<TQueryResult extends PgQueryResultHKT = PgQueryResultHKT, TFullSchema extends Record<string, unknown> = Record<string, never>, TRelations extends AnyRelations = EmptyRelations, TSchema extends V1.TablesRelationalConfig = V1.ExtractTablesWithRelations<TFullSchema>> extends PgSession {
  static readonly [entityKind]: string;
  constructor(dialect: PgDialect);
  abstract prepareQuery<T extends PreparedQueryConfig = PreparedQueryConfig>(query: Query, fields: SelectedFieldsOrdered | undefined, name: string | undefined, isResponseInArrayMode: boolean, customResultMapper?: (rows: unknown[][], mapColumnValue?: (value: unknown) => unknown) => T['execute'], queryMetadata?: {
    type: 'select' | 'update' | 'delete' | 'insert';
    tables: string[];
  }, cacheConfig?: WithCacheConfig): PgEffectPreparedQuery<T>;
  abstract prepareRelationalQuery<T extends PreparedQueryConfig = PreparedQueryConfig>(query: Query, fields: SelectedFieldsOrdered | undefined, name: string | undefined, customResultMapper: (rows: Record<string, unknown>[], mapColumnValue?: (value: unknown) => unknown) => T['execute']): PgEffectPreparedQuery<T>;
  execute<T>(query: SQL): Effect.Effect<T, TaggedDrizzleQueryError>;
  all<T>(query: SQL): Effect.Effect<T[], TaggedDrizzleQueryError>;
  abstract transaction<T>(transaction: (tx: PgEffectTransaction<TQueryResult, TFullSchema, TRelations, TSchema>) => Effect.Effect<T, TaggedDrizzleQueryError | TaggedTransactionRollbackError>): Effect.Effect<T, TaggedDrizzleQueryError | TaggedTransactionRollbackError>;
}
declare abstract class PgEffectTransaction<TQueryResult extends PgQueryResultHKT, TFullSchema extends Record<string, unknown> = Record<string, never>, TRelations extends AnyRelations = EmptyRelations, TSchema extends V1.TablesRelationalConfig = V1.ExtractTablesWithRelations<TFullSchema>> extends PgEffectDatabase<TQueryResult, TFullSchema, TRelations, TSchema> {
  protected relations: TRelations;
  protected schema: {
    fullSchema: Record<string, unknown>;
    schema: TSchema;
    tableNamesMap: Record<string, string>;
  } | undefined;
  protected readonly nestedIndex: number;
  static readonly [entityKind]: string;
  constructor(dialect: PgDialect, session: PgEffectSession<any, any, any, any>, relations: TRelations, schema: {
    fullSchema: Record<string, unknown>;
    schema: TSchema;
    tableNamesMap: Record<string, string>;
  } | undefined, nestedIndex?: number, parseRqbJson?: boolean);
  rollback(): Effect.Effect<never, TaggedTransactionRollbackError>;
  setTransaction(config: PgTransactionConfig): Effect.Effect<void, TaggedDrizzleQueryError>;
  abstract transaction<T>(transaction: (tx: PgEffectTransaction<TQueryResult, TFullSchema, TRelations, TSchema>) => Effect.Effect<T, TaggedDrizzleQueryError | TaggedTransactionRollbackError>): Effect.Effect<T, TaggedDrizzleQueryError | TaggedTransactionRollbackError>;
}
declare function migrate(migrations: MigrationMeta[], session: PgEffectSession, config: string | MigrationConfig): Effect.Effect<void | MigratorInitFailResponse, TaggedDrizzleQueryError, never>;
//#endregion
export { PgEffectPreparedQuery, PgEffectSession, PgEffectTransaction, migrate };
//# sourceMappingURL=session.d.ts.map