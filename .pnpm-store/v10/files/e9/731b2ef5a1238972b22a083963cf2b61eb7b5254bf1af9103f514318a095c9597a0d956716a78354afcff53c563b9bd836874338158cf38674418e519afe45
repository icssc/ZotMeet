{"version":3,"file":"session.js","names":["client: NeonHttpClient","logger: Logger","fields: SelectedFieldsOrdered | undefined","_isResponseInArrayMode: boolean","customResultMapper?: (\n\t\t\trows: TIsRqbV2 extends true ? Record<string, unknown>[] : unknown[][],\n\t\t) => T['execute']","isRqbV2Query?: TIsRqbV2","relations: AnyRelations","schema: V1.RelationalSchemaConfig<TSchema> | undefined","options: NeonHttpSessionOptions","preparedQueries: PreparedQuery[]","builtQueries: NeonQueryPromise<any, true>[]"],"sources":["../../src/neon-http/session.ts"],"sourcesContent":["import type { FullQueryResults, NeonQueryFunction, NeonQueryPromise } from '@neondatabase/serverless';\nimport type * as V1 from '~/_relations.ts';\nimport type { BatchItem } from '~/batch.ts';\nimport { type Cache, NoopCache } from '~/cache/core/index.ts';\nimport type { WithCacheConfig } from '~/cache/core/types.ts';\nimport { entityKind } from '~/entity.ts';\nimport type { Logger } from '~/logger.ts';\nimport { NoopLogger } from '~/logger.ts';\nimport { PgAsyncPreparedQuery, PgAsyncSession, PgAsyncTransaction } from '~/pg-core/async/session.ts';\nimport type { PgDialect } from '~/pg-core/dialect.ts';\nimport type { SelectedFieldsOrdered } from '~/pg-core/query-builders/select.types.ts';\nimport type { PgQueryResultHKT, PgTransactionConfig, PreparedQueryConfig } from '~/pg-core/session.ts';\nimport type { AnyRelations } from '~/relations.ts';\nimport type { PreparedQuery } from '~/session.ts';\nimport { fillPlaceholders, type Query } from '~/sql/sql.ts';\nimport { mapResultRow, type NeonAuthToken } from '~/utils.ts';\n\nexport type NeonHttpClient = NeonQueryFunction<any, any>;\n\nconst rawQueryConfig = {\n\tarrayMode: false,\n\tfullResults: true,\n} as const;\nconst queryConfig = {\n\tarrayMode: true,\n\tfullResults: true,\n} as const;\n\nexport class NeonHttpPreparedQuery<\n\tT extends PreparedQueryConfig,\n\tTIsRqbV2 extends boolean = false,\n> extends PgAsyncPreparedQuery<T> {\n\tstatic override readonly [entityKind]: string = 'NeonHttpPreparedQuery';\n\tprivate clientQuery: (sql: string, params: any[], opts: Record<string, any>) => NeonQueryPromise<any, any>;\n\n\tconstructor(\n\t\tprivate client: NeonHttpClient,\n\t\tquery: Query,\n\t\tprivate logger: Logger,\n\t\tcache: Cache,\n\t\tqueryMetadata: {\n\t\t\ttype: 'select' | 'update' | 'delete' | 'insert';\n\t\t\ttables: string[];\n\t\t} | undefined,\n\t\tcacheConfig: WithCacheConfig | undefined,\n\t\tprivate fields: SelectedFieldsOrdered | undefined,\n\t\tprivate _isResponseInArrayMode: boolean,\n\t\tprivate customResultMapper?: (\n\t\t\trows: TIsRqbV2 extends true ? Record<string, unknown>[] : unknown[][],\n\t\t) => T['execute'],\n\t\tprivate isRqbV2Query?: TIsRqbV2,\n\t) {\n\t\tsuper(query, cache, queryMetadata, cacheConfig);\n\t\t// `client.query` is for @neondatabase/serverless v1.0.0 and up, where the\n\t\t// root query function `client` is only usable as a template function;\n\t\t// `client` is a fallback for earlier versions\n\t\tthis.clientQuery = (client as any).query ?? client as any;\n\t}\n\n\tasync execute(placeholderValues: Record<string, unknown> | undefined): Promise<T['execute']>;\n\t/** @internal */\n\tasync execute(placeholderValues: Record<string, unknown> | undefined, token?: NeonAuthToken): Promise<T['execute']>;\n\t/** @internal */\n\tasync execute(\n\t\tplaceholderValues: Record<string, unknown> | undefined = {},\n\t\ttoken: NeonAuthToken | undefined = this.authToken,\n\t): Promise<T['execute']> {\n\t\tif (this.isRqbV2Query) return this.executeRqbV2(placeholderValues, token);\n\n\t\tconst params = fillPlaceholders(this.query.params, placeholderValues);\n\n\t\tthis.logger.logQuery(this.query.sql, params);\n\n\t\tconst { fields, clientQuery, query, customResultMapper } = this;\n\n\t\tif (!fields && !customResultMapper) {\n\t\t\treturn this.queryWithCache(query.sql, params, async () => {\n\t\t\t\treturn clientQuery(\n\t\t\t\t\tquery.sql,\n\t\t\t\t\tparams,\n\t\t\t\t\ttoken === undefined\n\t\t\t\t\t\t? rawQueryConfig\n\t\t\t\t\t\t: {\n\t\t\t\t\t\t\t...rawQueryConfig,\n\t\t\t\t\t\t\tauthToken: token,\n\t\t\t\t\t\t},\n\t\t\t\t);\n\t\t\t});\n\t\t}\n\n\t\tconst result = await this.queryWithCache(query.sql, params, async () => {\n\t\t\treturn await clientQuery(\n\t\t\t\tquery.sql,\n\t\t\t\tparams,\n\t\t\t\ttoken === undefined\n\t\t\t\t\t? queryConfig\n\t\t\t\t\t: {\n\t\t\t\t\t\t...queryConfig,\n\t\t\t\t\t\tauthToken: token,\n\t\t\t\t\t},\n\t\t\t);\n\t\t});\n\n\t\treturn this.mapResult(result);\n\t}\n\n\tprivate async executeRqbV2(\n\t\tplaceholderValues: Record<string, unknown>,\n\t\ttoken: NeonAuthToken | undefined,\n\t): Promise<T['execute']> {\n\t\tconst params = fillPlaceholders(this.query.params, placeholderValues);\n\n\t\tthis.logger.logQuery(this.query.sql, params);\n\n\t\tconst { clientQuery, query, customResultMapper } = this;\n\n\t\tconst result = await clientQuery(\n\t\t\tquery.sql,\n\t\t\tparams,\n\t\t\ttoken === undefined\n\t\t\t\t? rawQueryConfig\n\t\t\t\t: {\n\t\t\t\t\t...rawQueryConfig,\n\t\t\t\t\tauthToken: token,\n\t\t\t\t},\n\t\t);\n\n\t\tconst rows = (result as FullQueryResults<false>).rows;\n\n\t\treturn (customResultMapper as (rows: Record<string, unknown>[]) => T['execute'])(rows);\n\t}\n\n\toverride mapResult(result: unknown): unknown {\n\t\tif (!this.fields && !this.customResultMapper) {\n\t\t\treturn result;\n\t\t}\n\n\t\tconst rows = (result as FullQueryResults<true>).rows;\n\n\t\tif (this.customResultMapper) {\n\t\t\treturn (this.customResultMapper as (rows: unknown[][]) => T['execute'])(rows);\n\t\t}\n\n\t\treturn rows.map((row) => mapResultRow(this.fields!, row, this.joinsNotNullableMap));\n\t}\n\n\tall(placeholderValues: Record<string, unknown> | undefined = {}): Promise<T['all']> {\n\t\tconst params = fillPlaceholders(this.query.params, placeholderValues);\n\t\tthis.logger.logQuery(this.query.sql, params);\n\t\treturn this.clientQuery(\n\t\t\tthis.query.sql,\n\t\t\tparams,\n\t\t\tthis.authToken === undefined ? rawQueryConfig : {\n\t\t\t\t...rawQueryConfig,\n\t\t\t\tauthToken: this.authToken,\n\t\t\t},\n\t\t).then((result) => result.rows);\n\t}\n\n\tvalues(placeholderValues: Record<string, unknown> | undefined): Promise<T['values']>;\n\t/** @internal */\n\tvalues(placeholderValues: Record<string, unknown> | undefined, token?: NeonAuthToken): Promise<T['values']>;\n\t/** @internal */\n\tvalues(placeholderValues: Record<string, unknown> | undefined = {}, token?: NeonAuthToken): Promise<T['values']> {\n\t\tconst params = fillPlaceholders(this.query.params, placeholderValues);\n\t\tthis.logger.logQuery(this.query.sql, params);\n\t\treturn this.clientQuery(this.query.sql, params, { arrayMode: true, fullResults: true, authToken: token }).then((\n\t\t\tresult,\n\t\t) => result.rows);\n\t}\n\n\t/** @internal */\n\tisResponseInArrayMode() {\n\t\treturn this._isResponseInArrayMode;\n\t}\n}\n\nexport interface NeonHttpSessionOptions {\n\tlogger?: Logger;\n\tcache?: Cache;\n}\n\nexport class NeonHttpSession<\n\tTFullSchema extends Record<string, unknown>,\n\tTRelations extends AnyRelations,\n\tTSchema extends V1.TablesRelationalConfig,\n> extends PgAsyncSession<NeonHttpQueryResultHKT, TFullSchema, TRelations, TSchema> {\n\tstatic override readonly [entityKind]: string = 'NeonHttpSession';\n\n\tprivate clientQuery: (sql: string, params: any[], opts: Record<string, any>) => NeonQueryPromise<any, any>;\n\tprivate logger: Logger;\n\tprivate cache: Cache;\n\n\tconstructor(\n\t\tprivate client: NeonHttpClient,\n\t\tdialect: PgDialect,\n\t\tprivate relations: AnyRelations,\n\t\tprivate schema: V1.RelationalSchemaConfig<TSchema> | undefined,\n\t\tprivate options: NeonHttpSessionOptions = {},\n\t) {\n\t\tsuper(dialect);\n\t\t// `client.query` is for @neondatabase/serverless v1.0.0 and up, where the\n\t\t// root query function `client` is only usable as a template function;\n\t\t// `client` is a fallback for earlier versions\n\t\tthis.clientQuery = (client as any).query ?? client as any;\n\t\tthis.logger = options.logger ?? new NoopLogger();\n\t\tthis.cache = options.cache ?? new NoopCache();\n\t}\n\n\tprepareQuery<T extends PreparedQueryConfig = PreparedQueryConfig>(\n\t\tquery: Query,\n\t\tfields: SelectedFieldsOrdered | undefined,\n\t\tname: string | undefined,\n\t\tisResponseInArrayMode: boolean,\n\t\tcustomResultMapper?: (rows: unknown[][]) => T['execute'],\n\t\tqueryMetadata?: {\n\t\t\ttype: 'select' | 'update' | 'delete' | 'insert';\n\t\t\ttables: string[];\n\t\t},\n\t\tcacheConfig?: WithCacheConfig,\n\t): PgAsyncPreparedQuery<T> {\n\t\treturn new NeonHttpPreparedQuery(\n\t\t\tthis.client,\n\t\t\tquery,\n\t\t\tthis.logger,\n\t\t\tthis.cache,\n\t\t\tqueryMetadata,\n\t\t\tcacheConfig,\n\t\t\tfields,\n\t\t\tisResponseInArrayMode,\n\t\t\tcustomResultMapper,\n\t\t);\n\t}\n\n\tprepareRelationalQuery<T extends PreparedQueryConfig = PreparedQueryConfig>(\n\t\tquery: Query,\n\t\tfields: SelectedFieldsOrdered | undefined,\n\t\tname: string | undefined,\n\t\tcustomResultMapper: (rows: Record<string, unknown>[]) => T['execute'],\n\t): PgAsyncPreparedQuery<T> {\n\t\treturn new NeonHttpPreparedQuery(\n\t\t\tthis.client,\n\t\t\tquery,\n\t\t\tthis.logger,\n\t\t\tthis.cache,\n\t\t\tundefined,\n\t\t\tundefined,\n\t\t\tfields,\n\t\t\tfalse,\n\t\t\tcustomResultMapper,\n\t\t\ttrue,\n\t\t);\n\t}\n\n\tasync batch<U extends BatchItem<'pg'>, T extends Readonly<[U, ...U[]]>>(\n\t\tqueries: T,\n\t) {\n\t\tconst preparedQueries: PreparedQuery[] = [];\n\t\tconst builtQueries: NeonQueryPromise<any, true>[] = [];\n\t\tfor (const query of queries) {\n\t\t\tconst preparedQuery = query._prepare();\n\t\t\tconst builtQuery = preparedQuery.getQuery();\n\t\t\tpreparedQueries.push(preparedQuery);\n\t\t\tbuiltQueries.push(\n\t\t\t\tthis.clientQuery(builtQuery.sql, builtQuery.params, {\n\t\t\t\t\tfullResults: true,\n\t\t\t\t\tarrayMode: preparedQuery.isResponseInArrayMode(),\n\t\t\t\t}),\n\t\t\t);\n\t\t}\n\n\t\tconst batchResults = await this.client.transaction(builtQueries, queryConfig);\n\n\t\treturn batchResults.map((result, i) => preparedQueries[i]!.mapResult(result, true)) as any;\n\t}\n\n\t// change return type to QueryRows<true>\n\tasync query(query: string, params: unknown[]): Promise<FullQueryResults<true>> {\n\t\tthis.logger.logQuery(query, params);\n\t\tconst result = await this.clientQuery(query, params, { arrayMode: true, fullResults: true });\n\t\treturn result;\n\t}\n\n\t// change return type to QueryRows<false>\n\tasync queryObjects(\n\t\tquery: string,\n\t\tparams: unknown[],\n\t): Promise<FullQueryResults<false>> {\n\t\treturn this.clientQuery(query, params, { arrayMode: false, fullResults: true });\n\t}\n\n\toverride async transaction<T>(\n\t\t_transaction: (tx: NeonTransaction<TFullSchema, TRelations, TSchema>) => Promise<T>,\n\t\t// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\t\t_config: PgTransactionConfig = {},\n\t): Promise<T> {\n\t\tthrow new Error('No transactions support in neon-http driver');\n\t}\n}\n\nexport class NeonTransaction<\n\tTFullSchema extends Record<string, unknown>,\n\tTRelations extends AnyRelations,\n\tTSchema extends V1.TablesRelationalConfig,\n> extends PgAsyncTransaction<NeonHttpQueryResultHKT, TFullSchema, TRelations, TSchema> {\n\tstatic override readonly [entityKind]: string = 'NeonHttpTransaction';\n\n\toverride async transaction<T>(\n\t\t_transaction: (tx: NeonTransaction<TFullSchema, TRelations, TSchema>) => Promise<T>,\n\t): Promise<T> {\n\t\tthrow new Error('No transactions support in neon-http driver');\n\t\t// const savepointName = `sp${this.nestedIndex + 1}`;\n\t\t// const tx = new NeonTransaction(this.dialect, this.session, this.relations, this.schema, this.nestedIndex + 1);\n\t\t// await tx.execute(sql.raw(`savepoint ${savepointName}`));\n\t\t// try {\n\t\t// \tconst result = await transaction(tx);\n\t\t// \tawait tx.execute(sql.raw(`release savepoint ${savepointName}`));\n\t\t// \treturn result;\n\t\t// } catch (e) {\n\t\t// \tawait tx.execute(sql.raw(`rollback to savepoint ${savepointName}`));\n\t\t// \tthrow e;\n\t\t// }\n\t}\n}\n\nexport type NeonHttpQueryResult<T> = Omit<FullQueryResults<false>, 'rows'> & { rows: T[] };\n\nexport interface NeonHttpQueryResultHKT extends PgQueryResultHKT {\n\ttype: NeonHttpQueryResult<this['row']>;\n}\n"],"mappings":"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"}