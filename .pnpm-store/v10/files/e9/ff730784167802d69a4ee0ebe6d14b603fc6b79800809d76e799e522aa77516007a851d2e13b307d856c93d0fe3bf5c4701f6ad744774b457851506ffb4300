{"version":3,"file":"session.js","names":["SQLiteSession","client: Database","relations: TRelations","schema: V1.RelationalSchemaConfig<TSchema> | undefined","PreparedQueryBase","stmt: Statement","logger: Logger","fields: SelectedFieldsOrdered | undefined","_isResponseInArrayMode: boolean","customResultMapper?: (\n\t\t\trows: TIsRqbV2 extends true ? Record<string, unknown>[] : unknown[][],\n\t\t) => unknown","isRqbV2Query?: TIsRqbV2"],"sources":["../../src/better-sqlite3/session.ts"],"sourcesContent":["import type { Database, RunResult, Statement } from 'better-sqlite3';\nimport type * as V1 from '~/_relations.ts';\nimport { type Cache, NoopCache } from '~/cache/core/index.ts';\nimport type { WithCacheConfig } from '~/cache/core/types.ts';\nimport { entityKind } from '~/entity.ts';\nimport type { Logger } from '~/logger.ts';\nimport { NoopLogger } from '~/logger.ts';\nimport type { AnyRelations } from '~/relations.ts';\nimport { fillPlaceholders, type Query, sql } from '~/sql/sql.ts';\nimport type { SQLiteSyncDialect } from '~/sqlite-core/dialect.ts';\nimport { SQLiteTransaction } from '~/sqlite-core/index.ts';\nimport type { SelectedFieldsOrdered } from '~/sqlite-core/query-builders/select.types.ts';\nimport {\n\ttype PreparedQueryConfig as PreparedQueryConfigBase,\n\ttype SQLiteExecuteMethod,\n\tSQLitePreparedQuery as PreparedQueryBase,\n\tSQLiteSession,\n\ttype SQLiteTransactionConfig,\n} from '~/sqlite-core/session.ts';\nimport { mapResultRow } from '~/utils.ts';\n\nexport interface BetterSQLiteSessionOptions {\n\tlogger?: Logger;\n\tcache?: Cache;\n}\n\ntype PreparedQueryConfig = Omit<PreparedQueryConfigBase, 'statement' | 'run'>;\n\nexport class BetterSQLiteSession<\n\tTFullSchema extends Record<string, unknown>,\n\tTRelations extends AnyRelations,\n\tTSchema extends V1.TablesRelationalConfig,\n> extends SQLiteSession<'sync', RunResult, TFullSchema, TRelations, TSchema> {\n\tstatic override readonly [entityKind]: string = 'BetterSQLiteSession';\n\n\tprivate logger: Logger;\n\tprivate cache: Cache;\n\n\tconstructor(\n\t\tprivate client: Database,\n\t\tdialect: SQLiteSyncDialect,\n\t\tprivate relations: TRelations,\n\t\tprivate schema: V1.RelationalSchemaConfig<TSchema> | undefined,\n\t\toptions: BetterSQLiteSessionOptions = {},\n\t) {\n\t\tsuper(dialect);\n\t\tthis.logger = options.logger ?? new NoopLogger();\n\t\tthis.cache = options.cache ?? new NoopCache();\n\t}\n\n\tprepareQuery<T extends Omit<PreparedQueryConfig, 'run'>>(\n\t\tquery: Query,\n\t\tfields: SelectedFieldsOrdered | undefined,\n\t\texecuteMethod: SQLiteExecuteMethod,\n\t\tisResponseInArrayMode: boolean,\n\t\tcustomResultMapper?: (rows: unknown[][]) => unknown,\n\t\tqueryMetadata?: {\n\t\t\ttype: 'select' | 'update' | 'delete' | 'insert';\n\t\t\ttables: string[];\n\t\t},\n\t\tcacheConfig?: WithCacheConfig,\n\t): PreparedQuery<T> {\n\t\tconst stmt = this.client.prepare(query.sql);\n\t\treturn new PreparedQuery(\n\t\t\tstmt,\n\t\t\tquery,\n\t\t\tthis.logger,\n\t\t\tthis.cache,\n\t\t\tqueryMetadata,\n\t\t\tcacheConfig,\n\t\t\tfields,\n\t\t\texecuteMethod,\n\t\t\tisResponseInArrayMode,\n\t\t\tcustomResultMapper,\n\t\t);\n\t}\n\n\tprepareRelationalQuery<T extends Omit<PreparedQueryConfig, 'run'>>(\n\t\tquery: Query,\n\t\tfields: SelectedFieldsOrdered | undefined,\n\t\texecuteMethod: SQLiteExecuteMethod,\n\t\tcustomResultMapper: (rows: Record<string, unknown>[]) => unknown,\n\t): PreparedQuery<T, true> {\n\t\tconst stmt = this.client.prepare(query.sql);\n\t\treturn new PreparedQuery(\n\t\t\tstmt,\n\t\t\tquery,\n\t\t\tthis.logger,\n\t\t\tthis.cache,\n\t\t\tundefined,\n\t\t\tundefined,\n\t\t\tfields,\n\t\t\texecuteMethod,\n\t\t\tfalse,\n\t\t\tcustomResultMapper,\n\t\t\ttrue,\n\t\t);\n\t}\n\n\toverride transaction<T>(\n\t\ttransaction: (tx: BetterSQLiteTransaction<TFullSchema, TRelations, TSchema>) => T,\n\t\tconfig: SQLiteTransactionConfig = {},\n\t): T {\n\t\tconst tx = new BetterSQLiteTransaction('sync', this.dialect, this, this.relations, this.schema);\n\t\tconst nativeTx = this.client.transaction(transaction);\n\t\treturn nativeTx[config.behavior ?? 'deferred'](tx);\n\t}\n}\n\nexport class BetterSQLiteTransaction<\n\tTFullSchema extends Record<string, unknown>,\n\tTRelations extends AnyRelations,\n\tTSchema extends V1.TablesRelationalConfig,\n> extends SQLiteTransaction<'sync', RunResult, TFullSchema, TRelations, TSchema> {\n\tstatic override readonly [entityKind]: string = 'BetterSQLiteTransaction';\n\n\toverride transaction<T>(\n\t\ttransaction: (tx: BetterSQLiteTransaction<TFullSchema, TRelations, TSchema>) => T,\n\t): T {\n\t\tconst savepointName = `sp${this.nestedIndex}`;\n\t\tconst tx = new BetterSQLiteTransaction(\n\t\t\t'sync',\n\t\t\tthis.dialect,\n\t\t\tthis.session,\n\t\t\tthis.relations,\n\t\t\tthis.schema,\n\t\t\tthis.nestedIndex + 1,\n\t\t);\n\t\tthis.session.run(sql.raw(`savepoint ${savepointName}`));\n\t\ttry {\n\t\t\tconst result = transaction(tx);\n\t\t\tthis.session.run(sql.raw(`release savepoint ${savepointName}`));\n\t\t\treturn result;\n\t\t} catch (err) {\n\t\t\tthis.session.run(sql.raw(`rollback to savepoint ${savepointName}`));\n\t\t\tthrow err;\n\t\t}\n\t}\n}\n\nexport class PreparedQuery<T extends PreparedQueryConfig = PreparedQueryConfig, TIsRqbV2 extends boolean = false>\n\textends PreparedQueryBase<\n\t\t{ type: 'sync'; run: RunResult; all: T['all']; get: T['get']; values: T['values']; execute: T['execute'] }\n\t>\n{\n\tstatic override readonly [entityKind]: string = 'BetterSQLitePreparedQuery';\n\n\tconstructor(\n\t\tprivate stmt: Statement,\n\t\tquery: Query,\n\t\tprivate logger: Logger,\n\t\tcache: Cache,\n\t\tqueryMetadata: {\n\t\t\ttype: 'select' | 'update' | 'delete' | 'insert';\n\t\t\ttables: string[];\n\t\t} | undefined,\n\t\tcacheConfig: WithCacheConfig | undefined,\n\t\tprivate fields: SelectedFieldsOrdered | undefined,\n\t\texecuteMethod: SQLiteExecuteMethod,\n\t\tprivate _isResponseInArrayMode: boolean,\n\t\tprivate customResultMapper?: (\n\t\t\trows: TIsRqbV2 extends true ? Record<string, unknown>[] : unknown[][],\n\t\t) => unknown,\n\t\tprivate isRqbV2Query?: TIsRqbV2,\n\t) {\n\t\tsuper('sync', executeMethod, query, cache, queryMetadata, cacheConfig);\n\t}\n\n\trun(placeholderValues?: Record<string, unknown>): RunResult {\n\t\tconst params = fillPlaceholders(this.query.params, placeholderValues ?? {});\n\t\tthis.logger.logQuery(this.query.sql, params);\n\t\treturn this.stmt.run(...params);\n\t}\n\n\tall(placeholderValues?: Record<string, unknown>): T['all'] {\n\t\tif (this.isRqbV2Query) return this.allRqbV2(placeholderValues);\n\n\t\tconst { fields, joinsNotNullableMap, query, logger, stmt, customResultMapper } = this;\n\t\tif (!fields && !customResultMapper) {\n\t\t\tconst params = fillPlaceholders(query.params, placeholderValues ?? {});\n\t\t\tlogger.logQuery(query.sql, params);\n\t\t\treturn stmt.all(...params);\n\t\t}\n\n\t\tconst rows = this.values(placeholderValues) as unknown[][];\n\t\tif (customResultMapper) {\n\t\t\treturn (customResultMapper as (rows: unknown[][]) => unknown)(rows) as T['all'];\n\t\t}\n\t\treturn rows.map((row) => mapResultRow(fields!, row, joinsNotNullableMap));\n\t}\n\n\tget(placeholderValues?: Record<string, unknown>): T['get'] {\n\t\tif (this.isRqbV2Query) return this.getRqbV2(placeholderValues);\n\n\t\tconst params = fillPlaceholders(this.query.params, placeholderValues ?? {});\n\t\tthis.logger.logQuery(this.query.sql, params);\n\n\t\tconst { fields, stmt, joinsNotNullableMap, customResultMapper } = this;\n\t\tif (!fields && !customResultMapper) {\n\t\t\treturn stmt.get(...params);\n\t\t}\n\n\t\tconst row = stmt.raw().get(...params) as unknown[];\n\n\t\tif (!row) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\tif (customResultMapper) {\n\t\t\treturn (customResultMapper as (rows: unknown[][]) => unknown)([row]) as T['get'];\n\t\t}\n\n\t\treturn mapResultRow(fields!, row, joinsNotNullableMap);\n\t}\n\n\tprivate allRqbV2(placeholderValues?: Record<string, unknown>): T['all'] {\n\t\tconst { query, logger, stmt, customResultMapper } = this;\n\n\t\tconst params = fillPlaceholders(query.params, placeholderValues ?? {});\n\t\tlogger.logQuery(query.sql, params);\n\t\treturn (customResultMapper as (rows: Record<string, unknown>[]) => unknown)(\n\t\t\tstmt.all(...params) as Record<string, unknown>[],\n\t\t);\n\t}\n\n\tprivate getRqbV2(placeholderValues?: Record<string, unknown>): T['get'] {\n\t\tconst params = fillPlaceholders(this.query.params, placeholderValues ?? {});\n\t\tthis.logger.logQuery(this.query.sql, params);\n\n\t\tconst { stmt, customResultMapper } = this;\n\n\t\tconst row = stmt.get(...params) as Record<string, unknown>;\n\t\tif (row === undefined) return row;\n\n\t\treturn (customResultMapper as (rows: Record<string, unknown>[]) => unknown)(\n\t\t\t[row],\n\t\t);\n\t}\n\n\tvalues(placeholderValues?: Record<string, unknown>): T['values'] {\n\t\tconst params = fillPlaceholders(this.query.params, placeholderValues ?? {});\n\t\tthis.logger.logQuery(this.query.sql, params);\n\t\treturn this.stmt.raw().all(...params) as T['values'];\n\t}\n\n\t/** @internal */\n\tisResponseInArrayMode(): boolean {\n\t\treturn this._isResponseInArrayMode;\n\t}\n}\n"],"mappings":"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"}