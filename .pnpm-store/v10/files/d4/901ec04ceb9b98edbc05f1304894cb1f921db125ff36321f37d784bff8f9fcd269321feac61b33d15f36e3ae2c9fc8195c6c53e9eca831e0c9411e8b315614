{"version":3,"file":"session.js","names":["query: Query","dialect: CockroachDialect","sql","schema: {\n\t\t\tfullSchema: Record<string, unknown>;\n\t\t\tschema: TSchema;\n\t\t\ttableNamesMap: Record<string, string>;\n\t\t} | undefined","chunks: string[]"],"sources":["../../src/cockroach-core/session.ts"],"sourcesContent":["import type * as V1 from '~/_relations.ts';\nimport { entityKind } from '~/entity.ts';\nimport { TransactionRollbackError } from '~/errors.ts';\nimport type { PreparedQuery } from '~/session.ts';\nimport { type Query, type SQL, sql } from '~/sql/index.ts';\nimport { tracer } from '~/tracing.ts';\nimport type { NeonAuthToken } from '~/utils.ts';\nimport { CockroachDatabase } from './db.ts';\nimport type { CockroachDialect } from './dialect.ts';\nimport type { SelectedFieldsOrdered } from './query-builders/select.types.ts';\n\nexport interface PreparedQueryConfig {\n\texecute: unknown;\n\tall: unknown;\n\tvalues: unknown;\n}\n\nexport abstract class CockroachPreparedQuery<T extends PreparedQueryConfig> implements PreparedQuery {\n\tconstructor(protected query: Query) {}\n\n\tprotected authToken?: NeonAuthToken;\n\n\tgetQuery(): Query {\n\t\treturn this.query;\n\t}\n\n\tmapResult(response: unknown, _isFromBatch?: boolean): unknown {\n\t\treturn response;\n\t}\n\n\t/** @internal */\n\tsetToken(token?: NeonAuthToken) {\n\t\tthis.authToken = token;\n\t\treturn this;\n\t}\n\n\tstatic readonly [entityKind]: string = 'CockroachPreparedQuery';\n\n\t/** @internal */\n\tjoinsNotNullableMap?: Record<string, boolean>;\n\n\tabstract execute(placeholderValues?: Record<string, unknown>): Promise<T['execute']>;\n\t/** @internal */\n\tabstract execute(placeholderValues?: Record<string, unknown>, token?: NeonAuthToken): Promise<T['execute']>;\n\t/** @internal */\n\tabstract execute(placeholderValues?: Record<string, unknown>, token?: NeonAuthToken): Promise<T['execute']>;\n\n\t/** @internal */\n\tabstract all(placeholderValues?: Record<string, unknown>): Promise<T['all']>;\n\n\t/** @internal */\n\tabstract isResponseInArrayMode(): boolean;\n}\n\nexport interface CockroachTransactionConfig {\n\tisolationLevel?: 'read uncommitted' | 'read committed' | 'repeatable read' | 'serializable';\n\taccessMode?: 'read only' | 'read write';\n\tdeferrable?: boolean;\n}\n\nexport abstract class CockroachSession<\n\tTQueryResult extends CockroachQueryResultHKT = CockroachQueryResultHKT,\n\tTFullSchema extends Record<string, unknown> = Record<string, never>,\n\tTSchema extends V1.TablesRelationalConfig = Record<string, never>,\n> {\n\tstatic readonly [entityKind]: string = 'CockroachSession';\n\n\tconstructor(protected dialect: CockroachDialect) {}\n\n\tabstract prepareQuery<T extends PreparedQueryConfig = PreparedQueryConfig>(\n\t\tquery: Query,\n\t\tfields: SelectedFieldsOrdered | undefined,\n\t\tname: string | undefined,\n\t\tisResponseInArrayMode: boolean,\n\t\tcustomResultMapper?: (rows: unknown[][], mapColumnValue?: (value: unknown) => unknown) => T['execute'],\n\t): CockroachPreparedQuery<T>;\n\n\texecute<T>(query: SQL): Promise<T>;\n\t/** @internal */\n\texecute<T>(query: SQL, token?: NeonAuthToken): Promise<T>;\n\t/** @internal */\n\texecute<T>(query: SQL, token?: NeonAuthToken): Promise<T> {\n\t\treturn tracer.startActiveSpan('drizzle.operation', () => {\n\t\t\tconst prepared = tracer.startActiveSpan('drizzle.prepareQuery', () => {\n\t\t\t\treturn this.prepareQuery<PreparedQueryConfig & { execute: T }>(\n\t\t\t\t\tthis.dialect.sqlToQuery(query),\n\t\t\t\t\tundefined,\n\t\t\t\t\tundefined,\n\t\t\t\t\tfalse,\n\t\t\t\t);\n\t\t\t});\n\n\t\t\treturn prepared.setToken(token).execute(undefined, token);\n\t\t});\n\t}\n\n\tall<T = unknown>(query: SQL): Promise<T[]> {\n\t\treturn this.prepareQuery<PreparedQueryConfig & { all: T[] }>(\n\t\t\tthis.dialect.sqlToQuery(query),\n\t\t\tundefined,\n\t\t\tundefined,\n\t\t\tfalse,\n\t\t).all();\n\t}\n\n\tasync count(sql: SQL): Promise<number>;\n\t/** @internal */\n\tasync count(sql: SQL, token?: NeonAuthToken): Promise<number>;\n\t/** @internal */\n\tasync count(sql: SQL, token?: NeonAuthToken): Promise<number> {\n\t\tconst res = await this.execute<[{ count: string }]>(sql, token);\n\n\t\treturn Number(\n\t\t\tres[0]['count'],\n\t\t);\n\t}\n\n\tabstract transaction<T>(\n\t\ttransaction: (tx: CockroachTransaction<TQueryResult, TFullSchema, TSchema>) => Promise<T>,\n\t\tconfig?: CockroachTransactionConfig,\n\t): Promise<T>;\n}\n\nexport abstract class CockroachTransaction<\n\tTQueryResult extends CockroachQueryResultHKT,\n\tTFullSchema extends Record<string, unknown> = Record<string, never>,\n\tTSchema extends V1.TablesRelationalConfig = Record<string, never>,\n> extends CockroachDatabase<TQueryResult, TFullSchema, TSchema> {\n\tstatic override readonly [entityKind]: string = 'CockroachTransaction';\n\n\tconstructor(\n\t\tdialect: CockroachDialect,\n\t\tsession: CockroachSession<any, any, any>,\n\t\tprotected schema: {\n\t\t\tfullSchema: Record<string, unknown>;\n\t\t\tschema: TSchema;\n\t\t\ttableNamesMap: Record<string, string>;\n\t\t} | undefined,\n\t\tprotected readonly nestedIndex = 0,\n\t) {\n\t\tsuper(dialect, session, schema);\n\t}\n\n\trollback(): never {\n\t\tthrow new TransactionRollbackError();\n\t}\n\n\t/** @internal */\n\tgetTransactionConfigSQL(config: CockroachTransactionConfig): SQL {\n\t\tconst chunks: string[] = [];\n\t\tif (config.isolationLevel) {\n\t\t\tchunks.push(`isolation level ${config.isolationLevel}`);\n\t\t}\n\t\tif (config.accessMode) {\n\t\t\tchunks.push(config.accessMode);\n\t\t}\n\t\tif (typeof config.deferrable === 'boolean') {\n\t\t\tchunks.push(config.deferrable ? 'deferrable' : 'not deferrable');\n\t\t}\n\t\treturn sql.raw(chunks.join(' '));\n\t}\n\n\tsetTransaction(config: CockroachTransactionConfig): Promise<void> {\n\t\treturn this.session.execute(sql`set transaction ${this.getTransactionConfigSQL(config)}`);\n\t}\n\n\tabstract override transaction<T>(\n\t\ttransaction: (tx: CockroachTransaction<TQueryResult, TFullSchema, TSchema>) => Promise<T>,\n\t): Promise<T>;\n}\n\nexport interface CockroachQueryResultHKT {\n\treadonly $brand: 'CockroachQueryResultHKT';\n\treadonly row: unknown;\n\treadonly type: unknown;\n}\n\nexport type CockroachQueryResultKind<TKind extends CockroachQueryResultHKT, TRow> = (TKind & {\n\treadonly row: TRow;\n})['type'];\n"],"mappings":";;;;;;;AAiBA,IAAsB,yBAAtB,MAAqG;CACpG,YAAY,AAAUA,OAAc;EAAd;;CAEtB,AAAU;CAEV,WAAkB;AACjB,SAAO,KAAK;;CAGb,UAAU,UAAmB,cAAiC;AAC7D,SAAO;;;CAIR,SAAS,OAAuB;AAC/B,OAAK,YAAY;AACjB,SAAO;;CAGR,QAAiB,cAAsB;;CAGvC;;AAqBD,IAAsB,mBAAtB,MAIE;CACD,QAAiB,cAAsB;CAEvC,YAAY,AAAUC,SAA2B;EAA3B;;;CActB,QAAW,OAAY,OAAmC;AACzD,SAAO,OAAO,gBAAgB,2BAA2B;AAUxD,UATiB,OAAO,gBAAgB,8BAA8B;AACrE,WAAO,KAAK,aACX,KAAK,QAAQ,WAAW,MAAM,EAC9B,QACA,QACA,MACA;KACA,CAEc,SAAS,MAAM,CAAC,QAAQ,QAAW,MAAM;IACxD;;CAGH,IAAiB,OAA0B;AAC1C,SAAO,KAAK,aACX,KAAK,QAAQ,WAAW,MAAM,EAC9B,QACA,QACA,MACA,CAAC,KAAK;;;CAOR,MAAM,MAAM,OAAU,OAAwC;EAC7D,MAAM,MAAM,MAAM,KAAK,QAA6BC,OAAK,MAAM;AAE/D,SAAO,OACN,IAAI,GAAG,SACP;;;AASH,IAAsB,uBAAtB,cAIU,kBAAsD;CAC/D,QAA0B,cAAsB;CAEhD,YACC,SACA,SACA,AAAUC,QAKV,AAAmB,cAAc,GAChC;AACD,QAAM,SAAS,SAAS,OAAO;EAPrB;EAKS;;CAKpB,WAAkB;AACjB,QAAM,IAAI,0BAA0B;;;CAIrC,wBAAwB,QAAyC;EAChE,MAAMC,SAAmB,EAAE;AAC3B,MAAI,OAAO,eACV,QAAO,KAAK,mBAAmB,OAAO,iBAAiB;AAExD,MAAI,OAAO,WACV,QAAO,KAAK,OAAO,WAAW;AAE/B,MAAI,OAAO,OAAO,eAAe,UAChC,QAAO,KAAK,OAAO,aAAa,eAAe,iBAAiB;AAEjE,SAAO,IAAI,IAAI,OAAO,KAAK,IAAI,CAAC;;CAGjC,eAAe,QAAmD;AACjE,SAAO,KAAK,QAAQ,QAAQ,GAAG,mBAAmB,KAAK,wBAAwB,OAAO,GAAG"}