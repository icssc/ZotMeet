{"version":3,"sources":["../../src/lib/generate-interception-routes-rewrites.ts"],"sourcesContent":["import { NEXT_URL } from '../client/components/app-router-headers'\nimport {\n  extractInterceptionRouteInformation,\n  isInterceptionRouteAppPath,\n} from '../shared/lib/router/utils/interception-routes'\nimport type { Rewrite } from './load-custom-routes'\nimport type { DeepReadonly } from '../shared/lib/deep-readonly'\nimport { getNamedRouteRegex } from '../shared/lib/router/utils/route-regex'\n\nexport function generateInterceptionRoutesRewrites(\n  appPaths: string[],\n  basePath = ''\n): Rewrite[] {\n  const rewrites: Rewrite[] = []\n\n  for (const appPath of appPaths) {\n    if (isInterceptionRouteAppPath(appPath)) {\n      const { interceptingRoute, interceptedRoute } =\n        extractInterceptionRouteInformation(appPath)\n\n      const destination = getNamedRouteRegex(basePath + appPath, {\n        prefixRouteKeys: true,\n      })\n\n      const header = getNamedRouteRegex(interceptingRoute, {\n        prefixRouteKeys: true,\n        reference: destination.reference,\n      })\n\n      const source = getNamedRouteRegex(basePath + interceptedRoute, {\n        prefixRouteKeys: true,\n        reference: header.reference,\n      })\n\n      const headerRegex = header.namedRegex\n        // Strip ^ and $ anchors since matchHas() will add them automatically\n        .replace(/^\\^/, '')\n        .replace(/\\$$/, '')\n        // Replace matching the `/` with matching any route segment.\n        .replace(/^\\/\\(\\?:\\/\\)\\?$/, '/.*')\n        // Replace the optional trailing with slash capture group with one that\n        // will match any descendants.\n        .replace(/\\(\\?:\\/\\)\\?$/, '(?:/.*)?')\n\n      rewrites.push({\n        source: source.pathToRegexpPattern,\n        destination: destination.pathToRegexpPattern,\n        has: [\n          {\n            type: 'header',\n            key: NEXT_URL,\n            value: headerRegex,\n          },\n        ],\n        regex: source.namedRegex,\n      })\n    }\n  }\n\n  return rewrites\n}\n\nexport function isInterceptionRouteRewrite(route: DeepReadonly<Rewrite>) {\n  // When we generate interception rewrites in the above implementation, we always do so with only a single `has` condition.\n  return route.has?.[0]?.key === NEXT_URL\n}\n"],"names":["generateInterceptionRoutesRewrites","isInterceptionRouteRewrite","appPaths","basePath","rewrites","appPath","isInterceptionRouteAppPath","interceptingRoute","interceptedRoute","extractInterceptionRouteInformation","destination","getNamedRouteRegex","prefixRouteKeys","header","reference","source","headerRegex","namedRegex","replace","push","pathToRegexpPattern","has","type","key","NEXT_URL","value","regex","route"],"mappings":";;;;;;;;;;;;;;;IASgBA,kCAAkC;eAAlCA;;IAqDAC,0BAA0B;eAA1BA;;;kCA9DS;oCAIlB;4BAG4B;AAE5B,SAASD,mCACdE,QAAkB,EAClBC,WAAW,EAAE;IAEb,MAAMC,WAAsB,EAAE;IAE9B,KAAK,MAAMC,WAAWH,SAAU;QAC9B,IAAII,IAAAA,8CAA0B,EAACD,UAAU;YACvC,MAAM,EAAEE,iBAAiB,EAAEC,gBAAgB,EAAE,GAC3CC,IAAAA,uDAAmC,EAACJ;YAEtC,MAAMK,cAAcC,IAAAA,8BAAkB,EAACR,WAAWE,SAAS;gBACzDO,iBAAiB;YACnB;YAEA,MAAMC,SAASF,IAAAA,8BAAkB,EAACJ,mBAAmB;gBACnDK,iBAAiB;gBACjBE,WAAWJ,YAAYI,SAAS;YAClC;YAEA,MAAMC,SAASJ,IAAAA,8BAAkB,EAACR,WAAWK,kBAAkB;gBAC7DI,iBAAiB;gBACjBE,WAAWD,OAAOC,SAAS;YAC7B;YAEA,MAAME,cAAcH,OAAOI,UAAU,AACnC,qEAAqE;aACpEC,OAAO,CAAC,OAAO,IACfA,OAAO,CAAC,OAAO,GAChB,4DAA4D;aAC3DA,OAAO,CAAC,mBAAmB,MAC5B,uEAAuE;YACvE,8BAA8B;aAC7BA,OAAO,CAAC,gBAAgB;YAE3Bd,SAASe,IAAI,CAAC;gBACZJ,QAAQA,OAAOK,mBAAmB;gBAClCV,aAAaA,YAAYU,mBAAmB;gBAC5CC,KAAK;oBACH;wBACEC,MAAM;wBACNC,KAAKC,0BAAQ;wBACbC,OAAOT;oBACT;iBACD;gBACDU,OAAOX,OAAOE,UAAU;YAC1B;QACF;IACF;IAEA,OAAOb;AACT;AAEO,SAASH,2BAA2B0B,KAA4B;QAE9DA,aAAAA;IADP,0HAA0H;IAC1H,OAAOA,EAAAA,aAAAA,MAAMN,GAAG,sBAATM,cAAAA,UAAW,CAAC,EAAE,qBAAdA,YAAgBJ,GAAG,MAAKC,0BAAQ;AACzC","ignoreList":[0]}