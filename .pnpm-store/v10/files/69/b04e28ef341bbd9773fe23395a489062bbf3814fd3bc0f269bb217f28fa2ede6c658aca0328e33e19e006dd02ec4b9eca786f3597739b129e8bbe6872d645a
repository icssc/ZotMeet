{"version":3,"file":"db.js","names":["resultKind: TResultKind","dialect: { sync: SQLiteSyncDialect; async: SQLiteAsyncDialect }[TResultKind]","session: SQLiteSession<TResultKind, TRunResult, TFullSchema, TRelations, TSchema>","rowModeRQB?: boolean","forbidJsonb?: boolean","select: Q['select']","selectDistinct: Q['selectDistinct']","$count: Q['$count']","$with: Q['with']","update: Q['update']","insert: Q['insert']","$delete: Q['delete']","run: Q['run']","all: Q['all']","get: Q['get']","values: Q['values']","transaction: Q['transaction']"],"sources":["../../src/sqlite-core/db.ts"],"sourcesContent":["import type * as V1 from '~/_relations.ts';\nimport type { Cache } from '~/cache/core/cache.ts';\nimport { entityKind } from '~/entity.ts';\nimport type { TypedQueryBuilder } from '~/query-builders/query-builder.ts';\nimport type { AnyRelations, EmptyRelations } from '~/relations.ts';\nimport { SelectionProxyHandler } from '~/selection-proxy.ts';\nimport { type ColumnsSelection, type SQL, sql, type SQLWrapper } from '~/sql/sql.ts';\nimport type { SQLiteAsyncDialect, SQLiteSyncDialect } from '~/sqlite-core/dialect.ts';\nimport {\n\tQueryBuilder,\n\tSQLiteDeleteBase,\n\tSQLiteInsertBuilder,\n\tSQLiteSelectBuilder,\n\tSQLiteUpdateBuilder,\n} from '~/sqlite-core/query-builders/index.ts';\nimport type {\n\tDBResult,\n\tResult,\n\tSQLiteSession,\n\tSQLiteTransaction,\n\tSQLiteTransactionConfig,\n} from '~/sqlite-core/session.ts';\nimport type { SQLiteTable } from '~/sqlite-core/table.ts';\nimport { WithSubquery } from '~/subquery.ts';\nimport type { DrizzleTypeError } from '~/utils.ts';\nimport { _RelationalQueryBuilder } from './query-builders/_query.ts';\nimport { SQLiteCountBuilder } from './query-builders/count.ts';\nimport { RelationalQueryBuilder } from './query-builders/query.ts';\nimport { SQLiteRaw } from './query-builders/raw.ts';\nimport type { SelectedFields } from './query-builders/select.types.ts';\nimport type { WithBuilder } from './subquery.ts';\nimport type { SQLiteViewBase } from './view-base.ts';\n\nexport class BaseSQLiteDatabase<\n\tTResultKind extends 'sync' | 'async',\n\tTRunResult,\n\tTFullSchema extends Record<string, unknown> = Record<string, never>,\n\tTRelations extends AnyRelations = EmptyRelations,\n\tTSchema extends V1.TablesRelationalConfig = V1.ExtractTablesWithRelations<TFullSchema>,\n> {\n\tstatic readonly [entityKind]: string = 'BaseSQLiteDatabase';\n\n\tdeclare readonly _: {\n\t\treadonly schema: TSchema | undefined;\n\t\treadonly fullSchema: TFullSchema;\n\t\treadonly tableNamesMap: Record<string, string>;\n\t\treadonly relations: TRelations;\n\t};\n\n\t/** @deprecated */\n\t_query: TFullSchema extends Record<string, never>\n\t\t? DrizzleTypeError<'Seems like the schema generic is missing - did you forget to add it to your DB type?'>\n\t\t: {\n\t\t\t[K in keyof TSchema]: _RelationalQueryBuilder<TResultKind, TFullSchema, TSchema, TSchema[K]>;\n\t\t};\n\n\t// TO-DO: Figure out how to pass DrizzleTypeError without breaking withReplicas\n\tquery: {\n\t\t[K in keyof TRelations]: RelationalQueryBuilder<\n\t\t\tTResultKind,\n\t\t\tTRelations,\n\t\t\tTRelations[K]\n\t\t>;\n\t};\n\n\tconstructor(\n\t\tprivate resultKind: TResultKind,\n\t\t/** @internal */\n\t\treadonly dialect: { sync: SQLiteSyncDialect; async: SQLiteAsyncDialect }[TResultKind],\n\t\t/** @internal */\n\t\treadonly session: SQLiteSession<TResultKind, TRunResult, TFullSchema, TRelations, TSchema>,\n\t\trelations: TRelations,\n\t\t_schema: V1.RelationalSchemaConfig<TSchema> | undefined,\n\t\treadonly rowModeRQB?: boolean,\n\t\treadonly forbidJsonb?: boolean,\n\t) {\n\t\tthis._ = _schema\n\t\t\t? {\n\t\t\t\tschema: _schema.schema,\n\t\t\t\tfullSchema: _schema.fullSchema as TFullSchema,\n\t\t\t\ttableNamesMap: _schema.tableNamesMap,\n\t\t\t\trelations,\n\t\t\t}\n\t\t\t: {\n\t\t\t\tschema: undefined,\n\t\t\t\tfullSchema: {} as TFullSchema,\n\t\t\t\ttableNamesMap: {},\n\t\t\t\trelations,\n\t\t\t};\n\n\t\tthis._query = {} as typeof this['_query'];\n\t\tconst query = this._query as {\n\t\t\t[K in keyof TSchema]: _RelationalQueryBuilder<TResultKind, TFullSchema, TSchema, TSchema[K]>;\n\t\t};\n\t\tif (this._.schema) {\n\t\t\tfor (const [tableName, columns] of Object.entries(this._.schema)) {\n\t\t\t\tquery[tableName as keyof TSchema] = new _RelationalQueryBuilder(\n\t\t\t\t\tresultKind,\n\t\t\t\t\t_schema!.fullSchema,\n\t\t\t\t\tthis._.schema,\n\t\t\t\t\tthis._.tableNamesMap,\n\t\t\t\t\t_schema!.fullSchema[tableName] as SQLiteTable,\n\t\t\t\t\tcolumns,\n\t\t\t\t\tdialect,\n\t\t\t\t\tsession as SQLiteSession<any, any, any, any, any>,\n\t\t\t\t) as typeof query[keyof TSchema];\n\t\t\t}\n\t\t}\n\t\tthis.query = {} as typeof this['query'];\n\t\tfor (const [tableName, relation] of Object.entries(relations)) {\n\t\t\t(this.query as BaseSQLiteDatabase<\n\t\t\t\tTResultKind,\n\t\t\t\tTRunResult,\n\t\t\t\tTSchema,\n\t\t\t\tAnyRelations,\n\t\t\t\tV1.TablesRelationalConfig\n\t\t\t>['query'])[tableName] = new RelationalQueryBuilder(\n\t\t\t\tresultKind,\n\t\t\t\trelations,\n\t\t\t\trelations[relation.name]!.table as SQLiteTable,\n\t\t\t\trelation,\n\t\t\t\tdialect,\n\t\t\t\tsession as SQLiteSession<any, any, any, any, any>,\n\t\t\t\trowModeRQB,\n\t\t\t\tforbidJsonb,\n\t\t\t);\n\t\t}\n\t\tthis.$cache = { invalidate: async (_params: any) => {} };\n\t}\n\n\t/**\n\t * Creates a subquery that defines a temporary named result set as a CTE.\n\t *\n\t * It is useful for breaking down complex queries into simpler parts and for reusing the result set in subsequent parts of the query.\n\t *\n\t * See docs: {@link https://orm.drizzle.team/docs/select#with-clause}\n\t *\n\t * @param alias The alias for the subquery.\n\t *\n\t * Failure to provide an alias will result in a DrizzleTypeError, preventing the subquery from being referenced in other queries.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * // Create a subquery with alias 'sq' and use it in the select query\n\t * const sq = db.$with('sq').as(db.select().from(users).where(eq(users.id, 42)));\n\t *\n\t * const result = await db.with(sq).select().from(sq);\n\t * ```\n\t *\n\t * To select arbitrary SQL values as fields in a CTE and reference them in other CTEs or in the main query, you need to add aliases to them:\n\t *\n\t * ```ts\n\t * // Select an arbitrary SQL value as a field in a CTE and reference it in the main query\n\t * const sq = db.$with('sq').as(db.select({\n\t *   name: sql<string>`upper(${users.name})`.as('name'),\n\t * })\n\t * .from(users));\n\t *\n\t * const result = await db.with(sq).select({ name: sq.name }).from(sq);\n\t * ```\n\t */\n\t$with: WithBuilder = (alias: string, selection?: ColumnsSelection) => {\n\t\tconst self = this;\n\t\tconst as = (\n\t\t\tqb:\n\t\t\t\t| TypedQueryBuilder<ColumnsSelection | undefined>\n\t\t\t\t| SQL\n\t\t\t\t| ((qb: QueryBuilder) => TypedQueryBuilder<ColumnsSelection | undefined> | SQL),\n\t\t) => {\n\t\t\tif (typeof qb === 'function') {\n\t\t\t\tqb = qb(new QueryBuilder(self.dialect));\n\t\t\t}\n\n\t\t\treturn new Proxy(\n\t\t\t\tnew WithSubquery(\n\t\t\t\t\tqb.getSQL(),\n\t\t\t\t\tselection ?? ('getSelectedFields' in qb ? qb.getSelectedFields() ?? {} : {}) as SelectedFields,\n\t\t\t\t\talias,\n\t\t\t\t\ttrue,\n\t\t\t\t),\n\t\t\t\tnew SelectionProxyHandler({ alias, sqlAliasedBehavior: 'alias', sqlBehavior: 'error' }),\n\t\t\t);\n\t\t};\n\t\treturn { as };\n\t};\n\n\t$count(\n\t\tsource: SQLiteTable | SQLiteViewBase | SQL | SQLWrapper,\n\t\tfilters?: SQL<unknown>,\n\t) {\n\t\treturn new SQLiteCountBuilder({ source, filters, session: this.session });\n\t}\n\n\t/**\n\t * Incorporates a previously defined CTE (using `$with`) into the main query.\n\t *\n\t * This method allows the main query to reference a temporary named result set.\n\t *\n\t * See docs: {@link https://orm.drizzle.team/docs/select#with-clause}\n\t *\n\t * @param queries The CTEs to incorporate into the main query.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * // Define a subquery 'sq' as a CTE using $with\n\t * const sq = db.$with('sq').as(db.select().from(users).where(eq(users.id, 42)));\n\t *\n\t * // Incorporate the CTE 'sq' into the main query and select from it\n\t * const result = await db.with(sq).select().from(sq);\n\t * ```\n\t */\n\twith(...queries: WithSubquery[]) {\n\t\tconst self = this;\n\n\t\t/**\n\t\t * Creates a select query.\n\t\t *\n\t\t * Calling this method with no arguments will select all columns from the table. Pass a selection object to specify the columns you want to select.\n\t\t *\n\t\t * Use `.from()` method to specify which table to select from.\n\t\t *\n\t\t * See docs: {@link https://orm.drizzle.team/docs/select}\n\t\t *\n\t\t * @param fields The selection object.\n\t\t *\n\t\t * @example\n\t\t *\n\t\t * ```ts\n\t\t * // Select all columns and all rows from the 'cars' table\n\t\t * const allCars: Car[] = await db.select().from(cars);\n\t\t *\n\t\t * // Select specific columns and all rows from the 'cars' table\n\t\t * const carsIdsAndBrands: { id: number; brand: string }[] = await db.select({\n\t\t *   id: cars.id,\n\t\t *   brand: cars.brand\n\t\t * })\n\t\t *   .from(cars);\n\t\t * ```\n\t\t *\n\t\t * Like in SQL, you can use arbitrary expressions as selection fields, not just table columns:\n\t\t *\n\t\t * ```ts\n\t\t * // Select specific columns along with expression and all rows from the 'cars' table\n\t\t * const carsIdsAndLowerNames: { id: number; lowerBrand: string }[] = await db.select({\n\t\t *   id: cars.id,\n\t\t *   lowerBrand: sql<string>`lower(${cars.brand})`,\n\t\t * })\n\t\t *   .from(cars);\n\t\t * ```\n\t\t */\n\t\tfunction select(): SQLiteSelectBuilder<undefined, TResultKind, TRunResult>;\n\t\tfunction select<TSelection extends SelectedFields>(\n\t\t\tfields: TSelection,\n\t\t): SQLiteSelectBuilder<TSelection, TResultKind, TRunResult>;\n\t\tfunction select(\n\t\t\tfields?: SelectedFields,\n\t\t): SQLiteSelectBuilder<SelectedFields | undefined, TResultKind, TRunResult> {\n\t\t\treturn new SQLiteSelectBuilder({\n\t\t\t\tfields: fields ?? undefined,\n\t\t\t\tsession: self.session,\n\t\t\t\tdialect: self.dialect,\n\t\t\t\twithList: queries,\n\t\t\t});\n\t\t}\n\n\t\t/**\n\t\t * Adds `distinct` expression to the select query.\n\t\t *\n\t\t * Calling this method will return only unique values. When multiple columns are selected, it returns rows with unique combinations of values in these columns.\n\t\t *\n\t\t * Use `.from()` method to specify which table to select from.\n\t\t *\n\t\t * See docs: {@link https://orm.drizzle.team/docs/select#distinct}\n\t\t *\n\t\t * @param fields The selection object.\n\t\t *\n\t\t * @example\n\t\t *\n\t\t * ```ts\n\t\t * // Select all unique rows from the 'cars' table\n\t\t * await db.selectDistinct()\n\t\t *   .from(cars)\n\t\t *   .orderBy(cars.id, cars.brand, cars.color);\n\t\t *\n\t\t * // Select all unique brands from the 'cars' table\n\t\t * await db.selectDistinct({ brand: cars.brand })\n\t\t *   .from(cars)\n\t\t *   .orderBy(cars.brand);\n\t\t * ```\n\t\t */\n\t\tfunction selectDistinct(): SQLiteSelectBuilder<undefined, TResultKind, TRunResult>;\n\t\tfunction selectDistinct<TSelection extends SelectedFields>(\n\t\t\tfields: TSelection,\n\t\t): SQLiteSelectBuilder<TSelection, TResultKind, TRunResult>;\n\t\tfunction selectDistinct(\n\t\t\tfields?: SelectedFields,\n\t\t): SQLiteSelectBuilder<SelectedFields | undefined, TResultKind, TRunResult> {\n\t\t\treturn new SQLiteSelectBuilder({\n\t\t\t\tfields: fields ?? undefined,\n\t\t\t\tsession: self.session,\n\t\t\t\tdialect: self.dialect,\n\t\t\t\twithList: queries,\n\t\t\t\tdistinct: true,\n\t\t\t});\n\t\t}\n\n\t\t/**\n\t\t * Creates an update query.\n\t\t *\n\t\t * Calling this method without `.where()` clause will update all rows in a table. The `.where()` clause specifies which rows should be updated.\n\t\t *\n\t\t * Use `.set()` method to specify which values to update.\n\t\t *\n\t\t * See docs: {@link https://orm.drizzle.team/docs/update}\n\t\t *\n\t\t * @param table The table to update.\n\t\t *\n\t\t * @example\n\t\t *\n\t\t * ```ts\n\t\t * // Update all rows in the 'cars' table\n\t\t * await db.update(cars).set({ color: 'red' });\n\t\t *\n\t\t * // Update rows with filters and conditions\n\t\t * await db.update(cars).set({ color: 'red' }).where(eq(cars.brand, 'BMW'));\n\t\t *\n\t\t * // Update with returning clause\n\t\t * const updatedCar: Car[] = await db.update(cars)\n\t\t *   .set({ color: 'red' })\n\t\t *   .where(eq(cars.id, 1))\n\t\t *   .returning();\n\t\t * ```\n\t\t */\n\t\tfunction update<TTable extends SQLiteTable>(table: TTable): SQLiteUpdateBuilder<TTable, TResultKind, TRunResult> {\n\t\t\treturn new SQLiteUpdateBuilder(table, self.session, self.dialect, queries);\n\t\t}\n\n\t\t/**\n\t\t * Creates an insert query.\n\t\t *\n\t\t * Calling this method will create new rows in a table. Use `.values()` method to specify which values to insert.\n\t\t *\n\t\t * See docs: {@link https://orm.drizzle.team/docs/insert}\n\t\t *\n\t\t * @param table The table to insert into.\n\t\t *\n\t\t * @example\n\t\t *\n\t\t * ```ts\n\t\t * // Insert one row\n\t\t * await db.insert(cars).values({ brand: 'BMW' });\n\t\t *\n\t\t * // Insert multiple rows\n\t\t * await db.insert(cars).values([{ brand: 'BMW' }, { brand: 'Porsche' }]);\n\t\t *\n\t\t * // Insert with returning clause\n\t\t * const insertedCar: Car[] = await db.insert(cars)\n\t\t *   .values({ brand: 'BMW' })\n\t\t *   .returning();\n\t\t * ```\n\t\t */\n\t\tfunction insert<TTable extends SQLiteTable>(into: TTable): SQLiteInsertBuilder<TTable, TResultKind, TRunResult> {\n\t\t\treturn new SQLiteInsertBuilder(into, self.session, self.dialect, queries);\n\t\t}\n\n\t\t/**\n\t\t * Creates a delete query.\n\t\t *\n\t\t * Calling this method without `.where()` clause will delete all rows in a table. The `.where()` clause specifies which rows should be deleted.\n\t\t *\n\t\t * See docs: {@link https://orm.drizzle.team/docs/delete}\n\t\t *\n\t\t * @param table The table to delete from.\n\t\t *\n\t\t * @example\n\t\t *\n\t\t * ```ts\n\t\t * // Delete all rows in the 'cars' table\n\t\t * await db.delete(cars);\n\t\t *\n\t\t * // Delete rows with filters and conditions\n\t\t * await db.delete(cars).where(eq(cars.color, 'green'));\n\t\t *\n\t\t * // Delete with returning clause\n\t\t * const deletedCar: Car[] = await db.delete(cars)\n\t\t *   .where(eq(cars.id, 1))\n\t\t *   .returning();\n\t\t * ```\n\t\t */\n\t\tfunction delete_<TTable extends SQLiteTable>(from: TTable): SQLiteDeleteBase<TTable, TResultKind, TRunResult> {\n\t\t\treturn new SQLiteDeleteBase(from, self.session, self.dialect, queries);\n\t\t}\n\n\t\treturn { select, selectDistinct, update, insert, delete: delete_ };\n\t}\n\n\t/**\n\t * Creates a select query.\n\t *\n\t * Calling this method with no arguments will select all columns from the table. Pass a selection object to specify the columns you want to select.\n\t *\n\t * Use `.from()` method to specify which table to select from.\n\t *\n\t * See docs: {@link https://orm.drizzle.team/docs/select}\n\t *\n\t * @param fields The selection object.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * // Select all columns and all rows from the 'cars' table\n\t * const allCars: Car[] = await db.select().from(cars);\n\t *\n\t * // Select specific columns and all rows from the 'cars' table\n\t * const carsIdsAndBrands: { id: number; brand: string }[] = await db.select({\n\t *   id: cars.id,\n\t *   brand: cars.brand\n\t * })\n\t *   .from(cars);\n\t * ```\n\t *\n\t * Like in SQL, you can use arbitrary expressions as selection fields, not just table columns:\n\t *\n\t * ```ts\n\t * // Select specific columns along with expression and all rows from the 'cars' table\n\t * const carsIdsAndLowerNames: { id: number; lowerBrand: string }[] = await db.select({\n\t *   id: cars.id,\n\t *   lowerBrand: sql<string>`lower(${cars.brand})`,\n\t * })\n\t *   .from(cars);\n\t * ```\n\t */\n\tselect(): SQLiteSelectBuilder<undefined, TResultKind, TRunResult>;\n\tselect<TSelection extends SelectedFields>(\n\t\tfields: TSelection,\n\t): SQLiteSelectBuilder<TSelection, TResultKind, TRunResult>;\n\tselect(fields?: SelectedFields): SQLiteSelectBuilder<SelectedFields | undefined, TResultKind, TRunResult> {\n\t\treturn new SQLiteSelectBuilder({ fields: fields ?? undefined, session: this.session, dialect: this.dialect });\n\t}\n\n\t/**\n\t * Adds `distinct` expression to the select query.\n\t *\n\t * Calling this method will return only unique values. When multiple columns are selected, it returns rows with unique combinations of values in these columns.\n\t *\n\t * Use `.from()` method to specify which table to select from.\n\t *\n\t * See docs: {@link https://orm.drizzle.team/docs/select#distinct}\n\t *\n\t * @param fields The selection object.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * // Select all unique rows from the 'cars' table\n\t * await db.selectDistinct()\n\t *   .from(cars)\n\t *   .orderBy(cars.id, cars.brand, cars.color);\n\t *\n\t * // Select all unique brands from the 'cars' table\n\t * await db.selectDistinct({ brand: cars.brand })\n\t *   .from(cars)\n\t *   .orderBy(cars.brand);\n\t * ```\n\t */\n\tselectDistinct(): SQLiteSelectBuilder<undefined, TResultKind, TRunResult>;\n\tselectDistinct<TSelection extends SelectedFields>(\n\t\tfields: TSelection,\n\t): SQLiteSelectBuilder<TSelection, TResultKind, TRunResult>;\n\tselectDistinct(\n\t\tfields?: SelectedFields,\n\t): SQLiteSelectBuilder<SelectedFields | undefined, TResultKind, TRunResult> {\n\t\treturn new SQLiteSelectBuilder({\n\t\t\tfields: fields ?? undefined,\n\t\t\tsession: this.session,\n\t\t\tdialect: this.dialect,\n\t\t\tdistinct: true,\n\t\t});\n\t}\n\n\t/**\n\t * Creates an update query.\n\t *\n\t * Calling this method without `.where()` clause will update all rows in a table. The `.where()` clause specifies which rows should be updated.\n\t *\n\t * Use `.set()` method to specify which values to update.\n\t *\n\t * See docs: {@link https://orm.drizzle.team/docs/update}\n\t *\n\t * @param table The table to update.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * // Update all rows in the 'cars' table\n\t * await db.update(cars).set({ color: 'red' });\n\t *\n\t * // Update rows with filters and conditions\n\t * await db.update(cars).set({ color: 'red' }).where(eq(cars.brand, 'BMW'));\n\t *\n\t * // Update with returning clause\n\t * const updatedCar: Car[] = await db.update(cars)\n\t *   .set({ color: 'red' })\n\t *   .where(eq(cars.id, 1))\n\t *   .returning();\n\t * ```\n\t */\n\tupdate<TTable extends SQLiteTable>(table: TTable): SQLiteUpdateBuilder<TTable, TResultKind, TRunResult> {\n\t\treturn new SQLiteUpdateBuilder(table, this.session, this.dialect);\n\t}\n\n\t$cache: { invalidate: Cache['onMutate'] };\n\n\t/**\n\t * Creates an insert query.\n\t *\n\t * Calling this method will create new rows in a table. Use `.values()` method to specify which values to insert.\n\t *\n\t * See docs: {@link https://orm.drizzle.team/docs/insert}\n\t *\n\t * @param table The table to insert into.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * // Insert one row\n\t * await db.insert(cars).values({ brand: 'BMW' });\n\t *\n\t * // Insert multiple rows\n\t * await db.insert(cars).values([{ brand: 'BMW' }, { brand: 'Porsche' }]);\n\t *\n\t * // Insert with returning clause\n\t * const insertedCar: Car[] = await db.insert(cars)\n\t *   .values({ brand: 'BMW' })\n\t *   .returning();\n\t * ```\n\t */\n\tinsert<TTable extends SQLiteTable>(into: TTable): SQLiteInsertBuilder<TTable, TResultKind, TRunResult> {\n\t\treturn new SQLiteInsertBuilder(into, this.session, this.dialect);\n\t}\n\n\t/**\n\t * Creates a delete query.\n\t *\n\t * Calling this method without `.where()` clause will delete all rows in a table. The `.where()` clause specifies which rows should be deleted.\n\t *\n\t * See docs: {@link https://orm.drizzle.team/docs/delete}\n\t *\n\t * @param table The table to delete from.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * // Delete all rows in the 'cars' table\n\t * await db.delete(cars);\n\t *\n\t * // Delete rows with filters and conditions\n\t * await db.delete(cars).where(eq(cars.color, 'green'));\n\t *\n\t * // Delete with returning clause\n\t * const deletedCar: Car[] = await db.delete(cars)\n\t *   .where(eq(cars.id, 1))\n\t *   .returning();\n\t * ```\n\t */\n\tdelete<TTable extends SQLiteTable>(from: TTable): SQLiteDeleteBase<TTable, TResultKind, TRunResult> {\n\t\treturn new SQLiteDeleteBase(from, this.session, this.dialect);\n\t}\n\n\trun(query: SQLWrapper | string): DBResult<TResultKind, TRunResult> {\n\t\tconst sequel = typeof query === 'string' ? sql.raw(query) : query.getSQL();\n\t\tif (this.resultKind === 'async') {\n\t\t\treturn new SQLiteRaw(\n\t\t\t\tasync () => this.session.run(sequel),\n\t\t\t\t() => sequel,\n\t\t\t\t'run',\n\t\t\t\tthis.dialect as SQLiteAsyncDialect,\n\t\t\t\tthis.session.extractRawRunValueFromBatchResult.bind(this.session),\n\t\t\t) as DBResult<TResultKind, TRunResult>;\n\t\t}\n\t\treturn this.session.run(sequel) as DBResult<TResultKind, TRunResult>;\n\t}\n\n\tall<T = unknown>(query: SQLWrapper | string): DBResult<TResultKind, T[]> {\n\t\tconst sequel = typeof query === 'string' ? sql.raw(query) : query.getSQL();\n\t\tif (this.resultKind === 'async') {\n\t\t\treturn new SQLiteRaw(\n\t\t\t\tasync () => this.session.all(sequel),\n\t\t\t\t() => sequel,\n\t\t\t\t'all',\n\t\t\t\tthis.dialect as SQLiteAsyncDialect,\n\t\t\t\tthis.session.extractRawAllValueFromBatchResult.bind(this.session),\n\t\t\t) as any;\n\t\t}\n\t\treturn this.session.all(sequel) as DBResult<TResultKind, T[]>;\n\t}\n\n\tget<T = unknown>(query: SQLWrapper | string): DBResult<TResultKind, T> {\n\t\tconst sequel = typeof query === 'string' ? sql.raw(query) : query.getSQL();\n\t\tif (this.resultKind === 'async') {\n\t\t\treturn new SQLiteRaw(\n\t\t\t\tasync () => this.session.get(sequel),\n\t\t\t\t() => sequel,\n\t\t\t\t'get',\n\t\t\t\tthis.dialect as SQLiteAsyncDialect,\n\t\t\t\tthis.session.extractRawGetValueFromBatchResult.bind(this.session),\n\t\t\t) as DBResult<TResultKind, T>;\n\t\t}\n\t\treturn this.session.get(sequel) as DBResult<TResultKind, T>;\n\t}\n\n\tvalues<T extends unknown[] = unknown[]>(query: SQLWrapper | string): DBResult<TResultKind, T[]> {\n\t\tconst sequel = typeof query === 'string' ? sql.raw(query) : query.getSQL();\n\t\tif (this.resultKind === 'async') {\n\t\t\treturn new SQLiteRaw(\n\t\t\t\tasync () => this.session.values(sequel),\n\t\t\t\t() => sequel,\n\t\t\t\t'values',\n\t\t\t\tthis.dialect as SQLiteAsyncDialect,\n\t\t\t\tthis.session.extractRawValuesValueFromBatchResult.bind(this.session),\n\t\t\t) as any;\n\t\t}\n\t\treturn this.session.values(sequel) as DBResult<TResultKind, T[]>;\n\t}\n\n\ttransaction<T>(\n\t\ttransaction: (\n\t\t\ttx: SQLiteTransaction<TResultKind, TRunResult, TFullSchema, TRelations, TSchema>,\n\t\t) => Result<TResultKind, T>,\n\t\tconfig?: SQLiteTransactionConfig,\n\t): Result<TResultKind, T> {\n\t\treturn this.session.transaction(transaction, config);\n\t}\n}\n\nexport type SQLiteWithReplicas<Q> = Q & { $primary: Q; $replicas: Q[] };\n\nexport const withReplicas = <\n\tTResultKind extends 'sync' | 'async',\n\tTRunResult,\n\tTFullSchema extends Record<string, unknown>,\n\tTRelations extends AnyRelations,\n\tTSchema extends V1.TablesRelationalConfig,\n\tQ extends BaseSQLiteDatabase<\n\t\tTResultKind,\n\t\tTRunResult,\n\t\tTFullSchema,\n\t\tTRelations,\n\t\tTSchema extends Record<string, unknown> ? V1.ExtractTablesWithRelations<TFullSchema> : TSchema\n\t>,\n>(\n\tprimary: Q,\n\treplicas: [Q, ...Q[]],\n\tgetReplica: (replicas: Q[]) => Q = () => replicas[Math.floor(Math.random() * replicas.length)]!,\n): SQLiteWithReplicas<Q> => {\n\tconst select: Q['select'] = (...args: []) => getReplica(replicas).select(...args);\n\tconst selectDistinct: Q['selectDistinct'] = (...args: []) => getReplica(replicas).selectDistinct(...args);\n\tconst $count: Q['$count'] = (...args: [any]) => getReplica(replicas).$count(...args);\n\tconst $with: Q['with'] = (...args: []) => getReplica(replicas).with(...args);\n\n\tconst update: Q['update'] = (...args: [any]) => primary.update(...args);\n\tconst insert: Q['insert'] = (...args: [any]) => primary.insert(...args);\n\tconst $delete: Q['delete'] = (...args: [any]) => primary.delete(...args);\n\tconst run: Q['run'] = (...args: [any]) => primary.run(...args);\n\tconst all: Q['all'] = (...args: [any]) => primary.all(...args);\n\tconst get: Q['get'] = (...args: [any]) => primary.get(...args);\n\tconst values: Q['values'] = (...args: [any]) => primary.values(...args);\n\tconst transaction: Q['transaction'] = (...args: [any]) => primary.transaction(...args);\n\n\treturn {\n\t\t...primary,\n\t\tupdate,\n\t\tinsert,\n\t\tdelete: $delete,\n\t\trun,\n\t\tall,\n\t\tget,\n\t\tvalues,\n\t\ttransaction,\n\t\t$primary: primary,\n\t\t$replicas: replicas,\n\t\tselect,\n\t\tselectDistinct,\n\t\t$count,\n\t\twith: $with,\n\t\tget _query() {\n\t\t\treturn getReplica(replicas)._query;\n\t\t},\n\t\tget query() {\n\t\t\treturn getReplica(replicas).query;\n\t\t},\n\t};\n};\n"],"mappings":"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"}