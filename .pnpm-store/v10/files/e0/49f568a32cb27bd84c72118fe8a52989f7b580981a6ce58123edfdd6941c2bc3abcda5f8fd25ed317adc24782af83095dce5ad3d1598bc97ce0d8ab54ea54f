{"version":3,"sources":["../../../src/client/components/app-router-instance.ts"],"sourcesContent":["import {\n  type AppRouterState,\n  type ReducerActions,\n  type ReducerState,\n  ACTION_REFRESH,\n  ACTION_SERVER_ACTION,\n  ACTION_NAVIGATE,\n  ACTION_RESTORE,\n  type NavigateAction,\n  ACTION_HMR_REFRESH,\n  PrefetchKind,\n  type AppHistoryState,\n} from './router-reducer/router-reducer-types'\nimport { reducer } from './router-reducer/router-reducer'\nimport { startTransition } from 'react'\nimport { isThenable } from '../../shared/lib/is-thenable'\nimport {\n  FetchStrategy,\n  type PrefetchTaskFetchStrategy,\n} from './segment-cache/types'\nimport { prefetch as prefetchWithSegmentCache } from './segment-cache/prefetch'\nimport { dispatchAppRouterAction } from './use-action-queue'\nimport { addBasePath } from '../add-base-path'\nimport { isExternalURL } from './app-router-utils'\nimport type {\n  AppRouterInstance,\n  NavigateOptions,\n  PrefetchOptions,\n} from '../../shared/lib/app-router-context.shared-runtime'\nimport { setLinkForCurrentNavigation, type LinkInstance } from './links'\nimport type { ClientInstrumentationHooks } from '../app-index'\nimport type { GlobalErrorComponent } from './builtin/global-error'\n\nexport type DispatchStatePromise = React.Dispatch<ReducerState>\n\nexport type AppRouterActionQueue = {\n  state: AppRouterState\n  dispatch: (payload: ReducerActions, setState: DispatchStatePromise) => void\n  action: (state: AppRouterState, action: ReducerActions) => ReducerState\n\n  onRouterTransitionStart:\n    | ((url: string, type: 'push' | 'replace' | 'traverse') => void)\n    | null\n\n  pending: ActionQueueNode | null\n  needsRefresh?: boolean\n  last: ActionQueueNode | null\n}\n\nexport type GlobalErrorState = [\n  GlobalError: GlobalErrorComponent,\n  styles: React.ReactNode,\n]\n\nexport type ActionQueueNode = {\n  payload: ReducerActions\n  next: ActionQueueNode | null\n  resolve: (value: ReducerState) => void\n  reject: (err: Error) => void\n  discarded?: boolean\n}\n\nfunction runRemainingActions(\n  actionQueue: AppRouterActionQueue,\n  setState: DispatchStatePromise\n) {\n  if (actionQueue.pending !== null) {\n    actionQueue.pending = actionQueue.pending.next\n    if (actionQueue.pending !== null) {\n      runAction({\n        actionQueue,\n        action: actionQueue.pending,\n        setState,\n      })\n    }\n  } else {\n    // Check for refresh when pending is already null\n    // This handles the case where a discarded server action completes\n    // after the navigation has already finished and the queue is empty\n    if (actionQueue.needsRefresh) {\n      actionQueue.needsRefresh = false\n      actionQueue.dispatch({ type: ACTION_REFRESH }, setState)\n    }\n  }\n}\n\nasync function runAction({\n  actionQueue,\n  action,\n  setState,\n}: {\n  actionQueue: AppRouterActionQueue\n  action: ActionQueueNode\n  setState: DispatchStatePromise\n}) {\n  const prevState = actionQueue.state\n\n  actionQueue.pending = action\n\n  const payload = action.payload\n  const actionResult = actionQueue.action(prevState, payload)\n\n  function handleResult(nextState: AppRouterState) {\n    // if we discarded this action, the state should also be discarded\n    if (action.discarded) {\n      // Check if the discarded server action revalidated data\n      if (\n        action.payload.type === ACTION_SERVER_ACTION &&\n        action.payload.didRevalidate\n      ) {\n        // The server action was discarded but it revalidated data,\n        // mark that we need to refresh after all actions complete\n        actionQueue.needsRefresh = true\n      }\n      // Still need to run remaining actions even for discarded actions\n      // to potentially trigger the refresh\n      runRemainingActions(actionQueue, setState)\n      return\n    }\n\n    actionQueue.state = nextState\n\n    runRemainingActions(actionQueue, setState)\n    action.resolve(nextState)\n  }\n\n  // if the action is a promise, set up a callback to resolve it\n  if (isThenable(actionResult)) {\n    actionResult.then(handleResult, (err) => {\n      runRemainingActions(actionQueue, setState)\n      action.reject(err)\n    })\n  } else {\n    handleResult(actionResult)\n  }\n}\n\nfunction dispatchAction(\n  actionQueue: AppRouterActionQueue,\n  payload: ReducerActions,\n  setState: DispatchStatePromise\n) {\n  let resolvers: {\n    resolve: (value: ReducerState) => void\n    reject: (reason: any) => void\n  } = { resolve: setState, reject: () => {} }\n\n  // most of the action types are async with the exception of restore\n  // it's important that restore is handled quickly since it's fired on the popstate event\n  // and we don't want to add any delay on a back/forward nav\n  // this only creates a promise for the async actions\n  if (payload.type !== ACTION_RESTORE) {\n    // Create the promise and assign the resolvers to the object.\n    const deferredPromise = new Promise<AppRouterState>((resolve, reject) => {\n      resolvers = { resolve, reject }\n    })\n\n    startTransition(() => {\n      // we immediately notify React of the pending promise -- the resolver is attached to the action node\n      // and will be called when the associated action promise resolves\n      setState(deferredPromise)\n    })\n  }\n\n  const newAction: ActionQueueNode = {\n    payload,\n    next: null,\n    resolve: resolvers.resolve,\n    reject: resolvers.reject,\n  }\n\n  // Check if the queue is empty\n  if (actionQueue.pending === null) {\n    // The queue is empty, so add the action and start it immediately\n    // Mark this action as the last in the queue\n    actionQueue.last = newAction\n\n    runAction({\n      actionQueue,\n      action: newAction,\n      setState,\n    })\n  } else if (\n    payload.type === ACTION_NAVIGATE ||\n    payload.type === ACTION_RESTORE\n  ) {\n    // Navigations (including back/forward) take priority over any pending actions.\n    // Mark the pending action as discarded (so the state is never applied) and start the navigation action immediately.\n    actionQueue.pending.discarded = true\n\n    // The rest of the current queue should still execute after this navigation.\n    // (Note that it can't contain any earlier navigations, because we always put those into `actionQueue.pending` by calling `runAction`)\n    newAction.next = actionQueue.pending.next\n\n    runAction({\n      actionQueue,\n      action: newAction,\n      setState,\n    })\n  } else {\n    // The queue is not empty, so add the action to the end of the queue\n    // It will be started by runRemainingActions after the previous action finishes\n    if (actionQueue.last !== null) {\n      actionQueue.last.next = newAction\n    }\n    actionQueue.last = newAction\n  }\n}\n\nlet globalActionQueue: AppRouterActionQueue | null = null\n\nexport function createMutableActionQueue(\n  initialState: AppRouterState,\n  instrumentationHooks: ClientInstrumentationHooks | null\n): AppRouterActionQueue {\n  const actionQueue: AppRouterActionQueue = {\n    state: initialState,\n    dispatch: (payload: ReducerActions, setState: DispatchStatePromise) =>\n      dispatchAction(actionQueue, payload, setState),\n    action: async (state: AppRouterState, action: ReducerActions) => {\n      const result = reducer(state, action)\n      return result\n    },\n    pending: null,\n    last: null,\n    onRouterTransitionStart:\n      instrumentationHooks !== null &&\n      typeof instrumentationHooks.onRouterTransitionStart === 'function'\n        ? // This profiling hook will be called at the start of every navigation.\n          instrumentationHooks.onRouterTransitionStart\n        : null,\n  }\n\n  if (typeof window !== 'undefined') {\n    // The action queue is lazily created on hydration, but after that point\n    // it doesn't change. So we can store it in a global rather than pass\n    // it around everywhere via props/context.\n    if (globalActionQueue !== null) {\n      throw new Error(\n        'Internal Next.js Error: createMutableActionQueue was called more ' +\n          'than once'\n      )\n    }\n    globalActionQueue = actionQueue\n  }\n\n  return actionQueue\n}\n\nexport function getCurrentAppRouterState(): AppRouterState | null {\n  return globalActionQueue !== null ? globalActionQueue.state : null\n}\n\nfunction getAppRouterActionQueue(): AppRouterActionQueue {\n  if (globalActionQueue === null) {\n    throw new Error(\n      'Internal Next.js error: Router action dispatched before initialization.'\n    )\n  }\n  return globalActionQueue\n}\n\nfunction getProfilingHookForOnNavigationStart() {\n  if (globalActionQueue !== null) {\n    return globalActionQueue.onRouterTransitionStart\n  }\n  return null\n}\n\nexport function dispatchNavigateAction(\n  href: string,\n  navigateType: NavigateAction['navigateType'],\n  shouldScroll: boolean,\n  linkInstanceRef: LinkInstance | null\n): void {\n  // TODO: This stuff could just go into the reducer. Leaving as-is for now\n  // since we're about to rewrite all the router reducer stuff anyway.\n  const url = new URL(addBasePath(href), location.href)\n  if (process.env.__NEXT_APP_NAV_FAIL_HANDLING) {\n    window.next.__pendingUrl = url\n  }\n\n  setLinkForCurrentNavigation(linkInstanceRef)\n\n  const onRouterTransitionStart = getProfilingHookForOnNavigationStart()\n  if (onRouterTransitionStart !== null) {\n    onRouterTransitionStart(href, navigateType)\n  }\n\n  dispatchAppRouterAction({\n    type: ACTION_NAVIGATE,\n    url,\n    isExternalUrl: isExternalURL(url),\n    locationSearch: location.search,\n    shouldScroll,\n    navigateType,\n  })\n}\n\nexport function dispatchTraverseAction(\n  href: string,\n  historyState: AppHistoryState | undefined\n) {\n  const onRouterTransitionStart = getProfilingHookForOnNavigationStart()\n  if (onRouterTransitionStart !== null) {\n    onRouterTransitionStart(href, 'traverse')\n  }\n  dispatchAppRouterAction({\n    type: ACTION_RESTORE,\n    url: new URL(href),\n    historyState,\n  })\n}\n\n/**\n * The app router that is exposed through `useRouter`. These are public API\n * methods. Internal Next.js code should call the lower level methods directly\n * (although there's lots of existing code that doesn't do that).\n */\nexport const publicAppRouterInstance: AppRouterInstance = {\n  back: () => window.history.back(),\n  forward: () => window.history.forward(),\n  prefetch:\n    // Unlike the old implementation, the Segment Cache doesn't store its\n    // data in the router reducer state; it writes into a global mutable\n    // cache. So we don't need to dispatch an action.\n    (href: string, options?: PrefetchOptions) => {\n      const actionQueue = getAppRouterActionQueue()\n      const prefetchKind = options?.kind ?? PrefetchKind.AUTO\n\n      // We don't currently offer a way to issue a runtime prefetch via `router.prefetch()`.\n      // This will be possible when we update its API to not take a PrefetchKind.\n      let fetchStrategy: PrefetchTaskFetchStrategy\n      switch (prefetchKind) {\n        case PrefetchKind.AUTO: {\n          // We default to PPR. We'll discover whether or not the route supports it with the initial prefetch.\n          fetchStrategy = FetchStrategy.PPR\n          break\n        }\n        case PrefetchKind.FULL: {\n          fetchStrategy = FetchStrategy.Full\n          break\n        }\n        default: {\n          prefetchKind satisfies never\n          // Despite typescript thinking that this can't happen,\n          // we might get an unexpected value from user code.\n          // We don't know what they want, but we know they want a prefetch,\n          // so use the default.\n          fetchStrategy = FetchStrategy.PPR\n        }\n      }\n\n      prefetchWithSegmentCache(\n        href,\n        actionQueue.state.nextUrl,\n        actionQueue.state.tree,\n        fetchStrategy,\n        options?.onInvalidate ?? null\n      )\n    },\n  replace: (href: string, options?: NavigateOptions) => {\n    startTransition(() => {\n      dispatchNavigateAction(href, 'replace', options?.scroll ?? true, null)\n    })\n  },\n  push: (href: string, options?: NavigateOptions) => {\n    startTransition(() => {\n      dispatchNavigateAction(href, 'push', options?.scroll ?? true, null)\n    })\n  },\n  refresh: () => {\n    startTransition(() => {\n      dispatchAppRouterAction({\n        type: ACTION_REFRESH,\n      })\n    })\n  },\n  hmrRefresh: () => {\n    if (process.env.NODE_ENV !== 'development') {\n      throw new Error(\n        'hmrRefresh can only be used in development mode. Please use refresh instead.'\n      )\n    } else {\n      startTransition(() => {\n        dispatchAppRouterAction({\n          type: ACTION_HMR_REFRESH,\n        })\n      })\n    }\n  },\n}\n\n// Exists for debugging purposes. Don't use in application code.\nif (typeof window !== 'undefined' && window.next) {\n  window.next.router = publicAppRouterInstance\n}\n"],"names":["createMutableActionQueue","dispatchNavigateAction","dispatchTraverseAction","getCurrentAppRouterState","publicAppRouterInstance","runRemainingActions","actionQueue","setState","pending","next","runAction","action","needsRefresh","dispatch","type","ACTION_REFRESH","prevState","state","payload","actionResult","handleResult","nextState","discarded","ACTION_SERVER_ACTION","didRevalidate","resolve","isThenable","then","err","reject","dispatchAction","resolvers","ACTION_RESTORE","deferredPromise","Promise","startTransition","newAction","last","ACTION_NAVIGATE","globalActionQueue","initialState","instrumentationHooks","result","reducer","onRouterTransitionStart","window","Error","getAppRouterActionQueue","getProfilingHookForOnNavigationStart","href","navigateType","shouldScroll","linkInstanceRef","url","URL","addBasePath","location","process","env","__NEXT_APP_NAV_FAIL_HANDLING","__pendingUrl","setLinkForCurrentNavigation","dispatchAppRouterAction","isExternalUrl","isExternalURL","locationSearch","search","historyState","back","history","forward","prefetch","options","prefetchKind","kind","PrefetchKind","AUTO","fetchStrategy","FetchStrategy","PPR","FULL","Full","prefetchWithSegmentCache","nextUrl","tree","onInvalidate","replace","scroll","push","refresh","hmrRefresh","NODE_ENV","ACTION_HMR_REFRESH","router"],"mappings":"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","ignoreList":[0]}