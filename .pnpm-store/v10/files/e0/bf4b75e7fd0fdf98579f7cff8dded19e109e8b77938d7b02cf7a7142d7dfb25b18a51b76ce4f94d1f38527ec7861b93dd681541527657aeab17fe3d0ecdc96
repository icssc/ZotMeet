const require_chunk = require('./chunk-CdAKIUsw.js');
const require_utils$1 = require('./utils-D2E5ChQ0.js');
const require_grammar = require('./grammar-B2XVJ90y.js');
const require_types = require('./types-KQgd7P_m.js');
let node_process = require("node:process");
node_process = require_chunk.__toESM(node_process);
let node_os = require("node:os");
node_os = require_chunk.__toESM(node_os);
let node_tty = require("node:tty");
node_tty = require_chunk.__toESM(node_tty);

//#region ../node_modules/.pnpm/chalk@5.6.2/node_modules/chalk/source/vendor/ansi-styles/index.js
const ANSI_BACKGROUND_OFFSET = 10;
const wrapAnsi16 = (offset = 0) => (code) => `\u001B[${code + offset}m`;
const wrapAnsi256 = (offset = 0) => (code) => `\u001B[${38 + offset};5;${code}m`;
const wrapAnsi16m = (offset = 0) => (red, green, blue) => `\u001B[${38 + offset};2;${red};${green};${blue}m`;
const styles$1 = {
	modifier: {
		reset: [0, 0],
		bold: [1, 22],
		dim: [2, 22],
		italic: [3, 23],
		underline: [4, 24],
		overline: [53, 55],
		inverse: [7, 27],
		hidden: [8, 28],
		strikethrough: [9, 29]
	},
	color: {
		black: [30, 39],
		red: [31, 39],
		green: [32, 39],
		yellow: [33, 39],
		blue: [34, 39],
		magenta: [35, 39],
		cyan: [36, 39],
		white: [37, 39],
		blackBright: [90, 39],
		gray: [90, 39],
		grey: [90, 39],
		redBright: [91, 39],
		greenBright: [92, 39],
		yellowBright: [93, 39],
		blueBright: [94, 39],
		magentaBright: [95, 39],
		cyanBright: [96, 39],
		whiteBright: [97, 39]
	},
	bgColor: {
		bgBlack: [40, 49],
		bgRed: [41, 49],
		bgGreen: [42, 49],
		bgYellow: [43, 49],
		bgBlue: [44, 49],
		bgMagenta: [45, 49],
		bgCyan: [46, 49],
		bgWhite: [47, 49],
		bgBlackBright: [100, 49],
		bgGray: [100, 49],
		bgGrey: [100, 49],
		bgRedBright: [101, 49],
		bgGreenBright: [102, 49],
		bgYellowBright: [103, 49],
		bgBlueBright: [104, 49],
		bgMagentaBright: [105, 49],
		bgCyanBright: [106, 49],
		bgWhiteBright: [107, 49]
	}
};
const modifierNames = Object.keys(styles$1.modifier);
const foregroundColorNames = Object.keys(styles$1.color);
const backgroundColorNames = Object.keys(styles$1.bgColor);
const colorNames = [...foregroundColorNames, ...backgroundColorNames];
function assembleStyles() {
	const codes = /* @__PURE__ */ new Map();
	for (const [groupName, group] of Object.entries(styles$1)) {
		for (const [styleName, style] of Object.entries(group)) {
			styles$1[styleName] = {
				open: `\u001B[${style[0]}m`,
				close: `\u001B[${style[1]}m`
			};
			group[styleName] = styles$1[styleName];
			codes.set(style[0], style[1]);
		}
		Object.defineProperty(styles$1, groupName, {
			value: group,
			enumerable: false
		});
	}
	Object.defineProperty(styles$1, "codes", {
		value: codes,
		enumerable: false
	});
	styles$1.color.close = "\x1B[39m";
	styles$1.bgColor.close = "\x1B[49m";
	styles$1.color.ansi = wrapAnsi16();
	styles$1.color.ansi256 = wrapAnsi256();
	styles$1.color.ansi16m = wrapAnsi16m();
	styles$1.bgColor.ansi = wrapAnsi16(ANSI_BACKGROUND_OFFSET);
	styles$1.bgColor.ansi256 = wrapAnsi256(ANSI_BACKGROUND_OFFSET);
	styles$1.bgColor.ansi16m = wrapAnsi16m(ANSI_BACKGROUND_OFFSET);
	Object.defineProperties(styles$1, {
		rgbToAnsi256: {
			value(red, green, blue) {
				if (red === green && green === blue) {
					if (red < 8) return 16;
					if (red > 248) return 231;
					return Math.round((red - 8) / 247 * 24) + 232;
				}
				return 16 + 36 * Math.round(red / 255 * 5) + 6 * Math.round(green / 255 * 5) + Math.round(blue / 255 * 5);
			},
			enumerable: false
		},
		hexToRgb: {
			value(hex) {
				const matches = /[a-f\d]{6}|[a-f\d]{3}/i.exec(hex.toString(16));
				if (!matches) return [
					0,
					0,
					0
				];
				let [colorString] = matches;
				if (colorString.length === 3) colorString = [...colorString].map((character) => character + character).join("");
				const integer = Number.parseInt(colorString, 16);
				return [
					integer >> 16 & 255,
					integer >> 8 & 255,
					integer & 255
				];
			},
			enumerable: false
		},
		hexToAnsi256: {
			value: (hex) => styles$1.rgbToAnsi256(...styles$1.hexToRgb(hex)),
			enumerable: false
		},
		ansi256ToAnsi: {
			value(code) {
				if (code < 8) return 30 + code;
				if (code < 16) return 90 + (code - 8);
				let red;
				let green;
				let blue;
				if (code >= 232) {
					red = ((code - 232) * 10 + 8) / 255;
					green = red;
					blue = red;
				} else {
					code -= 16;
					const remainder = code % 36;
					red = Math.floor(code / 36) / 5;
					green = Math.floor(remainder / 6) / 5;
					blue = remainder % 6 / 5;
				}
				const value = Math.max(red, green, blue) * 2;
				if (value === 0) return 30;
				let result = 30 + (Math.round(blue) << 2 | Math.round(green) << 1 | Math.round(red));
				if (value === 2) result += 60;
				return result;
			},
			enumerable: false
		},
		rgbToAnsi: {
			value: (red, green, blue) => styles$1.ansi256ToAnsi(styles$1.rgbToAnsi256(red, green, blue)),
			enumerable: false
		},
		hexToAnsi: {
			value: (hex) => styles$1.ansi256ToAnsi(styles$1.hexToAnsi256(hex)),
			enumerable: false
		}
	});
	return styles$1;
}
const ansiStyles = assembleStyles();
var ansi_styles_default = ansiStyles;

//#endregion
//#region ../node_modules/.pnpm/chalk@5.6.2/node_modules/chalk/source/vendor/supports-color/index.js
function hasFlag(flag, argv = globalThis.Deno ? globalThis.Deno.args : node_process.default.argv) {
	const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
	const position = argv.indexOf(prefix + flag);
	const terminatorPosition = argv.indexOf("--");
	return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
}
const { env } = node_process.default;
let flagForceColor;
if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false") || hasFlag("color=never")) flagForceColor = 0;
else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) flagForceColor = 1;
function envForceColor() {
	if ("FORCE_COLOR" in env) {
		if (env.FORCE_COLOR === "true") return 1;
		if (env.FORCE_COLOR === "false") return 0;
		return env.FORCE_COLOR.length === 0 ? 1 : Math.min(Number.parseInt(env.FORCE_COLOR, 10), 3);
	}
}
function translateLevel(level) {
	if (level === 0) return false;
	return {
		level,
		hasBasic: true,
		has256: level >= 2,
		has16m: level >= 3
	};
}
function _supportsColor(haveStream, { streamIsTTY, sniffFlags = true } = {}) {
	const noFlagForceColor = envForceColor();
	if (noFlagForceColor !== void 0) flagForceColor = noFlagForceColor;
	const forceColor = sniffFlags ? flagForceColor : noFlagForceColor;
	if (forceColor === 0) return 0;
	if (sniffFlags) {
		if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) return 3;
		if (hasFlag("color=256")) return 2;
	}
	if ("TF_BUILD" in env && "AGENT_NAME" in env) return 1;
	if (haveStream && !streamIsTTY && forceColor === void 0) return 0;
	const min = forceColor || 0;
	if (env.TERM === "dumb") return min;
	if (node_process.default.platform === "win32") {
		const osRelease = node_os.default.release().split(".");
		if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) return Number(osRelease[2]) >= 14931 ? 3 : 2;
		return 1;
	}
	if ("CI" in env) {
		if ([
			"GITHUB_ACTIONS",
			"GITEA_ACTIONS",
			"CIRCLECI"
		].some((key) => key in env)) return 3;
		if ([
			"TRAVIS",
			"APPVEYOR",
			"GITLAB_CI",
			"BUILDKITE",
			"DRONE"
		].some((sign) => sign in env) || env.CI_NAME === "codeship") return 1;
		return min;
	}
	if ("TEAMCITY_VERSION" in env) return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
	if (env.COLORTERM === "truecolor") return 3;
	if (env.TERM === "xterm-kitty") return 3;
	if (env.TERM === "xterm-ghostty") return 3;
	if (env.TERM === "wezterm") return 3;
	if ("TERM_PROGRAM" in env) {
		const version = Number.parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
		switch (env.TERM_PROGRAM) {
			case "iTerm.app": return version >= 3 ? 3 : 2;
			case "Apple_Terminal": return 2;
		}
	}
	if (/-256(color)?$/i.test(env.TERM)) return 2;
	if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) return 1;
	if ("COLORTERM" in env) return 1;
	return min;
}
function createSupportsColor(stream, options = {}) {
	return translateLevel(_supportsColor(stream, {
		streamIsTTY: stream && stream.isTTY,
		...options
	}));
}
const supportsColor = {
	stdout: createSupportsColor({ isTTY: node_tty.default.isatty(1) }),
	stderr: createSupportsColor({ isTTY: node_tty.default.isatty(2) })
};
var supports_color_default = supportsColor;

//#endregion
//#region ../node_modules/.pnpm/chalk@5.6.2/node_modules/chalk/source/utilities.js
function stringReplaceAll(string, substring, replacer) {
	let index = string.indexOf(substring);
	if (index === -1) return string;
	const substringLength = substring.length;
	let endIndex = 0;
	let returnValue = "";
	do {
		returnValue += string.slice(endIndex, index) + substring + replacer;
		endIndex = index + substringLength;
		index = string.indexOf(substring, endIndex);
	} while (index !== -1);
	returnValue += string.slice(endIndex);
	return returnValue;
}
function stringEncaseCRLFWithFirstIndex(string, prefix, postfix, index) {
	let endIndex = 0;
	let returnValue = "";
	do {
		const gotCR = string[index - 1] === "\r";
		returnValue += string.slice(endIndex, gotCR ? index - 1 : index) + prefix + (gotCR ? "\r\n" : "\n") + postfix;
		endIndex = index + 1;
		index = string.indexOf("\n", endIndex);
	} while (index !== -1);
	returnValue += string.slice(endIndex);
	return returnValue;
}

//#endregion
//#region ../node_modules/.pnpm/chalk@5.6.2/node_modules/chalk/source/index.js
const { stdout: stdoutColor, stderr: stderrColor } = supports_color_default;
const GENERATOR = Symbol("GENERATOR");
const STYLER = Symbol("STYLER");
const IS_EMPTY = Symbol("IS_EMPTY");
const levelMapping = [
	"ansi",
	"ansi",
	"ansi256",
	"ansi16m"
];
const styles = Object.create(null);
const applyOptions = (object, options = {}) => {
	if (options.level && !(Number.isInteger(options.level) && options.level >= 0 && options.level <= 3)) throw new Error("The `level` option should be an integer from 0 to 3");
	const colorLevel = stdoutColor ? stdoutColor.level : 0;
	object.level = options.level === void 0 ? colorLevel : options.level;
};
const chalkFactory = (options) => {
	const chalk$1 = (...strings) => strings.join(" ");
	applyOptions(chalk$1, options);
	Object.setPrototypeOf(chalk$1, createChalk.prototype);
	return chalk$1;
};
function createChalk(options) {
	return chalkFactory(options);
}
Object.setPrototypeOf(createChalk.prototype, Function.prototype);
for (const [styleName, style] of Object.entries(ansi_styles_default)) styles[styleName] = { get() {
	const builder = createBuilder(this, createStyler(style.open, style.close, this[STYLER]), this[IS_EMPTY]);
	Object.defineProperty(this, styleName, { value: builder });
	return builder;
} };
styles.visible = { get() {
	const builder = createBuilder(this, this[STYLER], true);
	Object.defineProperty(this, "visible", { value: builder });
	return builder;
} };
const getModelAnsi = (model, level, type, ...arguments_) => {
	if (model === "rgb") {
		if (level === "ansi16m") return ansi_styles_default[type].ansi16m(...arguments_);
		if (level === "ansi256") return ansi_styles_default[type].ansi256(ansi_styles_default.rgbToAnsi256(...arguments_));
		return ansi_styles_default[type].ansi(ansi_styles_default.rgbToAnsi(...arguments_));
	}
	if (model === "hex") return getModelAnsi("rgb", level, type, ...ansi_styles_default.hexToRgb(...arguments_));
	return ansi_styles_default[type][model](...arguments_);
};
for (const model of [
	"rgb",
	"hex",
	"ansi256"
]) {
	styles[model] = { get() {
		const { level } = this;
		return function(...arguments_) {
			const styler = createStyler(getModelAnsi(model, levelMapping[level], "color", ...arguments_), ansi_styles_default.color.close, this[STYLER]);
			return createBuilder(this, styler, this[IS_EMPTY]);
		};
	} };
	const bgModel = "bg" + model[0].toUpperCase() + model.slice(1);
	styles[bgModel] = { get() {
		const { level } = this;
		return function(...arguments_) {
			const styler = createStyler(getModelAnsi(model, levelMapping[level], "bgColor", ...arguments_), ansi_styles_default.bgColor.close, this[STYLER]);
			return createBuilder(this, styler, this[IS_EMPTY]);
		};
	} };
}
const proto = Object.defineProperties(() => {}, {
	...styles,
	level: {
		enumerable: true,
		get() {
			return this[GENERATOR].level;
		},
		set(level) {
			this[GENERATOR].level = level;
		}
	}
});
const createStyler = (open, close, parent) => {
	let openAll;
	let closeAll;
	if (parent === void 0) {
		openAll = open;
		closeAll = close;
	} else {
		openAll = parent.openAll + open;
		closeAll = close + parent.closeAll;
	}
	return {
		open,
		close,
		openAll,
		closeAll,
		parent
	};
};
const createBuilder = (self$1, _styler, _isEmpty) => {
	const builder = (...arguments_) => applyStyle(builder, arguments_.length === 1 ? "" + arguments_[0] : arguments_.join(" "));
	Object.setPrototypeOf(builder, proto);
	builder[GENERATOR] = self$1;
	builder[STYLER] = _styler;
	builder[IS_EMPTY] = _isEmpty;
	return builder;
};
const applyStyle = (self$1, string) => {
	if (self$1.level <= 0 || !string) return self$1[IS_EMPTY] ? "" : string;
	let styler = self$1[STYLER];
	if (styler === void 0) return string;
	const { openAll, closeAll } = styler;
	if (string.includes("\x1B")) while (styler !== void 0) {
		string = stringReplaceAll(string, styler.close, styler.open);
		styler = styler.parent;
	}
	const lfIndex = string.indexOf("\n");
	if (lfIndex !== -1) string = stringEncaseCRLFWithFirstIndex(string, closeAll, openAll, lfIndex);
	return openAll + string + closeAll;
};
Object.defineProperties(createChalk.prototype, styles);
const chalk = createChalk();
const chalkStderr = createChalk({ level: stderrColor ? stderrColor.level : 0 });
var source_default = chalk;

//#endregion
//#region ../node_modules/.pnpm/hanji@0.0.5/node_modules/hanji/readline.js
var require_readline = /* @__PURE__ */ require_chunk.__commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.prepareReadLine = void 0;
	const prepareReadLine = () => {
		const stdin = process.stdin;
		const stdout = process.stdout;
		const readline = require("readline");
		const rl = readline.createInterface({
			input: stdin,
			escapeCodeTimeout: 50
		});
		readline.emitKeypressEvents(stdin, rl);
		return {
			stdin,
			stdout,
			closable: rl
		};
	};
	exports.prepareReadLine = prepareReadLine;
}));

//#endregion
//#region ../node_modules/.pnpm/sisteransi@1.0.5/node_modules/sisteransi/src/index.js
var require_src = /* @__PURE__ */ require_chunk.__commonJSMin(((exports, module) => {
	const ESC = "\x1B";
	const CSI = `${ESC}[`;
	const beep = "\x07";
	const cursor = {
		to(x, y) {
			if (!y) return `${CSI}${x + 1}G`;
			return `${CSI}${y + 1};${x + 1}H`;
		},
		move(x, y) {
			let ret = "";
			if (x < 0) ret += `${CSI}${-x}D`;
			else if (x > 0) ret += `${CSI}${x}C`;
			if (y < 0) ret += `${CSI}${-y}A`;
			else if (y > 0) ret += `${CSI}${y}B`;
			return ret;
		},
		up: (count = 1) => `${CSI}${count}A`,
		down: (count = 1) => `${CSI}${count}B`,
		forward: (count = 1) => `${CSI}${count}C`,
		backward: (count = 1) => `${CSI}${count}D`,
		nextLine: (count = 1) => `${CSI}E`.repeat(count),
		prevLine: (count = 1) => `${CSI}F`.repeat(count),
		left: `${CSI}G`,
		hide: `${CSI}?25l`,
		show: `${CSI}?25h`,
		save: `${ESC}7`,
		restore: `${ESC}8`
	};
	const scroll = {
		up: (count = 1) => `${CSI}S`.repeat(count),
		down: (count = 1) => `${CSI}T`.repeat(count)
	};
	const erase = {
		screen: `${CSI}2J`,
		up: (count = 1) => `${CSI}1J`.repeat(count),
		down: (count = 1) => `${CSI}J`.repeat(count),
		line: `${CSI}2K`,
		lineEnd: `${CSI}K`,
		lineStart: `${CSI}1K`,
		lines(count) {
			let clear = "";
			for (let i = 0; i < count; i++) clear += this.line + (i < count - 1 ? cursor.up() : "");
			if (count) clear += cursor.left;
			return clear;
		}
	};
	module.exports = {
		cursor,
		scroll,
		erase,
		beep
	};
}));

//#endregion
//#region ../node_modules/.pnpm/hanji@0.0.5/node_modules/hanji/utils.js
var require_utils = /* @__PURE__ */ require_chunk.__commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.clear = void 0;
	const sisteransi_1 = require_src();
	const strip = (str) => {
		const pattern = ["[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)", "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PRZcf-ntqry=><~]))"].join("|");
		const RGX = new RegExp(pattern, "g");
		return typeof str === "string" ? str.replace(RGX, "") : str;
	};
	const stringWidth = (str) => [...strip(str)].length;
	const clear = function(prompt, perLine) {
		if (!perLine) return sisteransi_1.erase.line + sisteransi_1.cursor.to(0);
		let rows = 0;
		const lines = prompt.split(/\r?\n/);
		for (let line of lines) rows += 1 + Math.floor(Math.max(stringWidth(line) - 1, 0) / perLine);
		return sisteransi_1.erase.lines(rows);
	};
	exports.clear = clear;
}));

//#endregion
//#region ../node_modules/.pnpm/lodash.throttle@4.1.1/node_modules/lodash.throttle/index.js
var require_lodash = /* @__PURE__ */ require_chunk.__commonJSMin(((exports, module) => {
	/**
	* lodash (Custom Build) <https://lodash.com/>
	* Build: `lodash modularize exports="npm" -o ./`
	* Copyright jQuery Foundation and other contributors <https://jquery.org/>
	* Released under MIT license <https://lodash.com/license>
	* Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
	* Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
	*/
	/** Used as the `TypeError` message for "Functions" methods. */
	var FUNC_ERROR_TEXT = "Expected a function";
	/** Used as references for various `Number` constants. */
	var NAN = NaN;
	/** `Object#toString` result references. */
	var symbolTag = "[object Symbol]";
	/** Used to match leading and trailing whitespace. */
	var reTrim = /^\s+|\s+$/g;
	/** Used to detect bad signed hexadecimal string values. */
	var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
	/** Used to detect binary string values. */
	var reIsBinary = /^0b[01]+$/i;
	/** Used to detect octal string values. */
	var reIsOctal = /^0o[0-7]+$/i;
	/** Built-in method references without a dependency on `root`. */
	var freeParseInt = parseInt;
	/** Detect free variable `global` from Node.js. */
	var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
	/** Detect free variable `self`. */
	var freeSelf = typeof self == "object" && self && self.Object === Object && self;
	/** Used as a reference to the global object. */
	var root = freeGlobal || freeSelf || Function("return this")();
	/**
	* Used to resolve the
	* [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
	* of values.
	*/
	var objectToString = Object.prototype.toString;
	var nativeMax = Math.max, nativeMin = Math.min;
	/**
	* Gets the timestamp of the number of milliseconds that have elapsed since
	* the Unix epoch (1 January 1970 00:00:00 UTC).
	*
	* @static
	* @memberOf _
	* @since 2.4.0
	* @category Date
	* @returns {number} Returns the timestamp.
	* @example
	*
	* _.defer(function(stamp) {
	*   console.log(_.now() - stamp);
	* }, _.now());
	* // => Logs the number of milliseconds it took for the deferred invocation.
	*/
	var now = function() {
		return root.Date.now();
	};
	/**
	* Creates a debounced function that delays invoking `func` until after `wait`
	* milliseconds have elapsed since the last time the debounced function was
	* invoked. The debounced function comes with a `cancel` method to cancel
	* delayed `func` invocations and a `flush` method to immediately invoke them.
	* Provide `options` to indicate whether `func` should be invoked on the
	* leading and/or trailing edge of the `wait` timeout. The `func` is invoked
	* with the last arguments provided to the debounced function. Subsequent
	* calls to the debounced function return the result of the last `func`
	* invocation.
	*
	* **Note:** If `leading` and `trailing` options are `true`, `func` is
	* invoked on the trailing edge of the timeout only if the debounced function
	* is invoked more than once during the `wait` timeout.
	*
	* If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
	* until to the next tick, similar to `setTimeout` with a timeout of `0`.
	*
	* See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
	* for details over the differences between `_.debounce` and `_.throttle`.
	*
	* @static
	* @memberOf _
	* @since 0.1.0
	* @category Function
	* @param {Function} func The function to debounce.
	* @param {number} [wait=0] The number of milliseconds to delay.
	* @param {Object} [options={}] The options object.
	* @param {boolean} [options.leading=false]
	*  Specify invoking on the leading edge of the timeout.
	* @param {number} [options.maxWait]
	*  The maximum time `func` is allowed to be delayed before it's invoked.
	* @param {boolean} [options.trailing=true]
	*  Specify invoking on the trailing edge of the timeout.
	* @returns {Function} Returns the new debounced function.
	* @example
	*
	* // Avoid costly calculations while the window size is in flux.
	* jQuery(window).on('resize', _.debounce(calculateLayout, 150));
	*
	* // Invoke `sendMail` when clicked, debouncing subsequent calls.
	* jQuery(element).on('click', _.debounce(sendMail, 300, {
	*   'leading': true,
	*   'trailing': false
	* }));
	*
	* // Ensure `batchLog` is invoked once after 1 second of debounced calls.
	* var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
	* var source = new EventSource('/stream');
	* jQuery(source).on('message', debounced);
	*
	* // Cancel the trailing debounced invocation.
	* jQuery(window).on('popstate', debounced.cancel);
	*/
	function debounce(func, wait, options) {
		var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
		if (typeof func != "function") throw new TypeError(FUNC_ERROR_TEXT);
		wait = toNumber(wait) || 0;
		if (isObject(options)) {
			leading = !!options.leading;
			maxing = "maxWait" in options;
			maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
			trailing = "trailing" in options ? !!options.trailing : trailing;
		}
		function invokeFunc(time) {
			var args = lastArgs, thisArg = lastThis;
			lastArgs = lastThis = void 0;
			lastInvokeTime = time;
			result = func.apply(thisArg, args);
			return result;
		}
		function leadingEdge(time) {
			lastInvokeTime = time;
			timerId = setTimeout(timerExpired, wait);
			return leading ? invokeFunc(time) : result;
		}
		function remainingWait(time) {
			var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, result$1 = wait - timeSinceLastCall;
			return maxing ? nativeMin(result$1, maxWait - timeSinceLastInvoke) : result$1;
		}
		function shouldInvoke(time) {
			var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
			return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
		}
		function timerExpired() {
			var time = now();
			if (shouldInvoke(time)) return trailingEdge(time);
			timerId = setTimeout(timerExpired, remainingWait(time));
		}
		function trailingEdge(time) {
			timerId = void 0;
			if (trailing && lastArgs) return invokeFunc(time);
			lastArgs = lastThis = void 0;
			return result;
		}
		function cancel() {
			if (timerId !== void 0) clearTimeout(timerId);
			lastInvokeTime = 0;
			lastArgs = lastCallTime = lastThis = timerId = void 0;
		}
		function flush() {
			return timerId === void 0 ? result : trailingEdge(now());
		}
		function debounced() {
			var time = now(), isInvoking = shouldInvoke(time);
			lastArgs = arguments;
			lastThis = this;
			lastCallTime = time;
			if (isInvoking) {
				if (timerId === void 0) return leadingEdge(lastCallTime);
				if (maxing) {
					timerId = setTimeout(timerExpired, wait);
					return invokeFunc(lastCallTime);
				}
			}
			if (timerId === void 0) timerId = setTimeout(timerExpired, wait);
			return result;
		}
		debounced.cancel = cancel;
		debounced.flush = flush;
		return debounced;
	}
	/**
	* Creates a throttled function that only invokes `func` at most once per
	* every `wait` milliseconds. The throttled function comes with a `cancel`
	* method to cancel delayed `func` invocations and a `flush` method to
	* immediately invoke them. Provide `options` to indicate whether `func`
	* should be invoked on the leading and/or trailing edge of the `wait`
	* timeout. The `func` is invoked with the last arguments provided to the
	* throttled function. Subsequent calls to the throttled function return the
	* result of the last `func` invocation.
	*
	* **Note:** If `leading` and `trailing` options are `true`, `func` is
	* invoked on the trailing edge of the timeout only if the throttled function
	* is invoked more than once during the `wait` timeout.
	*
	* If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
	* until to the next tick, similar to `setTimeout` with a timeout of `0`.
	*
	* See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
	* for details over the differences between `_.throttle` and `_.debounce`.
	*
	* @static
	* @memberOf _
	* @since 0.1.0
	* @category Function
	* @param {Function} func The function to throttle.
	* @param {number} [wait=0] The number of milliseconds to throttle invocations to.
	* @param {Object} [options={}] The options object.
	* @param {boolean} [options.leading=true]
	*  Specify invoking on the leading edge of the timeout.
	* @param {boolean} [options.trailing=true]
	*  Specify invoking on the trailing edge of the timeout.
	* @returns {Function} Returns the new throttled function.
	* @example
	*
	* // Avoid excessively updating the position while scrolling.
	* jQuery(window).on('scroll', _.throttle(updatePosition, 100));
	*
	* // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.
	* var throttled = _.throttle(renewToken, 300000, { 'trailing': false });
	* jQuery(element).on('click', throttled);
	*
	* // Cancel the trailing throttled invocation.
	* jQuery(window).on('popstate', throttled.cancel);
	*/
	function throttle(func, wait, options) {
		var leading = true, trailing = true;
		if (typeof func != "function") throw new TypeError(FUNC_ERROR_TEXT);
		if (isObject(options)) {
			leading = "leading" in options ? !!options.leading : leading;
			trailing = "trailing" in options ? !!options.trailing : trailing;
		}
		return debounce(func, wait, {
			"leading": leading,
			"maxWait": wait,
			"trailing": trailing
		});
	}
	/**
	* Checks if `value` is the
	* [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
	* of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
	*
	* @static
	* @memberOf _
	* @since 0.1.0
	* @category Lang
	* @param {*} value The value to check.
	* @returns {boolean} Returns `true` if `value` is an object, else `false`.
	* @example
	*
	* _.isObject({});
	* // => true
	*
	* _.isObject([1, 2, 3]);
	* // => true
	*
	* _.isObject(_.noop);
	* // => true
	*
	* _.isObject(null);
	* // => false
	*/
	function isObject(value) {
		var type = typeof value;
		return !!value && (type == "object" || type == "function");
	}
	/**
	* Checks if `value` is object-like. A value is object-like if it's not `null`
	* and has a `typeof` result of "object".
	*
	* @static
	* @memberOf _
	* @since 4.0.0
	* @category Lang
	* @param {*} value The value to check.
	* @returns {boolean} Returns `true` if `value` is object-like, else `false`.
	* @example
	*
	* _.isObjectLike({});
	* // => true
	*
	* _.isObjectLike([1, 2, 3]);
	* // => true
	*
	* _.isObjectLike(_.noop);
	* // => false
	*
	* _.isObjectLike(null);
	* // => false
	*/
	function isObjectLike(value) {
		return !!value && typeof value == "object";
	}
	/**
	* Checks if `value` is classified as a `Symbol` primitive or object.
	*
	* @static
	* @memberOf _
	* @since 4.0.0
	* @category Lang
	* @param {*} value The value to check.
	* @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
	* @example
	*
	* _.isSymbol(Symbol.iterator);
	* // => true
	*
	* _.isSymbol('abc');
	* // => false
	*/
	function isSymbol(value) {
		return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
	}
	/**
	* Converts `value` to a number.
	*
	* @static
	* @memberOf _
	* @since 4.0.0
	* @category Lang
	* @param {*} value The value to process.
	* @returns {number} Returns the number.
	* @example
	*
	* _.toNumber(3.2);
	* // => 3.2
	*
	* _.toNumber(Number.MIN_VALUE);
	* // => 5e-324
	*
	* _.toNumber(Infinity);
	* // => Infinity
	*
	* _.toNumber('3.2');
	* // => 3.2
	*/
	function toNumber(value) {
		if (typeof value == "number") return value;
		if (isSymbol(value)) return NAN;
		if (isObject(value)) {
			var other = typeof value.valueOf == "function" ? value.valueOf() : value;
			value = isObject(other) ? other + "" : other;
		}
		if (typeof value != "string") return value === 0 ? value : +value;
		value = value.replace(reTrim, "");
		var isBinary = reIsBinary.test(value);
		return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
	}
	module.exports = throttle;
}));

//#endregion
//#region ../node_modules/.pnpm/hanji@0.0.5/node_modules/hanji/index.js
var require_hanji = /* @__PURE__ */ require_chunk.__commonJSMin(((exports) => {
	var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
		function adopt(value) {
			return value instanceof P ? value : new P(function(resolve) {
				resolve(value);
			});
		}
		return new (P || (P = Promise))(function(resolve, reject) {
			function fulfilled(value) {
				try {
					step(generator.next(value));
				} catch (e) {
					reject(e);
				}
			}
			function rejected(value) {
				try {
					step(generator["throw"](value));
				} catch (e) {
					reject(e);
				}
			}
			function step(result) {
				result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
			}
			step((generator = generator.apply(thisArg, _arguments || [])).next());
		});
	};
	var __importDefault = exports && exports.__importDefault || function(mod) {
		return mod && mod.__esModule ? mod : { "default": mod };
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.onTerminate = exports.renderWithTask = exports.render = exports.TaskTerminal = exports.TaskView = exports.Terminal = exports.deferred = exports.SelectState = exports.Prompt = void 0;
	const readline_1 = require_readline();
	const sisteransi_1 = require_src();
	const utils_1 = require_utils();
	const lodash_throttle_1 = __importDefault(require_lodash());
	var Prompt = class {
		constructor() {
			this.attachCallbacks = [];
			this.detachCallbacks = [];
			this.inputCallbacks = [];
		}
		requestLayout() {
			this.terminal.requestLayout();
		}
		on(type, callback) {
			if (type === "attach") this.attachCallbacks.push(callback);
			else if (type === "detach") this.detachCallbacks.push(callback);
			else if (type === "input") this.inputCallbacks.push(callback);
		}
		attach(terminal) {
			this.terminal = terminal;
			this.attachCallbacks.forEach((it) => it(terminal));
		}
		detach(terminal) {
			this.detachCallbacks.forEach((it) => it(terminal));
			this.terminal = void 0;
		}
		input(str, key) {
			this.inputCallbacks.forEach((it) => it(str, key));
		}
	};
	exports.Prompt = Prompt;
	var SelectState = class {
		constructor(items) {
			this.items = items;
			this.selectedIdx = 0;
		}
		bind(prompt) {
			prompt.on("input", (str, key) => {
				if (this.consume(str, key)) prompt.requestLayout();
			});
		}
		consume(str, key) {
			if (!key) return false;
			if (key.name === "down") {
				this.selectedIdx = (this.selectedIdx + 1) % this.items.length;
				return true;
			}
			if (key.name === "up") {
				this.selectedIdx -= 1;
				this.selectedIdx = this.selectedIdx < 0 ? this.items.length - 1 : this.selectedIdx;
				return true;
			}
			return false;
		}
	};
	exports.SelectState = SelectState;
	const deferred = () => {
		let resolve;
		let reject;
		const promise = new Promise((res, rej) => {
			resolve = res;
			reject = rej;
		});
		return {
			resolve,
			reject,
			promise
		};
	};
	exports.deferred = deferred;
	var Terminal = class {
		constructor(view, stdin, stdout, closable) {
			this.view = view;
			this.stdin = stdin;
			this.stdout = stdout;
			this.closable = closable;
			this.text = "";
			this.status = "idle";
			if (this.stdin.isTTY) this.stdin.setRawMode(true);
			const keypress = (str, key) => {
				if (key.name === "c" && key.ctrl === true) {
					this.requestLayout();
					this.view.detach(this);
					this.tearDown(keypress);
					if (terminateHandler) {
						terminateHandler(this.stdin, this.stdout);
						return;
					}
					this.stdout.write(`\n^C\n`);
					process.exit(1);
				}
				if (key.name === "escape") {
					this.status = "aborted";
					this.requestLayout();
					this.view.detach(this);
					this.tearDown(keypress);
					this.resolve({
						status: "aborted",
						data: void 0
					});
					return;
				}
				if (key.name === "return") {
					this.status = "submitted";
					this.requestLayout();
					this.view.detach(this);
					this.tearDown(keypress);
					this.resolve({
						status: "submitted",
						data: this.view.result()
					});
					return;
				}
				view.input(str, key);
			};
			this.stdin.on("keypress", keypress);
			this.view.attach(this);
			const { resolve, promise } = (0, exports.deferred)();
			this.resolve = resolve;
			this.promise = promise;
			this.renderFunc = (0, lodash_throttle_1.default)((str) => {
				this.stdout.write(str);
			});
		}
		tearDown(keypress) {
			this.stdout.write(sisteransi_1.cursor.show);
			this.stdin.removeListener("keypress", keypress);
			if (this.stdin.isTTY) this.stdin.setRawMode(false);
			this.closable.close();
		}
		result() {
			return this.promise;
		}
		toggleCursor(state) {
			if (state === "hide") this.stdout.write(sisteransi_1.cursor.hide);
			else this.stdout.write(sisteransi_1.cursor.show);
		}
		requestLayout() {
			const string = this.view.render(this.status);
			const clearPrefix = this.text ? (0, utils_1.clear)(this.text, this.stdout.columns) : "";
			this.text = string;
			this.renderFunc(`${clearPrefix}${string}`);
		}
	};
	exports.Terminal = Terminal;
	var TaskView = class {
		constructor() {
			this.attachCallbacks = [];
			this.detachCallbacks = [];
		}
		requestLayout() {
			this.terminal.requestLayout();
		}
		attach(terminal) {
			this.terminal = terminal;
			this.attachCallbacks.forEach((it) => it(terminal));
		}
		detach(terminal) {
			this.detachCallbacks.forEach((it) => it(terminal));
			this.terminal = void 0;
		}
		on(type, callback) {
			if (type === "attach") this.attachCallbacks.push(callback);
			else if (type === "detach") this.detachCallbacks.push(callback);
		}
	};
	exports.TaskView = TaskView;
	var TaskTerminal = class {
		constructor(view, stdout) {
			this.view = view;
			this.stdout = stdout;
			this.text = "";
			this.view.attach(this);
		}
		requestLayout() {
			const string = this.view.render("pending");
			const clearPrefix = this.text ? (0, utils_1.clear)(this.text, this.stdout.columns) : "";
			this.text = string;
			this.stdout.write(`${clearPrefix}${string}`);
		}
		clear() {
			const string = this.view.render("done");
			this.view.detach(this);
			const clearPrefix = this.text ? (0, utils_1.clear)(this.text, this.stdout.columns) : "";
			this.stdout.write(`${clearPrefix}${string}`);
		}
	};
	exports.TaskTerminal = TaskTerminal;
	function render(view) {
		const { stdin, stdout, closable } = (0, readline_1.prepareReadLine)();
		if (view instanceof Prompt) {
			const terminal = new Terminal(view, stdin, stdout, closable);
			terminal.requestLayout();
			return terminal.result();
		}
		stdout.write(`${view}\n`);
		closable.close();
	}
	exports.render = render;
	function renderWithTask(view, task) {
		return __awaiter(this, void 0, void 0, function* () {
			const terminal = new TaskTerminal(view, process.stdout);
			terminal.requestLayout();
			const result = yield task;
			terminal.clear();
			return result;
		});
	}
	exports.renderWithTask = renderWithTask;
	let terminateHandler;
	function onTerminate(callback) {
		terminateHandler = callback;
	}
	exports.onTerminate = onTerminate;
}));

//#endregion
//#region src/utils/schemaValidator.ts
const dialects = [
	"postgresql",
	"mysql",
	"sqlite",
	"turso",
	"singlestore",
	"gel",
	"mssql",
	"cockroach",
	"duckdb"
];
const dialect = require_types.enumType(dialects);

//#endregion
//#region src/cli/validations/common.ts
const sqliteDriversLiterals = [
	require_types.literalType("d1-http"),
	require_types.literalType("expo"),
	require_types.literalType("durable-sqlite"),
	require_types.literalType("sqlite-cloud")
];
const postgresqlDriversLiterals = [require_types.literalType("aws-data-api"), require_types.literalType("pglite")];
const casingTypes = ["snake_case", "camelCase"];
const casingType = require_types.enumType(casingTypes);
const sqliteDriver = require_types.unionType(sqliteDriversLiterals);
const postgresDriver = require_types.unionType(postgresqlDriversLiterals);
const driver = require_types.unionType([sqliteDriver, postgresDriver]);
const configMigrations = require_types.objectType({
	table: require_types.stringType().default("__drizzle_migrations"),
	schema: require_types.stringType().default("drizzle")
}).default({
	table: "__drizzle_migrations",
	schema: "drizzle"
});
const configCommonSchema = require_types.objectType({
	dialect,
	schema: require_types.unionType([require_types.stringType(), require_types.stringType().array()]).optional(),
	out: require_types.stringType().default("drizzle"),
	breakpoints: require_types.booleanType().optional().default(true),
	verbose: require_types.booleanType().optional().default(false),
	driver: driver.optional(),
	tablesFilter: require_types.unionType([require_types.stringType(), require_types.stringType().array()]).optional(),
	schemaFilter: require_types.unionType([require_types.stringType(), require_types.stringType().array()]).optional(),
	migrations: configMigrations,
	dbCredentials: require_types.anyType().optional(),
	casing: casingType.optional(),
	sql: require_types.booleanType().default(true)
}).passthrough();
const casing = require_types.unionType([require_types.literalType("camel"), require_types.literalType("preserve")]).default("camel");
const introspectParams = require_types.objectType({
	schema: require_types.unionType([require_types.stringType(), require_types.stringType().array()]).optional(),
	out: require_types.stringType().optional().default("./drizzle"),
	breakpoints: require_types.booleanType().default(true),
	tablesFilter: require_types.unionType([require_types.stringType(), require_types.stringType().array()]).optional(),
	schemaFilter: require_types.unionType([require_types.stringType(), require_types.stringType().array()]).default(["public"]),
	introspect: require_types.objectType({ casing }).default({ casing: "camel" })
});
const configIntrospectCliSchema = require_types.objectType({
	schema: require_types.unionType([require_types.stringType(), require_types.stringType().array()]).optional(),
	out: require_types.stringType().optional().default("./drizzle"),
	breakpoints: require_types.booleanType().default(true),
	tablesFilter: require_types.unionType([require_types.stringType(), require_types.stringType().array()]).optional(),
	schemaFilter: require_types.unionType([require_types.stringType(), require_types.stringType().array()]).default(["public"]),
	introspectCasing: require_types.unionType([require_types.literalType("camel"), require_types.literalType("preserve")]).default("camel")
});
const configGenerateSchema = require_types.objectType({
	schema: require_types.unionType([require_types.stringType(), require_types.stringType().array()]),
	out: require_types.stringType().optional().default("./drizzle"),
	breakpoints: require_types.booleanType().default(true)
});
const configPushSchema = require_types.objectType({
	dialect,
	schema: require_types.unionType([require_types.stringType(), require_types.stringType().array()]),
	tablesFilter: require_types.unionType([require_types.stringType(), require_types.stringType().array()]).optional(),
	schemaFilter: require_types.unionType([require_types.stringType(), require_types.stringType().array()]).default(["public"]),
	verbose: require_types.booleanType().default(false),
	strict: require_types.booleanType().default(false),
	out: require_types.stringType().optional()
});

//#endregion
//#region src/cli/validations/outputs.ts
const withStyle = {
	error: (str) => `${source_default.red(`${source_default.white.bgRed(" Invalid input ")} ${str}`)}`,
	warning: (str) => `${source_default.white.bgGray(" Warning ")} ${str}`,
	errorWarning: (str) => `${source_default.red(`${source_default.white.bgRed(" Warning ")} ${str}`)}`,
	fullWarning: (str) => `${source_default.black.bgYellow(" Warning ")} ${source_default.bold(str)}`,
	suggestion: (str) => `${source_default.white.bgGray(" Suggestion ")} ${str}`,
	info: (str) => `${source_default.grey(str)}`
};

//#endregion
//#region src/cli/views.ts
var import_hanji = require_hanji();
const err = (msg) => {
	(0, import_hanji.render)(`${source_default.bold.red("Error")} ${msg}`);
};
const postgresSchemaWarning = (warning) => {
	if (warning.type === "policy_not_linked") return withStyle.errorWarning(`"Policy ${warning.policy} was skipped because it was not linked to any table. You should either include the policy in a table or use .link() on the policy to link it to any table you have. For more information, please check:`);
	require_utils$1.assertUnreachable(warning.type);
};
const postgresSchemaError = (error) => {
	if (error.type === "constraint_name_duplicate") {
		const { name, schema, table } = error;
		const tableName = source_default.underline.blue(`"${schema}"."${table}"`);
		const constraintName = source_default.underline.blue(`'${name}'`);
		return withStyle.errorWarning(`There's a duplicate constraint name ${constraintName} in ${tableName} table`);
	}
	if (error.type === "index_duplicate") {
		const { schema, table, name } = error;
		const sch = source_default.underline.blue(`"${schema}"`);
		const idx = source_default.underline.blue(`'${name}'`);
		const tableName = source_default.underline.blue(`"${schema}"."${table}"`);
		return withStyle.errorWarning(`There's a duplicate index name ${idx} in ${sch} schema in ${tableName}`);
	}
	if (error.type === "index_no_name") {
		const { schema, table, sql } = error;
		const tableName = source_default.underline.blue(`"${schema}"."${table}"`);
		return withStyle.errorWarning(`Please specify an index name in ${tableName} table that has "${sql}" expression.\n\nWe can generate index names for indexes on columns only; for expressions in indexes, you need to specify index name yourself.`);
	}
	if (error.type === "pgvector_index_noop") {
		const { table, indexName, column, method } = error;
		return withStyle.errorWarning(`You are specifying an index on the ${source_default.blueBright(column)} column inside the ${source_default.blueBright(table)} table with the ${source_default.blueBright("vector")} type without specifying an operator class. Vector extension doesn't have a default operator class, so you need to specify one of the available options. Here is a list of available op classes for the vector extension: [${require_grammar.vectorOps.map((it) => `${source_default.underline(`${it}`)}`).join(", ")}].\n\nYou can specify it using current syntax: ${source_default.underline(`index("${indexName}").using("${method}", table.${column}.op("${require_grammar.vectorOps[0]}"))`)}\n\nYou can check the "pg_vector" docs for more info: https://github.com/pgvector/pgvector?tab=readme-ov-file#indexing\n`);
	}
	if (error.type === "policy_duplicate") {
		const { schema, table, policy } = error;
		const tableName = source_default.underline.blue(`"${schema}"."${table}"`);
		return withStyle.errorWarning(`We've found duplicated policy name across ${tableName} table. Please rename one of the policies with ${source_default.underline.blue(policy)} name`);
	}
	if (error.type === "view_name_duplicate") {
		const schema = source_default.underline.blue(error.schema ?? "public");
		const name = source_default.underline.blue(error.name);
		return withStyle.errorWarning(`There's a view duplicate name ${name} in ${schema} schema`);
	}
	if (error.type === "sequence_name_duplicate") return withStyle.errorWarning(`There's a sequence name duplicate '${error.name}' in '${error.schema}' schema`);
	if (error.type === "table_name_duplicate") {
		const { name, schema } = error;
		const schemaName = source_default.underline.blue(`"${schema}"`);
		const tableName = source_default.underline.blue(`"${name}"`);
		return withStyle.errorWarning(`There's a duplicate table name ${tableName} in ${schemaName} schema`);
	}
	if (error.type === "column_name_duplicate") {
		const { name, schema, table } = error;
		const tableName = source_default.underline.blue(`"${schema}"."${table}"`);
		const columnName = source_default.underline.blue(`'${name}'`);
		return withStyle.errorWarning(`There's a duplicate column name ${columnName} in ${tableName} table`);
	}
	if (error.type === "enum_name_duplicate") {
		const { name, schema } = error;
		const schemaName = source_default.underline.blue(`"${schema}"`);
		const enumName = source_default.underline.blue(`'${name}'`);
		return withStyle.errorWarning(`There's a duplicate enum name ${enumName} in ${schemaName} schema`);
	}
	if (error.type === "enum_values_duplicate") {
		const { name, schema } = error;
		const schemaName = source_default.underline.blue(`"${schema}"`);
		const enumName = source_default.underline.blue(`'${name}'`);
		return withStyle.errorWarning(`There are duplicate values in enum ${enumName} in ${schemaName} schema`);
	}
	if (error.type === "privilege_duplicate") {
		const { name } = error;
		const privilegeName = source_default.underline.blue(`'${name}'`);
		return withStyle.errorWarning(`There's a duplicate privilege name ${privilegeName}`);
	}
	if (error.type === "role_duplicate") {
		const { name } = error;
		const roleName = source_default.underline.blue(`'${name}'`);
		return withStyle.errorWarning(`There's a duplicate role name ${roleName}`);
	}
	if (error.type === "schema_name_duplicate") {
		const { name } = error;
		const schemaName = source_default.underline.blue(`'${name}'`);
		return withStyle.errorWarning(`There's a duplicate schema name ${schemaName}`);
	}
	require_utils$1.assertUnreachable(error);
};
const isRenamePromptItem = (item) => {
	return "from" in item && "to" in item;
};
const keyFor = (it, defaultSchema = "public") => {
	return `${it.schema && it.schema !== defaultSchema ? `${it.schema}.` : ""}${it.table ? `${it.table}.` : ""}${it.name}`;
};
var ResolveSelect = class extends import_hanji.Prompt {
	state;
	constructor(base, data, entityType, defaultSchema = "public") {
		super();
		this.base = base;
		this.entityType = entityType;
		this.defaultSchema = defaultSchema;
		this.on("attach", (terminal) => terminal.toggleCursor("hide"));
		this.state = new import_hanji.SelectState(data);
		this.state.bind(this);
	}
	render(status) {
		if (status === "submitted" || status === "aborted") return "";
		const key = keyFor(this.base, this.defaultSchema);
		let text = `\nIs ${source_default.bold.blue(key)} ${this.entityType} created or renamed from another ${this.entityType}?\n`;
		const selectedPrefix = isRenamePromptItem(this.state.items[this.state.selectedIdx]) ? source_default.yellow("❯ ") : source_default.green("❯ ");
		const labelLength = this.state.items.filter((it) => isRenamePromptItem(it)).map((_) => {
			const keyFrom = keyFor(_.from);
			return key.length + 3 + keyFrom.length;
		}).reduce((a, b) => {
			if (a > b) return a;
			return b;
		}, 0);
		const entityType = this.entityType;
		this.state.items.forEach((it, idx) => {
			const isSelected = idx === this.state.selectedIdx;
			const isRenamed = isRenamePromptItem(it);
			const title = isRenamed ? `${keyFor(it.from, this.defaultSchema)} › ${keyFor(it.to, this.defaultSchema)}`.padEnd(labelLength, " ") : keyFor(it, this.defaultSchema).padEnd(labelLength, " ");
			const label = isRenamed ? `${source_default.yellow("~")} ${title} ${source_default.gray(`rename ${entityType}`)}` : `${source_default.green("+")} ${title} ${source_default.gray(`create ${entityType}`)}`;
			text += isSelected ? `${selectedPrefix}${label}` : `  ${label}`;
			text += idx !== this.state.items.length - 1 ? "\n" : "";
		});
		return text;
	}
	result() {
		return this.state.items[this.state.selectedIdx];
	}
};

//#endregion
Object.defineProperty(exports, 'ResolveSelect', {
  enumerable: true,
  get: function () {
    return ResolveSelect;
  }
});
Object.defineProperty(exports, 'err', {
  enumerable: true,
  get: function () {
    return err;
  }
});
Object.defineProperty(exports, 'isRenamePromptItem', {
  enumerable: true,
  get: function () {
    return isRenamePromptItem;
  }
});
Object.defineProperty(exports, 'postgresSchemaError', {
  enumerable: true,
  get: function () {
    return postgresSchemaError;
  }
});
Object.defineProperty(exports, 'postgresSchemaWarning', {
  enumerable: true,
  get: function () {
    return postgresSchemaWarning;
  }
});
Object.defineProperty(exports, 'require_hanji', {
  enumerable: true,
  get: function () {
    return require_hanji;
  }
});
Object.defineProperty(exports, 'source_default', {
  enumerable: true,
  get: function () {
    return source_default;
  }
});
Object.defineProperty(exports, 'withStyle', {
  enumerable: true,
  get: function () {
    return withStyle;
  }
});