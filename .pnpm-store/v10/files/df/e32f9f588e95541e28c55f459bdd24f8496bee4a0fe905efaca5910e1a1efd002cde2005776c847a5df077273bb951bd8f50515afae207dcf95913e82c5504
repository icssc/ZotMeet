{"version":3,"file":"char.js","names":[],"sources":["../../../src/pg-core/columns/char.ts"],"sourcesContent":["import { entityKind } from '~/entity.ts';\nimport type { PgTable } from '~/pg-core/table.ts';\nimport { type Equal, getColumnNameAndConfig, type Writable } from '~/utils.ts';\nimport { PgColumn, PgColumnBuilder } from './common.ts';\n\ntype PgCharBuilderConfig<TEnum extends [string, ...string[]]> = Equal<TEnum, [string, ...string[]]> extends true\n\t? { dataType: 'string'; data: string; driverParam: string }\n\t: { dataType: 'string enum'; data: TEnum[number]; enumValues: TEnum; driverParam: string };\n\nexport class PgCharBuilder<TEnum extends [string, ...string[]] = [string, ...string[]]> extends PgColumnBuilder<\n\tPgCharBuilderConfig<TEnum>,\n\t{ enumValues: TEnum; length: number; setLength: boolean }\n> {\n\tstatic override readonly [entityKind]: string = 'PgCharBuilder';\n\n\tconstructor(name: string, config: PgCharConfig<TEnum>) {\n\t\tsuper(name, config.enum?.length ? 'string enum' : 'string', 'PgChar');\n\t\tthis.config.length = config.length ?? 1;\n\t\tthis.config.setLength = config.length !== undefined;\n\t\tthis.config.enumValues = config.enum as TEnum;\n\t}\n\n\t/** @internal */\n\toverride build(table: PgTable<any>) {\n\t\treturn new PgChar(\n\t\t\ttable,\n\t\t\tthis.config as any,\n\t\t);\n\t}\n}\n\nexport class PgChar<TEnum extends [string, ...string[]] = [string, ...string[]]>\n\textends PgColumn<Equal<TEnum, [string, ...string[]]> extends true ? 'string' : 'string enum'>\n{\n\tstatic override readonly [entityKind]: string = 'PgChar';\n\n\toverride readonly enumValues: TEnum;\n\tprivate readonly setLength: boolean;\n\n\tconstructor(table: PgTable<any>, config: PgCharBuilder<TEnum>['config']) {\n\t\tsuper(table, config as any);\n\t\tthis.enumValues = config.enumValues;\n\t\tthis.setLength = config.setLength;\n\t}\n\n\tgetSQLType(): string {\n\t\treturn this.setLength ? `char(${this.length})` : `char`;\n\t}\n}\n\nexport interface PgCharConfig<\n\tTEnum extends readonly string[] | string[] | undefined = readonly string[] | string[] | undefined,\n> {\n\tenum?: TEnum;\n\tlength?: number;\n}\n\nexport function char(): PgCharBuilder;\nexport function char(name: string): PgCharBuilder;\nexport function char(config: { length?: number }): PgCharBuilder;\nexport function char(name: string, config: { length?: number }): PgCharBuilder;\nexport function char<U extends string, T extends Readonly<[U, ...U[]]>>(\n\tconfig: PgCharConfig<T | Writable<T>> & { enum: T | Writable<T> },\n): PgCharBuilder<Writable<T>>;\nexport function char<U extends string, T extends Readonly<[U, ...U[]]>>(\n\tname: string,\n\tconfig: PgCharConfig<T | Writable<T>> & { enum: T | Writable<T> },\n): PgCharBuilder<Writable<T>>;\nexport function char(a?: string | PgCharConfig, b: PgCharConfig = {}): any {\n\tconst { name, config } = getColumnNameAndConfig<PgCharConfig>(a, b);\n\treturn new PgCharBuilder(name, config as any);\n}\n"],"mappings":";;;;;AASA,IAAa,gBAAb,cAAgG,gBAG9F;CACD,QAA0B,cAAsB;CAEhD,YAAY,MAAc,QAA6B;AACtD,QAAM,MAAM,OAAO,MAAM,SAAS,gBAAgB,UAAU,SAAS;AACrE,OAAK,OAAO,SAAS,OAAO,UAAU;AACtC,OAAK,OAAO,YAAY,OAAO,WAAW;AAC1C,OAAK,OAAO,aAAa,OAAO;;;CAIjC,AAAS,MAAM,OAAqB;AACnC,SAAO,IAAI,OACV,OACA,KAAK,OACL;;;AAIH,IAAa,SAAb,cACS,SACT;CACC,QAA0B,cAAsB;CAEhD,AAAkB;CAClB,AAAiB;CAEjB,YAAY,OAAqB,QAAwC;AACxE,QAAM,OAAO,OAAc;AAC3B,OAAK,aAAa,OAAO;AACzB,OAAK,YAAY,OAAO;;CAGzB,aAAqB;AACpB,SAAO,KAAK,YAAY,QAAQ,KAAK,OAAO,KAAK;;;AAsBnD,SAAgB,KAAK,GAA2B,IAAkB,EAAE,EAAO;CAC1E,MAAM,EAAE,MAAM,WAAW,uBAAqC,GAAG,EAAE;AACnE,QAAO,IAAI,cAAc,MAAM,OAAc"}