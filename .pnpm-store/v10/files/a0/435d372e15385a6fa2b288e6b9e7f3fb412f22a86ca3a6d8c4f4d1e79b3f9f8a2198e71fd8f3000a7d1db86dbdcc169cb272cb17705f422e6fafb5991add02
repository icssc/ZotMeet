{"version":3,"file":"common.cjs","names":["ColumnBuilder","entityKind","ForeignKeyBuilder","ref","actions","Column","baseColumn: any","baseColumn: GelColumn","range?: [number | undefined, number | undefined]"],"sources":["../../../src/gel-core/columns/common.ts"],"sourcesContent":["import type {\n\tColumnBuilderBaseConfig,\n\tColumnBuilderExtraConfig,\n\tColumnBuilderRuntimeConfig,\n\tColumnType,\n\tHasGenerated,\n} from '~/column-builder.ts';\nimport { ColumnBuilder } from '~/column-builder.ts';\nimport type { ColumnBaseConfig } from '~/column.ts';\nimport { Column } from '~/column.ts';\nimport { entityKind } from '~/entity.ts';\nimport type { Simplify, Update } from '~/utils.ts';\n\nimport type { ForeignKey, UpdateDeleteAction } from '~/gel-core/foreign-keys.ts';\nimport { ForeignKeyBuilder } from '~/gel-core/foreign-keys.ts';\nimport type { AnyGelTable, GelTable } from '~/gel-core/table.ts';\nimport type { SQL } from '~/sql/sql.ts';\nimport { iife } from '~/tracing-utils.ts';\nimport type { GelIndexOpClass } from '../indexes.ts';\n\nexport type GelColumns = Record<string, GelColumn<any>>;\n\nexport interface ReferenceConfig {\n\tref: () => GelColumn;\n\tactions: {\n\t\tonUpdate?: UpdateDeleteAction;\n\t\tonDelete?: UpdateDeleteAction;\n\t};\n}\n\nexport abstract class GelColumnBuilder<\n\tT extends ColumnBuilderBaseConfig<ColumnType> = ColumnBuilderBaseConfig<ColumnType>,\n\tTRuntimeConfig extends object = object,\n\tTExtraConfig extends ColumnBuilderExtraConfig = ColumnBuilderExtraConfig,\n> extends ColumnBuilder<T, TRuntimeConfig, TExtraConfig> {\n\tprivate foreignKeyConfigs: ReferenceConfig[] = [];\n\n\tstatic override readonly [entityKind]: string = 'GelColumnBuilder';\n\n\tarray(length?: number): GelArrayBuilder<\n\t\t& {\n\t\t\tname: string;\n\t\t\tdataType: 'array basecolumn';\n\t\t\tdata: T['data'][];\n\t\t\tdriverParam: T['driverParam'][] | string;\n\t\t\tbaseBuilder: T;\n\t\t}\n\t\t& (T extends { notNull: true } ? { notNull: true } : {})\n\t\t& (T extends { hasDefault: true } ? { hasDefault: true } : {}),\n\t\tT\n\t> {\n\t\treturn new GelArrayBuilder(this.config.name, this as GelColumnBuilder<any, any>, length as any);\n\t}\n\n\treferences(\n\t\tref: ReferenceConfig['ref'],\n\t\tactions: ReferenceConfig['actions'] = {},\n\t): this {\n\t\tthis.foreignKeyConfigs.push({ ref, actions });\n\t\treturn this;\n\t}\n\n\tunique(\n\t\tname?: string,\n\t\tconfig?: { nulls: 'distinct' | 'not distinct' },\n\t): this {\n\t\tthis.config.isUnique = true;\n\t\tthis.config.uniqueName = name;\n\t\tthis.config.uniqueType = config?.nulls;\n\t\treturn this;\n\t}\n\n\tgeneratedAlwaysAs(as: SQL | (() => SQL)): HasGenerated<this, {\n\t\ttype: 'always';\n\t}> {\n\t\tthis.config.generated = {\n\t\t\tas,\n\t\t\ttype: 'always',\n\t\t\tmode: 'stored',\n\t\t};\n\t\treturn this as HasGenerated<this, {\n\t\t\ttype: 'always';\n\t\t}>;\n\t}\n\n\t/** @internal */\n\tbuildForeignKeys(column: GelColumn, table: GelTable): ForeignKey[] {\n\t\treturn this.foreignKeyConfigs.map(({ ref, actions }) => {\n\t\t\treturn iife(\n\t\t\t\t(ref, actions) => {\n\t\t\t\t\tconst builder = new ForeignKeyBuilder(() => {\n\t\t\t\t\t\tconst foreignColumn = ref();\n\t\t\t\t\t\treturn { columns: [column], foreignColumns: [foreignColumn] };\n\t\t\t\t\t});\n\t\t\t\t\tif (actions.onUpdate) {\n\t\t\t\t\t\tbuilder.onUpdate(actions.onUpdate);\n\t\t\t\t\t}\n\t\t\t\t\tif (actions.onDelete) {\n\t\t\t\t\t\tbuilder.onDelete(actions.onDelete);\n\t\t\t\t\t}\n\t\t\t\t\treturn builder.build(table);\n\t\t\t\t},\n\t\t\t\tref,\n\t\t\t\tactions,\n\t\t\t);\n\t\t});\n\t}\n\n\t/** @internal */\n\tabstract build(table: GelTable): GelColumn<any>;\n\n\t/** @internal */\n\tbuildExtraConfigColumn<TTableName extends string>(\n\t\ttable: AnyGelTable<{ name: TTableName }>,\n\t): GelExtraConfigColumn {\n\t\treturn new GelExtraConfigColumn(table, this.config);\n\t}\n}\n\n// To understand how to use `GelColumn` and `GelColumn`, see `Column` and `AnyColumn` documentation.\nexport abstract class GelColumn<\n\tT extends ColumnBaseConfig<ColumnType> = ColumnBaseConfig<ColumnType>,\n\tTRuntimeConfig extends object = {},\n> extends Column<T, TRuntimeConfig> {\n\tstatic override readonly [entityKind]: string = 'GelColumn';\n\n\t/** @internal */\n\toverride readonly table: GelTable;\n\n\tconstructor(\n\t\ttable: GelTable,\n\t\tconfig: ColumnBuilderRuntimeConfig<T['data']> & TRuntimeConfig,\n\t) {\n\t\tsuper(table, config);\n\t\tthis.table = table;\n\t}\n}\n\nexport type IndexedExtraConfigType = { order?: 'asc' | 'desc'; nulls?: 'first' | 'last'; opClass?: string };\n\nexport class GelExtraConfigColumn<\n\tT extends ColumnBaseConfig<ColumnType> = ColumnBaseConfig<ColumnType>,\n> extends GelColumn<T, IndexedExtraConfigType> {\n\tstatic override readonly [entityKind]: string = 'GelExtraConfigColumn';\n\n\toverride getSQLType(): string {\n\t\treturn this.getSQLType();\n\t}\n\n\tindexConfig: IndexedExtraConfigType = {\n\t\torder: this.config.order ?? 'asc',\n\t\tnulls: this.config.nulls ?? 'last',\n\t\topClass: this.config.opClass,\n\t};\n\tdefaultConfig: IndexedExtraConfigType = {\n\t\torder: 'asc',\n\t\tnulls: 'last',\n\t\topClass: undefined,\n\t};\n\n\tasc(): Omit<this, 'asc' | 'desc'> {\n\t\tthis.indexConfig.order = 'asc';\n\t\treturn this;\n\t}\n\n\tdesc(): Omit<this, 'asc' | 'desc'> {\n\t\tthis.indexConfig.order = 'desc';\n\t\treturn this;\n\t}\n\n\tnullsFirst(): Omit<this, 'nullsFirst' | 'nullsLast'> {\n\t\tthis.indexConfig.nulls = 'first';\n\t\treturn this;\n\t}\n\n\tnullsLast(): Omit<this, 'nullsFirst' | 'nullsLast'> {\n\t\tthis.indexConfig.nulls = 'last';\n\t\treturn this;\n\t}\n\n\t/**\n\t * ### PostgreSQL documentation quote\n\t *\n\t * > An operator class with optional parameters can be specified for each column of an index.\n\t * The operator class identifies the operators to be used by the index for that column.\n\t * For example, a B-tree index on four-byte integers would use the int4_ops class;\n\t * this operator class includes comparison functions for four-byte integers.\n\t * In practice the default operator class for the column's data type is usually sufficient.\n\t * The main point of having operator classes is that for some data types, there could be more than one meaningful ordering.\n\t * For example, we might want to sort a complex-number data type either by absolute value or by real part.\n\t * We could do this by defining two operator classes for the data type and then selecting the proper class when creating an index.\n\t * More information about operator classes check:\n\t *\n\t * ### Useful links\n\t * https://www.postgresql.org/docs/current/sql-createindex.html\n\t *\n\t * https://www.postgresql.org/docs/current/indexes-opclass.html\n\t *\n\t * https://www.postgresql.org/docs/current/xindex.html\n\t *\n\t * ### Additional types\n\t * If you have the `Gel_vector` extension installed in your database, you can use the\n\t * `vector_l2_ops`, `vector_ip_ops`, `vector_cosine_ops`, `vector_l1_ops`, `bit_hamming_ops`, `bit_jaccard_ops`, `halfvec_l2_ops`, `sparsevec_l2_ops` options, which are predefined types.\n\t *\n\t * **You can always specify any string you want in the operator class, in case Drizzle doesn't have it natively in its types**\n\t *\n\t * @param opClass\n\t * @returns\n\t */\n\top(opClass: GelIndexOpClass): Omit<this, 'op'> {\n\t\tthis.indexConfig.opClass = opClass;\n\t\treturn this;\n\t}\n}\n\nexport class IndexedColumn {\n\tstatic readonly [entityKind]: string = 'IndexedColumn';\n\tconstructor(\n\t\tname: string | undefined,\n\t\tkeyAsName: boolean,\n\t\ttype: string,\n\t\tindexConfig: IndexedExtraConfigType,\n\t) {\n\t\tthis.name = name;\n\t\tthis.keyAsName = keyAsName;\n\t\tthis.type = type;\n\t\tthis.indexConfig = indexConfig;\n\t}\n\n\tname: string | undefined;\n\tkeyAsName: boolean;\n\ttype: string;\n\tindexConfig: IndexedExtraConfigType;\n}\n\nexport type AnyGelColumn<TPartial extends Partial<ColumnBaseConfig<ColumnType>> = {}> = GelColumn<\n\tRequired<Update<ColumnBaseConfig<ColumnType>, TPartial>>\n>;\n\nexport type GelArrayColumnBuilderBaseConfig = ColumnBuilderBaseConfig<'array basecolumn'> & {\n\tbaseBuilder: ColumnBuilderBaseConfig<ColumnType>;\n};\n\nexport class GelArrayBuilder<\n\tT extends GelArrayColumnBuilderBaseConfig,\n\tTBase extends ColumnBuilderBaseConfig<ColumnType> | GelArrayColumnBuilderBaseConfig,\n> extends GelColumnBuilder<\n\tT & {\n\t\tbaseBuilder: TBase extends GelArrayColumnBuilderBaseConfig ? GelArrayBuilder<\n\t\t\t\tTBase,\n\t\t\t\tTBase extends { baseBuilder: infer TBaseBuilder extends ColumnBuilderBaseConfig<any> } ? TBaseBuilder\n\t\t\t\t\t: never\n\t\t\t>\n\t\t\t: GelColumnBuilder<TBase, {}, Simplify<Omit<TBase, keyof ColumnBuilderBaseConfig<any>>>>;\n\t},\n\t{\n\t\tbaseBuilder: TBase extends GelArrayColumnBuilderBaseConfig ? GelArrayBuilder<\n\t\t\t\tTBase,\n\t\t\t\tTBase extends { baseBuilder: infer TBaseBuilder extends ColumnBuilderBaseConfig<any> } ? TBaseBuilder\n\t\t\t\t\t: never\n\t\t\t>\n\t\t\t: GelColumnBuilder<TBase, {}, Simplify<Omit<TBase, keyof ColumnBuilderBaseConfig<any>>>>;\n\t\tlength: number | undefined;\n\t},\n\t{}\n> {\n\tstatic override readonly [entityKind]: string = 'GelArrayBuilder';\n\n\tconstructor(\n\t\tname: string,\n\t\tbaseBuilder: GelArrayBuilder<T, TBase>['config']['baseBuilder'],\n\t\tlength: number | undefined,\n\t) {\n\t\tsuper(name, 'array basecolumn', 'GelArray');\n\t\tthis.config.baseBuilder = baseBuilder;\n\t\tthis.config.length = length;\n\t}\n\n\t/** @internal */\n\toverride build(table: GelTable) {\n\t\tconst baseColumn: any = this.config.baseBuilder.build(table);\n\t\treturn new GelArray(\n\t\t\ttable,\n\t\t\tthis.config as any,\n\t\t\tbaseColumn,\n\t\t);\n\t}\n}\n\nexport class GelArray<\n\tT extends ColumnBaseConfig<'array basecolumn'> & {\n\t\tlength: number | undefined;\n\t\tbaseBuilder: ColumnBuilderBaseConfig<ColumnType>;\n\t},\n\tTBase extends ColumnBuilderBaseConfig<ColumnType>,\n> extends GelColumn<T, {}> {\n\tstatic override readonly [entityKind]: string = 'GelArray';\n\n\tconstructor(\n\t\ttable: AnyGelTable<{ name: T['tableName'] }>,\n\t\tconfig: GelArrayBuilder<T, TBase>['config'],\n\t\treadonly baseColumn: GelColumn,\n\t\treadonly range?: [number | undefined, number | undefined],\n\t) {\n\t\tsuper(table, config);\n\t}\n\n\toverride mapFromDriverValue(value: unknown[]): T['data'] {\n\t\treturn value.map((v) => this.baseColumn.mapFromDriverValue(v));\n\t}\n\n\t// Needed for arrays of custom types\n\tmapFromJsonValue(value: unknown[]): T['data'] {\n\t\tconst base = this.baseColumn;\n\n\t\treturn 'mapFromJsonValue' in base\n\t\t\t? value.map((v) => (<(value: unknown) => unknown> base.mapFromJsonValue)(v))\n\t\t\t: value.map((v) => base.mapFromDriverValue(v));\n\t}\n\n\tgetSQLType(): string {\n\t\treturn `${this.baseColumn.getSQLType()}[${typeof this.length === 'number' ? this.length : ''}]`;\n\t}\n}\n"],"mappings":"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"}