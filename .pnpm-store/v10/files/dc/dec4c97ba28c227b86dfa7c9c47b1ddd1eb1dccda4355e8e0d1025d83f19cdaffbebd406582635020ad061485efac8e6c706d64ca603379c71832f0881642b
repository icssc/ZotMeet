{"version":3,"sources":["../../../../../../src/client/components/router-reducer/reducers/server-patch-reducer.ts"],"sourcesContent":["import { createHrefFromUrl } from '../create-href-from-url'\nimport type {\n  ServerPatchAction,\n  ReducerState,\n  ReadonlyReducerState,\n  Mutable,\n} from '../router-reducer-types'\nimport { handleExternalUrl, handleNavigationResult } from './navigate-reducer'\nimport { navigateToSeededRoute } from '../../segment-cache/navigation'\nimport { refreshReducer } from './refresh-reducer'\nimport { FreshnessPolicy } from '../ppr-navigations'\n\nexport function serverPatchReducer(\n  state: ReadonlyReducerState,\n  action: ServerPatchAction\n): ReducerState {\n  const mutable: Mutable = {}\n  mutable.preserveCustomHistoryState = false\n\n  // A \"retry\" is a navigation that happens due to a route mismatch. It's\n  // similar to a refresh, because we will omit any existing dynamic data on\n  // the page. But we seed the retry navigation with the exact tree that the\n  // server just responded with.\n  const retryMpa = action.mpa\n  const retryUrl = new URL(action.url, location.origin)\n  const retrySeed = action.seed\n  if (retryMpa || retrySeed === null) {\n    // If the server did not send back data during the mismatch, fall back to\n    // an MPA navigation.\n    return handleExternalUrl(state, mutable, retryUrl.href, false)\n  }\n  const currentUrl = new URL(state.canonicalUrl, location.origin)\n  if (action.previousTree !== state.tree) {\n    // There was another, more recent navigation since the once that\n    // mismatched. We can abort the retry, but we still need to refresh the\n    // page to evict any stale dynamic data.\n    return refreshReducer(state)\n  }\n  // There have been no new navigations since the mismatched one. Refresh,\n  // using the tree we just received from the server.\n  const retryCanonicalUrl = createHrefFromUrl(retryUrl)\n  const retryNextUrl = action.nextUrl\n  // A retry should not create a new history entry.\n  const pendingPush = false\n  const shouldScroll = true\n  const now = Date.now()\n  const result = navigateToSeededRoute(\n    now,\n    retryUrl,\n    retryCanonicalUrl,\n    retrySeed,\n    currentUrl,\n    state.cache,\n    state.tree,\n    FreshnessPolicy.RefreshAll,\n    retryNextUrl,\n    shouldScroll\n  )\n  return handleNavigationResult(retryUrl, state, mutable, pendingPush, result)\n}\n"],"names":["createHrefFromUrl","handleExternalUrl","handleNavigationResult","navigateToSeededRoute","refreshReducer","FreshnessPolicy","serverPatchReducer","state","action","mutable","preserveCustomHistoryState","retryMpa","mpa","retryUrl","URL","url","location","origin","retrySeed","seed","href","currentUrl","canonicalUrl","previousTree","tree","retryCanonicalUrl","retryNextUrl","nextUrl","pendingPush","shouldScroll","now","Date","result","cache","RefreshAll"],"mappings":"AAAA,SAASA,iBAAiB,QAAQ,0BAAyB;AAO3D,SAASC,iBAAiB,EAAEC,sBAAsB,QAAQ,qBAAoB;AAC9E,SAASC,qBAAqB,QAAQ,iCAAgC;AACtE,SAASC,cAAc,QAAQ,oBAAmB;AAClD,SAASC,eAAe,QAAQ,qBAAoB;AAEpD,OAAO,SAASC,mBACdC,KAA2B,EAC3BC,MAAyB;IAEzB,MAAMC,UAAmB,CAAC;IAC1BA,QAAQC,0BAA0B,GAAG;IAErC,uEAAuE;IACvE,0EAA0E;IAC1E,0EAA0E;IAC1E,8BAA8B;IAC9B,MAAMC,WAAWH,OAAOI,GAAG;IAC3B,MAAMC,WAAW,IAAIC,IAAIN,OAAOO,GAAG,EAAEC,SAASC,MAAM;IACpD,MAAMC,YAAYV,OAAOW,IAAI;IAC7B,IAAIR,YAAYO,cAAc,MAAM;QAClC,yEAAyE;QACzE,qBAAqB;QACrB,OAAOjB,kBAAkBM,OAAOE,SAASI,SAASO,IAAI,EAAE;IAC1D;IACA,MAAMC,aAAa,IAAIP,IAAIP,MAAMe,YAAY,EAAEN,SAASC,MAAM;IAC9D,IAAIT,OAAOe,YAAY,KAAKhB,MAAMiB,IAAI,EAAE;QACtC,gEAAgE;QAChE,uEAAuE;QACvE,wCAAwC;QACxC,OAAOpB,eAAeG;IACxB;IACA,wEAAwE;IACxE,mDAAmD;IACnD,MAAMkB,oBAAoBzB,kBAAkBa;IAC5C,MAAMa,eAAelB,OAAOmB,OAAO;IACnC,iDAAiD;IACjD,MAAMC,cAAc;IACpB,MAAMC,eAAe;IACrB,MAAMC,MAAMC,KAAKD,GAAG;IACpB,MAAME,SAAS7B,sBACb2B,KACAjB,UACAY,mBACAP,WACAG,YACAd,MAAM0B,KAAK,EACX1B,MAAMiB,IAAI,EACVnB,gBAAgB6B,UAAU,EAC1BR,cACAG;IAEF,OAAO3B,uBAAuBW,UAAUN,OAAOE,SAASmB,aAAaI;AACvE","ignoreList":[0]}