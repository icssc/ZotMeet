import { entityKind } from "../entity.js";
import * as effect_Types0 from "effect/Types";
import * as effect_Cause0 from "effect/Cause";

//#region src/effect-core/errors.d.ts
declare const TaggedDrizzleError_base: new <A extends Record<string, any> = {}>(args: effect_Types0.Equals<A, {}> extends true ? void : { readonly [P in keyof A as P extends "_tag" ? never : P]: A[P] }) => effect_Cause0.YieldableError & {
  readonly _tag: "DrizzleError";
} & Readonly<A>;
declare class TaggedDrizzleError extends TaggedDrizzleError_base {
  static readonly [entityKind]: string;
  readonly message: string;
  readonly cause?: unknown;
  constructor({
    message,
    cause
  }: {
    message?: string;
    cause?: unknown;
  });
}
declare const TaggedDrizzleQueryError_base: new <A extends Record<string, any> = {}>(args: effect_Types0.Equals<A, {}> extends true ? void : { readonly [P in keyof A as P extends "_tag" ? never : P]: A[P] }) => effect_Cause0.YieldableError & {
  readonly _tag: "DrizzleQueryError";
} & Readonly<A>;
declare class TaggedDrizzleQueryError extends TaggedDrizzleQueryError_base {
  readonly query: string;
  readonly params: any[];
  cause?: Error | undefined;
  static readonly [entityKind]: string;
  readonly message: string;
  constructor(query: string, params: any[], cause?: Error | undefined);
}
declare const TaggedTransactionRollbackError_base: new <A extends Record<string, any> = {}>(args: effect_Types0.Equals<A, {}> extends true ? void : { readonly [P in keyof A as P extends "_tag" ? never : P]: A[P] }) => effect_Cause0.YieldableError & {
  readonly _tag: "TransactionRollbackError";
} & Readonly<A>;
declare class TaggedTransactionRollbackError extends TaggedTransactionRollbackError_base {
  static readonly [entityKind]: string;
  readonly message = "Rollback";
}
//#endregion
export { TaggedDrizzleError, TaggedDrizzleQueryError, TaggedTransactionRollbackError };
//# sourceMappingURL=errors.d.ts.map