{"version":3,"sources":["../../../../../../src/build/webpack/loaders/next-app-loader/index.ts"],"sourcesContent":["import type webpack from 'next/dist/compiled/webpack/webpack'\nimport {\n  UNDERSCORE_GLOBAL_ERROR_ROUTE,\n  UNDERSCORE_NOT_FOUND_ROUTE,\n  type ValueOf,\n} from '../../../../shared/lib/constants'\nimport {\n  UNDERSCORE_GLOBAL_ERROR_ROUTE_ENTRY,\n  UNDERSCORE_NOT_FOUND_ROUTE_ENTRY,\n} from '../../../../shared/lib/entry-constants'\nimport type { ModuleTuple, CollectedMetadata } from '../metadata/types'\n\nimport path from 'path'\nimport { bold } from '../../../../lib/picocolors'\nimport { getModuleBuildInfo } from '../get-module-build-info'\nimport { verifyRootLayout } from '../../../../lib/verify-root-layout'\nimport * as Log from '../../../output/log'\nimport { APP_DIR_ALIAS } from '../../../../lib/constants'\nimport {\n  createMetadataExportsCode,\n  createStaticMetadataFromRoute,\n} from '../metadata/discover'\nimport { promises as fs } from 'fs'\nimport { isAppRouteRoute } from '../../../../lib/is-app-route-route'\nimport type { NextConfig } from '../../../../server/config-shared'\nimport { AppPathnameNormalizer } from '../../../../server/normalizers/built/app/app-pathname-normalizer'\nimport type { ProxyConfig } from '../../../analysis/get-page-static-info'\nimport { isAppBuiltinPage } from '../../../utils'\nimport { loadEntrypoint } from '../../../load-entrypoint'\nimport {\n  isGroupSegment,\n  DEFAULT_SEGMENT_KEY,\n  PAGE_SEGMENT_KEY,\n} from '../../../../shared/lib/segment'\nimport { getFilesInDir } from '../../../../lib/get-files-in-dir'\nimport type { PageExtensions } from '../../../page-extensions-type'\nimport { PARALLEL_ROUTE_DEFAULT_PATH } from '../../../../client/components/builtin/default'\nimport { PARALLEL_ROUTE_DEFAULT_NULL_PATH } from '../../../../client/components/builtin/default-null'\nimport type { Compilation } from 'webpack'\nimport { createAppRouteCode } from './create-app-route-code'\nimport { MissingDefaultParallelRouteError } from '../../../../shared/lib/errors/missing-default-parallel-route-error'\nimport { isInterceptionRouteAppPath } from '../../../../shared/lib/router/utils/interception-routes'\n\nimport { normalizePathSep } from '../../../../shared/lib/page-path/normalize-path-sep'\nimport { installBindings } from '../../../swc/install-bindings'\n\nexport type AppLoaderOptions = {\n  name: string\n  page: string\n  pagePath: string\n  appDir: string\n  appPaths: readonly string[] | null\n  preferredRegion: string | string[] | undefined\n  pageExtensions: PageExtensions\n  assetPrefix: string\n  rootDir?: string\n  tsconfigPath?: string\n  isDev?: true\n  basePath: string\n  nextConfigOutput?: NextConfig['output']\n  middlewareConfig: string\n  isGlobalNotFoundEnabled: true | undefined\n}\ntype AppLoader = webpack.LoaderDefinitionFunction<AppLoaderOptions>\n\nconst HTTP_ACCESS_FALLBACKS = {\n  'not-found': 'not-found',\n  forbidden: 'forbidden',\n  unauthorized: 'unauthorized',\n} as const\nconst defaultHTTPAccessFallbackPaths = {\n  'not-found': 'next/dist/client/components/builtin/not-found.js',\n  forbidden: 'next/dist/client/components/builtin/forbidden.js',\n  unauthorized: 'next/dist/client/components/builtin/unauthorized.js',\n} as const\n\nconst FILE_TYPES = {\n  layout: 'layout',\n  template: 'template',\n  error: 'error',\n  loading: 'loading',\n  'global-error': 'global-error',\n  'global-not-found': 'global-not-found',\n  ...HTTP_ACCESS_FALLBACKS,\n} as const\n\nconst GLOBAL_ERROR_FILE_TYPE = 'global-error'\nconst GLOBAL_NOT_FOUND_FILE_TYPE = 'global-not-found'\nconst PAGE_SEGMENT = 'page$'\nconst PARALLEL_VIRTUAL_SEGMENT = 'slot$'\n\nconst defaultGlobalErrorPath =\n  'next/dist/client/components/builtin/global-error.js'\nconst defaultNotFoundPath = 'next/dist/client/components/builtin/not-found.js'\nconst defaultEmptyStubPath = 'next/dist/client/components/builtin/empty-stub.js'\nconst defaultLayoutPath = 'next/dist/client/components/builtin/layout.js'\nconst defaultGlobalNotFoundPath =\n  'next/dist/client/components/builtin/global-not-found.js'\nconst appErrorPath = 'next/dist/client/components/builtin/app-error.js'\n\ntype DirResolver = (pathToResolve: string) => string\ntype PathResolver = (\n  pathname: string\n) => Promise<string | undefined> | string | undefined\nexport type MetadataResolver = (\n  dir: string,\n  filename: string,\n  extensions: readonly string[]\n) => Promise<string | undefined>\n\nexport type AppDirModules = {\n  readonly [moduleKey in ValueOf<typeof FILE_TYPES>]?: ModuleTuple\n} & {\n  readonly page?: ModuleTuple\n} & {\n  readonly metadata?: CollectedMetadata\n} & {\n  readonly defaultPage?: ModuleTuple\n}\n\nconst normalizeParallelKey = (key: string) =>\n  key.startsWith('@') ? key.slice(1) : key\n\nconst isCatchAllSegment = (segment: string) =>\n  segment.startsWith('[...') || segment.startsWith('[[...')\n\nconst isDirectory = async (pathname: string) => {\n  try {\n    const stat = await fs.stat(pathname)\n    return stat.isDirectory()\n  } catch (err) {\n    return false\n  }\n}\n\nasync function createTreeCodeFromPath(\n  pagePath: string,\n  {\n    page,\n    resolveDir,\n    resolver,\n    resolveParallelSegments,\n    hasChildRoutesForSegment,\n    metadataResolver,\n    pageExtensions,\n    basePath,\n    collectedDeclarations,\n    isGlobalNotFoundEnabled,\n  }: {\n    page: string\n    resolveDir: DirResolver\n    resolver: PathResolver\n    metadataResolver: MetadataResolver\n    resolveParallelSegments: (\n      pathname: string\n    ) => [key: string, segment: string | string[]][]\n    hasChildRoutesForSegment: (segmentPath: string) => boolean\n    loaderContext: webpack.LoaderContext<AppLoaderOptions>\n    pageExtensions: PageExtensions\n    basePath: string\n    collectedDeclarations: [string, string][]\n    isGlobalNotFoundEnabled: boolean\n  }\n): Promise<{\n  treeCode: string\n  rootLayout: string | undefined\n  globalError: string\n  globalNotFound: string\n}> {\n  const splittedPath = pagePath.split(/[\\\\/]/, 1)\n  const isNotFoundRoute = page === UNDERSCORE_NOT_FOUND_ROUTE_ENTRY\n  const isAppErrorRoute = page === UNDERSCORE_GLOBAL_ERROR_ROUTE_ENTRY\n  const isDefaultNotFound = isAppBuiltinPage(pagePath)\n\n  const appDirPrefix = isDefaultNotFound ? APP_DIR_ALIAS : splittedPath[0]\n\n  let rootLayout: string | undefined\n  let globalError: string = defaultGlobalErrorPath\n  let globalNotFound: string = defaultNotFoundPath\n\n  async function resolveAdjacentParallelSegments(\n    segmentPath: string\n  ): Promise<string[]> {\n    const absoluteSegmentPath = resolveDir(`${appDirPrefix}${segmentPath}`)\n\n    if (!absoluteSegmentPath) {\n      return []\n    }\n\n    const segmentIsDirectory = await isDirectory(absoluteSegmentPath)\n\n    if (!segmentIsDirectory) {\n      return []\n    }\n\n    // We need to resolve all parallel routes in this level.\n    const files = await fs.opendir(absoluteSegmentPath)\n\n    const parallelSegments: string[] = ['children']\n\n    for await (const dirent of files) {\n      // Make sure name starts with \"@\" and is a directory.\n      if (dirent.isDirectory() && dirent.name.charCodeAt(0) === 64) {\n        parallelSegments.push(dirent.name)\n      }\n    }\n\n    return parallelSegments\n  }\n\n  async function createSubtreePropsFromSegmentPath(\n    segments: string[],\n    nestedCollectedDeclarations: [string, string][]\n  ): Promise<{\n    treeCode: string\n  }> {\n    const segmentPath = segments.join('/')\n\n    // Existing tree are the children of the current segment\n    const props: Record<string, string> = {}\n    // Root layer could be 1st layer of normal routes\n    const isRootLayer = segments.length === 0\n    const isRootLayoutOrRootPage = segments.length <= 1\n\n    // We need to resolve all parallel routes in this level.\n    const parallelSegments: [key: string, segment: string | string[]][] = []\n    if (isRootLayer) {\n      parallelSegments.push(['children', ''])\n    } else {\n      parallelSegments.push(...resolveParallelSegments(segmentPath))\n    }\n\n    let metadata: Awaited<ReturnType<typeof createStaticMetadataFromRoute>> =\n      null\n    const routerDirPath = `${appDirPrefix}${segmentPath}`\n    const resolvedRouteDir = resolveDir(routerDirPath)\n\n    if (\n      resolvedRouteDir &&\n      // Do not collect metadata for app-error route as it's for generating pure static 500.html\n      !normalizePathSep(pagePath).endsWith(appErrorPath)\n    ) {\n      metadata = await createStaticMetadataFromRoute(resolvedRouteDir, {\n        basePath,\n        segment: segmentPath,\n        metadataResolver,\n        isRootLayoutOrRootPage,\n        pageExtensions,\n      })\n    }\n\n    for (const [parallelKey, parallelSegment] of parallelSegments) {\n      // if parallelSegment is the page segment (ie, `page$` and not ['page$']), it gets loaded into the __PAGE__ slot\n      // as it's the page for the current route.\n      if (parallelSegment === PAGE_SEGMENT) {\n        const matchedPagePath = `${appDirPrefix}${segmentPath}${\n          parallelKey === 'children' ? '' : `/${parallelKey}`\n        }/page`\n\n        const resolvedPagePath = await resolver(matchedPagePath)\n        if (resolvedPagePath) {\n          const varName = `page${nestedCollectedDeclarations.length}`\n          nestedCollectedDeclarations.push([varName, resolvedPagePath])\n\n          // Use '' for segment as it's the page. There can't be a segment called '' so this is the safest way to add it.\n          props[normalizeParallelKey(parallelKey)] =\n            `['${PAGE_SEGMENT_KEY}', {}, {\n          page: [${varName}, ${JSON.stringify(resolvedPagePath)}],\n          ${createMetadataExportsCode(metadata)}\n        }]`\n          continue\n        } else {\n          throw new Error(`Can't resolve ${matchedPagePath}`)\n        }\n      }\n\n      // if the parallelSegment was not matched to the __PAGE__ slot, then it's a parallel route at this level.\n      // the code below recursively traverses the parallel slots directory to match the corresponding __PAGE__ for each parallel slot\n      // while also filling in layout/default/etc files into the loader tree at each segment level.\n\n      const subSegmentPath = [...segments]\n      if (parallelKey !== 'children') {\n        // A `children` parallel key should have already been processed in the above segment\n        // So we exclude it when constructing the subsegment path for the remaining segment levels\n        subSegmentPath.push(parallelKey)\n      }\n\n      const normalizedParallelSegment = Array.isArray(parallelSegment)\n        ? parallelSegment[0]\n        : parallelSegment\n\n      if (\n        normalizedParallelSegment !== PAGE_SEGMENT &&\n        normalizedParallelSegment !== PARALLEL_VIRTUAL_SEGMENT\n      ) {\n        // If we don't have a page segment, nor a special $children marker, it means we need to traverse the next directory\n        // (ie, `normalizedParallelSegment` would correspond with the folder that contains the next level of pages/layout/etc)\n        // we push it to the subSegmentPath so that we can fill in the loader tree for that segment.\n        subSegmentPath.push(normalizedParallelSegment)\n      }\n\n      const parallelSegmentPath = subSegmentPath.join('/')\n\n      // Fill in the loader tree for all of the special files types (layout, default, etc) at this level\n      // `page` is not included here as it's added above.\n      const filePathEntries = await Promise.all(\n        Object.values(FILE_TYPES).map(async (file) => {\n          return [\n            file,\n            await resolver(\n              `${appDirPrefix}${\n                // TODO-APP: parallelSegmentPath sometimes ends in `/` but sometimes it doesn't. This should be consistent.\n                parallelSegmentPath.endsWith('/')\n                  ? parallelSegmentPath\n                  : parallelSegmentPath + '/'\n              }${file}`\n            ),\n          ] as const\n        })\n      )\n      const filePaths = new Map<ValueOf<typeof FILE_TYPES>, string | undefined>(\n        filePathEntries\n      )\n\n      // Only resolve global-* convention files at the root layer\n      if (isRootLayer) {\n        const resolvedGlobalErrorPath = await resolver(\n          `${appDirPrefix}/${GLOBAL_ERROR_FILE_TYPE}`\n        )\n        if (resolvedGlobalErrorPath) {\n          globalError = resolvedGlobalErrorPath\n        }\n        // Add global-error to root layer's filePaths, so that it's always available,\n        // by default it's the built-in global-error.js\n        filePaths.set(GLOBAL_ERROR_FILE_TYPE, globalError)\n\n        // TODO(global-not-found): remove this flag assertion condition\n        //  once global-not-found is stable\n        if (isGlobalNotFoundEnabled) {\n          const resolvedGlobalNotFoundPath = await resolver(\n            `${appDirPrefix}/${GLOBAL_NOT_FOUND_FILE_TYPE}`\n          )\n          if (resolvedGlobalNotFoundPath) {\n            globalNotFound = resolvedGlobalNotFoundPath\n          }\n          // Add global-not-found to root layer's filePaths, so that it's always available,\n          // by default it's the built-in global-not-found.js\n          filePaths.set(GLOBAL_NOT_FOUND_FILE_TYPE, globalNotFound)\n        }\n      }\n\n      let definedFilePaths = Array.from(filePaths.entries()).filter(\n        ([, filePath]) => filePath !== undefined\n      ) as [ValueOf<typeof FILE_TYPES>, string][]\n\n      // Add default access fallback as root fallback if not present\n      const existedConventionNames = new Set(\n        definedFilePaths.map(([type]) => type)\n      )\n      // If the first layer is a group route, we treat it as root layer\n      const isFirstLayerGroupRoute =\n        segments.length === 1 &&\n        subSegmentPath.filter((seg) => isGroupSegment(seg)).length === 1\n\n      if (isRootLayer || isFirstLayerGroupRoute) {\n        const accessFallbackTypes = Object.keys(\n          defaultHTTPAccessFallbackPaths\n        ) as (keyof typeof defaultHTTPAccessFallbackPaths)[]\n        for (const type of accessFallbackTypes) {\n          const hasRootFallbackFile = await resolver(\n            `${appDirPrefix}/${FILE_TYPES[type]}`\n          )\n          const hasLayerFallbackFile = existedConventionNames.has(type)\n\n          // If you already have a root access error fallback, don't insert default access error boundary to group routes root\n          if (\n            // Is treated as root layout and without boundary\n            !(hasRootFallbackFile && isFirstLayerGroupRoute) &&\n            // Does not have a fallback boundary file\n            !hasLayerFallbackFile\n          ) {\n            const defaultFallbackPath = defaultHTTPAccessFallbackPaths[type]\n            if (!(isDefaultNotFound && type === 'not-found')) {\n              definedFilePaths.push([type, defaultFallbackPath])\n            }\n          }\n        }\n      }\n\n      if (!rootLayout) {\n        const layoutPath = definedFilePaths.find(\n          ([type]) => type === 'layout'\n        )?.[1]\n        rootLayout = layoutPath\n\n        // When `global-not-found` is disabled, we insert a default layout if\n        // root layout is presented. This logic and the default layout will be removed\n        // once `global-not-found` is stabilized.\n        if (\n          !isGlobalNotFoundEnabled &&\n          isDefaultNotFound &&\n          !layoutPath &&\n          !rootLayout\n        ) {\n          rootLayout = defaultLayoutPath\n          definedFilePaths.push(['layout', rootLayout])\n        }\n      }\n\n      let parallelSegmentKey = Array.isArray(parallelSegment)\n        ? parallelSegment[0]\n        : parallelSegment\n\n      // normalize the parallel segment key to remove any special markers that we inserted in the\n      // earlier logic (such as children$ and page$). These should never appear in the loader tree, and\n      // should instead be the corresponding segment keys (ie `__PAGE__`) or the `children` parallel route.\n      parallelSegmentKey =\n        parallelSegmentKey === PARALLEL_VIRTUAL_SEGMENT\n          ? '(slot)'\n          : parallelSegmentKey === PAGE_SEGMENT\n            ? PAGE_SEGMENT_KEY\n            : parallelSegmentKey\n\n      const normalizedParallelKey = normalizeParallelKey(parallelKey)\n      let subtreeCode: string | undefined\n      // If it's root not found page, set not-found boundary as children page\n      if (isNotFoundRoute) {\n        if (normalizedParallelKey === 'children') {\n          const matchedGlobalNotFound = isGlobalNotFoundEnabled\n            ? (definedFilePaths.find(\n                ([type]) => type === GLOBAL_NOT_FOUND_FILE_TYPE\n              )?.[1] ?? defaultGlobalNotFoundPath)\n            : undefined\n\n          // If custom global-not-found.js is defined, use global-not-found.js\n          if (matchedGlobalNotFound) {\n            const varName = `notFound${nestedCollectedDeclarations.length}`\n            nestedCollectedDeclarations.push([varName, matchedGlobalNotFound])\n            const layoutName = `layout${nestedCollectedDeclarations.length}`\n            nestedCollectedDeclarations.push([layoutName, defaultEmptyStubPath])\n            subtreeCode = `{\n              children: [${JSON.stringify(UNDERSCORE_NOT_FOUND_ROUTE)}, {\n                children: ['${PAGE_SEGMENT_KEY}', {}, {\n                  layout: [\n                    ${varName},\n                    ${JSON.stringify(matchedGlobalNotFound)}\n                  ],\n                  page: [\n                    ${layoutName},\n                    ${JSON.stringify(defaultEmptyStubPath)}\n                  ]\n                }]\n              }, {}]\n            }`\n          } else {\n            // If custom not-found.js is found, use it and layout to compose the page,\n            // and fallback to built-in not-found component if doesn't exist.\n            const notFoundPath =\n              definedFilePaths.find(([type]) => type === 'not-found')?.[1] ??\n              defaultNotFoundPath\n            const varName = `notFound${nestedCollectedDeclarations.length}`\n            nestedCollectedDeclarations.push([varName, notFoundPath])\n            subtreeCode = `{\n              children: [${JSON.stringify(UNDERSCORE_NOT_FOUND_ROUTE.slice(1))}, {\n                children: ['${PAGE_SEGMENT_KEY}', {}, {\n                  page: [\n                    ${varName},\n                    ${JSON.stringify(notFoundPath)}\n                  ]\n                }]\n              }, {}]\n            }`\n          }\n        }\n      }\n\n      // If it's app-error route, set app-error as children page\n      if (isAppErrorRoute) {\n        const varName = `appError${nestedCollectedDeclarations.length}`\n        nestedCollectedDeclarations.push([varName, appErrorPath])\n        subtreeCode = `{\n          children: [${JSON.stringify(UNDERSCORE_GLOBAL_ERROR_ROUTE.slice(1))}, {\n            children: ['${PAGE_SEGMENT_KEY}', {}, {\n              page: [\n                ${varName},\n                ${JSON.stringify(appErrorPath)}\n              ]\n            }]\n          }, {}]\n        }`\n      }\n\n      // For 404 route\n      // if global-not-found is in definedFilePaths, remove root layout for /_not-found,\n      // and change it to global-not-found route.\n      // TODO: remove this once global-not-found is stable.\n      if (isNotFoundRoute && isGlobalNotFoundEnabled) {\n        definedFilePaths = definedFilePaths.filter(\n          ([type]) => type !== 'layout'\n        )\n\n        // Replace the layout to global-not-found\n        definedFilePaths.push([\n          'layout',\n          definedFilePaths.find(\n            ([type]) => type === GLOBAL_NOT_FOUND_FILE_TYPE\n          )?.[1] ?? defaultGlobalNotFoundPath,\n        ])\n      }\n\n      if (isAppErrorRoute) {\n        definedFilePaths = definedFilePaths.filter(\n          ([type]) => type !== 'layout'\n        )\n      }\n\n      const modulesCode = `{\n        ${definedFilePaths\n          .map(([file, filePath]) => {\n            const varName = `module${nestedCollectedDeclarations.length}`\n            nestedCollectedDeclarations.push([varName, filePath])\n            return `'${file}': [${varName}, ${JSON.stringify(filePath)}],`\n          })\n          .join('\\n')}\n        ${createMetadataExportsCode(metadata)}\n      }`\n\n      if (!subtreeCode) {\n        const { treeCode: pageSubtreeCode } =\n          await createSubtreePropsFromSegmentPath(\n            subSegmentPath,\n            nestedCollectedDeclarations\n          )\n\n        subtreeCode = pageSubtreeCode\n      }\n\n      props[normalizedParallelKey] = `[\n        '${parallelSegmentKey}',\n        ${subtreeCode},\n        ${modulesCode}\n      ]`\n    }\n\n    const adjacentParallelSegments =\n      await resolveAdjacentParallelSegments(segmentPath)\n\n    for (const adjacentParallelSegment of adjacentParallelSegments) {\n      if (!props[normalizeParallelKey(adjacentParallelSegment)]) {\n        const actualSegment =\n          adjacentParallelSegment === 'children'\n            ? ''\n            : `/${adjacentParallelSegment}`\n\n        // Use the default path if it's found, otherwise if it's a children\n        // slot, then use the fallback (which triggers a `notFound()`). If this\n        // isn't a children slot, then throw an error, as it produces a silent\n        // 404 if we'd used the fallback.\n        const fullSegmentPath = `${appDirPrefix}${segmentPath}${actualSegment}`\n        let defaultPath = await resolver(`${fullSegmentPath}/default`)\n        if (!defaultPath) {\n          if (adjacentParallelSegment === 'children') {\n            // When we host applications on Vercel, the status code affects the\n            // underlying behavior of the route, which when we are missing the\n            // children slot of an interception route, will yield a full 404\n            // response for the RSC request instead. For this reason, we expect\n            // that if a default file is missing when we're rendering an\n            // interception route, we instead always render null for the default\n            // slot to avoid the full 404 response.\n            if (isInterceptionRouteAppPath(page)) {\n              defaultPath = PARALLEL_ROUTE_DEFAULT_NULL_PATH\n            } else {\n              defaultPath = PARALLEL_ROUTE_DEFAULT_PATH\n            }\n          } else {\n            // Check if we're inside a catch-all route (i.e., the parallel route is a child\n            // of a catch-all segment). Only skip validation if the slot is UNDER a catch-all.\n            // For example:\n            //   /[...catchAll]/@slot - isInsideCatchAll = true (skip validation) ✓\n            //   /@slot/[...catchAll] - isInsideCatchAll = false (require default) ✓\n            // The catch-all provides fallback behavior, so default.js is not required.\n            const isInsideCatchAll = segments.some(isCatchAllSegment)\n\n            // Check if this is a leaf segment (no child routes).\n            // Leaf segments don't need default.js because there are no child routes\n            // that could cause the parallel slot to unmatch. For example:\n            //   /repo-overview/@slot/page with no child routes - isLeafSegment = true (skip validation) ✓\n            //   /repo-overview/@slot/page with /repo-overview/child/page - isLeafSegment = false (require default) ✓\n            // This also handles route groups correctly by filtering them out.\n            const isLeafSegment = !hasChildRoutesForSegment(segmentPath)\n\n            if (!isInsideCatchAll && !isLeafSegment) {\n              // Replace internal webpack alias with user-facing directory name\n              const userFacingPath = fullSegmentPath.replace(\n                APP_DIR_ALIAS,\n                'app'\n              )\n              throw new MissingDefaultParallelRouteError(\n                userFacingPath,\n                adjacentParallelSegment\n              )\n            }\n            defaultPath = PARALLEL_ROUTE_DEFAULT_PATH\n          }\n        }\n\n        const varName = `default${nestedCollectedDeclarations.length}`\n        nestedCollectedDeclarations.push([varName, defaultPath])\n        props[normalizeParallelKey(adjacentParallelSegment)] = `[\n          '${DEFAULT_SEGMENT_KEY}',\n          {},\n          {\n            defaultPage: [${varName}, ${JSON.stringify(defaultPath)}],\n          }\n        ]`\n      }\n    }\n    return {\n      treeCode: `{\n        ${Object.entries(props)\n          .map(([key, value]) => `${key}: ${value}`)\n          .join(',\\n')}\n      }`,\n    }\n  }\n\n  const { treeCode } = await createSubtreePropsFromSegmentPath(\n    [],\n    collectedDeclarations\n  )\n\n  return {\n    treeCode: `${treeCode}.children;`,\n    rootLayout,\n    globalError,\n    globalNotFound,\n  }\n}\n\nfunction createAbsolutePath(appDir: string, pathToTurnAbsolute: string) {\n  return (\n    pathToTurnAbsolute\n      // Replace all POSIX path separators with the current OS path separator\n      .replace(/\\//g, path.sep)\n      .replace(/^private-next-app-dir/, appDir)\n  )\n}\n\nconst filesInDirMapMap: WeakMap<\n  Compilation,\n  Map<string, Promise<Set<string>>>\n> = new WeakMap()\nconst nextAppLoader: AppLoader = async function nextAppLoader() {\n  // install native bindings early so they are always available.\n  // When run by webpack, next will have already done this, so this will be fast,\n  // but if run by turbopack in a subprocess it is required.  In that case we cannot pass the\n  // `useWasmBinary` flag, but that is ok since turbopack doesn't currently support wasm.\n  await installBindings()\n  const loaderOptions = this.getOptions()\n  const {\n    name,\n    appDir,\n    appPaths,\n    pagePath,\n    pageExtensions,\n    rootDir,\n    tsconfigPath,\n    isDev,\n    nextConfigOutput,\n    preferredRegion,\n    basePath,\n    middlewareConfig: middlewareConfigBase64,\n  } = loaderOptions\n\n  const isGlobalNotFoundEnabled = !!loaderOptions.isGlobalNotFoundEnabled\n\n  // Update FILE_TYPES on the very top-level of the loader\n  if (!isGlobalNotFoundEnabled) {\n    // @ts-expect-error this delete is only necessary while experimental\n    delete FILE_TYPES['global-not-found']\n  }\n\n  const buildInfo = getModuleBuildInfo((this as any)._module)\n  const collectedDeclarations: [string, string][] = []\n\n  // Use the page from loaderOptions directly instead of deriving it from name.\n  // The name (bundlePath) may have been normalized with normalizePagePath()\n  // which is designed for Pages Router and incorrectly duplicates /index paths\n  // (e.g., /index/page -> /index/index/page). The page parameter contains the\n  // correct unnormalized value.\n  const page = loaderOptions.page\n\n  const middlewareConfig: ProxyConfig = JSON.parse(\n    Buffer.from(middlewareConfigBase64, 'base64').toString()\n  )\n  buildInfo.route = {\n    page,\n    absolutePagePath: createAbsolutePath(appDir, pagePath),\n    preferredRegion,\n    middlewareConfig,\n    relatedModules: [],\n  }\n\n  const extensions =\n    typeof pageExtensions === 'string'\n      ? [pageExtensions]\n      : pageExtensions.map((extension) => `.${extension}`)\n\n  const normalizedAppPaths =\n    typeof appPaths === 'string' ? [appPaths] : appPaths || []\n\n  const resolveParallelSegments = (\n    pathname: string\n  ): [string, string | string[]][] => {\n    const matched: Record<string, string | string[]> = {}\n    let existingChildrenPath: string | undefined\n    for (const appPath of normalizedAppPaths) {\n      if (appPath.startsWith(pathname + '/')) {\n        const rest = appPath.slice(pathname.length + 1).split('/')\n\n        // It is the actual page, mark it specially.\n        if (rest.length === 1 && rest[0] === 'page') {\n          existingChildrenPath = appPath\n          matched.children = PAGE_SEGMENT\n          continue\n        }\n\n        const isParallelRoute = rest[0].startsWith('@')\n        if (isParallelRoute) {\n          if (rest.length === 2 && rest[1] === 'page') {\n            // We found a parallel route at this level. We don't want to mark it explicitly as the page segment,\n            // as that should be matched to the `children` slot. Instead, we use an array, to signal to `createSubtreePropsFromSegmentPath`\n            // that it needs to recursively fill in the loader tree code for the parallel route at the appropriate levels.\n            matched[rest[0]] = [PAGE_SEGMENT]\n            continue\n          }\n          // If it was a parallel route but we weren't able to find the page segment (ie, maybe the page is nested further)\n          // we first insert a special marker to ensure that we still process layout/default/etc at the slot level prior to continuing\n          // on to the page segment.\n          matched[rest[0]] = [PARALLEL_VIRTUAL_SEGMENT, ...rest.slice(1)]\n          continue\n        }\n\n        if (existingChildrenPath && matched.children !== rest[0]) {\n          // If we get here, it means we already set a `page` segment earlier in the loop,\n          // meaning we already matched a page to the `children` parallel segment.\n          const isIncomingParallelPage = appPath.includes('@')\n          const hasCurrentParallelPage = existingChildrenPath.includes('@')\n\n          if (isIncomingParallelPage) {\n            // The duplicate segment was for a parallel slot. In this case,\n            // rather than throwing an error, we can ignore it since this can happen for valid reasons.\n            // For example, when we attempt to normalize catch-all routes, we'll push potential slot matches so\n            // that they are available in the loader tree when we go to render the page.\n            // We only need to throw an error if the duplicate segment was for a regular page.\n            // For example, /app/(groupa)/page & /app/(groupb)/page is an error since it corresponds\n            // with the same path.\n            continue\n          } else if (!hasCurrentParallelPage && !isIncomingParallelPage) {\n            // Both the current `children` and the incoming `children` are regular pages.\n            throw new Error(\n              `You cannot have two parallel pages that resolve to the same path. Please check ${existingChildrenPath} and ${appPath}. Refer to the route group docs for more information: https://nextjs.org/docs/app/building-your-application/routing/route-groups`\n            )\n          }\n        }\n\n        existingChildrenPath = appPath\n        matched.children = rest[0]\n      }\n    }\n\n    return Object.entries(matched)\n  }\n\n  const hasChildRoutesForSegment = (segmentPath: string): boolean => {\n    const pathPrefix = segmentPath ? `${segmentPath}/` : ''\n\n    for (const appPath of normalizedAppPaths) {\n      if (appPath.startsWith(pathPrefix)) {\n        const rest = appPath.slice(pathPrefix.length).split('/')\n\n        // Filter out route groups to get the actual route segments\n        // Route groups (e.g., \"(group)\") don't contribute to the URL path\n        const routeSegments = rest.filter((segment) => !isGroupSegment(segment))\n\n        // If it's just 'page' at this level, skip (not a child route)\n        if (routeSegments.length === 1 && routeSegments[0] === 'page') {\n          continue\n        }\n\n        // If the first segment (after filtering route groups) is a parallel route, skip\n        if (routeSegments[0]?.startsWith('@')) {\n          continue\n        }\n\n        // If we have more than just 'page', then there are child routes\n        // Examples:\n        //   ['child', 'page'] -> true (has child route)\n        //   ['page'] -> false (already filtered above)\n        //   ['grandchild', 'deeper', 'page'] -> true (has nested child routes)\n        if (\n          routeSegments.length > 1 ||\n          (routeSegments.length === 1 && routeSegments[0] !== 'page')\n        ) {\n          return true\n        }\n      }\n    }\n\n    return false\n  }\n\n  const resolveDir: DirResolver = (pathToResolve) => {\n    return createAbsolutePath(appDir, pathToResolve)\n  }\n\n  const resolveAppRoute: PathResolver = (pathToResolve) => {\n    return createAbsolutePath(appDir, pathToResolve)\n  }\n\n  // Cached checker to see if a file exists in a given directory.\n  // This can be more efficient than checking them with `fs.stat` one by one\n  // because all the thousands of files are likely in a few possible directories.\n  // Note that it should only be cached for this compilation, not globally.\n  const fileExistsInDirectory = async (dirname: string, fileName: string) => {\n    // I don't think we should ever hit this code path, but if we do we should handle it gracefully.\n    if (this._compilation === undefined) {\n      try {\n        return (await getFilesInDir(dirname).catch(() => new Set())).has(\n          fileName\n        )\n      } catch (e) {\n        return false\n      }\n    }\n    const map =\n      filesInDirMapMap.get(this._compilation) ||\n      new Map<string, Promise<Set<string>>>()\n    if (!filesInDirMapMap.has(this._compilation)) {\n      filesInDirMapMap.set(this._compilation, map)\n    }\n    if (!map.has(dirname)) {\n      map.set(\n        dirname,\n        getFilesInDir(dirname).catch(() => new Set())\n      )\n    }\n    return ((await map.get(dirname)) || new Set()).has(fileName)\n  }\n\n  const resolver: PathResolver = async (pathname) => {\n    const absolutePath = createAbsolutePath(appDir, pathname)\n\n    const filenameIndex = absolutePath.lastIndexOf(path.sep)\n    const dirname = absolutePath.slice(0, filenameIndex)\n    const filename = absolutePath.slice(filenameIndex + 1)\n\n    let result: string | undefined\n\n    for (const ext of extensions) {\n      const absolutePathWithExtension = `${absolutePath}${ext}`\n      if (\n        !result &&\n        (await fileExistsInDirectory(dirname, `${filename}${ext}`))\n      ) {\n        result = absolutePathWithExtension\n      }\n      // Call `addMissingDependency` for all files even if they didn't match,\n      // because they might be added or removed during development.\n      this.addMissingDependency(absolutePathWithExtension)\n    }\n\n    return result\n  }\n\n  const metadataResolver: MetadataResolver = async (\n    dirname,\n    filename,\n    exts\n  ) => {\n    const absoluteDir = createAbsolutePath(appDir, dirname)\n\n    let result: string | undefined\n\n    for (const ext of exts) {\n      // Compared to `resolver` above the exts do not have the `.` included already, so it's added here.\n      const filenameWithExt = `${filename}.${ext}`\n      const absolutePathWithExtension = `${absoluteDir}${path.sep}${filenameWithExt}`\n      if (!result && (await fileExistsInDirectory(dirname, filenameWithExt))) {\n        result = absolutePathWithExtension\n      }\n      // Call `addMissingDependency` for all files even if they didn't match,\n      // because they might be added or removed during development.\n      this.addMissingDependency(absolutePathWithExtension)\n    }\n\n    return result\n  }\n\n  if (isAppRouteRoute(name)) {\n    return createAppRouteCode({\n      appDir,\n      // TODO: investigate if the local `page` is the same as the loaderOptions.page\n      page: loaderOptions.page,\n      name,\n      pagePath,\n      resolveAppRoute,\n      pageExtensions,\n      nextConfigOutput,\n    })\n  }\n\n  let treeCodeResult = await createTreeCodeFromPath(pagePath, {\n    page,\n    resolveDir,\n    resolver,\n    metadataResolver,\n    resolveParallelSegments,\n    hasChildRoutesForSegment,\n    loaderContext: this,\n    pageExtensions,\n    basePath,\n    collectedDeclarations,\n    isGlobalNotFoundEnabled,\n  })\n\n  const isGlobalNotFoundPath =\n    page === UNDERSCORE_NOT_FOUND_ROUTE_ENTRY &&\n    !!treeCodeResult.globalNotFound &&\n    isGlobalNotFoundEnabled\n\n  const isAppErrorRoute = page === UNDERSCORE_GLOBAL_ERROR_ROUTE_ENTRY\n\n  if (!treeCodeResult.rootLayout && !isGlobalNotFoundPath && !isAppErrorRoute) {\n    if (!isDev) {\n      // If we're building and missing a root layout, exit the build\n      Log.error(\n        `${bold(\n          pagePath.replace(`${APP_DIR_ALIAS}/`, '')\n        )} doesn't have a root layout. To fix this error, make sure every page has a root layout.`\n      )\n      process.exit(1)\n    } else {\n      // In dev we'll try to create a root layout\n      const [createdRootLayout, rootLayoutPath] = await verifyRootLayout({\n        appDir: appDir,\n        dir: rootDir!,\n        tsconfigPath: tsconfigPath,\n        pagePath,\n        pageExtensions,\n      })\n      if (!createdRootLayout) {\n        let message = `${bold(\n          pagePath.replace(`${APP_DIR_ALIAS}/`, '')\n        )} doesn't have a root layout. `\n\n        if (rootLayoutPath) {\n          message += `We tried to create ${bold(\n            path.relative(this._compiler?.context ?? '', rootLayoutPath)\n          )} for you but something went wrong.`\n        } else {\n          message +=\n            'To fix this error, make sure every page has a root layout.'\n        }\n\n        throw new Error(message)\n      }\n\n      // Clear fs cache, get the new result with the created root layout.\n      if (this._compilation) filesInDirMapMap.get(this._compilation)?.clear()\n      treeCodeResult = await createTreeCodeFromPath(pagePath, {\n        page,\n        resolveDir,\n        resolver,\n        metadataResolver,\n        resolveParallelSegments,\n        hasChildRoutesForSegment,\n        loaderContext: this,\n        pageExtensions,\n        basePath,\n        collectedDeclarations,\n        isGlobalNotFoundEnabled,\n      })\n    }\n  }\n\n  const pathname = new AppPathnameNormalizer().normalize(page)\n\n  // Prefer to modify next/src/server/app-render/entry-base.ts since this is shared with Turbopack.\n  // Any changes to this code should be reflected in Turbopack's app_source.rs and/or app-renderer.tsx as well.\n  const code = await loadEntrypoint(\n    'app-page',\n    {\n      VAR_DEFINITION_PAGE: page,\n      VAR_DEFINITION_PATHNAME: pathname,\n      VAR_MODULE_GLOBAL_ERROR: treeCodeResult.globalError,\n    },\n    {\n      tree: treeCodeResult.treeCode,\n      __next_app_require__: '__webpack_require__',\n      // all modules are in the entry chunk, so we never actually need to load chunks in webpack\n      __next_app_load_chunk__: '() => Promise.resolve()',\n    }\n  )\n\n  // Lazily evaluate the imported modules in the generated code\n  const header = collectedDeclarations\n    .map(([varName, modulePath]) => {\n      return `const ${varName} = () => import(/* webpackMode: \"eager\" */ ${JSON.stringify(\n        modulePath\n      )});\\n`\n    })\n    .join('')\n\n  return header + code\n}\n\nexport default nextAppLoader\n"],"names":["UNDERSCORE_GLOBAL_ERROR_ROUTE","UNDERSCORE_NOT_FOUND_ROUTE","UNDERSCORE_GLOBAL_ERROR_ROUTE_ENTRY","UNDERSCORE_NOT_FOUND_ROUTE_ENTRY","path","bold","getModuleBuildInfo","verifyRootLayout","Log","APP_DIR_ALIAS","createMetadataExportsCode","createStaticMetadataFromRoute","promises","fs","isAppRouteRoute","AppPathnameNormalizer","isAppBuiltinPage","loadEntrypoint","isGroupSegment","DEFAULT_SEGMENT_KEY","PAGE_SEGMENT_KEY","getFilesInDir","PARALLEL_ROUTE_DEFAULT_PATH","PARALLEL_ROUTE_DEFAULT_NULL_PATH","createAppRouteCode","MissingDefaultParallelRouteError","isInterceptionRouteAppPath","normalizePathSep","installBindings","HTTP_ACCESS_FALLBACKS","forbidden","unauthorized","defaultHTTPAccessFallbackPaths","FILE_TYPES","layout","template","error","loading","GLOBAL_ERROR_FILE_TYPE","GLOBAL_NOT_FOUND_FILE_TYPE","PAGE_SEGMENT","PARALLEL_VIRTUAL_SEGMENT","defaultGlobalErrorPath","defaultNotFoundPath","defaultEmptyStubPath","defaultLayoutPath","defaultGlobalNotFoundPath","appErrorPath","normalizeParallelKey","key","startsWith","slice","isCatchAllSegment","segment","isDirectory","pathname","stat","err","createTreeCodeFromPath","pagePath","page","resolveDir","resolver","resolveParallelSegments","hasChildRoutesForSegment","metadataResolver","pageExtensions","basePath","collectedDeclarations","isGlobalNotFoundEnabled","splittedPath","split","isNotFoundRoute","isAppErrorRoute","isDefaultNotFound","appDirPrefix","rootLayout","globalError","globalNotFound","resolveAdjacentParallelSegments","segmentPath","absoluteSegmentPath","segmentIsDirectory","files","opendir","parallelSegments","dirent","name","charCodeAt","push","createSubtreePropsFromSegmentPath","segments","nestedCollectedDeclarations","join","props","isRootLayer","length","isRootLayoutOrRootPage","metadata","routerDirPath","resolvedRouteDir","endsWith","parallelKey","parallelSegment","matchedPagePath","resolvedPagePath","varName","JSON","stringify","Error","subSegmentPath","normalizedParallelSegment","Array","isArray","parallelSegmentPath","filePathEntries","Promise","all","Object","values","map","file","filePaths","Map","resolvedGlobalErrorPath","set","resolvedGlobalNotFoundPath","definedFilePaths","from","entries","filter","filePath","undefined","existedConventionNames","Set","type","isFirstLayerGroupRoute","seg","accessFallbackTypes","keys","hasRootFallbackFile","hasLayerFallbackFile","has","defaultFallbackPath","layoutPath","find","parallelSegmentKey","normalizedParallelKey","subtreeCode","matchedGlobalNotFound","layoutName","notFoundPath","modulesCode","treeCode","pageSubtreeCode","adjacentParallelSegments","adjacentParallelSegment","actualSegment","fullSegmentPath","defaultPath","isInsideCatchAll","some","isLeafSegment","userFacingPath","replace","value","createAbsolutePath","appDir","pathToTurnAbsolute","sep","filesInDirMapMap","WeakMap","nextAppLoader","loaderOptions","getOptions","appPaths","rootDir","tsconfigPath","isDev","nextConfigOutput","preferredRegion","middlewareConfig","middlewareConfigBase64","buildInfo","_module","parse","Buffer","toString","route","absolutePagePath","relatedModules","extensions","extension","normalizedAppPaths","matched","existingChildrenPath","appPath","rest","children","isParallelRoute","isIncomingParallelPage","includes","hasCurrentParallelPage","pathPrefix","routeSegments","pathToResolve","resolveAppRoute","fileExistsInDirectory","dirname","fileName","_compilation","catch","e","get","absolutePath","filenameIndex","lastIndexOf","filename","result","ext","absolutePathWithExtension","addMissingDependency","exts","absoluteDir","filenameWithExt","treeCodeResult","loaderContext","isGlobalNotFoundPath","process","exit","createdRootLayout","rootLayoutPath","dir","message","relative","_compiler","context","clear","normalize","code","VAR_DEFINITION_PAGE","VAR_DEFINITION_PATHNAME","VAR_MODULE_GLOBAL_ERROR","tree","__next_app_require__","__next_app_load_chunk__","header","modulePath"],"mappings":"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","ignoreList":[0]}