{"version":3,"file":"update.js","names":["table: TTable","session: PgSession","dialect: PgDialect","withList?: Subquery[]","builder: PgUpdateBuilderConstructor","tableName"],"sources":["../../../src/pg-core/query-builders/update.ts"],"sourcesContent":["import type { WithCacheConfig } from '~/cache/core/types.ts';\nimport type { GetColumnData } from '~/column.ts';\nimport { entityKind, is } from '~/entity.ts';\nimport type { PgDialect } from '~/pg-core/dialect.ts';\nimport type { PgQueryResultHKT, PgQueryResultKind, PgSession } from '~/pg-core/session.ts';\nimport { PgTable } from '~/pg-core/table.ts';\nimport type { TypedQueryBuilder } from '~/query-builders/query-builder.ts';\nimport type {\n\tAppendToNullabilityMap,\n\tAppendToResult,\n\tGetSelectTableName,\n\tGetSelectTableSelection,\n\tJoinNullability,\n\tJoinType,\n\tSelectMode,\n\tSelectResult,\n} from '~/query-builders/select.types.ts';\nimport { SelectionProxyHandler } from '~/selection-proxy.ts';\nimport { type ColumnsSelection, type Placeholder, type Query, SQL, type SQLWrapper } from '~/sql/sql.ts';\nimport { Subquery } from '~/subquery.ts';\nimport { getTableName, type InferInsertModel, Table } from '~/table.ts';\nimport {\n\ttype Assume,\n\ttype DrizzleTypeError,\n\ttype Equal,\n\tgetTableLikeName,\n\tmapUpdateSet,\n\ttype NeonAuthToken,\n\torderSelectedFields,\n\ttype Simplify,\n\ttype UpdateSet,\n} from '~/utils.ts';\nimport { ViewBaseConfig } from '~/view-common.ts';\nimport type { PgColumn } from '../columns/common.ts';\nimport type { PgViewBase } from '../view-base.ts';\nimport type {\n\tPgSelectJoinConfig,\n\tSelectedFields,\n\tSelectedFieldsOrdered,\n\tTableLikeHasEmptySelection,\n} from './select.types.ts';\n\nexport interface PgUpdateConfig {\n\twhere?: SQL | undefined;\n\tset: UpdateSet;\n\ttable: PgTable;\n\tfrom?: PgTable | Subquery | PgViewBase | SQL;\n\tjoins: PgSelectJoinConfig[];\n\treturningFields?: SelectedFields;\n\treturning?: SelectedFieldsOrdered;\n\twithList?: Subquery[];\n}\n\nexport type PgUpdateSetSource<\n\tTTable extends PgTable,\n\tTModel extends Record<string, any> = InferInsertModel<TTable>,\n> =\n\t& {\n\t\t[Key in keyof TModel & string]?:\n\t\t\t| GetColumnData<TTable['_']['columns'][Key]>\n\t\t\t| SQL\n\t\t\t| PgColumn\n\t\t\t| Placeholder\n\t\t\t| undefined;\n\t}\n\t& {};\n\nexport interface PgUpdateBuilderConstructor {\n\tnew(\n\t\ttable: PgTable,\n\t\tset: UpdateSet,\n\t\tsession: PgSession,\n\t\tdialect: PgDialect,\n\t\twithList?: Subquery[],\n\t): AnyPgUpdate;\n}\n\nexport class PgUpdateBuilder<\n\tTTable extends PgTable,\n\tTQueryResult extends PgQueryResultHKT,\n\tTBuilderHKT extends PgUpdateHKTBase = PgUpdateHKT,\n> {\n\tstatic readonly [entityKind]: string = 'PgUpdateBuilder';\n\n\tdeclare readonly _: {\n\t\treadonly table: TTable;\n\t};\n\n\tconstructor(\n\t\tprivate table: TTable,\n\t\tprivate session: PgSession,\n\t\tprivate dialect: PgDialect,\n\t\tprivate withList?: Subquery[],\n\t\tprivate builder: PgUpdateBuilderConstructor = PgUpdateBase,\n\t) {}\n\n\t/** @internal */\n\tprivate authToken?: NeonAuthToken;\n\t/** @internal */\n\tsetToken(token?: NeonAuthToken) {\n\t\tthis.authToken = token;\n\t\treturn this;\n\t}\n\n\tset(\n\t\tvalues: PgUpdateSetSource<TTable>,\n\t): PgUpdateWithout<\n\t\tAssume<PgUpdateKind<TBuilderHKT, TTable, TQueryResult>, AnyPgUpdate>,\n\t\tfalse,\n\t\t'leftJoin' | 'rightJoin' | 'innerJoin' | 'fullJoin'\n\t> {\n\t\tconst builder = new this.builder(\n\t\t\tthis.table,\n\t\t\tmapUpdateSet(this.table, values),\n\t\t\tthis.session,\n\t\t\tthis.dialect,\n\t\t\tthis.withList,\n\t\t) as AnyPgUpdate;\n\n\t\tif ('setToken' in builder) {\n\t\t\t(builder.setToken as (authToken?: NeonAuthToken) => typeof builder)(this.authToken);\n\t\t}\n\n\t\treturn builder as any;\n\t}\n}\n\nexport type PgUpdateWithout<\n\tT extends AnyPgUpdate,\n\tTDynamic extends boolean,\n\tK extends keyof T & string,\n> = TDynamic extends true ? T : Omit<\n\tPgUpdateKind<\n\t\tT['_']['hkt'],\n\t\tT['_']['table'],\n\t\tT['_']['queryResult'],\n\t\tT['_']['from'],\n\t\tT['_']['selectedFields'],\n\t\tT['_']['returning'],\n\t\tT['_']['nullabilityMap'],\n\t\tT['_']['joins'],\n\t\tTDynamic,\n\t\tT['_']['excludedMethods'] | K\n\t>,\n\tT['_']['excludedMethods'] | K\n>;\n\nexport type PgUpdateWithJoins<\n\tT extends AnyPgUpdate,\n\tTDynamic extends boolean,\n\tTFrom extends PgTable | Subquery | PgViewBase | SQL,\n> = Omit<\n\tPgUpdateKind<\n\t\tT['_']['hkt'],\n\t\tT['_']['table'],\n\t\tT['_']['queryResult'],\n\t\tTFrom,\n\t\tT['_']['selectedFields'],\n\t\tT['_']['returning'],\n\t\tAppendToNullabilityMap<T['_']['nullabilityMap'], GetSelectTableName<TFrom>, 'inner'>,\n\t\t[...T['_']['joins'], {\n\t\t\tname: GetSelectTableName<TFrom>;\n\t\t\tjoinType: 'inner';\n\t\t\ttable: TFrom;\n\t\t}],\n\t\tTDynamic,\n\t\tTDynamic extends true ? never\n\t\t\t: Exclude<T['_']['excludedMethods'] | 'from', 'leftJoin' | 'rightJoin' | 'innerJoin' | 'fullJoin'>\n\t>,\n\tTDynamic extends true ? never\n\t\t: Exclude<T['_']['excludedMethods'] | 'from', 'leftJoin' | 'rightJoin' | 'innerJoin' | 'fullJoin'>\n>;\n\nexport type PgUpdateJoinFn<\n\tT extends AnyPgUpdate,\n\tTDynamic extends boolean,\n\tTJoinType extends JoinType,\n> = <\n\tTJoinedTable extends PgTable | Subquery | PgViewBase | SQL,\n>(\n\ttable: TableLikeHasEmptySelection<TJoinedTable> extends true ? DrizzleTypeError<\n\t\t\t\"Cannot reference a data-modifying statement subquery if it doesn't contain a `returning` clause\"\n\t\t>\n\t\t: TJoinedTable,\n\ton:\n\t\t| (\n\t\t\t(\n\t\t\t\tupdateTable: T['_']['table']['_']['columns'],\n\t\t\t\tfrom: T['_']['from'] extends PgTable ? T['_']['from']['_']['columns']\n\t\t\t\t\t: T['_']['from'] extends Subquery | PgViewBase ? T['_']['from']['_']['selectedFields']\n\t\t\t\t\t: never,\n\t\t\t) => SQL | undefined\n\t\t)\n\t\t| SQL\n\t\t| undefined,\n) => PgUpdateJoin<T, TDynamic, TJoinType, TJoinedTable>;\n\nexport type PgUpdateJoin<\n\tT extends AnyPgUpdate,\n\tTDynamic extends boolean,\n\tTJoinType extends JoinType,\n\tTJoinedTable extends PgTable | Subquery | PgViewBase | SQL,\n> = Omit<\n\tPgUpdateKind<\n\t\tT['_']['hkt'],\n\t\tT['_']['table'],\n\t\tT['_']['queryResult'],\n\t\tT['_']['from'],\n\t\tT['_']['selectedFields'],\n\t\tT['_']['returning'],\n\t\tAppendToNullabilityMap<T['_']['nullabilityMap'], GetSelectTableName<TJoinedTable>, TJoinType>,\n\t\t[...T['_']['joins'], {\n\t\t\tname: GetSelectTableName<TJoinedTable>;\n\t\t\tjoinType: TJoinType;\n\t\t\ttable: TJoinedTable;\n\t\t}],\n\t\tTDynamic,\n\t\tTDynamic extends true ? never : T['_']['excludedMethods']\n\t>,\n\tTDynamic extends true ? never : T['_']['excludedMethods']\n>;\n\nexport type Join = {\n\tname: string | undefined;\n\tjoinType: JoinType;\n\ttable: PgTable | Subquery | PgViewBase | SQL;\n};\n\ntype AccumulateToResult<\n\tT extends AnyPgUpdate,\n\tTSelectMode extends SelectMode,\n\tTJoins extends Join[],\n\tTSelectedFields extends ColumnsSelection,\n> = TJoins extends [infer TJoin extends Join, ...infer TRest extends Join[]] ? AccumulateToResult<\n\t\tT,\n\t\tTSelectMode extends 'partial' ? TSelectMode : 'multiple',\n\t\tTRest,\n\t\tAppendToResult<\n\t\t\tT['_']['table']['_']['name'],\n\t\t\tTSelectedFields,\n\t\t\tTJoin['name'],\n\t\t\tTJoin['table'] extends Table ? TJoin['table']['_']['columns']\n\t\t\t\t: TJoin['table'] extends Subquery ? Assume<TJoin['table']['_']['selectedFields'], SelectedFields>\n\t\t\t\t: never,\n\t\t\tTSelectMode extends 'partial' ? TSelectMode : 'multiple'\n\t\t>\n\t>\n\t: TSelectedFields;\n\nexport type PgUpdateReturningAll<T extends AnyPgUpdate, TDynamic extends boolean> = T extends any ? PgUpdateWithout<\n\t\tPgUpdateKind<\n\t\t\tT['_']['hkt'],\n\t\t\tT['_']['table'],\n\t\t\tT['_']['queryResult'],\n\t\t\tT['_']['from'],\n\t\t\tEqual<T['_']['joins'], []> extends true ? T['_']['table']['_']['columns'] : Simplify<\n\t\t\t\t& Record<T['_']['table']['_']['name'], T['_']['table']['_']['columns']>\n\t\t\t\t& {\n\t\t\t\t\t[K in keyof T['_']['joins'] as T['_']['joins'][K]['table']['_']['name']]:\n\t\t\t\t\t\tT['_']['joins'][K]['table']['_']['columns'];\n\t\t\t\t}\n\t\t\t>,\n\t\t\tSelectResult<\n\t\t\t\tAccumulateToResult<\n\t\t\t\t\tT,\n\t\t\t\t\t'single',\n\t\t\t\t\tT['_']['joins'],\n\t\t\t\t\tGetSelectTableSelection<T['_']['table']>\n\t\t\t\t>,\n\t\t\t\t'partial',\n\t\t\t\tT['_']['nullabilityMap']\n\t\t\t>,\n\t\t\tT['_']['nullabilityMap'],\n\t\t\tT['_']['joins'],\n\t\t\tTDynamic,\n\t\t\tT['_']['excludedMethods']\n\t\t>,\n\t\tTDynamic,\n\t\t'returning'\n\t>\n\t: never;\n\nexport type PgUpdateReturning<\n\tT extends AnyPgUpdate,\n\tTDynamic extends boolean,\n\tTSelectedFields extends SelectedFields,\n> = T extends any ? PgUpdateWithout<\n\t\tPgUpdateKind<\n\t\t\tT['_']['hkt'],\n\t\t\tT['_']['table'],\n\t\t\tT['_']['queryResult'],\n\t\t\tT['_']['from'],\n\t\t\tTSelectedFields,\n\t\t\tSelectResult<\n\t\t\t\tAccumulateToResult<\n\t\t\t\t\tT,\n\t\t\t\t\t'partial',\n\t\t\t\t\tT['_']['joins'],\n\t\t\t\t\tTSelectedFields\n\t\t\t\t>,\n\t\t\t\t'partial',\n\t\t\t\tT['_']['nullabilityMap']\n\t\t\t>,\n\t\t\tT['_']['nullabilityMap'],\n\t\t\tT['_']['joins'],\n\t\t\tTDynamic,\n\t\t\tT['_']['excludedMethods']\n\t\t>,\n\t\tTDynamic,\n\t\t'returning'\n\t>\n\t: never;\n\nexport type PgUpdateDynamic<T extends AnyPgUpdate> = PgUpdateKind<\n\tT['_']['hkt'],\n\tT['_']['table'],\n\tT['_']['queryResult'],\n\tT['_']['from'],\n\tT['_']['selectedFields'],\n\tT['_']['returning'],\n\tT['_']['nullabilityMap'],\n\tT['_']['joins'],\n\ttrue,\n\tnever\n>;\n\nexport type PgUpdate<\n\tTTable extends PgTable = PgTable,\n\tTQueryResult extends PgQueryResultHKT = PgQueryResultHKT,\n\tTFrom extends PgTable | Subquery | PgViewBase | SQL | undefined = undefined,\n\tTSelectedFields extends ColumnsSelection | undefined = undefined,\n\tTReturning extends Record<string, unknown> | undefined = Record<string, unknown> | undefined,\n\tTNullabilityMap extends Record<string, JoinNullability> = Record<TTable['_']['name'], 'not-null'>,\n\tTJoins extends Join[] = [],\n> = PgUpdateBase<\n\tPgUpdateHKT,\n\tTTable,\n\tTQueryResult,\n\tTFrom,\n\tTSelectedFields,\n\tTReturning,\n\tTNullabilityMap,\n\tTJoins,\n\ttrue,\n\tnever\n>;\n\nexport interface PgUpdateHKTBase {\n\ttable: unknown;\n\tjoins: unknown;\n\tnullabilityMap: unknown;\n\tqueryResult: unknown;\n\tfrom: unknown;\n\tselectedFields: unknown;\n\treturning: unknown;\n\tdynamic: boolean;\n\texcludedMethods: string;\n\t_type: unknown;\n}\n\nexport interface PgUpdateHKT extends PgUpdateHKTBase {\n\t_type: PgUpdateBase<\n\t\tPgUpdateHKT,\n\t\tAssume<this['table'], PgTable>,\n\t\tAssume<this['queryResult'], PgQueryResultHKT>,\n\t\tAssume<this['from'], PgTable | Subquery | PgViewBase | SQL | undefined>,\n\t\tAssume<this['selectedFields'], ColumnsSelection | undefined>,\n\t\tAssume<this['returning'], Record<string, unknown> | undefined>,\n\t\tAssume<this['nullabilityMap'], Record<string, JoinNullability>>,\n\t\tAssume<this['joins'], Join[]>,\n\t\tthis['dynamic'],\n\t\tthis['excludedMethods']\n\t>;\n}\n\nexport type PgUpdateKind<\n\tT extends PgUpdateHKTBase,\n\tTTable extends PgTable,\n\tTQueryResult extends PgQueryResultHKT,\n\tTFrom extends PgTable | Subquery | PgViewBase | SQL | undefined = undefined,\n\tTSelectedFields extends ColumnsSelection | undefined = undefined,\n\tTReturning extends Record<string, unknown> | undefined = undefined,\n\tTNullabilityMap extends Record<string, JoinNullability> = Record<TTable['_']['name'], 'not-null'>,\n\tTJoins extends Join[] = [],\n\tTDynamic extends boolean = false,\n\tTExcludedMethods extends string = never,\n> = (T & {\n\ttable: TTable;\n\tjoins: TJoins;\n\tnullabilityMap: TNullabilityMap;\n\tqueryResult: TQueryResult;\n\tfrom: TFrom;\n\tselectedFields: TSelectedFields;\n\treturning: TReturning;\n\tdynamic: TDynamic;\n\texcludedMethods: TExcludedMethods;\n\tresult: TReturning extends undefined ? PgQueryResultKind<TQueryResult, never> : TReturning[];\n})['_type'];\n\nexport type AnyPgUpdate = PgUpdateBase<any, any, any, any, any, any, any, any, any, any>;\n\nexport interface PgUpdateBase<\n\tTHKT extends PgUpdateHKTBase,\n\tTTable extends PgTable,\n\tTQueryResult extends PgQueryResultHKT,\n\tTFrom extends PgTable | Subquery | PgViewBase | SQL | undefined = undefined,\n\tTSelectedFields extends ColumnsSelection | undefined = undefined,\n\tTReturning extends Record<string, unknown> | undefined = undefined,\n\tTNullabilityMap extends Record<string, JoinNullability> = Record<TTable['_']['name'], 'not-null'>,\n\tTJoins extends Join[] = [],\n\tTDynamic extends boolean = false,\n\tTExcludedMethods extends string = never,\n> extends\n\tTypedQueryBuilder<\n\t\tTSelectedFields,\n\t\tTReturning extends undefined ? PgQueryResultKind<TQueryResult, never> : TReturning[]\n\t>,\n\tSQLWrapper\n{\n\treadonly _: {\n\t\treadonly dialect: 'pg';\n\t\treadonly hkt: THKT;\n\t\treadonly table: TTable;\n\t\treadonly joins: TJoins;\n\t\treadonly nullabilityMap: TNullabilityMap;\n\t\treadonly queryResult: TQueryResult;\n\t\treadonly from: TFrom;\n\t\treadonly selectedFields: TSelectedFields;\n\t\treadonly returning: TReturning;\n\t\treadonly dynamic: TDynamic;\n\t\treadonly excludedMethods: TExcludedMethods;\n\t\treadonly result: TReturning extends undefined ? PgQueryResultKind<TQueryResult, never> : TReturning[];\n\t};\n}\n\nexport class PgUpdateBase<\n\t// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\tTHKT extends PgUpdateHKTBase,\n\tTTable extends PgTable,\n\t// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\tTQueryResult extends PgQueryResultHKT,\n\tTFrom extends PgTable | Subquery | PgViewBase | SQL | undefined = undefined,\n\t// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\tTSelectedFields extends ColumnsSelection | undefined = undefined,\n\t// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\tTReturning extends Record<string, unknown> | undefined = undefined,\n\t// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\tTNullabilityMap extends Record<string, JoinNullability> = Record<TTable['_']['name'], 'not-null'>,\n\t// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\tTJoins extends Join[] = [],\n\t// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\tTDynamic extends boolean = false,\n\t// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\tTExcludedMethods extends string = never,\n> implements SQLWrapper {\n\tstatic readonly [entityKind]: string = 'PgUpdate';\n\n\tprotected config: PgUpdateConfig;\n\tprotected tableName: string | undefined;\n\tprotected joinsNotNullableMap: Record<string, boolean>;\n\tprotected cacheConfig?: WithCacheConfig;\n\n\tconstructor(\n\t\ttable: TTable,\n\t\tset: UpdateSet,\n\t\tprotected session: PgSession,\n\t\tprotected dialect: PgDialect,\n\t\twithList?: Subquery[],\n\t) {\n\t\tthis.config = { set, table, withList, joins: [] };\n\t\tthis.tableName = getTableLikeName(table);\n\t\tthis.joinsNotNullableMap = typeof this.tableName === 'string' ? { [this.tableName]: true } : {};\n\t}\n\n\tfrom<TFrom extends PgTable | Subquery | PgViewBase | SQL>(\n\t\tsource: TableLikeHasEmptySelection<TFrom> extends true ? DrizzleTypeError<\n\t\t\t\t\"Cannot reference a data-modifying statement subquery if it doesn't contain a `returning` clause\"\n\t\t\t>\n\t\t\t: TFrom,\n\t): PgUpdateWithJoins<this, TDynamic, TFrom> {\n\t\tconst src = source as TFrom;\n\t\tconst tableName = getTableLikeName(src);\n\t\tif (typeof tableName === 'string') {\n\t\t\tthis.joinsNotNullableMap[tableName] = true;\n\t\t}\n\t\tthis.config.from = src;\n\t\treturn this as any;\n\t}\n\n\tprivate getTableLikeFields(table: PgTable | Subquery | PgViewBase): Record<string, unknown> {\n\t\tif (is(table, PgTable)) {\n\t\t\treturn table[Table.Symbol.Columns];\n\t\t} else if (is(table, Subquery)) {\n\t\t\treturn table._.selectedFields;\n\t\t}\n\t\treturn table[ViewBaseConfig].selectedFields;\n\t}\n\n\tprivate createJoin<TJoinType extends JoinType>(\n\t\tjoinType: TJoinType,\n\t): PgUpdateJoinFn<this, TDynamic, TJoinType> {\n\t\treturn ((\n\t\t\ttable: PgTable | Subquery | PgViewBase | SQL,\n\t\t\ton: ((updateTable: TTable, from: TFrom) => SQL | undefined) | SQL | undefined,\n\t\t) => {\n\t\t\tconst tableName = getTableLikeName(table);\n\n\t\t\tif (typeof tableName === 'string' && this.config.joins.some((join) => join.alias === tableName)) {\n\t\t\t\tthrow new Error(`Alias \"${tableName}\" is already used in this query`);\n\t\t\t}\n\n\t\t\tif (typeof on === 'function') {\n\t\t\t\tconst from = this.config.from && !is(this.config.from, SQL)\n\t\t\t\t\t? this.getTableLikeFields(this.config.from)\n\t\t\t\t\t: undefined;\n\t\t\t\ton = on(\n\t\t\t\t\tnew Proxy(\n\t\t\t\t\t\tthis.config.table[Table.Symbol.Columns],\n\t\t\t\t\t\tnew SelectionProxyHandler({ sqlAliasedBehavior: 'sql', sqlBehavior: 'sql' }),\n\t\t\t\t\t) as any,\n\t\t\t\t\tfrom && new Proxy(\n\t\t\t\t\t\tfrom,\n\t\t\t\t\t\tnew SelectionProxyHandler({ sqlAliasedBehavior: 'sql', sqlBehavior: 'sql' }),\n\t\t\t\t\t) as any,\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tthis.config.joins.push({ on, table, joinType, alias: tableName });\n\n\t\t\tif (typeof tableName === 'string') {\n\t\t\t\tswitch (joinType) {\n\t\t\t\t\tcase 'left': {\n\t\t\t\t\t\tthis.joinsNotNullableMap[tableName] = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcase 'right': {\n\t\t\t\t\t\tthis.joinsNotNullableMap = Object.fromEntries(\n\t\t\t\t\t\t\tObject.entries(this.joinsNotNullableMap).map(([key]) => [key, false]),\n\t\t\t\t\t\t);\n\t\t\t\t\t\tthis.joinsNotNullableMap[tableName] = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcase 'inner': {\n\t\t\t\t\t\tthis.joinsNotNullableMap[tableName] = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcase 'full': {\n\t\t\t\t\t\tthis.joinsNotNullableMap = Object.fromEntries(\n\t\t\t\t\t\t\tObject.entries(this.joinsNotNullableMap).map(([key]) => [key, false]),\n\t\t\t\t\t\t);\n\t\t\t\t\t\tthis.joinsNotNullableMap[tableName] = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn this as any;\n\t\t}) as any;\n\t}\n\n\tleftJoin = this.createJoin('left');\n\n\trightJoin = this.createJoin('right');\n\n\tinnerJoin = this.createJoin('inner');\n\n\tfullJoin = this.createJoin('full');\n\n\t/**\n\t * Adds a 'where' clause to the query.\n\t *\n\t * Calling this method will update only those rows that fulfill a specified condition.\n\t *\n\t * See docs: {@link https://orm.drizzle.team/docs/update}\n\t *\n\t * @param where the 'where' clause.\n\t *\n\t * @example\n\t * You can use conditional operators and `sql function` to filter the rows to be updated.\n\t *\n\t * ```ts\n\t * // Update all cars with green color\n\t * await db.update(cars).set({ color: 'red' })\n\t *   .where(eq(cars.color, 'green'));\n\t * // or\n\t * await db.update(cars).set({ color: 'red' })\n\t *   .where(sql`${cars.color} = 'green'`)\n\t * ```\n\t *\n\t * You can logically combine conditional operators with `and()` and `or()` operators:\n\t *\n\t * ```ts\n\t * // Update all BMW cars with a green color\n\t * await db.update(cars).set({ color: 'red' })\n\t *   .where(and(eq(cars.color, 'green'), eq(cars.brand, 'BMW')));\n\t *\n\t * // Update all cars with the green or blue color\n\t * await db.update(cars).set({ color: 'red' })\n\t *   .where(or(eq(cars.color, 'green'), eq(cars.color, 'blue')));\n\t * ```\n\t */\n\twhere(where: SQL | undefined): PgUpdateWithout<this, TDynamic, 'where'> {\n\t\tthis.config.where = where;\n\t\treturn this as any;\n\t}\n\n\t/**\n\t * Adds a `returning` clause to the query.\n\t *\n\t * Calling this method will return the specified fields of the updated rows. If no fields are specified, all fields will be returned.\n\t *\n\t * See docs: {@link https://orm.drizzle.team/docs/update#update-with-returning}\n\t *\n\t * @example\n\t * ```ts\n\t * // Update all cars with the green color and return all fields\n\t * const updatedCars: Car[] = await db.update(cars)\n\t *   .set({ color: 'red' })\n\t *   .where(eq(cars.color, 'green'))\n\t *   .returning();\n\t *\n\t * // Update all cars with the green color and return only their id and brand fields\n\t * const updatedCarsIdsAndBrands: { id: number, brand: string }[] = await db.update(cars)\n\t *   .set({ color: 'red' })\n\t *   .where(eq(cars.color, 'green'))\n\t *   .returning({ id: cars.id, brand: cars.brand });\n\t * ```\n\t */\n\treturning(): PgUpdateReturningAll<this, TDynamic>;\n\treturning<TSelectedFields extends SelectedFields>(\n\t\tfields: TSelectedFields,\n\t): PgUpdateReturning<this, TDynamic, TSelectedFields>;\n\treturning(\n\t\tfields?: SelectedFields,\n\t): PgUpdateReturningAll<this, TDynamic> | PgUpdateReturning<this, TDynamic, SelectedFields> {\n\t\tif (!fields) {\n\t\t\tfields = Object.assign({}, this.config.table[Table.Symbol.Columns]);\n\n\t\t\tif (this.config.from) {\n\t\t\t\tconst tableName = getTableLikeName(this.config.from);\n\n\t\t\t\tif (typeof tableName === 'string' && this.config.from && !is(this.config.from, SQL)) {\n\t\t\t\t\tconst fromFields = this.getTableLikeFields(this.config.from);\n\t\t\t\t\tfields[tableName] = fromFields as any;\n\t\t\t\t}\n\n\t\t\t\tfor (const join of this.config.joins) {\n\t\t\t\t\tconst tableName = getTableLikeName(join.table);\n\n\t\t\t\t\tif (typeof tableName === 'string' && !is(join.table, SQL)) {\n\t\t\t\t\t\tconst fromFields = this.getTableLikeFields(join.table);\n\t\t\t\t\t\tfields[tableName] = fromFields as any;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthis.config.returningFields = fields;\n\t\tthis.config.returning = orderSelectedFields<PgColumn>(fields);\n\t\treturn this as any;\n\t}\n\n\t/** @internal */\n\tgetSQL(): SQL {\n\t\treturn this.dialect.buildUpdateQuery(this.config);\n\t}\n\n\ttoSQL(): Query {\n\t\tconst { typings: _typings, ...rest } = this.dialect.sqlToQuery(this.getSQL());\n\t\treturn rest;\n\t}\n\n\t/** @internal */\n\tgetSelectedFields(): this['_']['selectedFields'] {\n\t\treturn (\n\t\t\tthis.config.returningFields\n\t\t\t\t? new Proxy(\n\t\t\t\t\tthis.config.returningFields,\n\t\t\t\t\tnew SelectionProxyHandler({\n\t\t\t\t\t\talias: getTableName(this.config.table),\n\t\t\t\t\t\tsqlAliasedBehavior: 'alias',\n\t\t\t\t\t\tsqlBehavior: 'error',\n\t\t\t\t\t}),\n\t\t\t\t)\n\t\t\t\t: undefined\n\t\t) as this['_']['selectedFields'];\n\t}\n\n\t$dynamic(): PgUpdateDynamic<this> {\n\t\treturn this as any;\n\t}\n}\n"],"mappings":"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"}