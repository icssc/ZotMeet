{"version":3,"file":"table.js","names":["parsedColumns: TColumnsMap","name","pgTableInternal: PgTableFnInternal","pgTableWithRLS: PgTableFn['withRLS']","pgTable: PgTableFn","fn: PgTableFnInternal"],"sources":["../../src/pg-core/table.ts"],"sourcesContent":["import { entityKind } from '~/entity.ts';\nimport type { InferModelFromColumns } from '~/table.ts';\nimport { Table, type TableConfig as TableConfigBase, type UpdateTableConfig } from '~/table.ts';\nimport type { CheckBuilder } from './checks.ts';\nimport { getPgColumnBuilders, type PgColumnsBuilders } from './columns/all.ts';\nimport type {\n\tAnyPgColumnBuilder,\n\tExtraConfigColumn,\n\tPgBuildColumns,\n\tPgBuildExtraConfigColumns,\n\tPgColumn,\n\tPgColumnBuilder,\n\tPgColumns,\n} from './columns/common.ts';\nimport type { ForeignKey, ForeignKeyBuilder } from './foreign-keys.ts';\nimport type { AnyIndexBuilder } from './indexes.ts';\nimport type { PgPolicy } from './policies.ts';\nimport type { PrimaryKeyBuilder } from './primary-keys.ts';\nimport type { UniqueConstraintBuilder } from './unique-constraint.ts';\n\nexport type PgTableExtraConfigValue =\n\t| AnyIndexBuilder\n\t| CheckBuilder\n\t| ForeignKeyBuilder\n\t| PrimaryKeyBuilder\n\t| UniqueConstraintBuilder\n\t| PgPolicy;\n\nexport type PgTableExtraConfig = Record<string, PgTableExtraConfigValue>;\n\nexport type TableConfig = TableConfigBase<PgColumns>;\n\n/** @internal */\nexport const InlineForeignKeys = Symbol.for('drizzle:PgInlineForeignKeys');\n/** @internal */\nexport const EnableRLS = Symbol.for('drizzle:EnableRLS');\n\nexport class PgTable<out T extends TableConfig = TableConfig> extends Table<T> {\n\tstatic override readonly [entityKind]: string = 'PgTable';\n\n\t/** @internal */\n\tstatic override readonly Symbol = Object.assign({}, Table.Symbol, {\n\t\tInlineForeignKeys: InlineForeignKeys as typeof InlineForeignKeys,\n\t\tEnableRLS: EnableRLS as typeof EnableRLS,\n\t});\n\n\t/**@internal */\n\t[InlineForeignKeys]: ForeignKey[] = [];\n\n\t/** @internal */\n\t[EnableRLS]: boolean = false;\n\n\t/** @internal */\n\toverride [Table.Symbol.ExtraConfigBuilder]: ((self: Record<string, PgColumn>) => PgTableExtraConfig) | undefined =\n\t\tundefined;\n\n\t/** @internal */\n\toverride [Table.Symbol.ExtraConfigColumns]: Record<string, ExtraConfigColumn> = {};\n}\n\nexport type AnyPgTable<TPartial extends Partial<TableConfig> = {}> = PgTable<UpdateTableConfig<TableConfig, TPartial>>;\n\n// type InferInsertColumns<TColumns extends PgColumns> = Simplify<\n// \t& {\n// \t\t// Required keys: insertType does not include undefined or null\n// \t\t[\n// \t\t\tKey in keyof TColumns & string as TColumns[Key]['_']['insertType'] extends never ? never\n// \t\t\t\t// Check doesn't work properly with `\"strictNullChecks\": false`, to be reworked\n// \t\t\t\t: undefined extends TColumns[Key]['_']['insertType'] ? never\n// \t\t\t\t: Key\n// \t\t]: TColumns[Key]['_']['insertType'];\n// \t}\n// \t& {\n// \t\t// Optional keys: insertType includes undefined\n// \t\t[\n// \t\t\tKey in keyof TColumns & string as TColumns[Key]['_']['insertType'] extends never ? never\n// \t\t\t\t// Check doesn't work properly with `\"strictNullChecks\": false`, to be reworked\n// \t\t\t\t: undefined extends TColumns[Key]['_']['insertType'] ? Key\n// \t\t\t\t: never\n// \t\t]?: TColumns[Key]['_']['insertType'];\n// \t}\n// >;\n\nexport type PgTableWithColumns<T extends TableConfig> =\n\t& PgTable<T>\n\t& T['columns']\n\t& {\n\t\treadonly $inferSelect: InferModelFromColumns<T['columns'], 'select'>;\n\t\treadonly $inferInsert: InferModelFromColumns<T['columns'], 'insert'>;\n\t}\n\t& {\n\t\t/** @deprecated use `pgTable.withRLS()` instead*/\n\t\tenableRLS: () => Omit<\n\t\t\tPgTableWithColumns<T>,\n\t\t\t'enableRLS'\n\t\t>;\n\t};\n\n/** @internal */\nexport function pgTableWithSchema<\n\tTTableName extends string,\n\tTSchemaName extends string | undefined,\n\tTColumnsMap extends Record<string, AnyPgColumnBuilder>,\n>(\n\tname: TTableName,\n\tcolumns: TColumnsMap | ((columnTypes: PgColumnsBuilders) => TColumnsMap),\n\textraConfig:\n\t\t| ((self: PgBuildExtraConfigColumns<TColumnsMap>) => PgTableExtraConfig | PgTableExtraConfigValue[])\n\t\t| undefined,\n\tschema: TSchemaName,\n\tbaseName = name,\n): PgTableWithColumns<{\n\tname: TTableName;\n\tschema: TSchemaName;\n\tcolumns: PgBuildColumns<TTableName, TColumnsMap>;\n\tdialect: 'pg';\n}> {\n\tconst rawTable = new PgTable<{\n\t\tname: TTableName;\n\t\tschema: TSchemaName;\n\t\tcolumns: PgBuildColumns<TTableName, TColumnsMap>;\n\t\tdialect: 'pg';\n\t}>(name, schema, baseName);\n\n\tconst parsedColumns: TColumnsMap = typeof columns === 'function' ? columns(getPgColumnBuilders()) : columns;\n\n\tconst builtColumns = Object.fromEntries(\n\t\tObject.entries(parsedColumns).map(([name, colBuilderBase]) => {\n\t\t\tconst colBuilder = colBuilderBase as PgColumnBuilder;\n\t\t\tcolBuilder.setName(name);\n\t\t\tconst column = colBuilder.build(rawTable);\n\t\t\trawTable[InlineForeignKeys].push(...colBuilder.buildForeignKeys(column, rawTable));\n\t\t\treturn [name, column];\n\t\t}),\n\t) as unknown as PgBuildColumns<TTableName, TColumnsMap>;\n\n\tconst builtColumnsForExtraConfig = Object.fromEntries(\n\t\tObject.entries(parsedColumns).map(([name, colBuilderBase]) => {\n\t\t\tconst colBuilder = colBuilderBase as PgColumnBuilder;\n\t\t\tcolBuilder.setName(name);\n\t\t\tconst column = colBuilder.buildExtraConfigColumn(rawTable);\n\t\t\treturn [name, column];\n\t\t}),\n\t) as unknown as PgBuildExtraConfigColumns<TColumnsMap>;\n\n\tconst table = Object.assign(rawTable, builtColumns);\n\n\ttable[Table.Symbol.Columns] = builtColumns;\n\ttable[Table.Symbol.ExtraConfigColumns] = builtColumnsForExtraConfig;\n\n\tif (extraConfig) {\n\t\ttable[PgTable.Symbol.ExtraConfigBuilder] = extraConfig as any;\n\t}\n\n\treturn Object.assign(table, {\n\t\tenableRLS: () => {\n\t\t\ttable[PgTable.Symbol.EnableRLS] = true;\n\t\t\treturn table as PgTableWithColumns<{\n\t\t\t\tname: TTableName;\n\t\t\t\tschema: TSchemaName;\n\t\t\t\tcolumns: PgBuildColumns<TTableName, TColumnsMap>;\n\t\t\t\tdialect: 'pg';\n\t\t\t}>;\n\t\t},\n\t}) as any;\n}\n\nexport interface PgTableFnInternal<TSchema extends string | undefined = undefined> {\n\t<\n\t\tTTableName extends string,\n\t\tTColumnsMap extends Record<string, AnyPgColumnBuilder>,\n\t>(\n\t\tname: TTableName,\n\t\tcolumns: TColumnsMap,\n\t\textraConfig?: (\n\t\t\tself: PgBuildExtraConfigColumns<TColumnsMap>,\n\t\t) => PgTableExtraConfigValue[],\n\t): PgTableWithColumns<{\n\t\tname: TTableName;\n\t\tschema: TSchema;\n\t\tcolumns: PgBuildColumns<TTableName, TColumnsMap>;\n\t\tdialect: 'pg';\n\t}>;\n\n\t<\n\t\tTTableName extends string,\n\t\tTColumnsMap extends Record<string, AnyPgColumnBuilder>,\n\t>(\n\t\tname: TTableName,\n\t\tcolumns: (columnTypes: PgColumnsBuilders) => TColumnsMap,\n\t\textraConfig?: (self: PgBuildExtraConfigColumns<TColumnsMap>) => PgTableExtraConfigValue[],\n\t): PgTableWithColumns<{\n\t\tname: TTableName;\n\t\tschema: TSchema;\n\t\tcolumns: PgBuildColumns<TTableName, TColumnsMap>;\n\t\tdialect: 'pg';\n\t}>;\n\t/**\n\t * @deprecated The third parameter of pgTable is changing and will only accept an array instead of an object\n\t *\n\t * @example\n\t * Deprecated version:\n\t * ```ts\n\t * export const users = pgTable(\"users\", {\n\t * \tid: integer(),\n\t * }, (t) => ({\n\t * \tidx: index('custom_name').on(t.id)\n\t * }));\n\t * ```\n\t *\n\t * New API:\n\t * ```ts\n\t * export const users = pgTable(\"users\", {\n\t * \tid: integer(),\n\t * }, (t) => [\n\t * \tindex('custom_name').on(t.id)\n\t * ]);\n\t * ```\n\t */\n\t<\n\t\tTTableName extends string,\n\t\tTColumnsMap extends Record<string, AnyPgColumnBuilder>,\n\t>(\n\t\tname: TTableName,\n\t\tcolumns: TColumnsMap,\n\t\textraConfig: (\n\t\t\tself: PgBuildExtraConfigColumns<TColumnsMap>,\n\t\t) => PgTableExtraConfig,\n\t): PgTableWithColumns<{\n\t\tname: TTableName;\n\t\tschema: TSchema;\n\t\tcolumns: PgBuildColumns<TTableName, TColumnsMap>;\n\t\tdialect: 'pg';\n\t}>;\n\n\t/**\n\t * @deprecated The third parameter of pgTable is changing and will only accept an array instead of an object\n\t *\n\t * @example\n\t * Deprecated version:\n\t * ```ts\n\t * export const users = pgTable(\"users\", {\n\t * \tid: integer(),\n\t * }, (t) => ({\n\t * \tidx: index('custom_name').on(t.id)\n\t * }));\n\t * ```\n\t *\n\t * New API:\n\t * ```ts\n\t * export const users = pgTable(\"users\", {\n\t * \tid: integer(),\n\t * }, (t) => [\n\t * \tindex('custom_name').on(t.id)\n\t * ]);\n\t * ```\n\t */\n\t<\n\t\tTTableName extends string,\n\t\tTColumnsMap extends Record<string, AnyPgColumnBuilder>,\n\t>(\n\t\tname: TTableName,\n\t\tcolumns: (columnTypes: PgColumnsBuilders) => TColumnsMap,\n\t\textraConfig: (self: PgBuildExtraConfigColumns<TColumnsMap>) => PgTableExtraConfig,\n\t): PgTableWithColumns<{\n\t\tname: TTableName;\n\t\tschema: TSchema;\n\t\tcolumns: PgBuildColumns<TTableName, TColumnsMap>;\n\t\tdialect: 'pg';\n\t}>;\n}\n\nexport interface PgTableFn<TSchema extends string | undefined = undefined> extends PgTableFnInternal<TSchema> {\n\twithRLS: PgTableFnInternal<TSchema>;\n}\n\nconst pgTableInternal: PgTableFnInternal = (name, columns, extraConfig) => {\n\treturn pgTableWithSchema(name, columns, extraConfig, undefined);\n};\n\nconst pgTableWithRLS: PgTableFn['withRLS'] = (name, columns, extraConfig) => {\n\tconst table = pgTableWithSchema(name, columns, extraConfig, undefined);\n\ttable[EnableRLS] = true;\n\n\treturn table;\n};\n\nexport const pgTable: PgTableFn = Object.assign(pgTableInternal, { withRLS: pgTableWithRLS });\n\nexport function pgTableCreator(customizeTableName: (name: string) => string): PgTableFn {\n\tconst fn: PgTableFnInternal = (name, columns, extraConfig) => {\n\t\treturn pgTableWithSchema(customizeTableName(name) as typeof name, columns, extraConfig, undefined, name);\n\t};\n\n\treturn Object.assign(fn, {\n\t\twithRLS: ((name, columns, extraConfig) => {\n\t\t\tconst table = pgTableWithSchema(customizeTableName(name) as typeof name, columns, extraConfig, undefined, name);\n\t\t\ttable[EnableRLS] = true;\n\n\t\t\treturn table;\n\t\t}) as PgTableFnInternal,\n\t});\n}\n"],"mappings":";;;;;;AAiCA,MAAa,oBAAoB,OAAO,IAAI,8BAA8B;;AAE1E,MAAa,YAAY,OAAO,IAAI,oBAAoB;AAExD,IAAa,UAAb,cAAsE,MAAS;CAC9E,QAA0B,cAAsB;;CAGhD,OAAyB,SAAS,OAAO,OAAO,EAAE,EAAE,MAAM,QAAQ;EAC9C;EACR;EACX,CAAC;;CAGF,CAAC,qBAAmC,EAAE;;CAGtC,CAAC,aAAsB;;CAGvB,CAAU,MAAM,OAAO,sBACtB;;CAGD,CAAU,MAAM,OAAO,sBAAyD,EAAE;;;AA0CnF,SAAgB,kBAKf,MACA,SACA,aAGA,QACA,WAAW,MAMT;CACF,MAAM,WAAW,IAAI,QAKlB,MAAM,QAAQ,SAAS;CAE1B,MAAMA,gBAA6B,OAAO,YAAY,aAAa,QAAQ,qBAAqB,CAAC,GAAG;CAEpG,MAAM,eAAe,OAAO,YAC3B,OAAO,QAAQ,cAAc,CAAC,KAAK,CAACC,QAAM,oBAAoB;EAC7D,MAAM,aAAa;AACnB,aAAW,QAAQA,OAAK;EACxB,MAAM,SAAS,WAAW,MAAM,SAAS;AACzC,WAAS,mBAAmB,KAAK,GAAG,WAAW,iBAAiB,QAAQ,SAAS,CAAC;AAClF,SAAO,CAACA,QAAM,OAAO;GACpB,CACF;CAED,MAAM,6BAA6B,OAAO,YACzC,OAAO,QAAQ,cAAc,CAAC,KAAK,CAACA,QAAM,oBAAoB;EAC7D,MAAM,aAAa;AACnB,aAAW,QAAQA,OAAK;AAExB,SAAO,CAACA,QADO,WAAW,uBAAuB,SAAS,CACrC;GACpB,CACF;CAED,MAAM,QAAQ,OAAO,OAAO,UAAU,aAAa;AAEnD,OAAM,MAAM,OAAO,WAAW;AAC9B,OAAM,MAAM,OAAO,sBAAsB;AAEzC,KAAI,YACH,OAAM,QAAQ,OAAO,sBAAsB;AAG5C,QAAO,OAAO,OAAO,OAAO,EAC3B,iBAAiB;AAChB,QAAM,QAAQ,OAAO,aAAa;AAClC,SAAO;IAOR,CAAC;;AAgHH,MAAMC,mBAAsC,MAAM,SAAS,gBAAgB;AAC1E,QAAO,kBAAkB,MAAM,SAAS,aAAa,OAAU;;AAGhE,MAAMC,kBAAwC,MAAM,SAAS,gBAAgB;CAC5E,MAAM,QAAQ,kBAAkB,MAAM,SAAS,aAAa,OAAU;AACtE,OAAM,aAAa;AAEnB,QAAO;;AAGR,MAAaC,UAAqB,OAAO,OAAO,iBAAiB,EAAE,SAAS,gBAAgB,CAAC;AAE7F,SAAgB,eAAe,oBAAyD;CACvF,MAAMC,MAAyB,MAAM,SAAS,gBAAgB;AAC7D,SAAO,kBAAkB,mBAAmB,KAAK,EAAiB,SAAS,aAAa,QAAW,KAAK;;AAGzG,QAAO,OAAO,OAAO,IAAI,EACxB,WAAW,MAAM,SAAS,gBAAgB;EACzC,MAAM,QAAQ,kBAAkB,mBAAmB,KAAK,EAAiB,SAAS,aAAa,QAAW,KAAK;AAC/G,QAAM,aAAa;AAEnB,SAAO;KAER,CAAC"}