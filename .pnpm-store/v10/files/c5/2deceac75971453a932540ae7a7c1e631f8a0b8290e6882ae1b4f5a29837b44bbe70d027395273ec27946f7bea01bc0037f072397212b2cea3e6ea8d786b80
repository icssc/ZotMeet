{"version":3,"sources":["../../../../../src/server/lib/cache-handlers/default.ts"],"sourcesContent":["/**\n * This is the default \"use cache\" handler it defaults to an in-memory store.\n * In-memory caches are fragile and should not use stale-while-revalidate\n * semantics on the caches because it's not worth warming up an entry that's\n * likely going to get evicted before we get to use it anyway. However, we also\n * don't want to reuse a stale entry for too long so stale entries should be\n * considered expired/missing in such cache handlers.\n */\n\nimport { LRUCache } from '../lru-cache'\nimport type { CacheEntry, CacheHandler } from './types'\nimport {\n  areTagsExpired,\n  areTagsStale,\n  tagsManifest,\n  type TagManifestEntry,\n} from '../incremental-cache/tags-manifest.external'\n\ntype PrivateCacheEntry = {\n  entry: CacheEntry\n\n  // For the default cache we store errored cache\n  // entries and allow them to be used up to 3 times\n  // after that we want to dispose it and try for fresh\n\n  // If an entry is errored we return no entry\n  // three times so that we retry hitting origin (MISS)\n  // and then if it still fails to set after the third we\n  // return the errored content and use expiration of\n  // Math.min(30, entry.expiration)\n  isErrored: boolean\n  errorRetryCount: number\n\n  // compute size on set since we need to read size\n  // of the ReadableStream for LRU evicting\n  size: number\n}\n\nexport function createDefaultCacheHandler(maxSize: number): CacheHandler {\n  // If the max size is 0, return a cache handler that doesn't cache anything,\n  // this avoids an unnecessary LRUCache instance and potential memory\n  // allocation.\n  if (maxSize === 0) {\n    return {\n      get: () => Promise.resolve(undefined),\n      set: () => Promise.resolve(),\n      refreshTags: () => Promise.resolve(),\n      getExpiration: () => Promise.resolve(0),\n      updateTags: () => Promise.resolve(),\n    }\n  }\n\n  const memoryCache = new LRUCache<PrivateCacheEntry>(\n    maxSize,\n    (entry) => entry.size\n  )\n  const pendingSets = new Map<string, Promise<void>>()\n\n  const debug = process.env.NEXT_PRIVATE_DEBUG_CACHE\n    ? console.debug.bind(console, 'DefaultCacheHandler:')\n    : undefined\n\n  return {\n    async get(cacheKey) {\n      const pendingPromise = pendingSets.get(cacheKey)\n\n      if (pendingPromise) {\n        debug?.('get', cacheKey, 'pending')\n        await pendingPromise\n      }\n\n      const privateEntry = memoryCache.get(cacheKey)\n\n      if (!privateEntry) {\n        debug?.('get', cacheKey, 'not found')\n        return undefined\n      }\n\n      const entry = privateEntry.entry\n      if (\n        performance.timeOrigin + performance.now() >\n        entry.timestamp + entry.revalidate * 1000\n      ) {\n        // In-memory caches should expire after revalidate time because it is\n        // unlikely that a new entry will be able to be used before it is dropped\n        // from the cache.\n        debug?.('get', cacheKey, 'expired')\n\n        return undefined\n      }\n\n      let revalidate = entry.revalidate\n\n      if (areTagsExpired(entry.tags, entry.timestamp)) {\n        debug?.('get', cacheKey, 'had expired tag')\n        return undefined\n      }\n\n      if (areTagsStale(entry.tags, entry.timestamp)) {\n        debug?.('get', cacheKey, 'had stale tag')\n        revalidate = -1\n      }\n\n      const [returnStream, newSaved] = entry.value.tee()\n      entry.value = newSaved\n\n      debug?.('get', cacheKey, 'found', {\n        tags: entry.tags,\n        timestamp: entry.timestamp,\n        expire: entry.expire,\n        revalidate,\n      })\n\n      return {\n        ...entry,\n        revalidate,\n        value: returnStream,\n      }\n    },\n\n    async set(cacheKey, pendingEntry) {\n      debug?.('set', cacheKey, 'start')\n\n      let resolvePending: () => void = () => {}\n      const pendingPromise = new Promise<void>((resolve) => {\n        resolvePending = resolve\n      })\n      pendingSets.set(cacheKey, pendingPromise)\n\n      const entry = await pendingEntry\n\n      let size = 0\n\n      try {\n        const [value, clonedValue] = entry.value.tee()\n        entry.value = value\n        const reader = clonedValue.getReader()\n\n        for (let chunk; !(chunk = await reader.read()).done; ) {\n          size += Buffer.from(chunk.value).byteLength\n        }\n\n        memoryCache.set(cacheKey, {\n          entry,\n          isErrored: false,\n          errorRetryCount: 0,\n          size,\n        })\n\n        debug?.('set', cacheKey, 'done')\n      } catch (err) {\n        // TODO: store partial buffer with error after we retry 3 times\n        debug?.('set', cacheKey, 'failed', err)\n      } finally {\n        resolvePending()\n        pendingSets.delete(cacheKey)\n      }\n    },\n\n    async refreshTags() {\n      // Nothing to do for an in-memory cache handler.\n    },\n\n    async getExpiration(tags) {\n      const expirations = tags.map((tag) => {\n        const entry = tagsManifest.get(tag)\n        if (!entry) return 0\n        // Return the most recent timestamp (either expired or stale)\n        return entry.expired || 0\n      })\n\n      const expiration = Math.max(...expirations, 0)\n\n      debug?.('getExpiration', { tags, expiration })\n\n      return expiration\n    },\n\n    async updateTags(tags, durations) {\n      const now = Math.round(performance.timeOrigin + performance.now())\n      debug?.('updateTags', { tags, timestamp: now })\n\n      for (const tag of tags) {\n        // TODO: update file-system-cache?\n        const existingEntry = tagsManifest.get(tag) || {}\n\n        if (durations) {\n          // Use provided durations directly\n          const updates: TagManifestEntry = { ...existingEntry }\n\n          // mark as stale immediately\n          updates.stale = now\n\n          if (durations.expire !== undefined) {\n            updates.expired = now + durations.expire * 1000 // Convert seconds to ms\n          }\n\n          tagsManifest.set(tag, updates)\n        } else {\n          // Update expired field for immediate expiration (default behavior when no durations provided)\n          tagsManifest.set(tag, { ...existingEntry, expired: now })\n        }\n      }\n    },\n  }\n}\n"],"names":["LRUCache","areTagsExpired","areTagsStale","tagsManifest","createDefaultCacheHandler","maxSize","get","Promise","resolve","undefined","set","refreshTags","getExpiration","updateTags","memoryCache","entry","size","pendingSets","Map","debug","process","env","NEXT_PRIVATE_DEBUG_CACHE","console","bind","cacheKey","pendingPromise","privateEntry","performance","timeOrigin","now","timestamp","revalidate","tags","returnStream","newSaved","value","tee","expire","pendingEntry","resolvePending","clonedValue","reader","getReader","chunk","read","done","Buffer","from","byteLength","isErrored","errorRetryCount","err","delete","expirations","map","tag","expired","expiration","Math","max","durations","round","existingEntry","updates","stale"],"mappings":"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","ignoreList":[0]}