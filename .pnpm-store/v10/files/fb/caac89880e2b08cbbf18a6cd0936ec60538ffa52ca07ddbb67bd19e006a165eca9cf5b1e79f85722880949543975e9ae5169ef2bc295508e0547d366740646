{"version":3,"file":"table.cjs","names":["entityKind","TableName"],"sources":["../src/table.ts"],"sourcesContent":["import type { Column, Columns, GetColumnData } from './column.ts';\nimport { entityKind } from './entity.ts';\nimport type { OptionalKeyOnly, RequiredKeyOnly } from './operations.ts';\nimport type { View } from './sql/sql.ts';\nimport { TableName } from './table.utils.ts';\nimport type { Simplify, Update } from './utils.ts';\n\nexport interface TableConfig<TColumns extends Columns = Columns> {\n\tname: string;\n\tschema: string | undefined;\n\tcolumns: TColumns;\n\tdialect: string;\n}\n\nexport type UpdateTableConfig<T extends TableConfig, TUpdate extends Partial<TableConfig>> = Required<\n\tUpdate<T, TUpdate>\n>;\n\n/** @internal */\nexport const TableSchema = Symbol.for('drizzle:Schema');\n\n/** @internal */\nexport const TableColumns = Symbol.for('drizzle:Columns');\n\n/** @internal */\nexport const ExtraConfigColumns = Symbol.for('drizzle:ExtraConfigColumns');\n\n/** @internal */\nexport const OriginalName = Symbol.for('drizzle:OriginalName');\n\n/** @internal */\nexport const BaseName = Symbol.for('drizzle:BaseName');\n\n/** @internal */\nexport const IsAlias = Symbol.for('drizzle:IsAlias');\n\n/** @internal */\nexport const ExtraConfigBuilder = Symbol.for('drizzle:ExtraConfigBuilder');\n\nconst IsDrizzleTable = Symbol.for('drizzle:IsDrizzleTable');\n\nexport interface TableTypeConfig<T extends TableConfig> {\n\treadonly brand: 'Table';\n\treadonly name: T['name'];\n\treadonly schema: T['schema'];\n\treadonly columns: T['columns'];\n\treadonly dialect: T['dialect'];\n}\n\nexport class Table<out T extends TableConfig = TableConfig> {\n\tstatic readonly [entityKind]: string = 'Table';\n\n\tdeclare readonly _: TableTypeConfig<T>;\n\n\t/** @internal */\n\tstatic readonly Symbol = {\n\t\tName: TableName as typeof TableName,\n\t\tSchema: TableSchema as typeof TableSchema,\n\t\tOriginalName: OriginalName as typeof OriginalName,\n\t\tColumns: TableColumns as typeof TableColumns,\n\t\tExtraConfigColumns: ExtraConfigColumns as typeof ExtraConfigColumns,\n\t\tBaseName: BaseName as typeof BaseName,\n\t\tIsAlias: IsAlias as typeof IsAlias,\n\t\tExtraConfigBuilder: ExtraConfigBuilder as typeof ExtraConfigBuilder,\n\t};\n\n\t/**\n\t * @internal\n\t * Can be changed if the table is aliased.\n\t */\n\t[TableName]: string;\n\n\t/**\n\t * @internal\n\t * Used to store the original name of the table, before any aliasing.\n\t */\n\t[OriginalName]: string;\n\n\t/** @internal */\n\t[TableSchema]: string | undefined;\n\n\t/** @internal */\n\t[TableColumns]!: T['columns'];\n\n\t/** @internal */\n\t[ExtraConfigColumns]!: Record<string, unknown>;\n\n\t/**\n\t *  @internal\n\t * Used to store the table name before the transformation via the `tableCreator` functions.\n\t */\n\t[BaseName]: string;\n\n\t/** @internal */\n\t[IsAlias] = false;\n\n\t/** @internal */\n\t[IsDrizzleTable] = true;\n\n\t/** @internal */\n\t[ExtraConfigBuilder]: ((self: any) => Record<string, unknown> | unknown[]) | undefined = undefined;\n\n\tconstructor(name: string, schema: string | undefined, baseName: string) {\n\t\tthis[TableName] = this[OriginalName] = name;\n\t\tthis[TableSchema] = schema;\n\t\tthis[BaseName] = baseName;\n\t}\n}\n\nexport function isTable(table: unknown): table is Table {\n\treturn typeof table === 'object' && table !== null && IsDrizzleTable in table;\n}\n\n/**\n * Any table with a specified boundary.\n *\n * @example\n\t```ts\n\t// Any table with a specific name\n\ttype AnyUsersTable = AnyTable<{ name: 'users' }>;\n\t```\n *\n * To describe any table with any config, simply use `Table` without any type arguments, like this:\n *\n\t```ts\n\tfunction needsTable(table: Table) {\n\t\t...\n\t}\n\t```\n */\nexport type AnyTable<TPartial extends Partial<TableConfig>> = Table<UpdateTableConfig<TableConfig, TPartial>>;\n\nexport function getTableName<T extends Table>(table: T): T['_']['name'] {\n\treturn table[TableName];\n}\n\nexport function getTableUniqueName<\n\tT extends Table | View,\n\tTResult extends string = T extends Table ? T['_']['schema'] extends undefined ? `public.${T['_']['name']}`\n\t\t: `${T['_']['schema']}.${T['_']['name']}`\n\t\t// Views don't have type-level schema names, to be added\n\t\t: `${string}.${T['_']['name']}`,\n>(\n\ttable: T,\n): TResult {\n\treturn `${table[TableSchema] ?? 'public'}.${table[TableName]}` as TResult;\n}\n\nexport type MapColumnName<TName extends string, TColumn extends Column, TDBColumNames extends boolean> =\n\tTDBColumNames extends true ? TColumn['_']['name']\n\t\t: TName;\n\nexport type InferModelFromColumns<\n\tTColumns extends Columns,\n\tTInferMode extends 'select' | 'insert' = 'select',\n\tTConfig extends { override?: boolean } = { dbColumnNames: false; override: false },\n> = Simplify<\n\tTInferMode extends 'insert' ?\n\t\t\t& {\n\t\t\t\t[\n\t\t\t\t\tKey in keyof TColumns & string as RequiredKeyOnly<\n\t\t\t\t\t\tKey,\n\t\t\t\t\t\tTColumns[Key]\n\t\t\t\t\t>\n\t\t\t\t]: GetColumnData<TColumns[Key], 'query'>;\n\t\t\t}\n\t\t\t& {\n\t\t\t\t[\n\t\t\t\t\tKey in keyof TColumns & string as OptionalKeyOnly<\n\t\t\t\t\t\tKey,\n\t\t\t\t\t\tTColumns[Key],\n\t\t\t\t\t\tTConfig['override']\n\t\t\t\t\t>\n\t\t\t\t]?: GetColumnData<TColumns[Key], 'query'> | undefined;\n\t\t\t}\n\t\t: {\n\t\t\t[\n\t\t\t\tKey in keyof TColumns & string\n\t\t\t]: GetColumnData<TColumns[Key], 'query'>;\n\t\t}\n>;\n\n/** @deprecated Use one of the alternatives: {@link InferSelectModel} / {@link InferInsertModel}, or `table.$inferSelect` / `table.$inferInsert`\n */\nexport type InferModel<\n\tTTable extends Table,\n\tTInferMode extends 'select' | 'insert' = 'select',\n> = InferModelFromColumns<TTable['_']['columns'], TInferMode>;\n\nexport type InferSelectModel<\n\tTTable extends Table,\n> = InferModelFromColumns<TTable['_']['columns'], 'select'>;\n\nexport type InferInsertModel<\n\tTTable extends Table,\n\tTOverride extends { override?: boolean } = { override: false },\n> = InferModelFromColumns<TTable['_']['columns'], 'insert', TOverride>;\n\nexport type InferEnum<T> = T extends { enumValues: readonly (infer U)[] } ? U\n\t: never;\n\nexport interface InferTableColumnsModels<TColumns extends Columns> {\n\treadonly $inferSelect: InferModelFromColumns<TColumns, 'select'>;\n\treadonly $inferInsert: InferModelFromColumns<TColumns, 'insert', { override: false }>;\n}\n"],"mappings":";;;;;AAmBA,MAAa,cAAc,OAAO,IAAI,iBAAiB;;AAGvD,MAAa,eAAe,OAAO,IAAI,kBAAkB;;AAGzD,MAAa,qBAAqB,OAAO,IAAI,6BAA6B;;AAG1E,MAAa,eAAe,OAAO,IAAI,uBAAuB;;AAG9D,MAAa,WAAW,OAAO,IAAI,mBAAmB;;AAGtD,MAAa,UAAU,OAAO,IAAI,kBAAkB;;AAGpD,MAAa,qBAAqB,OAAO,IAAI,6BAA6B;AAE1E,MAAM,iBAAiB,OAAO,IAAI,yBAAyB;AAU3D,IAAa,QAAb,MAA4D;CAC3D,QAAiBA,6BAAsB;;CAKvC,OAAgB,SAAS;EACxB,MAAMC;EACN,QAAQ;EACM;EACd,SAAS;EACW;EACV;EACD;EACW;EACpB;;;;;CAMD,CAACA;;;;;CAMD,CAAC;;CAGD,CAAC;;CAGD,CAAC;;CAGD,CAAC;;;;;CAMD,CAAC;;CAGD,CAAC,WAAW;;CAGZ,CAAC,kBAAkB;;CAGnB,CAAC,sBAAwF;CAEzF,YAAY,MAAc,QAA4B,UAAkB;AACvE,OAAKA,iCAAa,KAAK,gBAAgB;AACvC,OAAK,eAAe;AACpB,OAAK,YAAY;;;AAInB,SAAgB,QAAQ,OAAgC;AACvD,QAAO,OAAO,UAAU,YAAY,UAAU,QAAQ,kBAAkB;;AAsBzE,SAAgB,aAA8B,OAA0B;AACvE,QAAO,MAAMA;;AAGd,SAAgB,mBAOf,OACU;AACV,QAAO,GAAG,MAAM,gBAAgB,SAAS,GAAG,MAAMA"}