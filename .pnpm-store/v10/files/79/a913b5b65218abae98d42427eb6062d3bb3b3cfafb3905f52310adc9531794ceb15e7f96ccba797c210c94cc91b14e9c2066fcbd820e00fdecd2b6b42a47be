{"version":3,"file":"session.js","names":["SQLiteSession","client: D1Database | D1DatabaseSession","relations: TRelations","schema: V1.RelationalSchemaConfig<TSchema> | undefined","options: SQLiteD1SessionOptions","preparedQueries: PreparedQuery[]","builtQueries: D1PreparedStatement[]","builtQuery","rows: unknown[][]","SQLitePreparedQuery","logger: Logger","_isResponseInArrayMode: boolean","customResultMapper?: (\n\t\t\trows: TIsRqbV2 extends true ? Record<string, unknown>[] : unknown[][],\n\t\t) => unknown","isRqbV2Query?: TIsRqbV2"],"sources":["../../src/d1/session.ts"],"sourcesContent":["/// <reference types=\"@cloudflare/workers-types\" />\n\nimport type * as V1 from '~/_relations.ts';\nimport type { BatchItem } from '~/batch.ts';\nimport { type Cache, NoopCache } from '~/cache/core/index.ts';\nimport type { WithCacheConfig } from '~/cache/core/types.ts';\nimport { entityKind } from '~/entity.ts';\nimport type { Logger } from '~/logger.ts';\nimport { NoopLogger } from '~/logger.ts';\nimport type { AnyRelations } from '~/relations.ts';\nimport type { PreparedQuery } from '~/session.ts';\nimport { fillPlaceholders, type Query, sql } from '~/sql/sql.ts';\nimport type { SQLiteAsyncDialect } from '~/sqlite-core/dialect.ts';\nimport { SQLiteTransaction } from '~/sqlite-core/index.ts';\nimport type { SelectedFieldsOrdered } from '~/sqlite-core/query-builders/select.types.ts';\nimport type {\n\tPreparedQueryConfig as PreparedQueryConfigBase,\n\tSQLiteExecuteMethod,\n\tSQLiteTransactionConfig,\n} from '~/sqlite-core/session.ts';\nimport { SQLitePreparedQuery, SQLiteSession } from '~/sqlite-core/session.ts';\nimport { mapResultRow } from '~/utils.ts';\n\nexport interface SQLiteD1SessionOptions {\n\tlogger?: Logger;\n\tcache?: Cache;\n}\n\ntype PreparedQueryConfig = Omit<PreparedQueryConfigBase, 'statement' | 'run'>;\n\nexport class SQLiteD1Session<\n\tTFullSchema extends Record<string, unknown>,\n\tTRelations extends AnyRelations,\n\tTSchema extends V1.TablesRelationalConfig,\n> extends SQLiteSession<'async', D1Result, TFullSchema, TRelations, TSchema> {\n\tstatic override readonly [entityKind]: string = 'SQLiteD1Session';\n\n\tprivate logger: Logger;\n\tprivate cache: Cache;\n\n\tconstructor(\n\t\tprivate client: D1Database | D1DatabaseSession,\n\t\tdialect: SQLiteAsyncDialect,\n\t\tprivate relations: TRelations,\n\t\tprivate schema: V1.RelationalSchemaConfig<TSchema> | undefined,\n\t\tprivate options: SQLiteD1SessionOptions = {},\n\t) {\n\t\tsuper(dialect);\n\t\tthis.logger = options.logger ?? new NoopLogger();\n\t\tthis.cache = options.cache ?? new NoopCache();\n\t}\n\n\tprepareQuery(\n\t\tquery: Query,\n\t\tfields: SelectedFieldsOrdered | undefined,\n\t\texecuteMethod: SQLiteExecuteMethod,\n\t\tisResponseInArrayMode: boolean,\n\t\tcustomResultMapper?: (rows: unknown[][]) => unknown,\n\t\tqueryMetadata?: {\n\t\t\ttype: 'select' | 'update' | 'delete' | 'insert';\n\t\t\ttables: string[];\n\t\t},\n\t\tcacheConfig?: WithCacheConfig,\n\t): D1PreparedQuery {\n\t\tconst stmt = this.client.prepare(query.sql);\n\t\treturn new D1PreparedQuery(\n\t\t\tstmt,\n\t\t\tquery,\n\t\t\tthis.logger,\n\t\t\tthis.cache,\n\t\t\tqueryMetadata,\n\t\t\tcacheConfig,\n\t\t\tfields,\n\t\t\texecuteMethod,\n\t\t\tisResponseInArrayMode,\n\t\t\tcustomResultMapper,\n\t\t);\n\t}\n\n\tprepareRelationalQuery(\n\t\tquery: Query,\n\t\tfields: SelectedFieldsOrdered | undefined,\n\t\texecuteMethod: SQLiteExecuteMethod,\n\t\tcustomResultMapper?: (rows: Record<string, unknown>[]) => unknown,\n\t): D1PreparedQuery<PreparedQueryConfig, true> {\n\t\tconst stmt = this.client.prepare(query.sql);\n\t\treturn new D1PreparedQuery(\n\t\t\tstmt,\n\t\t\tquery,\n\t\t\tthis.logger,\n\t\t\tthis.cache,\n\t\t\tundefined,\n\t\t\tundefined,\n\t\t\tfields,\n\t\t\texecuteMethod,\n\t\t\tfalse,\n\t\t\tcustomResultMapper,\n\t\t\ttrue,\n\t\t);\n\t}\n\n\tasync batch<T extends BatchItem<'sqlite'>[] | readonly BatchItem<'sqlite'>[]>(queries: T) {\n\t\tconst preparedQueries: PreparedQuery[] = [];\n\t\tconst builtQueries: D1PreparedStatement[] = [];\n\n\t\tfor (const query of queries) {\n\t\t\tconst preparedQuery = query._prepare();\n\t\t\tconst builtQuery = preparedQuery.getQuery();\n\t\t\tpreparedQueries.push(preparedQuery);\n\t\t\tif (builtQuery.params.length > 0) {\n\t\t\t\tbuiltQueries.push((preparedQuery as D1PreparedQuery).stmt.bind(...builtQuery.params));\n\t\t\t} else {\n\t\t\t\tconst builtQuery = preparedQuery.getQuery();\n\t\t\t\tbuiltQueries.push(\n\t\t\t\t\tthis.client.prepare(builtQuery.sql).bind(...builtQuery.params),\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\tconst batchResults = await this.client.batch<any>(builtQueries);\n\t\treturn batchResults.map((result, i) => preparedQueries[i]!.mapResult(result, true));\n\t}\n\n\toverride extractRawAllValueFromBatchResult(result: unknown): unknown {\n\t\treturn (result as D1Result).results;\n\t}\n\n\toverride extractRawGetValueFromBatchResult(result: unknown): unknown {\n\t\treturn (result as D1Result).results[0];\n\t}\n\n\toverride extractRawValuesValueFromBatchResult(result: unknown): unknown {\n\t\treturn d1ToRawMapping((result as D1Result).results);\n\t}\n\n\toverride async transaction<T>(\n\t\ttransaction: (tx: D1Transaction<TFullSchema, TRelations, TSchema>) => T | Promise<T>,\n\t\tconfig?: SQLiteTransactionConfig,\n\t): Promise<T> {\n\t\tconst tx = new D1Transaction('async', this.dialect, this, this.relations, this.schema, undefined, undefined, true);\n\t\tawait this.run(sql.raw(`begin${config?.behavior ? ' ' + config.behavior : ''}`));\n\t\ttry {\n\t\t\tconst result = await transaction(tx);\n\t\t\tawait this.run(sql`commit`);\n\t\t\treturn result;\n\t\t} catch (err) {\n\t\t\tawait this.run(sql`rollback`);\n\t\t\tthrow err;\n\t\t}\n\t}\n}\n\nexport class D1Transaction<\n\tTFullSchema extends Record<string, unknown>,\n\tTRelations extends AnyRelations,\n\tTSchema extends V1.TablesRelationalConfig,\n> extends SQLiteTransaction<'async', D1Result, TFullSchema, TRelations, TSchema> {\n\tstatic override readonly [entityKind]: string = 'D1Transaction';\n\n\toverride async transaction<T>(\n\t\ttransaction: (tx: D1Transaction<TFullSchema, TRelations, TSchema>) => Promise<T>,\n\t): Promise<T> {\n\t\tconst savepointName = `sp${this.nestedIndex}`;\n\t\tconst tx = new D1Transaction(\n\t\t\t'async',\n\t\t\tthis.dialect,\n\t\t\tthis.session,\n\t\t\tthis.relations,\n\t\t\tthis.schema,\n\t\t\tthis.nestedIndex + 1,\n\t\t\tundefined,\n\t\t\tthis.forbidJsonb,\n\t\t);\n\t\tawait this.session.run(sql.raw(`savepoint ${savepointName}`));\n\t\ttry {\n\t\t\tconst result = await transaction(tx);\n\t\t\tawait this.session.run(sql.raw(`release savepoint ${savepointName}`));\n\t\t\treturn result;\n\t\t} catch (err) {\n\t\t\tawait this.session.run(sql.raw(`rollback to savepoint ${savepointName}`));\n\t\t\tthrow err;\n\t\t}\n\t}\n}\n\n/**\n * This function was taken from the D1 implementation: https://github.com/cloudflare/workerd/blob/4aae9f4c7ae30a59a88ca868c4aff88bda85c956/src/cloudflare/internal/d1-api.ts#L287\n * It may cause issues with duplicated column names in join queries, which should be fixed on the D1 side.\n * @param results\n * @returns\n */\nfunction d1ToRawMapping(results: any) {\n\tconst rows: unknown[][] = [];\n\tfor (const row of results) {\n\t\tconst entry = Object.keys(row).map((k) => row[k]);\n\t\trows.push(entry);\n\t}\n\treturn rows;\n}\n\nexport class D1PreparedQuery<T extends PreparedQueryConfig = PreparedQueryConfig, TIsRqbV2 extends boolean = false>\n\textends SQLitePreparedQuery<\n\t\t{ type: 'async'; run: D1Response; all: T['all']; get: T['get']; values: T['values']; execute: T['execute'] }\n\t>\n{\n\tstatic override readonly [entityKind]: string = 'D1PreparedQuery';\n\n\t/** @internal */\n\tfields?: SelectedFieldsOrdered;\n\n\t/** @internal */\n\tstmt: D1PreparedStatement;\n\n\tconstructor(\n\t\tstmt: D1PreparedStatement,\n\t\tquery: Query,\n\t\tprivate logger: Logger,\n\t\tcache: Cache,\n\t\tqueryMetadata: {\n\t\t\ttype: 'select' | 'update' | 'delete' | 'insert';\n\t\t\ttables: string[];\n\t\t} | undefined,\n\t\tcacheConfig: WithCacheConfig | undefined,\n\t\tfields: SelectedFieldsOrdered | undefined,\n\t\texecuteMethod: SQLiteExecuteMethod,\n\t\tprivate _isResponseInArrayMode: boolean,\n\t\tprivate customResultMapper?: (\n\t\t\trows: TIsRqbV2 extends true ? Record<string, unknown>[] : unknown[][],\n\t\t) => unknown,\n\t\tprivate isRqbV2Query?: TIsRqbV2,\n\t) {\n\t\tsuper('async', executeMethod, query, cache, queryMetadata, cacheConfig);\n\t\tthis.fields = fields;\n\t\tthis.stmt = stmt;\n\t}\n\n\tasync run(placeholderValues?: Record<string, unknown>): Promise<D1Response> {\n\t\tconst params = fillPlaceholders(this.query.params, placeholderValues ?? {});\n\t\tthis.logger.logQuery(this.query.sql, params);\n\t\treturn await this.queryWithCache(this.query.sql, params, async () => {\n\t\t\treturn this.stmt.bind(...params).run();\n\t\t});\n\t}\n\n\tasync all(placeholderValues?: Record<string, unknown>): Promise<T['all']> {\n\t\tif (this.isRqbV2Query) return this.allRqbV2(placeholderValues);\n\n\t\tconst { fields, query, logger, stmt, customResultMapper } = this;\n\t\tif (!fields && !customResultMapper) {\n\t\t\tconst params = fillPlaceholders(query.params, placeholderValues ?? {});\n\t\t\tlogger.logQuery(query.sql, params);\n\t\t\treturn await this.queryWithCache(query.sql, params, async () => {\n\t\t\t\treturn stmt.bind(...params).all().then(({ results }) => this.mapAllResult(results!));\n\t\t\t});\n\t\t}\n\n\t\tconst rows = await this.values(placeholderValues);\n\n\t\treturn this.mapAllResult(rows);\n\t}\n\n\tprivate async allRqbV2(placeholderValues?: Record<string, unknown>): Promise<T['all']> {\n\t\tconst { query, logger, stmt, customResultMapper } = this;\n\n\t\tconst params = fillPlaceholders(query.params, placeholderValues ?? {});\n\t\tlogger.logQuery(query.sql, params);\n\t\treturn stmt.bind(...params).all().then(({ results }) =>\n\t\t\t(customResultMapper as (rows: Record<string, unknown>[]) => unknown)(results!)\n\t\t);\n\t}\n\n\toverride mapAllResult(rows: unknown, isFromBatch?: boolean): unknown {\n\t\tif (isFromBatch) {\n\t\t\trows = this.isRqbV2Query ? (rows as D1Result).results : d1ToRawMapping((rows as D1Result).results);\n\t\t}\n\n\t\tif (!this.fields && !this.customResultMapper) {\n\t\t\treturn rows;\n\t\t}\n\n\t\tif (this.customResultMapper) {\n\t\t\treturn (this.customResultMapper as (rows: unknown[][]) => unknown)(rows as unknown[][]);\n\t\t}\n\n\t\treturn (rows as unknown[][]).map((row) => mapResultRow(this.fields!, row, this.joinsNotNullableMap));\n\t}\n\n\tasync get(placeholderValues?: Record<string, unknown>): Promise<T['get']> {\n\t\tif (this.isRqbV2Query) return this.getRqbV2(placeholderValues);\n\n\t\tconst { fields, joinsNotNullableMap, query, logger, stmt, customResultMapper } = this;\n\t\tif (!fields && !customResultMapper) {\n\t\t\tconst params = fillPlaceholders(query.params, placeholderValues ?? {});\n\t\t\tlogger.logQuery(query.sql, params);\n\t\t\treturn await this.queryWithCache(query.sql, params, async () => {\n\t\t\t\treturn stmt.bind(...params).all().then(({ results }) => results![0]);\n\t\t\t});\n\t\t}\n\n\t\tconst rows = await this.values(placeholderValues);\n\n\t\tif (!rows[0]) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\tif (customResultMapper) {\n\t\t\treturn (customResultMapper as (rows: unknown[][]) => unknown)(rows) as T['all'];\n\t\t}\n\n\t\treturn mapResultRow(fields!, rows[0], joinsNotNullableMap);\n\t}\n\n\tprivate async getRqbV2(placeholderValues?: Record<string, unknown>): Promise<T['get']> {\n\t\tconst { query, logger, stmt, customResultMapper } = this;\n\n\t\tconst params = fillPlaceholders(query.params, placeholderValues ?? {});\n\t\tlogger.logQuery(query.sql, params);\n\t\tconst { results: rows } = await stmt.bind(...params).all();\n\n\t\tif (!rows[0]) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\treturn (customResultMapper as (rows: Record<string, unknown>[]) => unknown)(rows) as T['get'];\n\t}\n\n\toverride mapGetResult(result: unknown, isFromBatch?: boolean): unknown {\n\t\tif (isFromBatch) {\n\t\t\tresult = this.isRqbV2Query ? (result as D1Result).results[0] : d1ToRawMapping((result as D1Result).results)[0];\n\t\t}\n\n\t\tif (!this.fields && !this.customResultMapper) {\n\t\t\treturn result;\n\t\t}\n\n\t\tif (this.customResultMapper) {\n\t\t\treturn (this.customResultMapper as (rows: unknown[][]) => unknown)([result as unknown[]]) as T['all'];\n\t\t}\n\n\t\treturn mapResultRow(this.fields!, result as unknown[], this.joinsNotNullableMap);\n\t}\n\n\tasync values<T extends any[] = unknown[]>(placeholderValues?: Record<string, unknown>): Promise<T[]> {\n\t\tconst params = fillPlaceholders(this.query.params, placeholderValues ?? {});\n\t\tthis.logger.logQuery(this.query.sql, params);\n\t\treturn await this.queryWithCache(this.query.sql, params, async () => {\n\t\t\treturn this.stmt.bind(...params).raw();\n\t\t});\n\t}\n\n\t/** @internal */\n\tisResponseInArrayMode(): boolean {\n\t\treturn this._isResponseInArrayMode;\n\t}\n}\n"],"mappings":";;;;;;;;;AA8BA,IAAa,kBAAb,cAIUA,gBAAmE;CAC5E,QAA0B,cAAsB;CAEhD,AAAQ;CACR,AAAQ;CAER,YACC,AAAQC,QACR,SACA,AAAQC,WACR,AAAQC,QACR,AAAQC,UAAkC,EAAE,EAC3C;AACD,QAAM,QAAQ;EANN;EAEA;EACA;EACA;AAGR,OAAK,SAAS,QAAQ,UAAU,IAAI,YAAY;AAChD,OAAK,QAAQ,QAAQ,SAAS,IAAI,WAAW;;CAG9C,aACC,OACA,QACA,eACA,uBACA,oBACA,eAIA,aACkB;AAElB,SAAO,IAAI,gBADE,KAAK,OAAO,QAAQ,MAAM,IAAI,EAG1C,OACA,KAAK,QACL,KAAK,OACL,eACA,aACA,QACA,eACA,uBACA,mBACA;;CAGF,uBACC,OACA,QACA,eACA,oBAC6C;AAE7C,SAAO,IAAI,gBADE,KAAK,OAAO,QAAQ,MAAM,IAAI,EAG1C,OACA,KAAK,QACL,KAAK,OACL,QACA,QACA,QACA,eACA,OACA,oBACA,KACA;;CAGF,MAAM,MAAwE,SAAY;EACzF,MAAMC,kBAAmC,EAAE;EAC3C,MAAMC,eAAsC,EAAE;AAE9C,OAAK,MAAM,SAAS,SAAS;GAC5B,MAAM,gBAAgB,MAAM,UAAU;GACtC,MAAM,aAAa,cAAc,UAAU;AAC3C,mBAAgB,KAAK,cAAc;AACnC,OAAI,WAAW,OAAO,SAAS,EAC9B,cAAa,KAAM,cAAkC,KAAK,KAAK,GAAG,WAAW,OAAO,CAAC;QAC/E;IACN,MAAMC,eAAa,cAAc,UAAU;AAC3C,iBAAa,KACZ,KAAK,OAAO,QAAQA,aAAW,IAAI,CAAC,KAAK,GAAGA,aAAW,OAAO,CAC9D;;;AAKH,UADqB,MAAM,KAAK,OAAO,MAAW,aAAa,EAC3C,KAAK,QAAQ,MAAM,gBAAgB,GAAI,UAAU,QAAQ,KAAK,CAAC;;CAGpF,AAAS,kCAAkC,QAA0B;AACpE,SAAQ,OAAoB;;CAG7B,AAAS,kCAAkC,QAA0B;AACpE,SAAQ,OAAoB,QAAQ;;CAGrC,AAAS,qCAAqC,QAA0B;AACvE,SAAO,eAAgB,OAAoB,QAAQ;;CAGpD,MAAe,YACd,aACA,QACa;EACb,MAAM,KAAK,IAAI,cAAc,SAAS,KAAK,SAAS,MAAM,KAAK,WAAW,KAAK,QAAQ,QAAW,QAAW,KAAK;AAClH,QAAM,KAAK,IAAI,IAAI,IAAI,QAAQ,QAAQ,WAAW,MAAM,OAAO,WAAW,KAAK,CAAC;AAChF,MAAI;GACH,MAAM,SAAS,MAAM,YAAY,GAAG;AACpC,SAAM,KAAK,IAAI,GAAG,SAAS;AAC3B,UAAO;WACC,KAAK;AACb,SAAM,KAAK,IAAI,GAAG,WAAW;AAC7B,SAAM;;;;AAKT,IAAa,gBAAb,MAAa,sBAIH,kBAAuE;CAChF,QAA0B,cAAsB;CAEhD,MAAe,YACd,aACa;EACb,MAAM,gBAAgB,KAAK,KAAK;EAChC,MAAM,KAAK,IAAI,cACd,SACA,KAAK,SACL,KAAK,SACL,KAAK,WACL,KAAK,QACL,KAAK,cAAc,GACnB,QACA,KAAK,YACL;AACD,QAAM,KAAK,QAAQ,IAAI,IAAI,IAAI,aAAa,gBAAgB,CAAC;AAC7D,MAAI;GACH,MAAM,SAAS,MAAM,YAAY,GAAG;AACpC,SAAM,KAAK,QAAQ,IAAI,IAAI,IAAI,qBAAqB,gBAAgB,CAAC;AACrE,UAAO;WACC,KAAK;AACb,SAAM,KAAK,QAAQ,IAAI,IAAI,IAAI,yBAAyB,gBAAgB,CAAC;AACzE,SAAM;;;;;;;;;;AAWT,SAAS,eAAe,SAAc;CACrC,MAAMC,OAAoB,EAAE;AAC5B,MAAK,MAAM,OAAO,SAAS;EAC1B,MAAM,QAAQ,OAAO,KAAK,IAAI,CAAC,KAAK,MAAM,IAAI,GAAG;AACjD,OAAK,KAAK,MAAM;;AAEjB,QAAO;;AAGR,IAAa,kBAAb,cACSC,sBAGT;CACC,QAA0B,cAAsB;;CAGhD;;CAGA;CAEA,YACC,MACA,OACA,AAAQC,QACR,OACA,eAIA,aACA,QACA,eACA,AAAQC,wBACR,AAAQC,oBAGR,AAAQC,cACP;AACD,QAAM,SAAS,eAAe,OAAO,OAAO,eAAe,YAAY;EAf/D;EASA;EACA;EAGA;AAGR,OAAK,SAAS;AACd,OAAK,OAAO;;CAGb,MAAM,IAAI,mBAAkE;EAC3E,MAAM,SAAS,iBAAiB,KAAK,MAAM,QAAQ,qBAAqB,EAAE,CAAC;AAC3E,OAAK,OAAO,SAAS,KAAK,MAAM,KAAK,OAAO;AAC5C,SAAO,MAAM,KAAK,eAAe,KAAK,MAAM,KAAK,QAAQ,YAAY;AACpE,UAAO,KAAK,KAAK,KAAK,GAAG,OAAO,CAAC,KAAK;IACrC;;CAGH,MAAM,IAAI,mBAAgE;AACzE,MAAI,KAAK,aAAc,QAAO,KAAK,SAAS,kBAAkB;EAE9D,MAAM,EAAE,QAAQ,OAAO,QAAQ,MAAM,uBAAuB;AAC5D,MAAI,CAAC,UAAU,CAAC,oBAAoB;GACnC,MAAM,SAAS,iBAAiB,MAAM,QAAQ,qBAAqB,EAAE,CAAC;AACtE,UAAO,SAAS,MAAM,KAAK,OAAO;AAClC,UAAO,MAAM,KAAK,eAAe,MAAM,KAAK,QAAQ,YAAY;AAC/D,WAAO,KAAK,KAAK,GAAG,OAAO,CAAC,KAAK,CAAC,MAAM,EAAE,cAAc,KAAK,aAAa,QAAS,CAAC;KACnF;;EAGH,MAAM,OAAO,MAAM,KAAK,OAAO,kBAAkB;AAEjD,SAAO,KAAK,aAAa,KAAK;;CAG/B,MAAc,SAAS,mBAAgE;EACtF,MAAM,EAAE,OAAO,QAAQ,MAAM,uBAAuB;EAEpD,MAAM,SAAS,iBAAiB,MAAM,QAAQ,qBAAqB,EAAE,CAAC;AACtE,SAAO,SAAS,MAAM,KAAK,OAAO;AAClC,SAAO,KAAK,KAAK,GAAG,OAAO,CAAC,KAAK,CAAC,MAAM,EAAE,cACxC,mBAAoE,QAAS,CAC9E;;CAGF,AAAS,aAAa,MAAe,aAAgC;AACpE,MAAI,YACH,QAAO,KAAK,eAAgB,KAAkB,UAAU,eAAgB,KAAkB,QAAQ;AAGnG,MAAI,CAAC,KAAK,UAAU,CAAC,KAAK,mBACzB,QAAO;AAGR,MAAI,KAAK,mBACR,QAAQ,KAAK,mBAAsD,KAAoB;AAGxF,SAAQ,KAAqB,KAAK,QAAQ,aAAa,KAAK,QAAS,KAAK,KAAK,oBAAoB,CAAC;;CAGrG,MAAM,IAAI,mBAAgE;AACzE,MAAI,KAAK,aAAc,QAAO,KAAK,SAAS,kBAAkB;EAE9D,MAAM,EAAE,QAAQ,qBAAqB,OAAO,QAAQ,MAAM,uBAAuB;AACjF,MAAI,CAAC,UAAU,CAAC,oBAAoB;GACnC,MAAM,SAAS,iBAAiB,MAAM,QAAQ,qBAAqB,EAAE,CAAC;AACtE,UAAO,SAAS,MAAM,KAAK,OAAO;AAClC,UAAO,MAAM,KAAK,eAAe,MAAM,KAAK,QAAQ,YAAY;AAC/D,WAAO,KAAK,KAAK,GAAG,OAAO,CAAC,KAAK,CAAC,MAAM,EAAE,cAAc,QAAS,GAAG;KACnE;;EAGH,MAAM,OAAO,MAAM,KAAK,OAAO,kBAAkB;AAEjD,MAAI,CAAC,KAAK,GACT;AAGD,MAAI,mBACH,QAAQ,mBAAsD,KAAK;AAGpE,SAAO,aAAa,QAAS,KAAK,IAAI,oBAAoB;;CAG3D,MAAc,SAAS,mBAAgE;EACtF,MAAM,EAAE,OAAO,QAAQ,MAAM,uBAAuB;EAEpD,MAAM,SAAS,iBAAiB,MAAM,QAAQ,qBAAqB,EAAE,CAAC;AACtE,SAAO,SAAS,MAAM,KAAK,OAAO;EAClC,MAAM,EAAE,SAAS,SAAS,MAAM,KAAK,KAAK,GAAG,OAAO,CAAC,KAAK;AAE1D,MAAI,CAAC,KAAK,GACT;AAGD,SAAQ,mBAAoE,KAAK;;CAGlF,AAAS,aAAa,QAAiB,aAAgC;AACtE,MAAI,YACH,UAAS,KAAK,eAAgB,OAAoB,QAAQ,KAAK,eAAgB,OAAoB,QAAQ,CAAC;AAG7G,MAAI,CAAC,KAAK,UAAU,CAAC,KAAK,mBACzB,QAAO;AAGR,MAAI,KAAK,mBACR,QAAQ,KAAK,mBAAsD,CAAC,OAAoB,CAAC;AAG1F,SAAO,aAAa,KAAK,QAAS,QAAqB,KAAK,oBAAoB;;CAGjF,MAAM,OAAoC,mBAA2D;EACpG,MAAM,SAAS,iBAAiB,KAAK,MAAM,QAAQ,qBAAqB,EAAE,CAAC;AAC3E,OAAK,OAAO,SAAS,KAAK,MAAM,KAAK,OAAO;AAC5C,SAAO,MAAM,KAAK,eAAe,KAAK,MAAM,KAAK,QAAQ,YAAY;AACpE,UAAO,KAAK,KAAK,KAAK,GAAG,OAAO,CAAC,KAAK;IACrC;;;CAIH,wBAAiC;AAChC,SAAO,KAAK"}