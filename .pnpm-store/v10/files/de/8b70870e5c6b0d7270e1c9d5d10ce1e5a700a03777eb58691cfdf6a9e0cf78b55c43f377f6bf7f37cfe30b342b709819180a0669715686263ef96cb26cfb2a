{"version":3,"sources":["../../src/telemetry/storage.ts"],"sourcesContent":["import type { BinaryLike } from 'crypto'\nimport { bold, cyan, magenta } from '../lib/picocolors'\nimport Conf from 'next/dist/compiled/conf'\nimport { createHash, randomBytes } from 'crypto'\nimport isDockerFunction from 'next/dist/compiled/is-docker'\nimport path from 'path'\n\nimport { getAnonymousMeta } from './anonymous-meta'\nimport * as ciEnvironment from '../server/ci-info'\nimport { postNextTelemetryPayload } from './post-telemetry-payload'\nimport { getRawProjectId } from './project-id'\nimport { AbortController } from 'next/dist/compiled/@edge-runtime/ponyfill'\nimport fs from 'fs'\n\n// This is the key that stores whether or not telemetry is enabled or disabled.\nconst TELEMETRY_KEY_ENABLED = 'telemetry.enabled'\n\n// This is the key that specifies when the user was informed about anonymous\n// telemetry collection.\nconst TELEMETRY_KEY_NOTIFY_DATE = 'telemetry.notifiedAt'\n\n// This is a quasi-persistent identifier used to dedupe recurring events. It's\n// generated from random data and completely anonymous.\nconst TELEMETRY_KEY_ID = `telemetry.anonymousId`\n\n// This is the cryptographic salt that is included within every hashed value.\n// This salt value is never sent to us, ensuring privacy and the one-way nature\n// of the hash (prevents dictionary lookups of pre-computed hashes).\n// See the `oneWayHash` function.\nconst TELEMETRY_KEY_SALT = `telemetry.salt`\n\nexport type TelemetryEvent = { eventName: string; payload: object }\n\ntype RecordObject = {\n  isFulfilled: boolean\n  isRejected: boolean\n  value?: any\n  reason?: any\n}\n\nfunction getStorageDirectory(distDir: string): string | undefined {\n  const isLikelyEphemeral = ciEnvironment.isCI || isDockerFunction()\n\n  if (isLikelyEphemeral) {\n    return path.join(distDir, 'cache')\n  }\n\n  return undefined\n}\n\nexport class Telemetry {\n  readonly sessionId: string\n\n  private conf: Conf<any> | null\n  private distDir: string\n  private loadProjectId: undefined | string | Promise<string>\n  private NEXT_TELEMETRY_DISABLED: any\n  private NEXT_TELEMETRY_DEBUG: any\n\n  private queue: Set<Promise<RecordObject>>\n\n  constructor({ distDir }: { distDir: string }) {\n    // Read in the constructor so that .env can be loaded before reading\n    const { NEXT_TELEMETRY_DISABLED, NEXT_TELEMETRY_DEBUG } = process.env\n    this.NEXT_TELEMETRY_DISABLED = NEXT_TELEMETRY_DISABLED\n    this.NEXT_TELEMETRY_DEBUG = NEXT_TELEMETRY_DEBUG\n    this.distDir = distDir\n    const storageDirectory = getStorageDirectory(distDir)\n\n    try {\n      // `conf` incorrectly throws a permission error during initialization\n      // instead of waiting for first use. We need to handle it, otherwise the\n      // process may crash.\n      this.conf = new Conf({ projectName: 'nextjs', cwd: storageDirectory })\n    } catch (_) {\n      this.conf = null\n    }\n    this.sessionId = randomBytes(32).toString('hex')\n    this.queue = new Set()\n\n    this.notify()\n  }\n\n  private notify = () => {\n    if (this.isDisabled || !this.conf) {\n      return\n    }\n\n    // The end-user has already been notified about our telemetry integration. We\n    // don't need to constantly annoy them about it.\n    // We will re-inform users about the telemetry if significant changes are\n    // ever made.\n    if (this.conf.get(TELEMETRY_KEY_NOTIFY_DATE, '')) {\n      return\n    }\n    this.conf.set(TELEMETRY_KEY_NOTIFY_DATE, Date.now().toString())\n\n    console.log(\n      `${magenta(\n        bold('Attention')\n      )}: Next.js now collects completely anonymous telemetry regarding usage.`\n    )\n    console.log(\n      `This information is used to shape Next.js' roadmap and prioritize features.`\n    )\n    console.log(\n      `You can learn more, including how to opt-out if you'd not like to participate in this anonymous program, by visiting the following URL:`\n    )\n    console.log(cyan('https://nextjs.org/telemetry'))\n    console.log()\n  }\n\n  get anonymousId(): string {\n    const val = this.conf && this.conf.get(TELEMETRY_KEY_ID)\n    if (val) {\n      return val\n    }\n\n    const generated = randomBytes(32).toString('hex')\n    this.conf && this.conf.set(TELEMETRY_KEY_ID, generated)\n    return generated\n  }\n\n  get salt(): string {\n    const val = this.conf && this.conf.get(TELEMETRY_KEY_SALT)\n    if (val) {\n      return val\n    }\n\n    const generated = randomBytes(16).toString('hex')\n    this.conf && this.conf.set(TELEMETRY_KEY_SALT, generated)\n    return generated\n  }\n\n  private get isDisabled(): boolean {\n    if (!!this.NEXT_TELEMETRY_DISABLED || !this.conf) {\n      return true\n    }\n    return this.conf.get(TELEMETRY_KEY_ENABLED, true) === false\n  }\n\n  setEnabled = (_enabled: boolean) => {\n    const enabled = !!_enabled\n    this.conf && this.conf.set(TELEMETRY_KEY_ENABLED, enabled)\n    return this.conf && this.conf.path\n  }\n\n  get isEnabled(): boolean {\n    return (\n      !this.NEXT_TELEMETRY_DISABLED &&\n      !!this.conf &&\n      this.conf.get(TELEMETRY_KEY_ENABLED, true) !== false\n    )\n  }\n\n  oneWayHash = (payload: BinaryLike): string => {\n    const hash = createHash('sha256')\n\n    // Always prepend the payload value with salt. This ensures the hash is truly\n    // one-way.\n    hash.update(this.salt)\n\n    // Update is an append operation, not a replacement. The salt from the prior\n    // update is still present!\n    hash.update(payload)\n    return hash.digest('hex')\n  }\n\n  private async getProjectId(): Promise<string> {\n    this.loadProjectId = this.loadProjectId || getRawProjectId()\n    return this.oneWayHash(await this.loadProjectId)\n  }\n\n  record = (\n    _events: TelemetryEvent | TelemetryEvent[],\n    deferred?: boolean\n  ): Promise<RecordObject> => {\n    const prom = (\n      deferred\n        ? // if we know we are going to immediately call\n          // flushDetached we can skip starting the initial\n          // submitRecord which will then be cancelled\n          new Promise((resolve) =>\n            resolve({\n              isFulfilled: true,\n              isRejected: false,\n              value: _events,\n            })\n          )\n        : this.submitRecord(_events)\n    )\n      .then((value) => ({\n        isFulfilled: true,\n        isRejected: false,\n        value,\n      }))\n      .catch((reason) => ({\n        isFulfilled: false,\n        isRejected: true,\n        reason,\n      }))\n      // Acts as `Promise#finally` because `catch` transforms the error\n      .then((res) => {\n        // Clean up the event to prevent unbounded `Set` growth\n        if (!deferred) {\n          this.queue.delete(prom)\n        }\n        return res\n      })\n\n    ;(prom as any)._events = Array.isArray(_events) ? _events : [_events]\n    ;(prom as any)._controller = (prom as any)._controller\n    // Track this `Promise` so we can flush pending events\n    this.queue.add(prom)\n\n    return prom\n  }\n\n  flush = async () => {\n    return Promise.all(this.queue).catch(() => null)\n  }\n\n  // writes current events to disk and spawns separate\n  // detached process to submit the records without blocking\n  // the main process from exiting\n  flushDetached = (mode: 'dev', dir: string) => {\n    const allEvents: TelemetryEvent[] = []\n\n    this.queue.forEach((item: any) => {\n      try {\n        item._controller?.abort()\n        allEvents.push(...item._events)\n      } catch (_) {\n        // if we fail to abort ignore this event\n      }\n    })\n\n    if (allEvents.length === 0) {\n      // No events to flush\n      return\n    }\n\n    fs.mkdirSync(this.distDir, { recursive: true })\n    // Use unique filename per process to avoid race conditions between parent/child\n    const eventsFile = `_events_${process.pid}.json`\n    fs.writeFileSync(\n      path.join(this.distDir, eventsFile),\n      JSON.stringify(allEvents)\n    )\n\n    // Note: cross-spawn is not used here as it causes\n    // a new command window to appear when we don't want it to\n    const child_process =\n      require('child_process') as typeof import('child_process')\n\n    // we use spawnSync when debugging to ensure logs are piped\n    // correctly to stdout/stderr\n    const spawn = this.NEXT_TELEMETRY_DEBUG\n      ? child_process.spawnSync\n      : child_process.spawn\n\n    spawn(\n      process.execPath,\n      [require.resolve('./detached-flush'), mode, dir, eventsFile],\n      {\n        detached: !this.NEXT_TELEMETRY_DEBUG,\n        windowsHide: true,\n        shell: false,\n        ...(this.NEXT_TELEMETRY_DEBUG\n          ? {\n              stdio: 'inherit',\n            }\n          : {}),\n      }\n    )\n  }\n\n  private submitRecord = async (\n    _events: TelemetryEvent | TelemetryEvent[]\n  ): Promise<any> => {\n    let events: TelemetryEvent[]\n    if (Array.isArray(_events)) {\n      events = _events\n    } else {\n      events = [_events]\n    }\n\n    if (events.length < 1) {\n      return Promise.resolve()\n    }\n\n    if (this.NEXT_TELEMETRY_DEBUG) {\n      // Return a promise that resolves after logging to ensure the output\n      // is captured before the process exits (e.g., during flushDetached)\n      return new Promise((resolve) => {\n        setTimeout(() => {\n          // Print to standard error to simplify selecting the output\n          events.forEach(({ eventName, payload }) =>\n            console.error(\n              `[telemetry] ` + JSON.stringify({ eventName, payload }, null, 2)\n            )\n          )\n          resolve(undefined)\n        }, 100)\n      })\n    }\n\n    // Skip recording telemetry if the feature is disabled\n    if (this.isDisabled) {\n      return Promise.resolve()\n    }\n\n    const postController = new AbortController()\n    const res = postNextTelemetryPayload(\n      {\n        context: {\n          anonymousId: this.anonymousId,\n          projectId: await this.getProjectId(),\n          sessionId: this.sessionId,\n        },\n        meta: getAnonymousMeta(),\n        events: events.map(({ eventName, payload }) => ({\n          eventName,\n          fields: payload,\n        })),\n      },\n      postController.signal\n    )\n    res._controller = postController\n    return res\n  }\n}\n"],"names":["Telemetry","TELEMETRY_KEY_ENABLED","TELEMETRY_KEY_NOTIFY_DATE","TELEMETRY_KEY_ID","TELEMETRY_KEY_SALT","getStorageDirectory","distDir","isLikelyEphemeral","ciEnvironment","isCI","isDockerFunction","path","join","undefined","constructor","notify","isDisabled","conf","get","set","Date","now","toString","console","log","magenta","bold","cyan","setEnabled","_enabled","enabled","oneWayHash","payload","hash","createHash","update","salt","digest","record","_events","deferred","prom","Promise","resolve","isFulfilled","isRejected","value","submitRecord","then","catch","reason","res","queue","delete","Array","isArray","_controller","add","flush","all","flushDetached","mode","dir","allEvents","forEach","item","abort","push","_","length","fs","mkdirSync","recursive","eventsFile","process","pid","writeFileSync","JSON","stringify","child_process","require","spawn","NEXT_TELEMETRY_DEBUG","spawnSync","execPath","detached","windowsHide","shell","stdio","events","setTimeout","eventName","error","postController","AbortController","postNextTelemetryPayload","context","anonymousId","projectId","getProjectId","sessionId","meta","getAnonymousMeta","map","fields","signal","NEXT_TELEMETRY_DISABLED","env","storageDirectory","Conf","projectName","cwd","randomBytes","Set","val","generated","isEnabled","loadProjectId","getRawProjectId"],"mappings":"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","ignoreList":[0]}