{"version":3,"file":"session.cjs","names":["MySqlPreparedQuery","entityKind","client: BunSQL","query: string","params: unknown[]","logger: Logger","fields: SelectedFieldsOrdered | undefined","customResultMapper?: (\n\t\t\trows: TIsRqbV2 extends true ? Record<string, unknown>[] : unknown[][],\n\t\t) => T['execute']","generatedIds?: Record<string, unknown>[]","returningIds?: SelectedFieldsOrdered","isRqbV2Query?: TIsRqbV2","Column","MySqlSession","client: TSQL","relations: TRelations","schema: V1.RelationalSchemaConfig<TSchema> | undefined","options: BunMySqlSessionOptions","NoopLogger","NoopCache","MySqlTransaction"],"sources":["../../../src/bun-sql/mysql/session.ts"],"sourcesContent":["/// <reference types=\"bun-types\" />\n\nimport type { SavepointSQL, SQL as BunSQL, TransactionSQL } from 'bun';\nimport type * as V1 from '~/_relations.ts';\nimport { type Cache, NoopCache } from '~/cache/core/index.ts';\nimport type { WithCacheConfig } from '~/cache/core/types.ts';\nimport { Column } from '~/column.ts';\nimport { entityKind, is } from '~/entity.ts';\nimport type { Logger } from '~/logger.ts';\nimport { NoopLogger } from '~/logger.ts';\nimport type { MySqlDialect } from '~/mysql-core/dialect.ts';\nimport type { SelectedFieldsOrdered } from '~/mysql-core/query-builders/select.types.ts';\nimport {\n\ttype Mode,\n\tMySqlPreparedQuery,\n\ttype MySqlPreparedQueryConfig,\n\ttype MySqlPreparedQueryHKT,\n\ttype MySqlQueryResultHKT,\n\tMySqlSession,\n\tMySqlTransaction,\n\ttype MySqlTransactionConfig,\n\ttype PreparedQueryKind,\n} from '~/mysql-core/session.ts';\nimport type { AnyRelations } from '~/relations.ts';\nimport { fillPlaceholders } from '~/sql/sql.ts';\nimport type { Query, SQL } from '~/sql/sql.ts';\nimport { type Assume, mapResultRow } from '~/utils.ts';\n\nexport class BunMySqlPreparedQuery<T extends MySqlPreparedQueryConfig, TIsRqbV2 extends boolean = false>\n\textends MySqlPreparedQuery<T>\n{\n\tstatic override readonly [entityKind]: string = 'BunMySqlPreparedQuery';\n\n\tconstructor(\n\t\tprivate client: BunSQL,\n\t\tprivate query: string,\n\t\tprivate params: unknown[],\n\t\tprivate logger: Logger,\n\t\tcache: Cache,\n\t\tqueryMetadata: {\n\t\t\ttype: 'select' | 'update' | 'delete' | 'insert';\n\t\t\ttables: string[];\n\t\t} | undefined,\n\t\tcacheConfig: WithCacheConfig | undefined,\n\t\tprivate fields: SelectedFieldsOrdered | undefined,\n\t\tprivate customResultMapper?: (\n\t\t\trows: TIsRqbV2 extends true ? Record<string, unknown>[] : unknown[][],\n\t\t) => T['execute'],\n\t\t// Keys that were used in $default and the value that was generated for them\n\t\tprivate generatedIds?: Record<string, unknown>[],\n\t\t// Keys that should be returned, it has the column with all properries + key from object\n\t\tprivate returningIds?: SelectedFieldsOrdered,\n\t\tprivate isRqbV2Query?: TIsRqbV2,\n\t) {\n\t\tsuper(cache, queryMetadata, cacheConfig);\n\t}\n\n\tasync execute(placeholderValues: Record<string, unknown> = {}): Promise<T['execute']> {\n\t\tif (this.isRqbV2Query) return this.executeRqbV2(placeholderValues);\n\n\t\tconst {\n\t\t\tfields,\n\t\t\tclient,\n\t\t\tlogger,\n\t\t\tparams: rawParams,\n\t\t\tquery,\n\t\t\tjoinsNotNullableMap,\n\t\t\tcustomResultMapper,\n\t\t\treturningIds,\n\t\t\tgeneratedIds,\n\t\t} = this;\n\t\tconst params = fillPlaceholders(rawParams, placeholderValues);\n\n\t\tlogger.logQuery(query, params);\n\n\t\tif (!fields && !customResultMapper) {\n\t\t\tconst res = await this.queryWithCache(query, params, async () => {\n\t\t\t\treturn await client.unsafe(query, params);\n\t\t\t});\n\n\t\t\tconst insertId = res.lastInsertRowid;\n\t\t\tconst affectedRows = res.affectedRows;\n\t\t\t// for each row, I need to check keys from\n\t\t\tif (returningIds) {\n\t\t\t\tconst returningResponse = [];\n\t\t\t\tlet j = 0;\n\t\t\t\tfor (let i = insertId; i < insertId + affectedRows; i++) {\n\t\t\t\t\tfor (const column of returningIds) {\n\t\t\t\t\t\tconst key = returningIds[0]!.path[0]!;\n\t\t\t\t\t\tif (is(column.field, Column)) {\n\t\t\t\t\t\t\t// @ts-ignore\n\t\t\t\t\t\t\tif (column.field.primary && column.field.autoIncrement) {\n\t\t\t\t\t\t\t\treturningResponse.push({ [key]: i });\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (column.field.defaultFn && generatedIds) {\n\t\t\t\t\t\t\t\t// generatedIds[rowIdx][key]\n\t\t\t\t\t\t\t\treturningResponse.push({ [key]: generatedIds[j]![key] });\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tj++;\n\t\t\t\t}\n\n\t\t\t\treturn returningResponse;\n\t\t\t}\n\n\t\t\treturn res;\n\t\t}\n\n\t\tconst rows = await this.queryWithCache(query, params, async () => {\n\t\t\treturn await client.unsafe(query, params).values();\n\t\t});\n\n\t\tif (customResultMapper) {\n\t\t\treturn customResultMapper(rows);\n\t\t}\n\n\t\treturn rows.map((row: unknown[]) => mapResultRow<T['execute']>(fields!, row, joinsNotNullableMap));\n\t}\n\n\tprivate async executeRqbV2(placeholderValues: Record<string, unknown> = {}): Promise<T['execute']> {\n\t\tconst params = fillPlaceholders(this.params, placeholderValues);\n\n\t\tthis.logger.logQuery(this.query, params);\n\n\t\tconst { client, query, customResultMapper } = this;\n\t\tconst rows = await client.unsafe(query, params);\n\n\t\treturn (customResultMapper as (rows: Record<string, unknown>[]) => T['execute'])(rows);\n\t}\n\n\tasync *iterator(\n\t\tplaceholderValues: Record<string, unknown> = {},\n\t): AsyncGenerator<T['execute'] extends any[] ? T['execute'][number] : T['execute']> {\n\t\tconst { fields, params: queryParams, query, joinsNotNullableMap, client, customResultMapper } = this;\n\t\tconst params = fillPlaceholders(queryParams, placeholderValues);\n\t\tconst rows = await this.queryWithCache(query, params, async () => {\n\t\t\treturn await client.unsafe(query, params).values();\n\t\t});\n\t\tconst hasRowsMapper = Boolean(fields || customResultMapper);\n\n\t\tfor (const row of rows) {\n\t\t\tif (row === undefined || (Array.isArray(row) && row.length === 0)) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (hasRowsMapper) {\n\t\t\t\tif (customResultMapper) {\n\t\t\t\t\tconst mappedRow = (customResultMapper as (rows: unknown[][]) => T['execute'])([row as unknown[]]);\n\t\t\t\t\tyield (Array.isArray(mappedRow) ? mappedRow[0] : mappedRow);\n\t\t\t\t} else {\n\t\t\t\t\tyield mapResultRow(fields!, row as unknown[], joinsNotNullableMap);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tyield row as T['execute'];\n\t\t\t}\n\t\t}\n\t}\n}\n\nexport interface BunMySqlSessionOptions {\n\tlogger?: Logger;\n\tcache?: Cache;\n\tmode: Mode;\n}\n\nexport class BunMySqlSession<\n\tTSQL extends BunSQL,\n\tTFullSchema extends Record<string, unknown>,\n\tTRelations extends AnyRelations,\n\tTSchema extends V1.TablesRelationalConfig,\n> extends MySqlSession<MySqlQueryResultHKT, BunMySqlPreparedQueryHKT, TFullSchema, TRelations, TSchema> {\n\tstatic override readonly [entityKind]: string = 'BunMySqlSession';\n\n\tprivate logger: Logger;\n\tprivate mode: Mode;\n\tprivate cache: Cache;\n\n\tconstructor(\n\t\treadonly client: TSQL,\n\t\tdialect: MySqlDialect,\n\t\tprivate relations: TRelations,\n\t\tprivate schema: V1.RelationalSchemaConfig<TSchema> | undefined,\n\t\treadonly options: BunMySqlSessionOptions,\n\t) {\n\t\tsuper(dialect);\n\t\tthis.logger = options.logger ?? new NoopLogger();\n\t\tthis.cache = options.cache ?? new NoopCache();\n\t\tthis.mode = options.mode;\n\t}\n\n\tprepareQuery<T extends MySqlPreparedQueryConfig>(\n\t\tquery: Query,\n\t\tfields: SelectedFieldsOrdered | undefined,\n\t\tcustomResultMapper?: (rows: unknown[][]) => T['execute'],\n\t\tgeneratedIds?: Record<string, unknown>[],\n\t\treturningIds?: SelectedFieldsOrdered,\n\t\tqueryMetadata?: {\n\t\t\ttype: 'select' | 'update' | 'delete' | 'insert';\n\t\t\ttables: string[];\n\t\t},\n\t\tcacheConfig?: WithCacheConfig,\n\t): PreparedQueryKind<BunMySqlPreparedQueryHKT, T> {\n\t\t// Add returningId fields\n\t\t// Each driver gets them from response from database\n\t\treturn new BunMySqlPreparedQuery(\n\t\t\tthis.client,\n\t\t\tquery.sql,\n\t\t\tquery.params,\n\t\t\tthis.logger,\n\t\t\tthis.cache,\n\t\t\tqueryMetadata,\n\t\t\tcacheConfig,\n\t\t\tfields,\n\t\t\tcustomResultMapper,\n\t\t\tgeneratedIds,\n\t\t\treturningIds,\n\t\t) as PreparedQueryKind<BunMySqlPreparedQueryHKT, T>;\n\t}\n\n\tprepareRelationalQuery<T extends MySqlPreparedQueryConfig>(\n\t\tquery: Query,\n\t\tfields: SelectedFieldsOrdered | undefined,\n\t\tcustomResultMapper: (rows: Record<string, unknown>[]) => T['execute'],\n\t\tgeneratedIds?: Record<string, unknown>[],\n\t\treturningIds?: SelectedFieldsOrdered,\n\t): PreparedQueryKind<BunMySqlPreparedQueryHKT, T> {\n\t\t// Add returningId fields\n\t\t// Each driver gets them from response from database\n\t\treturn new BunMySqlPreparedQuery(\n\t\t\tthis.client,\n\t\t\tquery.sql,\n\t\t\tquery.params,\n\t\t\tthis.logger,\n\t\t\tthis.cache,\n\t\t\tundefined,\n\t\t\tundefined,\n\t\t\tfields,\n\t\t\tcustomResultMapper,\n\t\t\tgeneratedIds,\n\t\t\treturningIds,\n\t\t\ttrue,\n\t\t) as any;\n\t}\n\n\t/** @internal */\n\tasync query(query: string, params: unknown[]): Promise<Record<string, unknown>[]> {\n\t\tthis.logger.logQuery(query, params);\n\t\tconst result = await this.client.unsafe(query, params);\n\t\treturn result;\n\t}\n\n\toverride all<T = unknown>(query: SQL): Promise<T[]> {\n\t\tconst querySql = this.dialect.sqlToQuery(query);\n\t\tthis.logger.logQuery(querySql.sql, querySql.params);\n\t\treturn this.client.unsafe(querySql.sql, querySql.params);\n\t}\n\n\toverride async count(sql: SQL): Promise<number> {\n\t\tconst query = this.dialect.sqlToQuery(sql);\n\t\tconst data = await this.client.unsafe(query.sql, query.params).values();\n\n\t\tconst count = data[0][0];\n\t\tif (typeof count === 'number') return count;\n\t\treturn Number(count);\n\t}\n\n\toverride async transaction<T>(\n\t\ttransaction: (tx: BunMySqlTransaction<TFullSchema, TRelations, TSchema>) => Promise<T>,\n\t\tconfig?: MySqlTransactionConfig,\n\t): Promise<T> {\n\t\tconst startTransactionSql = config\n\t\t\t? this.getStartTransactionSQL(config)?.inlineParams().toQuery(this.dialect).sql.slice(18) ?? ''\n\t\t\t: '';\n\n\t\tif (config?.isolationLevel) throw new Error(\"Driver doesn't support setting isolation level on transaction\");\n\n\t\treturn this.client.begin(startTransactionSql, async (client) => {\n\t\t\tconst session = new BunMySqlSession<TransactionSQL, TFullSchema, TRelations, TSchema>(\n\t\t\t\tclient,\n\t\t\t\tthis.dialect,\n\t\t\t\tthis.relations,\n\t\t\t\tthis.schema,\n\t\t\t\tthis.options,\n\t\t\t);\n\t\t\tconst tx = new BunMySqlTransaction<TFullSchema, TRelations, TSchema>(\n\t\t\t\tthis.dialect,\n\t\t\t\tsession as MySqlSession<any, any, any, any, any>,\n\t\t\t\tthis.relations,\n\t\t\t\tthis.schema,\n\t\t\t\t0,\n\t\t\t\tthis.mode,\n\t\t\t);\n\t\t\t// if (config) {\n\t\t\t// \tconst setTransactionConfigSql = this.getSetTransactionSQL(config);\n\t\t\t// \tif (setTransactionConfigSql) {\n\t\t\t// \t\tawait tx.execute(setTransactionConfigSql);\n\t\t\t// \t}\n\t\t\t// }\n\t\t\treturn transaction(tx);\n\t\t}) as Promise<T>;\n\t}\n}\n\nexport class BunMySqlTransaction<\n\tTFullSchema extends Record<string, unknown>,\n\tTRelations extends AnyRelations,\n\tTSchema extends V1.TablesRelationalConfig,\n> extends MySqlTransaction<\n\tBunMySqlQueryResultHKT,\n\tBunMySqlPreparedQueryHKT,\n\tTFullSchema,\n\tTRelations,\n\tTSchema\n> {\n\tstatic override readonly [entityKind]: string = 'BunMySqlTransaction';\n\n\toverride async transaction<T>(\n\t\ttransaction: (tx: BunMySqlTransaction<TFullSchema, TRelations, TSchema>) => Promise<T>,\n\t): Promise<T> {\n\t\treturn (<BunMySqlSession<TransactionSQL, any, any, any>> this.session).client.savepoint((client) => {\n\t\t\tconst session = new BunMySqlSession<SavepointSQL, TFullSchema, TRelations, TSchema>(\n\t\t\t\tclient,\n\t\t\t\tthis.dialect,\n\t\t\t\tthis.relations,\n\t\t\t\tthis.schema,\n\t\t\t\t(<BunMySqlSession<any, any, any, any>> this.session).options,\n\t\t\t);\n\t\t\tconst tx = new BunMySqlTransaction<TFullSchema, TRelations, TSchema>(\n\t\t\t\tthis.dialect,\n\t\t\t\tsession as MySqlSession<any, any, any, any, any>,\n\t\t\t\tthis.relations,\n\t\t\t\tthis.schema,\n\t\t\t\tthis.nestedIndex + 1,\n\t\t\t\tthis.mode,\n\t\t\t);\n\t\t\treturn transaction(tx);\n\t\t}) as Promise<T>;\n\t}\n}\n\nexport interface BunMySqlQueryResultHKT extends MySqlQueryResultHKT {\n\ttype: Record<string, unknown>[] & Record<string, unknown>;\n}\n\nexport interface BunMySqlPreparedQueryHKT extends MySqlPreparedQueryHKT {\n\ttype: BunMySqlPreparedQuery<Assume<this['config'], MySqlPreparedQueryConfig>>;\n}\n"],"mappings":";;;;;;;;;;AA4BA,IAAa,wBAAb,cACSA,2CACT;CACC,QAA0BC,0BAAsB;CAEhD,YACC,AAAQC,QACR,AAAQC,OACR,AAAQC,QACR,AAAQC,QACR,OACA,eAIA,aACA,AAAQC,QACR,AAAQC,oBAIR,AAAQC,cAER,AAAQC,cACR,AAAQC,cACP;AACD,QAAM,OAAO,eAAe,YAAY;EApBhC;EACA;EACA;EACA;EAOA;EACA;EAIA;EAEA;EACA;;CAKT,MAAM,QAAQ,oBAA6C,EAAE,EAAyB;AACrF,MAAI,KAAK,aAAc,QAAO,KAAK,aAAa,kBAAkB;EAElE,MAAM,EACL,QACA,QACA,QACA,QAAQ,WACR,OACA,qBACA,oBACA,cACA,iBACG;EACJ,MAAM,4CAA0B,WAAW,kBAAkB;AAE7D,SAAO,SAAS,OAAO,OAAO;AAE9B,MAAI,CAAC,UAAU,CAAC,oBAAoB;GACnC,MAAM,MAAM,MAAM,KAAK,eAAe,OAAO,QAAQ,YAAY;AAChE,WAAO,MAAM,OAAO,OAAO,OAAO,OAAO;KACxC;GAEF,MAAM,WAAW,IAAI;GACrB,MAAM,eAAe,IAAI;AAEzB,OAAI,cAAc;IACjB,MAAM,oBAAoB,EAAE;IAC5B,IAAI,IAAI;AACR,SAAK,IAAI,IAAI,UAAU,IAAI,WAAW,cAAc,KAAK;AACxD,UAAK,MAAM,UAAU,cAAc;MAClC,MAAM,MAAM,aAAa,GAAI,KAAK;AAClC,8BAAO,OAAO,OAAOC,mBAAO,EAAE;AAE7B,WAAI,OAAO,MAAM,WAAW,OAAO,MAAM,cACxC,mBAAkB,KAAK,GAAG,MAAM,GAAG,CAAC;AAErC,WAAI,OAAO,MAAM,aAAa,aAE7B,mBAAkB,KAAK,GAAG,MAAM,aAAa,GAAI,MAAM,CAAC;;;AAI3D;;AAGD,WAAO;;AAGR,UAAO;;EAGR,MAAM,OAAO,MAAM,KAAK,eAAe,OAAO,QAAQ,YAAY;AACjE,UAAO,MAAM,OAAO,OAAO,OAAO,OAAO,CAAC,QAAQ;IACjD;AAEF,MAAI,mBACH,QAAO,mBAAmB,KAAK;AAGhC,SAAO,KAAK,KAAK,qCAA8C,QAAS,KAAK,oBAAoB,CAAC;;CAGnG,MAAc,aAAa,oBAA6C,EAAE,EAAyB;EAClG,MAAM,4CAA0B,KAAK,QAAQ,kBAAkB;AAE/D,OAAK,OAAO,SAAS,KAAK,OAAO,OAAO;EAExC,MAAM,EAAE,QAAQ,OAAO,uBAAuB;AAG9C,SAAQ,mBAFK,MAAM,OAAO,OAAO,OAAO,OAAO,CAEuC;;CAGvF,OAAO,SACN,oBAA6C,EAAE,EACoC;EACnF,MAAM,EAAE,QAAQ,QAAQ,aAAa,OAAO,qBAAqB,QAAQ,uBAAuB;EAChG,MAAM,4CAA0B,aAAa,kBAAkB;EAC/D,MAAM,OAAO,MAAM,KAAK,eAAe,OAAO,QAAQ,YAAY;AACjE,UAAO,MAAM,OAAO,OAAO,OAAO,OAAO,CAAC,QAAQ;IACjD;EACF,MAAM,gBAAgB,QAAQ,UAAU,mBAAmB;AAE3D,OAAK,MAAM,OAAO,MAAM;AACvB,OAAI,QAAQ,UAAc,MAAM,QAAQ,IAAI,IAAI,IAAI,WAAW,EAC9D;AAGD,OAAI,cACH,KAAI,oBAAoB;IACvB,MAAM,YAAa,mBAA2D,CAAC,IAAiB,CAAC;AACjG,UAAO,MAAM,QAAQ,UAAU,GAAG,UAAU,KAAK;SAEjD,oCAAmB,QAAS,KAAkB,oBAAoB;OAGnE,OAAM;;;;AAYV,IAAa,kBAAb,MAAa,wBAKHC,qCAA8F;CACvG,QAA0BX,0BAAsB;CAEhD,AAAQ;CACR,AAAQ;CACR,AAAQ;CAER,YACC,AAASY,QACT,SACA,AAAQC,WACR,AAAQC,QACR,AAASC,SACR;AACD,QAAM,QAAQ;EANL;EAED;EACA;EACC;AAGT,OAAK,SAAS,QAAQ,UAAU,IAAIC,wBAAY;AAChD,OAAK,QAAQ,QAAQ,SAAS,IAAIC,iCAAW;AAC7C,OAAK,OAAO,QAAQ;;CAGrB,aACC,OACA,QACA,oBACA,cACA,cACA,eAIA,aACiD;AAGjD,SAAO,IAAI,sBACV,KAAK,QACL,MAAM,KACN,MAAM,QACN,KAAK,QACL,KAAK,OACL,eACA,aACA,QACA,oBACA,cACA,aACA;;CAGF,uBACC,OACA,QACA,oBACA,cACA,cACiD;AAGjD,SAAO,IAAI,sBACV,KAAK,QACL,MAAM,KACN,MAAM,QACN,KAAK,QACL,KAAK,OACL,QACA,QACA,QACA,oBACA,cACA,cACA,KACA;;;CAIF,MAAM,MAAM,OAAe,QAAuD;AACjF,OAAK,OAAO,SAAS,OAAO,OAAO;AAEnC,SADe,MAAM,KAAK,OAAO,OAAO,OAAO,OAAO;;CAIvD,AAAS,IAAiB,OAA0B;EACnD,MAAM,WAAW,KAAK,QAAQ,WAAW,MAAM;AAC/C,OAAK,OAAO,SAAS,SAAS,KAAK,SAAS,OAAO;AACnD,SAAO,KAAK,OAAO,OAAO,SAAS,KAAK,SAAS,OAAO;;CAGzD,MAAe,MAAM,KAA2B;EAC/C,MAAM,QAAQ,KAAK,QAAQ,WAAW,IAAI;EAG1C,MAAM,SAFO,MAAM,KAAK,OAAO,OAAO,MAAM,KAAK,MAAM,OAAO,CAAC,QAAQ,EAEpD,GAAG;AACtB,MAAI,OAAO,UAAU,SAAU,QAAO;AACtC,SAAO,OAAO,MAAM;;CAGrB,MAAe,YACd,aACA,QACa;EACb,MAAM,sBAAsB,SACzB,KAAK,uBAAuB,OAAO,EAAE,cAAc,CAAC,QAAQ,KAAK,QAAQ,CAAC,IAAI,MAAM,GAAG,IAAI,KAC3F;AAEH,MAAI,QAAQ,eAAgB,OAAM,IAAI,MAAM,gEAAgE;AAE5G,SAAO,KAAK,OAAO,MAAM,qBAAqB,OAAO,WAAW;GAC/D,MAAM,UAAU,IAAI,gBACnB,QACA,KAAK,SACL,KAAK,WACL,KAAK,QACL,KAAK,QACL;AAeD,UAAO,YAdI,IAAI,oBACd,KAAK,SACL,SACA,KAAK,WACL,KAAK,QACL,GACA,KAAK,KACL,CAOqB;IACrB;;;AAIJ,IAAa,sBAAb,MAAa,4BAIHC,yCAMR;CACD,QAA0BlB,0BAAsB;CAEhD,MAAe,YACd,aACa;AACb,SAAyD,KAAK,QAAS,OAAO,WAAW,WAAW;GACnG,MAAM,UAAU,IAAI,gBACnB,QACA,KAAK,SACL,KAAK,WACL,KAAK,QACkC,KAAK,QAAS,QACrD;AASD,UAAO,YARI,IAAI,oBACd,KAAK,SACL,SACA,KAAK,WACL,KAAK,QACL,KAAK,cAAc,GACnB,KAAK,KACL,CACqB;IACrB"}