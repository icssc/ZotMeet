{"version":3,"file":"react-router-B8lbOffe.js","names":[],"sources":["../src/adapters/lib/react-router.ts"],"sourcesContent":["import { startTransition, useCallback, useEffect, useState } from 'react'\nimport { debug } from '../../lib/debug'\nimport { createEmitter } from '../../lib/emitter'\nimport { setQueueResetMutex } from '../../lib/queues/reset'\nimport { renderQueryString } from '../../lib/url-encoding'\nimport { createAdapterProvider, type AdapterProvider } from './context'\nimport type { AdapterInterface, AdapterOptions } from './defs'\nimport { applyChange, filterSearchParams } from './key-isolation'\nimport {\n  patchHistory as applyHistoryPatch,\n  historyUpdateMarker,\n  type SearchParamsSyncEmitterEvents\n} from './patch-history'\n\n// Abstract away the types for the useNavigate hook from react-router-based frameworks\ntype NavigateUrl = {\n  hash?: string\n  search?: string\n}\ntype NavigateOptions = {\n  replace?: boolean\n  preventScrollReset?: boolean\n  state?: unknown\n}\ntype NavigateFn = (url: NavigateUrl, options: NavigateOptions) => void\ntype UseNavigate = () => NavigateFn\ntype UseSearchParams = (initial: URLSearchParams) => [URLSearchParams, {}]\n\n// --\n\ntype CreateReactRouterBasedAdapterArgs = {\n  adapter: string\n  useNavigate: UseNavigate\n  useSearchParams: UseSearchParams\n}\n\nexport function createReactRouterBasedAdapter({\n  adapter,\n  useNavigate,\n  useSearchParams\n}: CreateReactRouterBasedAdapterArgs): {\n  NuqsAdapter: AdapterProvider\n  useOptimisticSearchParams: () => URLSearchParams\n} {\n  const emitter = createEmitter<SearchParamsSyncEmitterEvents>()\n  function useNuqsReactRouterBasedAdapter(\n    watchKeys: string[]\n  ): AdapterInterface {\n    const navigate = useNavigate()\n    const searchParams = useOptimisticSearchParams(watchKeys)\n    const updateUrl = useCallback(\n      (search: URLSearchParams, options: AdapterOptions) => {\n        startTransition(() => {\n          emitter.emit('update', search)\n        })\n        const url = new URL(location.href)\n        url.search = renderQueryString(search)\n        debug(`[nuqs ${adapter}] Updating url: %s`, url)\n        // First, update the URL locally without triggering a network request,\n        // this allows keeping a reactive URL if the network is slow.\n        const updateMethod =\n          options.history === 'push' ? history.pushState : history.replaceState\n        setQueueResetMutex(options.shallow ? 1 : 2)\n        updateMethod.call(\n          history,\n          history.state, // Maintain the history state\n          historyUpdateMarker,\n          url\n        )\n        if (options.shallow === false) {\n          navigate(\n            {\n              // Somehow passing the full URL object here strips the search params\n              // when accessing the request.url in loaders.\n              hash: url.hash,\n              search: url.search\n            },\n            {\n              replace: true,\n              preventScrollReset: true,\n              state: history.state?.usr\n            }\n          )\n        }\n        if (options.scroll) {\n          window.scrollTo(0, 0)\n        }\n      },\n      [navigate]\n    )\n    return {\n      searchParams,\n      updateUrl,\n      autoResetQueueOnUpdate: false\n    }\n  }\n  function useOptimisticSearchParams(\n    watchKeys: string[] = []\n  ): URLSearchParams {\n    const [serverSearchParams] = useSearchParams(\n      // Note: this will only be taken into account the first time the hook is called,\n      // and cached for subsequent calls, causing problems when mounting components\n      // after shallow updates have occurred.\n      typeof location === 'undefined'\n        ? new URLSearchParams()\n        : new URLSearchParams(location.search)\n    )\n    const [searchParams, setSearchParams] = useState(() => {\n      return typeof location === 'undefined'\n        ? // We use this on the server to SSR with the correct search params.\n          filterSearchParams(serverSearchParams, watchKeys, true)\n        : // Since useSearchParams isn't reactive to shallow changes,\n          // it doesn't pick up changes in the URL on mount, so we need to initialise\n          // the reactive state with the current URL instead.\n          filterSearchParams(\n            new URLSearchParams(location.search),\n            watchKeys,\n            false // No need for a copy here\n          )\n    })\n    useEffect(() => {\n      function onPopState() {\n        setSearchParams(\n          applyChange(new URLSearchParams(location.search), watchKeys, false)\n        )\n      }\n      function onEmitterUpdate(search: URLSearchParams) {\n        setSearchParams(applyChange(search, watchKeys, true))\n      }\n      emitter.on('update', onEmitterUpdate)\n      window.addEventListener('popstate', onPopState)\n      return () => {\n        emitter.off('update', onEmitterUpdate)\n        window.removeEventListener('popstate', onPopState)\n      }\n    }, [watchKeys.join('&')])\n    return searchParams\n  }\n  /**\n   * Sync shallow updates of the URL with the useOptimisticSearchParams hook.\n   *\n   * By default, the useOptimisticSearchParams hook will only react to internal nuqs updates.\n   * If third party code updates the History API directly, use this function to\n   * enable useOptimisticSearchParams to react to those changes.\n   *\n   * Note: this is actually required in React Router frameworks to follow Link navigations.\n   */\n  applyHistoryPatch(emitter, adapter)\n\n  return {\n    NuqsAdapter: createAdapterProvider(useNuqsReactRouterBasedAdapter),\n    useOptimisticSearchParams\n  }\n}\n"],"mappings":";;;;;;;;AAoCA,SAAgB,8BAA8B,EAC5C,SACA,aACA,mBAIA;CACA,MAAM,UAAU,eAA8C;CAC9D,SAAS,+BACP,WACkB;EAClB,MAAM,WAAW,aAAa;AA0C9B,SAAO;GACL,cA1CmB,0BAA0B,UAAU;GA2CvD,WA1CgB,aACf,QAAyB,YAA4B;AACpD,0BAAsB;AACpB,aAAQ,KAAK,UAAU,OAAO;MAC9B;IACF,MAAM,MAAM,IAAI,IAAI,SAAS,KAAK;AAClC,QAAI,SAAS,kBAAkB,OAAO;AACtC,UAAM,SAAS,QAAQ,qBAAqB,IAAI;IAGhD,MAAM,eACJ,QAAQ,YAAY,SAAS,QAAQ,YAAY,QAAQ;AAC3D,uBAAmB,QAAQ,UAAU,IAAI,EAAE;AAC3C,iBAAa,KACX,SACA,QAAQ,OACR,qBACA,IACD;AACD,QAAI,QAAQ,YAAY,MACtB,UACE;KAGE,MAAM,IAAI;KACV,QAAQ,IAAI;KACb,EACD;KACE,SAAS;KACT,oBAAoB;KACpB,OAAO,QAAQ,OAAO;KACvB,CACF;AAEH,QAAI,QAAQ,OACV,QAAO,SAAS,GAAG,EAAE;MAGzB,CAAC,SAAS,CACX;GAIC,wBAAwB;GACzB;;CAEH,SAAS,0BACP,YAAsB,EAAE,EACP;EACjB,MAAM,CAAC,sBAAsB,gBAI3B,OAAO,aAAa,cAChB,IAAI,iBAAiB,GACrB,IAAI,gBAAgB,SAAS,OAAO,CACzC;EACD,MAAM,CAAC,cAAc,mBAAmB,eAAe;AACrD,UAAO,OAAO,aAAa,cAEvB,mBAAmB,oBAAoB,WAAW,KAAK,GAIvD,mBACE,IAAI,gBAAgB,SAAS,OAAO,EACpC,WACA,MACD;IACL;AACF,kBAAgB;GACd,SAAS,aAAa;AACpB,oBACE,YAAY,IAAI,gBAAgB,SAAS,OAAO,EAAE,WAAW,MAAM,CACpE;;GAEH,SAAS,gBAAgB,QAAyB;AAChD,oBAAgB,YAAY,QAAQ,WAAW,KAAK,CAAC;;AAEvD,WAAQ,GAAG,UAAU,gBAAgB;AACrC,UAAO,iBAAiB,YAAY,WAAW;AAC/C,gBAAa;AACX,YAAQ,IAAI,UAAU,gBAAgB;AACtC,WAAO,oBAAoB,YAAY,WAAW;;KAEnD,CAAC,UAAU,KAAK,IAAI,CAAC,CAAC;AACzB,SAAO;;;;;;;;;;;AAWT,cAAkB,SAAS,QAAQ;AAEnC,QAAO;EACL,aAAa,sBAAsB,+BAA+B;EAClE;EACD"}