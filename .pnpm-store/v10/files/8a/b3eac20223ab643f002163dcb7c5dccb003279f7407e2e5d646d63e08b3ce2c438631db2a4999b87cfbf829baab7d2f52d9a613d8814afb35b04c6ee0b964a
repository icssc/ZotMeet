{"version":3,"file":"migrator.cjs","names":["sql"],"sources":["../../src/xata-http/migrator.ts"],"sourcesContent":["import { type MigratorInitFailResponse, readMigrationFiles } from '~/migrator.ts';\nimport type { AnyRelations, EmptyRelations } from '~/relations.ts';\nimport { sql } from '~/sql/sql.ts';\nimport type { XataHttpDatabase } from './driver.ts';\n\nexport interface MigrationConfig {\n\tmigrationsFolder: string;\n\tmigrationsTable?: string;\n\t/** @internal */\n\tinit?: boolean;\n}\n\n/**\n * This function reads migrationFolder and execute each unapplied migration and mark it as executed in database\n *\n * NOTE: The Xata HTTP driver does not support transactions. This means that if any part of a migration fails,\n * no rollback will be executed. Currently, you will need to handle unsuccessful migration yourself.\n * @param db - drizzle db instance\n * @param config - path to migration folder generated by drizzle-kit\n */ export async function migrate<\n\tTSchema extends Record<string, unknown>,\n\tTRelations extends AnyRelations = EmptyRelations,\n>(\n\tdb: XataHttpDatabase<TSchema, TRelations>,\n\tconfig: MigrationConfig,\n): Promise<void | MigratorInitFailResponse> {\n\tconst migrations = readMigrationFiles(config);\n\tconst migrationsTable = config.migrationsTable ?? '__drizzle_migrations';\n\tconst migrationTableCreate = sql`\n\t\tCREATE TABLE IF NOT EXISTS ${sql.identifier(migrationsTable)} (\n\t\t\tid SERIAL PRIMARY KEY,\n\t\t\thash text NOT NULL,\n\t\t\tcreated_at bigint\n\t\t)\n\t`;\n\tawait db.session.execute(migrationTableCreate);\n\n\tconst dbMigrations = await db.session.all<{\n\t\tid: number;\n\t\thash: string;\n\t\tcreated_at: string;\n\t}>(\n\t\tsql`select id, hash, created_at from ${sql.identifier(migrationsTable)} order by created_at desc limit 1`,\n\t);\n\n\tif (typeof config === 'object' && config.init) {\n\t\tif (dbMigrations.length) {\n\t\t\treturn { exitCode: 'databaseMigrations' as const };\n\t\t}\n\n\t\tif (migrations.length > 1) {\n\t\t\treturn { exitCode: 'localMigrations' as const };\n\t\t}\n\n\t\tconst [migration] = migrations;\n\n\t\tif (!migration) return;\n\n\t\tawait db.session.execute(\n\t\t\tsql`insert into ${\n\t\t\t\tsql.identifier(migrationsTable)\n\t\t\t} (\"hash\", \"created_at\") values(${migration.hash}, ${migration.folderMillis})`,\n\t\t);\n\n\t\treturn;\n\t}\n\n\tconst lastDbMigration = dbMigrations[0];\n\tfor await (const migration of migrations) {\n\t\tif (!lastDbMigration || Number(lastDbMigration.created_at) < migration.folderMillis) {\n\t\t\tfor (const stmt of migration.sql) {\n\t\t\t\tawait db.session.execute(sql.raw(stmt));\n\t\t\t}\n\n\t\t\tawait db.session.execute(\n\t\t\t\tsql`insert into ${\n\t\t\t\t\tsql.identifier(migrationsTable)\n\t\t\t\t} (\"hash\", \"created_at\") values(${migration.hash}, ${migration.folderMillis})`,\n\t\t\t);\n\t\t}\n\t}\n}\n"],"mappings":";;;;;;;;;;;;GAmBI,eAAsB,QAIzB,IACA,QAC2C;CAC3C,MAAM,mDAAgC,OAAO;CAC7C,MAAM,kBAAkB,OAAO,mBAAmB;CAClD,MAAM,uBAAuB,gBAAG;+BACFA,iBAAI,WAAW,gBAAgB,CAAC;;;;;;AAM9D,OAAM,GAAG,QAAQ,QAAQ,qBAAqB;CAE9C,MAAM,eAAe,MAAM,GAAG,QAAQ,IAKrC,gBAAG,oCAAoCA,iBAAI,WAAW,gBAAgB,CAAC,mCACvE;AAED,KAAI,OAAO,WAAW,YAAY,OAAO,MAAM;AAC9C,MAAI,aAAa,OAChB,QAAO,EAAE,UAAU,sBAA+B;AAGnD,MAAI,WAAW,SAAS,EACvB,QAAO,EAAE,UAAU,mBAA4B;EAGhD,MAAM,CAAC,aAAa;AAEpB,MAAI,CAAC,UAAW;AAEhB,QAAM,GAAG,QAAQ,QAChB,gBAAG,eACFA,iBAAI,WAAW,gBAAgB,CAC/B,iCAAiC,UAAU,KAAK,IAAI,UAAU,aAAa,GAC5E;AAED;;CAGD,MAAM,kBAAkB,aAAa;AACrC,YAAW,MAAM,aAAa,WAC7B,KAAI,CAAC,mBAAmB,OAAO,gBAAgB,WAAW,GAAG,UAAU,cAAc;AACpF,OAAK,MAAM,QAAQ,UAAU,IAC5B,OAAM,GAAG,QAAQ,QAAQA,iBAAI,IAAI,KAAK,CAAC;AAGxC,QAAM,GAAG,QAAQ,QAChB,gBAAG,eACFA,iBAAI,WAAW,gBAAgB,CAC/B,iCAAiC,UAAU,KAAK,IAAI,UAAU,aAAa,GAC5E"}