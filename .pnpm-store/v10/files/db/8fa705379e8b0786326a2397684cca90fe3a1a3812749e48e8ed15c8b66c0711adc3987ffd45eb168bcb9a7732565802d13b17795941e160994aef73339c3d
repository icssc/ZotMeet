{"version":3,"sources":["../../../../src/server/app-render/app-render-prerender-utils.ts"],"sourcesContent":["import { InvariantError } from '../../shared/lib/invariant-error'\nimport { createAtomicTimerGroup } from './app-render-scheduling'\nimport {\n  DANGEROUSLY_runPendingImmediatesAfterCurrentTask,\n  expectNoPendingImmediates,\n} from '../node-environment-extensions/fast-set-immediate.external'\n\n/**\n * This is a utility function to make scheduling sequential tasks that run back to back easier.\n * We schedule on the same queue (setTimeout) at the same time to ensure no other events can sneak in between.\n */\nexport function prerenderAndAbortInSequentialTasks<R>(\n  prerender: () => Promise<R>,\n  abort: () => void\n): Promise<R> {\n  if (process.env.NEXT_RUNTIME === 'edge') {\n    throw new InvariantError(\n      '`prerenderAndAbortInSequentialTasks` should not be called in edge runtime.'\n    )\n  } else {\n    return new Promise((resolve, reject) => {\n      const scheduleTimeout = createAtomicTimerGroup()\n\n      let pendingResult: Promise<R>\n      scheduleTimeout(() => {\n        try {\n          DANGEROUSLY_runPendingImmediatesAfterCurrentTask()\n          pendingResult = prerender()\n          pendingResult.catch(() => {})\n        } catch (err) {\n          reject(err)\n        }\n      })\n      scheduleTimeout(() => {\n        try {\n          expectNoPendingImmediates()\n          abort()\n          resolve(pendingResult)\n        } catch (err) {\n          reject(err)\n        }\n      })\n    })\n  }\n}\n\n/**\n * Like `prerenderAndAbortInSequentialTasks`, but with another task between `prerender` and `abort`,\n * which allows us to move a part of the render into a separate task.\n */\nexport function prerenderAndAbortInSequentialTasksWithStages<R>(\n  prerender: () => Promise<R>,\n  advanceStage: () => void,\n  abort: () => void\n): Promise<R> {\n  if (process.env.NEXT_RUNTIME === 'edge') {\n    throw new InvariantError(\n      '`prerenderAndAbortInSequentialTasksWithStages` should not be called in edge runtime.'\n    )\n  } else {\n    return new Promise((resolve, reject) => {\n      const scheduleTimeout = createAtomicTimerGroup()\n\n      let pendingResult: Promise<R>\n      scheduleTimeout(() => {\n        try {\n          DANGEROUSLY_runPendingImmediatesAfterCurrentTask()\n          pendingResult = prerender()\n          pendingResult.catch(() => {})\n        } catch (err) {\n          reject(err)\n        }\n      })\n      scheduleTimeout(() => {\n        try {\n          DANGEROUSLY_runPendingImmediatesAfterCurrentTask()\n          advanceStage()\n        } catch (err) {\n          reject(err)\n        }\n      })\n      scheduleTimeout(() => {\n        try {\n          expectNoPendingImmediates()\n          abort()\n          resolve(pendingResult)\n        } catch (err) {\n          reject(err)\n        }\n      })\n    })\n  }\n}\n\n// React's RSC prerender function will emit an incomplete flight stream when using `prerender`. If the connection\n// closes then whatever hanging chunks exist will be errored. This is because prerender (an experimental feature)\n// has not yet implemented a concept of resume. For now we will simulate a paused connection by wrapping the stream\n// in one that doesn't close even when the underlying is complete.\nexport class ReactServerResult {\n  private _stream: null | ReadableStream<Uint8Array>\n\n  constructor(stream: ReadableStream<Uint8Array>) {\n    this._stream = stream\n  }\n\n  tee() {\n    if (this._stream === null) {\n      throw new Error(\n        'Cannot tee a ReactServerResult that has already been consumed'\n      )\n    }\n    const tee = this._stream.tee()\n    this._stream = tee[0]\n    return tee[1]\n  }\n\n  consume() {\n    if (this._stream === null) {\n      throw new Error(\n        'Cannot consume a ReactServerResult that has already been consumed'\n      )\n    }\n    const stream = this._stream\n    this._stream = null\n    return stream\n  }\n}\n\nexport type ReactServerPrerenderResolveToType = {\n  prelude: ReadableStream<Uint8Array>\n}\n\nexport async function createReactServerPrerenderResult(\n  underlying: Promise<ReactServerPrerenderResolveToType>\n): Promise<ReactServerPrerenderResult> {\n  const chunks: Array<Uint8Array> = []\n  const { prelude } = await underlying\n  const reader = prelude.getReader()\n  while (true) {\n    const { done, value } = await reader.read()\n    if (done) {\n      return new ReactServerPrerenderResult(chunks)\n    } else {\n      chunks.push(value)\n    }\n  }\n}\n\nexport async function createReactServerPrerenderResultFromRender(\n  underlying: ReadableStream<Uint8Array>\n): Promise<ReactServerPrerenderResult> {\n  const chunks: Array<Uint8Array> = []\n  const reader = underlying.getReader()\n  while (true) {\n    const { done, value } = await reader.read()\n    if (done) {\n      break\n    } else {\n      chunks.push(value)\n    }\n  }\n  return new ReactServerPrerenderResult(chunks)\n}\nexport class ReactServerPrerenderResult {\n  private _chunks: null | Array<Uint8Array>\n\n  private assertChunks(expression: string): Array<Uint8Array> {\n    if (this._chunks === null) {\n      throw new InvariantError(\n        `Cannot \\`${expression}\\` on a ReactServerPrerenderResult that has already been consumed.`\n      )\n    }\n    return this._chunks\n  }\n\n  private consumeChunks(expression: string): Array<Uint8Array> {\n    const chunks = this.assertChunks(expression)\n    this.consume()\n    return chunks\n  }\n\n  consume(): void {\n    this._chunks = null\n  }\n\n  constructor(chunks: Array<Uint8Array>) {\n    this._chunks = chunks\n  }\n\n  asUnclosingStream(): ReadableStream<Uint8Array> {\n    const chunks = this.assertChunks('asUnclosingStream()')\n    return createUnclosingStream(chunks)\n  }\n\n  consumeAsUnclosingStream(): ReadableStream<Uint8Array> {\n    const chunks = this.consumeChunks('consumeAsUnclosingStream()')\n    return createUnclosingStream(chunks)\n  }\n\n  asStream(): ReadableStream<Uint8Array> {\n    const chunks = this.assertChunks('asStream()')\n    return createClosingStream(chunks)\n  }\n\n  consumeAsStream(): ReadableStream<Uint8Array> {\n    const chunks = this.consumeChunks('consumeAsStream()')\n    return createClosingStream(chunks)\n  }\n}\n\nfunction createUnclosingStream(\n  chunks: Array<Uint8Array>\n): ReadableStream<Uint8Array> {\n  let i = 0\n  return new ReadableStream({\n    async pull(controller) {\n      if (i < chunks.length) {\n        controller.enqueue(chunks[i++])\n      }\n      // we intentionally keep the stream open. The consumer will clear\n      // out chunks once finished and the remaining memory will be GC'd\n      // when this object goes out of scope\n    },\n  })\n}\n\nfunction createClosingStream(\n  chunks: Array<Uint8Array>\n): ReadableStream<Uint8Array> {\n  let i = 0\n  return new ReadableStream({\n    async pull(controller) {\n      if (i < chunks.length) {\n        controller.enqueue(chunks[i++])\n      } else {\n        controller.close()\n      }\n    },\n  })\n}\n\nexport async function processPrelude(\n  unprocessedPrelude: ReadableStream<Uint8Array>\n) {\n  const [prelude, peek] = unprocessedPrelude.tee()\n\n  const reader = peek.getReader()\n  const firstResult = await reader.read()\n  reader.cancel()\n\n  const preludeIsEmpty = firstResult.done === true\n\n  return { prelude, preludeIsEmpty }\n}\n"],"names":["InvariantError","createAtomicTimerGroup","DANGEROUSLY_runPendingImmediatesAfterCurrentTask","expectNoPendingImmediates","prerenderAndAbortInSequentialTasks","prerender","abort","process","env","NEXT_RUNTIME","Promise","resolve","reject","scheduleTimeout","pendingResult","catch","err","prerenderAndAbortInSequentialTasksWithStages","advanceStage","ReactServerResult","constructor","stream","_stream","tee","Error","consume","createReactServerPrerenderResult","underlying","chunks","prelude","reader","getReader","done","value","read","ReactServerPrerenderResult","push","createReactServerPrerenderResultFromRender","assertChunks","expression","_chunks","consumeChunks","asUnclosingStream","createUnclosingStream","consumeAsUnclosingStream","asStream","createClosingStream","consumeAsStream","i","ReadableStream","pull","controller","length","enqueue","close","processPrelude","unprocessedPrelude","peek","firstResult","cancel","preludeIsEmpty"],"mappings":"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","ignoreList":[0]}