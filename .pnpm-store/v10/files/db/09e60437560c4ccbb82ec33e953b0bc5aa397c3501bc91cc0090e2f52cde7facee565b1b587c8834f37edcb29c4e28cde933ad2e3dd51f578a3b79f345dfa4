{"version":3,"file":"insert.cjs","names":["entityKind","table: TTable","session: PgSession","dialect: PgDialect","withList?: Subquery[]","overridingSystemValue_?: boolean","builder: PgInsertBuilderConstructor","result: Record<string, Param | SQL>","Table","SQL","Param","QueryBuilder","TableColumns","sql","SelectionProxyHandler"],"sources":["../../../src/pg-core/query-builders/insert.ts"],"sourcesContent":["import type { WithCacheConfig } from '~/cache/core/types.ts';\nimport { entityKind, is } from '~/entity.ts';\nimport type { PgDialect } from '~/pg-core/dialect.ts';\nimport type { IndexColumn } from '~/pg-core/indexes.ts';\nimport type { PgQueryResultHKT, PgQueryResultKind, PgSession } from '~/pg-core/session.ts';\nimport type { PgTable, TableConfig } from '~/pg-core/table.ts';\nimport type { TypedQueryBuilder } from '~/query-builders/query-builder.ts';\nimport type { SelectResultFields } from '~/query-builders/select.types.ts';\nimport { SelectionProxyHandler } from '~/selection-proxy.ts';\nimport type { ColumnsSelection, Placeholder, Query, SQLWrapper } from '~/sql/sql.ts';\nimport { Param, SQL, sql } from '~/sql/sql.ts';\nimport type { Subquery } from '~/subquery.ts';\nimport type { InferInsertModel } from '~/table.ts';\nimport { getTableName, Table, TableColumns } from '~/table.ts';\nimport { type Assume, haveSameKeys, mapUpdateSet, type NeonAuthToken, orderSelectedFields } from '~/utils.ts';\nimport type { AnyPgColumn, PgColumn } from '../columns/common.ts';\nimport { QueryBuilder } from './query-builder.ts';\nimport type { SelectedFieldsFlat, SelectedFieldsOrdered } from './select.types.ts';\nimport type { PgUpdateSetSource } from './update.ts';\n\nexport interface PgInsertConfig<TTable extends PgTable = PgTable> {\n\ttable: TTable;\n\tvalues: Record<string, Param | SQL>[] | PgInsertSelectQueryBuilder<TTable> | SQL;\n\twithList?: Subquery[];\n\tonConflict?: SQL;\n\treturningFields?: SelectedFieldsFlat;\n\treturning?: SelectedFieldsOrdered;\n\tselect?: boolean;\n\toverridingSystemValue_?: boolean;\n}\n\nexport type PgInsertValue<\n\tTTable extends PgTable<TableConfig>,\n\tOverrideT extends boolean = false,\n\tTModel extends Record<string, any> = InferInsertModel<TTable, { dbColumnNames: false; override: OverrideT }>,\n> =\n\t& {\n\t\t[Key in keyof TModel]:\n\t\t\t| TModel[Key]\n\t\t\t| SQL\n\t\t\t| Placeholder;\n\t}\n\t& {};\n\nexport type PgInsertSelectQueryBuilder<\n\tTTable extends PgTable,\n\tTModel extends Record<string, any> = InferInsertModel<TTable>,\n> = TypedQueryBuilder<\n\t{ [K in keyof TModel]: AnyPgColumn | SQL | SQL.Aliased | TModel[K] }\n>;\n\nexport interface PgInsertBuilderConstructor {\n\tnew(\n\t\ttable: PgTable,\n\t\tvalues: PgInsertConfig['values'],\n\t\tsession: PgSession,\n\t\tdialect: PgDialect,\n\t\twithList?: Subquery[],\n\t\tselect?: boolean,\n\t\toverridingSystemValue_?: boolean,\n\t): AnyPgInsert;\n}\n\nexport class PgInsertBuilder<\n\tTTable extends PgTable,\n\tTQueryResult extends PgQueryResultHKT,\n\tOverrideT extends boolean = false,\n\tTBuilderHKT extends PgInsertHKTBase = PgInsertHKT,\n> {\n\tstatic readonly [entityKind]: string = 'PgInsertBuilder';\n\n\tconstructor(\n\t\tprivate table: TTable,\n\t\tprivate session: PgSession,\n\t\tprivate dialect: PgDialect,\n\t\tprivate withList?: Subquery[],\n\t\tprivate overridingSystemValue_?: boolean,\n\t\tprivate builder: PgInsertBuilderConstructor = PgInsertBase,\n\t) {}\n\n\t/** @internal */\n\tprivate authToken?: NeonAuthToken;\n\t/** @internal */\n\tsetToken(token?: NeonAuthToken) {\n\t\tthis.authToken = token;\n\t\treturn this;\n\t}\n\n\toverridingSystemValue(): Omit<PgInsertBuilder<TTable, TQueryResult, true, TBuilderHKT>, 'overridingSystemValue'> {\n\t\tthis.overridingSystemValue_ = true;\n\t\treturn this as any;\n\t}\n\n\tvalues(value: PgInsertValue<TTable, OverrideT>): PgInsertKind<TBuilderHKT, TTable, TQueryResult>;\n\tvalues(values: PgInsertValue<TTable, OverrideT>[]): PgInsertKind<TBuilderHKT, TTable, TQueryResult>;\n\tvalues(\n\t\tvalues: PgInsertValue<TTable, OverrideT> | PgInsertValue<TTable, OverrideT>[],\n\t): PgInsertKind<TBuilderHKT, TTable, TQueryResult> {\n\t\tvalues = Array.isArray(values) ? values : [values];\n\t\tif (values.length === 0) {\n\t\t\tthrow new Error('values() must be called with at least one value');\n\t\t}\n\t\tconst mappedValues = values.map((entry) => {\n\t\t\tconst result: Record<string, Param | SQL> = {};\n\t\t\tconst cols = this.table[Table.Symbol.Columns];\n\t\t\tfor (const colKey of Object.keys(entry)) {\n\t\t\t\tconst colValue = entry[colKey as keyof typeof entry];\n\t\t\t\tresult[colKey] = is(colValue, SQL) ? colValue : new Param(colValue, cols[colKey]);\n\t\t\t}\n\t\t\treturn result;\n\t\t});\n\n\t\tconst builder = new this.builder(\n\t\t\tthis.table,\n\t\t\tmappedValues,\n\t\t\tthis.session,\n\t\t\tthis.dialect,\n\t\t\tthis.withList,\n\t\t\tfalse,\n\t\t\tthis.overridingSystemValue_,\n\t\t);\n\n\t\tif ('setToken' in builder) {\n\t\t\t(builder.setToken as (authToken?: NeonAuthToken) => typeof builder)(this.authToken);\n\t\t}\n\n\t\treturn builder as any;\n\t}\n\n\tselect(\n\t\tselectQuery: (qb: QueryBuilder) => PgInsertSelectQueryBuilder<TTable>,\n\t): PgInsertKind<TBuilderHKT, TTable, TQueryResult>;\n\tselect(selectQuery: (qb: QueryBuilder) => SQL): PgInsertKind<TBuilderHKT, TTable, TQueryResult>;\n\tselect(selectQuery: SQL): PgInsertBase<TBuilderHKT, TTable, TQueryResult>;\n\tselect(selectQuery: PgInsertSelectQueryBuilder<TTable>): PgInsertKind<TBuilderHKT, TTable, TQueryResult>;\n\tselect(\n\t\tselectQuery:\n\t\t\t| SQL\n\t\t\t| PgInsertSelectQueryBuilder<TTable>\n\t\t\t| ((qb: QueryBuilder) => PgInsertSelectQueryBuilder<TTable> | SQL),\n\t): PgInsertKind<TBuilderHKT, TTable, TQueryResult> {\n\t\tconst select = typeof selectQuery === 'function' ? selectQuery(new QueryBuilder()) : selectQuery;\n\n\t\tif (\n\t\t\t!is(select, SQL)\n\t\t\t&& !haveSameKeys(this.table[TableColumns], select._.selectedFields)\n\t\t) {\n\t\t\tthrow new Error(\n\t\t\t\t'Insert select error: selected fields are not the same or are in a different order compared to the table definition',\n\t\t\t);\n\t\t}\n\n\t\tconst builder = new this.builder(this.table, select, this.session, this.dialect, this.withList, true) as any;\n\n\t\tif ('setToken' in builder) {\n\t\t\t(builder.setToken as (authToken?: NeonAuthToken) => typeof builder)(this.authToken);\n\t\t}\n\n\t\treturn builder as any;\n\t}\n}\n\nexport interface PgInsertHKTBase {\n\ttable: unknown;\n\tqueryResult: unknown;\n\tselectedFields: unknown;\n\treturning: unknown;\n\tdynamic: boolean;\n\texcludedMethods: string;\n\tresult: unknown;\n\t_type: unknown;\n}\n\nexport interface PgInsertHKT extends PgInsertHKTBase {\n\t_type: PgInsertBase<\n\t\tPgInsertHKT,\n\t\tAssume<this['table'], PgTable>,\n\t\tAssume<this['queryResult'], PgQueryResultHKT>,\n\t\tthis['selectedFields'],\n\t\tthis['returning'],\n\t\tthis['dynamic'],\n\t\tthis['excludedMethods']\n\t>;\n}\n\nexport type PgInsertKind<\n\tT extends PgInsertHKTBase,\n\tTTable extends PgTable,\n\tTQueryResult extends PgQueryResultHKT,\n\tTSelectedFields extends ColumnsSelection | undefined = undefined,\n\tTReturning extends Record<string, unknown> | undefined = undefined,\n\tTDynamic extends boolean = false,\n\tTExcludedMethods extends string = never,\n> = (T & {\n\ttable: TTable;\n\tqueryResult: TQueryResult;\n\tselectedFields: TSelectedFields;\n\treturning: TReturning;\n\tdynamic: TDynamic;\n\texcludedMethods: TExcludedMethods;\n})['_type'];\n\nexport type PgInsertWithout<T extends AnyPgInsert, TDynamic extends boolean, K extends string> = TDynamic extends true\n\t? T\n\t: Omit<\n\t\tPgInsertKind<\n\t\t\tT['_']['hkt'],\n\t\t\tT['_']['table'],\n\t\t\tT['_']['queryResult'],\n\t\t\tT['_']['selectedFields'],\n\t\t\tT['_']['returning'],\n\t\t\tTDynamic,\n\t\t\tT['_']['excludedMethods'] | K\n\t\t>,\n\t\tT['_']['excludedMethods'] | K\n\t>;\n\nexport type PgInsertReturning<\n\tT extends AnyPgInsert,\n\tTDynamic extends boolean,\n\tTSelectedFields extends SelectedFieldsFlat,\n> = T extends any ? PgInsertWithout<\n\t\tPgInsertKind<\n\t\t\tT['_']['hkt'],\n\t\t\tT['_']['table'],\n\t\t\tT['_']['queryResult'],\n\t\t\tTSelectedFields,\n\t\t\tSelectResultFields<TSelectedFields>,\n\t\t\tTDynamic,\n\t\t\tT['_']['excludedMethods']\n\t\t>,\n\t\tTDynamic,\n\t\t'returning'\n\t>\n\t: never;\n\nexport type PgInsertReturningAll<T extends AnyPgInsert, TDynamic extends boolean> = T extends any ? PgInsertWithout<\n\t\tPgInsertKind<\n\t\t\tT['_']['hkt'],\n\t\t\tT['_']['table'],\n\t\t\tT['_']['queryResult'],\n\t\t\tT['_']['table']['_']['columns'],\n\t\t\tT['_']['table']['$inferSelect'],\n\t\t\tTDynamic,\n\t\t\tT['_']['excludedMethods']\n\t\t>,\n\t\tTDynamic,\n\t\t'returning'\n\t>\n\t: never;\n\nexport interface PgInsertOnConflictDoUpdateConfig<T extends AnyPgInsert> {\n\ttarget: IndexColumn | IndexColumn[];\n\t/** @deprecated use either `targetWhere` or `setWhere` */\n\twhere?: SQL;\n\t// TODO: add tests for targetWhere and setWhere\n\ttargetWhere?: SQL;\n\tsetWhere?: SQL;\n\tset: PgUpdateSetSource<T['_']['table']>;\n}\n\nexport type PgInsertDynamic<T extends AnyPgInsert> = PgInsertKind<\n\tT['_']['hkt'],\n\tT['_']['table'],\n\tT['_']['queryResult'],\n\tT['_']['selectedFields'],\n\tT['_']['returning'],\n\ttrue,\n\tnever\n>;\n\nexport type AnyPgInsert = PgInsertBase<any, any, any, any, any, any, any>;\n\nexport type PgInsert<\n\tTTable extends PgTable = PgTable,\n\tTQueryResult extends PgQueryResultHKT = PgQueryResultHKT,\n\tTSelectedFields extends ColumnsSelection | undefined = ColumnsSelection | undefined,\n\tTReturning extends Record<string, unknown> | undefined = Record<string, unknown> | undefined,\n> = PgInsertBase<PgInsertHKT, TTable, TQueryResult, TSelectedFields, TReturning, true, never>;\n\nexport interface PgInsertBase<\n\tTHKT extends PgInsertHKTBase,\n\tTTable extends PgTable,\n\tTQueryResult extends PgQueryResultHKT,\n\tTSelectedFields = undefined,\n\tTReturning = undefined,\n\tTDynamic extends boolean = false,\n\tTExcludedMethods extends string = never,\n> extends\n\tTypedQueryBuilder<\n\t\tTSelectedFields,\n\t\tTReturning extends undefined ? PgQueryResultKind<TQueryResult, never> : TReturning[]\n\t>,\n\tSQLWrapper\n{\n\treadonly _: {\n\t\treadonly dialect: 'pg';\n\t\treadonly hkt: THKT;\n\t\treadonly table: TTable;\n\t\treadonly queryResult: TQueryResult;\n\t\treadonly selectedFields: TSelectedFields;\n\t\treadonly returning: TReturning;\n\t\treadonly dynamic: TDynamic;\n\t\treadonly excludedMethods: TExcludedMethods;\n\t\treadonly result: TReturning extends undefined ? PgQueryResultKind<TQueryResult, never> : TReturning[];\n\t};\n}\n\nexport class PgInsertBase<\n\t// oxlint-disable-next-line no-unused-vars\n\tTHKT extends PgInsertHKTBase,\n\tTTable extends PgTable,\n\tTQueryResult extends PgQueryResultHKT,\n\tTSelectedFields = undefined,\n\tTReturning = undefined,\n\t// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\tTDynamic extends boolean = false,\n\t// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\tTExcludedMethods extends string = never,\n> implements\n\tTypedQueryBuilder<\n\t\tTSelectedFields,\n\t\tTReturning extends undefined ? PgQueryResultKind<TQueryResult, never> : TReturning[]\n\t>,\n\tSQLWrapper\n{\n\tstatic readonly [entityKind]: string = 'PgInsert';\n\n\tprotected config: PgInsertConfig<TTable>;\n\tprotected cacheConfig?: WithCacheConfig;\n\n\tconstructor(\n\t\ttable: TTable,\n\t\tvalues: PgInsertConfig['values'],\n\t\tprotected session: PgSession,\n\t\tprotected dialect: PgDialect,\n\t\twithList?: Subquery[],\n\t\tselect?: boolean,\n\t\toverridingSystemValue_?: boolean,\n\t) {\n\t\tthis.config = { table, values: values as any, withList, select, overridingSystemValue_ };\n\t}\n\n\t/**\n\t * Adds a `returning` clause to the query.\n\t *\n\t * Calling this method will return the specified fields of the inserted rows. If no fields are specified, all fields will be returned.\n\t *\n\t * See docs: {@link https://orm.drizzle.team/docs/insert#insert-returning}\n\t *\n\t * @example\n\t * ```ts\n\t * // Insert one row and return all fields\n\t * const insertedCar: Car[] = await db.insert(cars)\n\t *   .values({ brand: 'BMW' })\n\t *   .returning();\n\t *\n\t * // Insert one row and return only the id\n\t * const insertedCarId: { id: number }[] = await db.insert(cars)\n\t *   .values({ brand: 'BMW' })\n\t *   .returning({ id: cars.id });\n\t * ```\n\t */\n\treturning(): PgInsertReturningAll<this, TDynamic>;\n\treturning<TSelectedFields extends SelectedFieldsFlat>(\n\t\tfields: TSelectedFields,\n\t): PgInsertReturning<this, TDynamic, TSelectedFields>;\n\treturning(\n\t\tfields: SelectedFieldsFlat = this.config.table[Table.Symbol.Columns],\n\t): PgInsertReturningAll<this, TDynamic> | PgInsertReturning<this, TDynamic, SelectedFieldsFlat> {\n\t\tthis.config.returningFields = fields;\n\t\tthis.config.returning = orderSelectedFields<PgColumn>(this.config.returningFields);\n\t\treturn this as any;\n\t}\n\n\t/**\n\t * Adds an `on conflict do nothing` clause to the query.\n\t *\n\t * Calling this method simply avoids inserting a row as its alternative action.\n\t *\n\t * See docs: {@link https://orm.drizzle.team/docs/insert#on-conflict-do-nothing}\n\t *\n\t * @param config The `target` and `where` clauses.\n\t *\n\t * @example\n\t * ```ts\n\t * // Insert one row and cancel the insert if there's a conflict\n\t * await db.insert(cars)\n\t *   .values({ id: 1, brand: 'BMW' })\n\t *   .onConflictDoNothing();\n\t *\n\t * // Explicitly specify conflict target\n\t * await db.insert(cars)\n\t *   .values({ id: 1, brand: 'BMW' })\n\t *   .onConflictDoNothing({ target: cars.id });\n\t * ```\n\t */\n\tonConflictDoNothing(\n\t\tconfig: { target?: IndexColumn | IndexColumn[]; where?: SQL } = {},\n\t): PgInsertWithout<this, TDynamic, 'onConflictDoNothing' | 'onConflictDoUpdate'> {\n\t\tif (config.target === undefined) {\n\t\t\tthis.config.onConflict = sql`do nothing`;\n\t\t} else {\n\t\t\tlet targetColumn = '';\n\t\t\ttargetColumn = Array.isArray(config.target)\n\t\t\t\t? config.target.map((it) => this.dialect.escapeName(this.dialect.casing.getColumnCasing(it))).join(',')\n\t\t\t\t: this.dialect.escapeName(this.dialect.casing.getColumnCasing(config.target));\n\n\t\t\tconst whereSql = config.where ? sql` where ${config.where}` : undefined;\n\t\t\tthis.config.onConflict = sql`(${sql.raw(targetColumn)})${whereSql} do nothing`;\n\t\t}\n\t\treturn this as any;\n\t}\n\n\t/**\n\t * Adds an `on conflict do update` clause to the query.\n\t *\n\t * Calling this method will update the existing row that conflicts with the row proposed for insertion as its alternative action.\n\t *\n\t * See docs: {@link https://orm.drizzle.team/docs/insert#upserts-and-conflicts}\n\t *\n\t * @param config The `target`, `set` and `where` clauses.\n\t *\n\t * @example\n\t * ```ts\n\t * // Update the row if there's a conflict\n\t * await db.insert(cars)\n\t *   .values({ id: 1, brand: 'BMW' })\n\t *   .onConflictDoUpdate({\n\t *     target: cars.id,\n\t *     set: { brand: 'Porsche' }\n\t *   });\n\t *\n\t * // Upsert with 'where' clause\n\t * await db.insert(cars)\n\t *   .values({ id: 1, brand: 'BMW' })\n\t *   .onConflictDoUpdate({\n\t *     target: cars.id,\n\t *     set: { brand: 'newBMW' },\n\t *     targetWhere: sql`${cars.createdAt} > '2023-01-01'::date`,\n\t *   });\n\t * ```\n\t */\n\tonConflictDoUpdate(\n\t\tconfig: PgInsertOnConflictDoUpdateConfig<this>,\n\t): PgInsertWithout<this, TDynamic, 'onConflictDoNothing' | 'onConflictDoUpdate'> {\n\t\tif (config.where && (config.targetWhere || config.setWhere)) {\n\t\t\tthrow new Error(\n\t\t\t\t'You cannot use both \"where\" and \"targetWhere\"/\"setWhere\" at the same time - \"where\" is deprecated, use \"targetWhere\" or \"setWhere\" instead.',\n\t\t\t);\n\t\t}\n\t\tconst whereSql = config.where ? sql` where ${config.where}` : undefined;\n\t\tconst targetWhereSql = config.targetWhere ? sql` where ${config.targetWhere}` : undefined;\n\t\tconst setWhereSql = config.setWhere ? sql` where ${config.setWhere}` : undefined;\n\t\tconst setSql = this.dialect.buildUpdateSet(this.config.table, mapUpdateSet(this.config.table, config.set));\n\t\tlet targetColumn = '';\n\t\ttargetColumn = Array.isArray(config.target)\n\t\t\t? config.target.map((it) => this.dialect.escapeName(this.dialect.casing.getColumnCasing(it))).join(',')\n\t\t\t: this.dialect.escapeName(this.dialect.casing.getColumnCasing(config.target));\n\t\tthis.config.onConflict = sql`(${\n\t\t\tsql.raw(targetColumn)\n\t\t})${targetWhereSql} do update set ${setSql}${whereSql}${setWhereSql}`;\n\t\treturn this as any;\n\t}\n\n\t/** @internal */\n\tgetSQL(): SQL {\n\t\treturn this.dialect.buildInsertQuery(this.config);\n\t}\n\n\ttoSQL(): Query {\n\t\tconst { typings: _typings, ...rest } = this.dialect.sqlToQuery(this.getSQL());\n\t\treturn rest;\n\t}\n\n\t/** @internal */\n\tgetSelectedFields(): this['_']['selectedFields'] {\n\t\treturn (\n\t\t\tthis.config.returningFields\n\t\t\t\t? new Proxy(\n\t\t\t\t\tthis.config.returningFields,\n\t\t\t\t\tnew SelectionProxyHandler({\n\t\t\t\t\t\talias: getTableName(this.config.table),\n\t\t\t\t\t\tsqlAliasedBehavior: 'alias',\n\t\t\t\t\t\tsqlBehavior: 'error',\n\t\t\t\t\t}),\n\t\t\t\t)\n\t\t\t\t: undefined\n\t\t) as this['_']['selectedFields'];\n\t}\n\n\t$dynamic(): PgInsertDynamic<this> {\n\t\treturn this as any;\n\t}\n}\n"],"mappings":"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"}