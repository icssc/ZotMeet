{"version":3,"file":"impl.pages-DPcvoxQ5.js","names":["isNuqsUpdateMutex: boolean","out: Record<string, string | string[]>"],"sources":["../src/adapters/next/impl.pages.ts"],"sourcesContent":["import { useRouter } from 'next/compat/router.js'\nimport type { NextRouter } from 'next/router'\nimport { useCallback, useEffect, useMemo } from 'react'\nimport { debug } from '../../lib/debug'\nimport { resetQueues } from '../../lib/queues/reset'\nimport { renderQueryString } from '../../lib/url-encoding'\nimport type { AdapterInterface, UpdateUrlFunction } from '../lib/defs'\n\ndeclare global {\n  interface Window {\n    next?: {\n      router?: NextRouter & {\n        state: {\n          asPath: string\n        }\n      }\n    }\n  }\n}\n\nexport function isPagesRouter(): boolean {\n  return typeof window.next?.router?.state?.asPath === 'string'\n}\n\nlet isNuqsUpdateMutex: boolean = false\n\nfunction onNavigation() {\n  if (isNuqsUpdateMutex) {\n    return\n  }\n  resetQueues()\n}\n\nexport function useNuqsNextPagesRouterAdapter(): AdapterInterface {\n  const router = useRouter()\n\n  useEffect(() => {\n    router?.events.on('routeChangeStart', onNavigation)\n    router?.events.on('beforeHistoryChange', onNavigation)\n    return () => {\n      router?.events.off('routeChangeStart', onNavigation)\n      router?.events.off('beforeHistoryChange', onNavigation)\n    }\n  }, [])\n\n  const searchParams = useMemo(() => {\n    const searchParams = new URLSearchParams()\n    if (router === null) {\n      return searchParams\n    }\n    for (const [key, value] of Object.entries(router.query)) {\n      if (typeof value === 'string') {\n        searchParams.set(key, value)\n      } else if (Array.isArray(value)) {\n        for (const v of value) {\n          searchParams.append(key, v)\n        }\n      }\n    }\n    return searchParams\n  }, [JSON.stringify(router?.query)])\n\n  const updateUrl: UpdateUrlFunction = useCallback((search, options) => {\n    // While the Next.js team doesn't recommend using internals like this,\n    // we need direct access to the pages router, as a bound/closured version from\n    // useRouter may be out of date by the time the updateUrl function is called,\n    // and would also cause updateUrl to not be referentially stable.\n    const nextRouter = window.next?.router!\n    const urlParams = extractDynamicUrlParams(\n      nextRouter.pathname,\n      nextRouter.query\n    )\n    const asPath =\n      getAsPathPathname(nextRouter.asPath) +\n      renderQueryString(search) +\n      location.hash\n    debug('[nuqs next/pages] Updating url: %s', asPath)\n    const method =\n      options.history === 'push' ? nextRouter.push : nextRouter.replace\n    isNuqsUpdateMutex = true\n    method\n      .call(\n        nextRouter,\n        // This is what makes the URL work (mapping dynamic segments placeholders\n        // in pathname to their values in query, plus search params in query too).\n        {\n          pathname: nextRouter.pathname,\n          query: {\n            // Note: we put search params first so that one that conflicts\n            // with dynamic params will be overwritten.\n            ...urlSearchParamsToObject(search),\n            ...urlParams\n          }\n          // For some reason we don't need to pass the hash here,\n          // it's preserved when passed as part of the asPath.\n        },\n        // This is what makes the URL pretty (resolved dynamic segments\n        // and nuqs-formatted search params).\n        asPath,\n        // And these are the options that are passed to the router.\n        {\n          scroll: options.scroll,\n          shallow: options.shallow\n        }\n      )\n      .finally(() => {\n        isNuqsUpdateMutex = false\n      })\n  }, [])\n\n  return {\n    searchParams,\n    updateUrl,\n    autoResetQueueOnUpdate: false\n  }\n}\n\nexport function getAsPathPathname(asPath: string): string {\n  return asPath\n    .replace(/#.*$/, '') // Remove hash\n    .replace(/\\?.*$/, '') // Remove search\n}\n\nexport function urlSearchParamsToObject(\n  search: URLSearchParams\n): Record<string, string | string[]> {\n  const out: Record<string, string | string[]> = {}\n  for (const key of search.keys()) {\n    const values = search.getAll(key)\n    if (values.length === 1) {\n      out[key] = values[0]!\n    } else if (values.length > 1) {\n      out[key] = values\n    }\n  }\n  return out\n}\n\n/**\n * Next.js pages router merges dynamic URL params with search params in its\n * internal state.\n * However, we need to pass just the URL params to the href part of the router\n * update functions.\n * This function finds the dynamic URL params placeholders in the pathname\n * (eg: `/path/[foo]/[bar]`) and extracts the corresponding values from the\n * query state object, leaving out any other search params.\n */\nexport function extractDynamicUrlParams(\n  pathname: string,\n  values: Record<string, string | string[] | undefined>\n): Record<string, string | string[] | undefined> {\n  const paramNames = new Set<string>()\n  const dynamicRegex = /\\[([^\\]]+)\\]/g\n  const catchAllRegex = /\\[\\.{3}([^\\]]+)\\]$/\n  const optionalCatchAllRegex = /\\[\\[\\.{3}([^\\]]+)\\]\\]$/\n\n  let match\n  while ((match = dynamicRegex.exec(pathname)) !== null) {\n    const paramName = match[1]\n    if (paramName) {\n      paramNames.add(paramName)\n    }\n  }\n  const dynamicValues = Object.fromEntries(\n    Object.entries(values).filter(([key]) => paramNames.has(key))\n  )\n  const matchCatchAll = catchAllRegex.exec(pathname)\n  if (matchCatchAll && matchCatchAll[1]) {\n    const key = matchCatchAll[1]\n    dynamicValues[key] = values[key] ?? []\n  }\n  const matchOptionalCatchAll = optionalCatchAllRegex.exec(pathname)\n  if (matchOptionalCatchAll && matchOptionalCatchAll[1]) {\n    const key = matchOptionalCatchAll[1]\n    // Note: while Next.js returns undefined if there are no values for the\n    // optional catch-all, passing undefined back when setting the state\n    // results in the value being set to an empty string.\n    // Passing an empty array instead results in the value remaining undefined.\n    dynamicValues[key] = values[key] ?? []\n  }\n  return dynamicValues\n}\n"],"mappings":";;;;;;AAoBA,SAAgB,gBAAyB;AACvC,QAAO,OAAO,OAAO,MAAM,QAAQ,OAAO,WAAW;;AAGvD,IAAIA,oBAA6B;AAEjC,SAAS,eAAe;AACtB,KAAI,kBACF;AAEF,cAAa;;AAGf,SAAgB,gCAAkD;CAChE,MAAM,SAAS,WAAW;AAE1B,iBAAgB;AACd,UAAQ,OAAO,GAAG,oBAAoB,aAAa;AACnD,UAAQ,OAAO,GAAG,uBAAuB,aAAa;AACtD,eAAa;AACX,WAAQ,OAAO,IAAI,oBAAoB,aAAa;AACpD,WAAQ,OAAO,IAAI,uBAAuB,aAAa;;IAExD,EAAE,CAAC;AAmEN,QAAO;EACL,cAlEmB,cAAc;GACjC,MAAM,eAAe,IAAI,iBAAiB;AAC1C,OAAI,WAAW,KACb,QAAO;AAET,QAAK,MAAM,CAAC,KAAK,UAAU,OAAO,QAAQ,OAAO,MAAM,CACrD,KAAI,OAAO,UAAU,SACnB,cAAa,IAAI,KAAK,MAAM;YACnB,MAAM,QAAQ,MAAM,CAC7B,MAAK,MAAM,KAAK,MACd,cAAa,OAAO,KAAK,EAAE;AAIjC,UAAO;KACN,CAAC,KAAK,UAAU,QAAQ,MAAM,CAAC,CAAC;EAoDjC,WAlDmC,aAAa,QAAQ,YAAY;GAKpE,MAAM,aAAa,OAAO,MAAM;GAChC,MAAM,YAAY,wBAChB,WAAW,UACX,WAAW,MACZ;GACD,MAAM,SACJ,kBAAkB,WAAW,OAAO,GACpC,kBAAkB,OAAO,GACzB,SAAS;AACX,SAAM,sCAAsC,OAAO;GACnD,MAAM,SACJ,QAAQ,YAAY,SAAS,WAAW,OAAO,WAAW;AAC5D,uBAAoB;AACpB,UACG,KACC,YAGA;IACE,UAAU,WAAW;IACrB,OAAO;KAGL,GAAG,wBAAwB,OAAO;KAClC,GAAG;KACJ;IAGF,EAGD,QAEA;IACE,QAAQ,QAAQ;IAChB,SAAS,QAAQ;IAClB,CACF,CACA,cAAc;AACb,wBAAoB;KACpB;KACH,EAAE,CAAC;EAKJ,wBAAwB;EACzB;;AAGH,SAAgB,kBAAkB,QAAwB;AACxD,QAAO,OACJ,QAAQ,QAAQ,GAAG,CACnB,QAAQ,SAAS,GAAG;;AAGzB,SAAgB,wBACd,QACmC;CACnC,MAAMC,MAAyC,EAAE;AACjD,MAAK,MAAM,OAAO,OAAO,MAAM,EAAE;EAC/B,MAAM,SAAS,OAAO,OAAO,IAAI;AACjC,MAAI,OAAO,WAAW,EACpB,KAAI,OAAO,OAAO;WACT,OAAO,SAAS,EACzB,KAAI,OAAO;;AAGf,QAAO;;;;;;;;;;;AAYT,SAAgB,wBACd,UACA,QAC+C;CAC/C,MAAM,6BAAa,IAAI,KAAa;CACpC,MAAM,eAAe;CACrB,MAAM,gBAAgB;CACtB,MAAM,wBAAwB;CAE9B,IAAI;AACJ,SAAQ,QAAQ,aAAa,KAAK,SAAS,MAAM,MAAM;EACrD,MAAM,YAAY,MAAM;AACxB,MAAI,UACF,YAAW,IAAI,UAAU;;CAG7B,MAAM,gBAAgB,OAAO,YAC3B,OAAO,QAAQ,OAAO,CAAC,QAAQ,CAAC,SAAS,WAAW,IAAI,IAAI,CAAC,CAC9D;CACD,MAAM,gBAAgB,cAAc,KAAK,SAAS;AAClD,KAAI,iBAAiB,cAAc,IAAI;EACrC,MAAM,MAAM,cAAc;AAC1B,gBAAc,OAAO,OAAO,QAAQ,EAAE;;CAExC,MAAM,wBAAwB,sBAAsB,KAAK,SAAS;AAClE,KAAI,yBAAyB,sBAAsB,IAAI;EACrD,MAAM,MAAM,sBAAsB;AAKlC,gBAAc,OAAO,OAAO,QAAQ,EAAE;;AAExC,QAAO"}