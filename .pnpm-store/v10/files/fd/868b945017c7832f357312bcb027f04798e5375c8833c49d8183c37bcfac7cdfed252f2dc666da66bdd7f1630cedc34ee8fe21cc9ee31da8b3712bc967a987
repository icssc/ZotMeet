{"version":3,"file":"session.cjs","names":["PgEffectPreparedQuery","entityKind","client: PgClient","queryString: string","params: unknown[]","logger: Logger","fields: SelectedFieldsOrdered | undefined","_isResponseInArrayMode: boolean","customResultMapper?: (\n\t\t\trows: TIsRqbV2 extends true ? Record<string, unknown>[] : unknown[][],\n\t\t) => T['execute']","isRqbV2Query?: TIsRqbV2","Effect","TaggedDrizzleQueryError","PgEffectSession","relations: TRelations","schema: V1.RelationalSchemaConfig<TSchema> | undefined","NoopLogger","PgEffectTransaction"],"sources":["../../src/effect-postgres/session.ts"],"sourcesContent":["import type { PgClient } from '@effect/sql-pg/PgClient';\nimport { Effect } from 'effect';\nimport type * as V1 from '~/_relations.ts';\nimport type { EffectCache } from '~/cache/core/cache-effect.ts';\nimport type { WithCacheConfig } from '~/cache/core/types.ts';\nimport { TaggedDrizzleQueryError, type TaggedTransactionRollbackError } from '~/effect-core/errors.ts';\nimport { entityKind } from '~/entity.ts';\nimport { type Logger, NoopLogger } from '~/logger.ts';\nimport type { PgDialect } from '~/pg-core/dialect.ts';\nimport { PgEffectPreparedQuery, PgEffectSession, PgEffectTransaction } from '~/pg-core/effect/session.ts';\nimport type { SelectedFieldsOrdered } from '~/pg-core/query-builders/select.types.ts';\nimport type { PgQueryResultHKT, PreparedQueryConfig } from '~/pg-core/session.ts';\nimport type { AnyRelations } from '~/relations.ts';\nimport type { Query, SQL } from '~/sql/sql.ts';\nimport { fillPlaceholders } from '~/sql/sql.ts';\nimport { type Assume, mapResultRow } from '~/utils.ts';\n\nexport interface EffectPgQueryResultHKT extends PgQueryResultHKT {\n\ttype: readonly Assume<this['row'], object>[];\n}\n\nexport class EffectPgPreparedQuery<T extends PreparedQueryConfig, TIsRqbV2 extends boolean = false>\n\textends PgEffectPreparedQuery<T>\n{\n\tstatic override readonly [entityKind]: string = 'EffectPgPreparedQuery';\n\n\tconstructor(\n\t\tprivate client: PgClient,\n\t\tprivate queryString: string,\n\t\tprivate params: unknown[],\n\t\tprivate logger: Logger,\n\t\tcache: EffectCache | undefined,\n\t\tqueryMetadata: {\n\t\t\ttype: 'select' | 'update' | 'delete' | 'insert';\n\t\t\ttables: string[];\n\t\t} | undefined,\n\t\tcacheConfig: WithCacheConfig | undefined,\n\t\tprivate fields: SelectedFieldsOrdered | undefined,\n\t\tname: string | undefined,\n\t\tprivate _isResponseInArrayMode: boolean,\n\t\tprivate customResultMapper?: (\n\t\t\trows: TIsRqbV2 extends true ? Record<string, unknown>[] : unknown[][],\n\t\t) => T['execute'],\n\t\tprivate isRqbV2Query?: TIsRqbV2,\n\t) {\n\t\tsuper({ sql: queryString, params }, cache, queryMetadata, cacheConfig);\n\t}\n\n\texecute(placeholderValues?: Record<string, unknown>): Effect.Effect<T['execute'], TaggedDrizzleQueryError> {\n\t\tif (this.isRqbV2Query) return this.executeRqbV2(placeholderValues);\n\n\t\tconst { query, logger, customResultMapper, fields, joinsNotNullableMap, client } = this;\n\t\tconst params = fillPlaceholders(query.params, placeholderValues ?? {});\n\t\tlogger.logQuery(query.sql, params);\n\n\t\tif (!fields && !customResultMapper) {\n\t\t\treturn this.queryWithCache(\n\t\t\t\tquery.sql,\n\t\t\t\tparams,\n\t\t\t\tthis.client.unsafe(query.sql, params as any).withoutTransform,\n\t\t\t);\n\t\t}\n\n\t\treturn this.queryWithCache(\n\t\t\tquery.sql,\n\t\t\tparams,\n\t\t\tclient.unsafe(query.sql, params as any).values,\n\t\t).pipe(Effect.andThen(\n\t\t\t(rows) => {\n\t\t\t\tif (customResultMapper) return (customResultMapper as (rows: unknown[][]) => unknown)(rows as unknown[][]);\n\n\t\t\t\treturn rows.map((row) =>\n\t\t\t\t\tmapResultRow(\n\t\t\t\t\t\tfields!,\n\t\t\t\t\t\trow as unknown[],\n\t\t\t\t\t\tjoinsNotNullableMap,\n\t\t\t\t\t)\n\t\t\t\t);\n\t\t\t},\n\t\t));\n\t}\n\n\tprivate executeRqbV2(\n\t\tplaceholderValues?: Record<string, unknown>,\n\t): Effect.Effect<T['execute'], TaggedDrizzleQueryError> {\n\t\tconst { query, logger, customResultMapper, client } = this;\n\t\tconst params = fillPlaceholders(query.params, placeholderValues ?? {});\n\n\t\tlogger.logQuery(query.sql, params);\n\t\treturn (\n\t\t\tclient.unsafe(query.sql, params as any).withoutTransform.pipe(\n\t\t\t\tEffect.andThen((v) =>\n\t\t\t\t\t(customResultMapper as (\n\t\t\t\t\t\trows: Record<string, unknown>[],\n\t\t\t\t\t\tmapColumnValue?: (value: unknown) => unknown,\n\t\t\t\t\t) => unknown)(v as Record<string, unknown>[])\n\t\t\t\t),\n\t\t\t).pipe(Effect.catchAll((e) => {\n\t\t\t\t// eslint-disable-next-line @drizzle-internal/no-instanceof\n\t\t\t\treturn Effect.fail(new TaggedDrizzleQueryError(query.sql, params, e instanceof Error ? e : undefined));\n\t\t\t}))\n\t\t);\n\t}\n\n\toverride all(placeholderValues?: Record<string, unknown>): Effect.Effect<T['all'], TaggedDrizzleQueryError, never> {\n\t\tconst { query, logger, client } = this;\n\t\tconst params = fillPlaceholders(query.params, placeholderValues ?? {});\n\n\t\tlogger.logQuery(query.sql, params);\n\n\t\treturn this.queryWithCache(\n\t\t\tquery.sql,\n\t\t\tparams,\n\t\t\tclient.unsafe(query.sql, params as any).withoutTransform,\n\t\t);\n\t}\n\n\t/** @internal */\n\tisResponseInArrayMode(): boolean {\n\t\treturn this._isResponseInArrayMode;\n\t}\n}\n\nexport class EffectPgSession<\n\tTQueryResult extends PgQueryResultHKT,\n\tTFullSchema extends Record<string, unknown>,\n\tTRelations extends AnyRelations,\n\tTSchema extends V1.TablesRelationalConfig,\n> extends PgEffectSession<TQueryResult, TFullSchema, TRelations, TSchema> {\n\tstatic override readonly [entityKind]: string = 'EffectPgSession';\n\n\tprivate logger: Logger;\n\tprivate cache: EffectCache | undefined;\n\n\tconstructor(\n\t\tprivate client: PgClient,\n\t\tdialect: PgDialect,\n\t\tprotected relations: TRelations,\n\t\tprotected schema: V1.RelationalSchemaConfig<TSchema> | undefined,\n\t\toptions: { logger?: Logger; cache?: EffectCache } = {},\n\t) {\n\t\tsuper(dialect);\n\t\tthis.logger = options.logger ?? new NoopLogger();\n\t\tthis.cache = options.cache;\n\t}\n\n\tprepareQuery<T extends PreparedQueryConfig = PreparedQueryConfig>(\n\t\tquery: Query,\n\t\tfields: SelectedFieldsOrdered | undefined,\n\t\tname: string | undefined,\n\t\tisResponseInArrayMode: boolean,\n\t\tcustomResultMapper?: (rows: unknown[][]) => T['execute'],\n\t\tqueryMetadata?: {\n\t\t\ttype: 'select' | 'update' | 'delete' | 'insert';\n\t\t\ttables: string[];\n\t\t},\n\t\tcacheConfig?: WithCacheConfig,\n\t) {\n\t\treturn new EffectPgPreparedQuery(\n\t\t\tthis.client,\n\t\t\tquery.sql,\n\t\t\tquery.params,\n\t\t\tthis.logger,\n\t\t\tthis.cache,\n\t\t\tqueryMetadata,\n\t\t\tcacheConfig,\n\t\t\tfields,\n\t\t\tname,\n\t\t\tisResponseInArrayMode,\n\t\t\tcustomResultMapper,\n\t\t\tfalse,\n\t\t);\n\t}\n\n\tprepareRelationalQuery<T extends PreparedQueryConfig = PreparedQueryConfig>(\n\t\tquery: Query,\n\t\tfields: SelectedFieldsOrdered | undefined,\n\t\tname: string | undefined,\n\t\tcustomResultMapper?: (rows: Record<string, unknown>[]) => T['execute'],\n\t): EffectPgPreparedQuery<T, true> {\n\t\treturn new EffectPgPreparedQuery<T, true>(\n\t\t\tthis.client,\n\t\t\tquery.sql,\n\t\t\tquery.params,\n\t\t\tthis.logger,\n\t\t\tthis.cache,\n\t\t\tundefined,\n\t\t\tundefined,\n\t\t\tfields,\n\t\t\tname,\n\t\t\tfalse,\n\t\t\tcustomResultMapper,\n\t\t\ttrue,\n\t\t);\n\t}\n\n\toverride execute<T>(query: SQL): Effect.Effect<T, TaggedDrizzleQueryError> {\n\t\treturn this.prepareQuery<PreparedQueryConfig & { execute: T }>(\n\t\t\tthis.dialect.sqlToQuery(query),\n\t\t\tundefined,\n\t\t\tundefined,\n\t\t\tfalse,\n\t\t).execute();\n\t}\n\n\toverride all<T>(query: SQL): Effect.Effect<T, TaggedDrizzleQueryError> {\n\t\treturn this.prepareQuery<PreparedQueryConfig & { all: T }>(\n\t\t\tthis.dialect.sqlToQuery(query),\n\t\t\tundefined,\n\t\t\tundefined,\n\t\t\tfalse,\n\t\t).all();\n\t}\n\n\toverride transaction<T>(\n\t\ttransaction: (\n\t\t\t/** Every query within transaction Effect is completed in transaction, regardless of database instance used\n\t\t\t *\n\t\t\t * `tx` argument is only required for `tx.rollback()`\n\t\t\t */\n\t\t\ttx: EffectPgTransaction<\n\t\t\t\tTQueryResult,\n\t\t\t\tTFullSchema,\n\t\t\t\tTRelations,\n\t\t\t\tTSchema\n\t\t\t>,\n\t\t) => Effect.Effect<T, TaggedDrizzleQueryError | TaggedTransactionRollbackError, never>,\n\t): Effect.Effect<T, TaggedDrizzleQueryError | TaggedTransactionRollbackError, never> {\n\t\tconst { dialect, relations, schema } = this;\n\t\tconst session = this;\n\n\t\treturn this.client.withTransaction(Effect.gen(function*() {\n\t\t\tconst tx = new EffectPgTransaction<TQueryResult, TFullSchema, TRelations, TSchema>(\n\t\t\t\tdialect,\n\t\t\t\tsession,\n\t\t\t\trelations,\n\t\t\t\tschema,\n\t\t\t);\n\n\t\t\treturn yield* transaction(tx);\n\t\t})) as Effect.Effect<T, TaggedDrizzleQueryError | TaggedTransactionRollbackError, never>;\n\t}\n}\n\nexport class EffectPgTransaction<\n\tTQueryResult extends PgQueryResultHKT,\n\tTFullSchema extends Record<string, unknown>,\n\tTRelations extends AnyRelations,\n\tTSchema extends V1.TablesRelationalConfig,\n> extends PgEffectTransaction<TQueryResult, TFullSchema, TRelations, TSchema> {\n\tstatic override readonly [entityKind]: string = 'EffectPgTransaction';\n\n\toverride transaction<T>(\n\t\ttransaction: (\n\t\t\ttx: PgEffectTransaction<TQueryResult, TFullSchema, TRelations, TSchema>,\n\t\t) => Effect.Effect<T, TaggedDrizzleQueryError | TaggedTransactionRollbackError, never>,\n\t): Effect.Effect<T, TaggedDrizzleQueryError | TaggedTransactionRollbackError, never> {\n\t\treturn this.session.transaction(transaction);\n\t}\n}\n"],"mappings":"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"}