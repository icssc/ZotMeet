{"version":3,"file":"session.cjs","names":["SQLiteSession","entityKind","client: DurableObjectStorage","relations: TRelations","schema: V1.RelationalSchemaConfig<TSchema> | undefined","NoopLogger","SQLiteTransaction","PreparedQueryBase","logger: Logger","fields: SelectedFieldsOrdered | undefined","_isResponseInArrayMode: boolean","customResultMapper?: (\n\t\t\trows: TIsRqbV2 extends true ? Record<string, unknown>[] : unknown[][],\n\t\t) => unknown","isRqbV2Query?: TIsRqbV2"],"sources":["../../src/durable-sqlite/session.ts"],"sourcesContent":["import type * as V1 from '~/_relations.ts';\nimport { entityKind } from '~/entity.ts';\nimport type { Logger } from '~/logger.ts';\nimport { NoopLogger } from '~/logger.ts';\nimport type { AnyRelations } from '~/relations.ts';\nimport { fillPlaceholders, type Query } from '~/sql/sql.ts';\nimport { type SQLiteSyncDialect, SQLiteTransaction } from '~/sqlite-core/index.ts';\nimport type { SelectedFieldsOrdered } from '~/sqlite-core/query-builders/select.types.ts';\nimport {\n\ttype PreparedQueryConfig as PreparedQueryConfigBase,\n\ttype SQLiteExecuteMethod,\n\tSQLitePreparedQuery as PreparedQueryBase,\n\tSQLiteSession,\n\ttype SQLiteTransactionConfig,\n} from '~/sqlite-core/session.ts';\nimport { mapResultRow } from '~/utils.ts';\n\nexport interface SQLiteDOSessionOptions {\n\tlogger?: Logger;\n}\n\ntype PreparedQueryConfig = Omit<PreparedQueryConfigBase, 'statement' | 'run'>;\n\nexport class SQLiteDOSession<\n\tTFullSchema extends Record<string, unknown>,\n\tTRelations extends AnyRelations,\n\tTSchema extends V1.TablesRelationalConfig,\n> extends SQLiteSession<\n\t'sync',\n\tSqlStorageCursor<Record<string, SqlStorageValue>>,\n\tTFullSchema,\n\tTRelations,\n\tTSchema\n> {\n\tstatic override readonly [entityKind]: string = 'SQLiteDOSession';\n\n\tprivate logger: Logger;\n\n\tconstructor(\n\t\tprivate client: DurableObjectStorage,\n\t\tdialect: SQLiteSyncDialect,\n\t\tprivate relations: TRelations,\n\t\tprivate schema: V1.RelationalSchemaConfig<TSchema> | undefined,\n\t\toptions: SQLiteDOSessionOptions = {},\n\t) {\n\t\tsuper(dialect);\n\t\tthis.logger = options.logger ?? new NoopLogger();\n\t}\n\n\tprepareQuery<T extends Omit<PreparedQueryConfig, 'run'>>(\n\t\tquery: Query,\n\t\tfields: SelectedFieldsOrdered | undefined,\n\t\texecuteMethod: SQLiteExecuteMethod,\n\t\tisResponseInArrayMode: boolean,\n\t\tcustomResultMapper?: (rows: unknown[][]) => unknown,\n\t): SQLiteDOPreparedQuery<T> {\n\t\treturn new SQLiteDOPreparedQuery(\n\t\t\tthis.client,\n\t\t\tquery,\n\t\t\tthis.logger,\n\t\t\tfields,\n\t\t\texecuteMethod,\n\t\t\tisResponseInArrayMode,\n\t\t\tcustomResultMapper,\n\t\t);\n\t}\n\n\tprepareRelationalQuery<T extends Omit<PreparedQueryConfig, 'run'>>(\n\t\tquery: Query,\n\t\tfields: SelectedFieldsOrdered | undefined,\n\t\texecuteMethod: SQLiteExecuteMethod,\n\t\tcustomResultMapper: (rows: Record<string, unknown>[]) => unknown,\n\t): SQLiteDOPreparedQuery<T, true> {\n\t\treturn new SQLiteDOPreparedQuery(\n\t\t\tthis.client,\n\t\t\tquery,\n\t\t\tthis.logger,\n\t\t\tfields,\n\t\t\texecuteMethod,\n\t\t\tfalse,\n\t\t\tcustomResultMapper,\n\t\t\ttrue,\n\t\t);\n\t}\n\n\toverride transaction<T>(\n\t\ttransaction: (\n\t\t\ttx: SQLiteTransaction<\n\t\t\t\t'sync',\n\t\t\t\tSqlStorageCursor<Record<string, SqlStorageValue>>,\n\t\t\t\tTFullSchema,\n\t\t\t\tTRelations,\n\t\t\t\tTSchema\n\t\t\t>,\n\t\t) => T,\n\t\t_config?: SQLiteTransactionConfig,\n\t): T {\n\t\tconst tx = new SQLiteDOTransaction('sync', this.dialect, this, this.relations, this.schema, undefined, false, true);\n\t\treturn this.client.transactionSync(() => transaction(tx));\n\t}\n}\n\nexport class SQLiteDOTransaction<\n\tTFullSchema extends Record<string, unknown>,\n\tTRelations extends AnyRelations,\n\tTSchema extends V1.TablesRelationalConfig,\n> extends SQLiteTransaction<\n\t'sync',\n\tSqlStorageCursor<Record<string, SqlStorageValue>>,\n\tTFullSchema,\n\tTRelations,\n\tTSchema\n> {\n\tstatic override readonly [entityKind]: string = 'SQLiteDOTransaction';\n\n\toverride transaction<T>(\n\t\ttransaction: (tx: SQLiteDOTransaction<TFullSchema, TRelations, TSchema>) => T,\n\t): T {\n\t\tconst tx = new SQLiteDOTransaction(\n\t\t\t'sync',\n\t\t\tthis.dialect,\n\t\t\tthis.session,\n\t\t\tthis.relations,\n\t\t\tthis.schema,\n\t\t\tthis.nestedIndex + 1,\n\t\t\tfalse,\n\t\t\ttrue,\n\t\t);\n\t\treturn this.session.transaction(() => transaction(tx));\n\t}\n}\n\nexport class SQLiteDOPreparedQuery<\n\tT extends PreparedQueryConfig = PreparedQueryConfig,\n\tTIsRqbV2 extends boolean = false,\n> extends PreparedQueryBase<{\n\ttype: 'sync';\n\trun: void;\n\tall: T['all'];\n\tget: T['get'];\n\tvalues: T['values'];\n\texecute: T['execute'];\n}> {\n\tstatic override readonly [entityKind]: string = 'SQLiteDOPreparedQuery';\n\n\tconstructor(\n\t\tprivate client: DurableObjectStorage,\n\t\tquery: Query,\n\t\tprivate logger: Logger,\n\t\tprivate fields: SelectedFieldsOrdered | undefined,\n\t\texecuteMethod: SQLiteExecuteMethod,\n\t\tprivate _isResponseInArrayMode: boolean,\n\t\tprivate customResultMapper?: (\n\t\t\trows: TIsRqbV2 extends true ? Record<string, unknown>[] : unknown[][],\n\t\t) => unknown,\n\t\tprivate isRqbV2Query?: TIsRqbV2,\n\t) {\n\t\t// 3-6 params are for cache. As long as we don't support sync cache - it will be skipped here\n\t\tsuper('sync', executeMethod, query, undefined, undefined, undefined);\n\t}\n\n\trun(placeholderValues?: Record<string, unknown>): SqlStorageCursor<Record<string, SqlStorageValue>> {\n\t\tconst params = fillPlaceholders(this.query.params, placeholderValues ?? {});\n\t\tthis.logger.logQuery(this.query.sql, params);\n\n\t\tif (params.length > 0) {\n\t\t\treturn this.client.sql.exec(this.query.sql, ...params);\n\t\t}\n\t\treturn this.client.sql.exec(this.query.sql);\n\t}\n\n\tall(placeholderValues?: Record<string, unknown>): T['all'] {\n\t\tif (this.isRqbV2Query) return this.allRqbV2(placeholderValues);\n\n\t\tconst { fields, joinsNotNullableMap, query, logger, client, customResultMapper } = this;\n\t\tif (!fields && !customResultMapper) {\n\t\t\tconst params = fillPlaceholders(query.params, placeholderValues ?? {});\n\t\t\tlogger.logQuery(query.sql, params);\n\n\t\t\treturn params.length > 0 ? client.sql.exec(query.sql, ...params).toArray() : client.sql.exec(query.sql).toArray();\n\t\t}\n\n\t\tconst rows = this.values(placeholderValues) as unknown[][];\n\n\t\tif (customResultMapper) {\n\t\t\treturn (customResultMapper as (rows: unknown[][]) => unknown)(rows) as T['all'];\n\t\t}\n\n\t\treturn rows.map((row) => mapResultRow(fields!, row, joinsNotNullableMap));\n\t}\n\n\tprivate allRqbV2(placeholderValues?: Record<string, unknown>): T['all'] {\n\t\tconst { query, logger, client, customResultMapper } = this;\n\n\t\tconst params = fillPlaceholders(query.params, placeholderValues ?? {});\n\t\tlogger.logQuery(query.sql, params);\n\n\t\tconst rows = params.length > 0\n\t\t\t? client.sql.exec(query.sql, ...params).toArray()\n\t\t\t: client.sql.exec(query.sql).toArray();\n\n\t\treturn (customResultMapper as (rows: Record<string, unknown>[]) => unknown)(rows);\n\t}\n\n\tget(placeholderValues?: Record<string, unknown>): T['get'] {\n\t\tif (this.isRqbV2Query) return this.getRqbV2(placeholderValues);\n\n\t\tconst params = fillPlaceholders(this.query.params, placeholderValues ?? {});\n\t\tthis.logger.logQuery(this.query.sql, params);\n\n\t\tconst { fields, client, joinsNotNullableMap, customResultMapper, query } = this;\n\t\tif (!fields && !customResultMapper) {\n\t\t\treturn (params.length > 0 ? client.sql.exec(query.sql, ...params) : client.sql.exec(query.sql)).next().value;\n\t\t}\n\n\t\tconst rows = this.values(placeholderValues) as unknown[][];\n\t\tconst row = rows[0];\n\n\t\tif (!row) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\tif (customResultMapper) {\n\t\t\treturn (customResultMapper as (rows: unknown[][]) => unknown)(rows) as T['get'];\n\t\t}\n\n\t\treturn mapResultRow(fields!, row, joinsNotNullableMap);\n\t}\n\n\tprivate getRqbV2(placeholderValues?: Record<string, unknown>): T['get'] {\n\t\tconst params = fillPlaceholders(this.query.params, placeholderValues ?? {});\n\t\tthis.logger.logQuery(this.query.sql, params);\n\n\t\tconst { client, customResultMapper, query } = this;\n\n\t\tconst row = (params.length > 0 ? client.sql.exec(query.sql, ...params) : client.sql.exec(query.sql)).next().value;\n\n\t\tif (!row) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\treturn (customResultMapper as (rows: Record<string, unknown>[]) => unknown)([row]) as T['get'];\n\t}\n\n\tvalues(placeholderValues?: Record<string, unknown>): T['values'] {\n\t\tconst params = fillPlaceholders(this.query.params, placeholderValues ?? {});\n\t\tthis.logger.logQuery(this.query.sql, params);\n\n\t\tconst res = params.length > 0\n\t\t\t? this.client.sql.exec(this.query.sql, ...params)\n\t\t\t: this.client.sql.exec(this.query.sql);\n\n\t\t// @ts-ignore .raw().toArray() exists\n\t\treturn res.raw().toArray();\n\t}\n\n\t/** @internal */\n\tisResponseInArrayMode(): boolean {\n\t\treturn this._isResponseInArrayMode;\n\t}\n}\n"],"mappings":"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"}