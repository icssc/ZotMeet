{"version":3,"file":"session.cjs","names":["entityKind","query: Query","dialect: PgDialect"],"sources":["../../src/pg-core/session.ts"],"sourcesContent":["import type { WithCacheConfig } from '~/cache/core/types.ts';\nimport { entityKind } from '~/entity.ts';\nimport type { PreparedQuery } from '~/session.ts';\nimport type { Query, SQL } from '~/sql/index.ts';\nimport type { PgDialect } from './dialect.ts';\nimport type { SelectedFieldsOrdered } from './query-builders/select.types.ts';\n\nexport interface PreparedQueryConfig {\n\texecute: unknown;\n\tall: unknown;\n\tvalues: unknown;\n}\n\nexport abstract class PgBasePreparedQuery implements PreparedQuery {\n\tstatic readonly [entityKind]: string = 'PgBasePreparedQuery';\n\n\tconstructor(protected query: Query) {}\n\n\tgetQuery(): Query {\n\t\treturn this.query;\n\t}\n\n\tmapResult(response: unknown, _isFromBatch?: boolean): unknown {\n\t\treturn response;\n\t}\n\n\t/** @internal */\n\tjoinsNotNullableMap?: Record<string, boolean>;\n\n\t/** @internal */\n\tabstract isResponseInArrayMode(): boolean;\n\n\tabstract execute(placeholderValues?: Record<string, unknown>): unknown;\n\n\t/** @internal */\n\tabstract all(placeholderValues?: Record<string, unknown>): unknown;\n\n\t/** @internal */\n\tprotected abstract queryWithCache(\n\t\tqueryString: string,\n\t\tparams: any[],\n\t\tquery: unknown,\n\t): unknown;\n}\n\nexport interface PgTransactionConfig {\n\tisolationLevel?: 'read uncommitted' | 'read committed' | 'repeatable read' | 'serializable';\n\taccessMode?: 'read only' | 'read write';\n\tdeferrable?: boolean;\n}\n\nexport abstract class PgSession {\n\tstatic readonly [entityKind]: string = 'PgSession';\n\n\tconstructor(protected dialect: PgDialect) {}\n\n\tabstract prepareQuery<T extends PreparedQueryConfig = PreparedQueryConfig>(\n\t\tquery: Query,\n\t\tfields: SelectedFieldsOrdered | undefined,\n\t\tname: string | undefined,\n\t\tisResponseInArrayMode: boolean,\n\t\tcustomResultMapper?: (rows: unknown[][], mapColumnValue?: (value: unknown) => unknown) => T['execute'],\n\t\tqueryMetadata?: {\n\t\t\ttype: 'select' | 'update' | 'delete' | 'insert';\n\t\t\ttables: string[];\n\t\t},\n\t\tcacheConfig?: WithCacheConfig,\n\t): PgBasePreparedQuery;\n\n\tabstract prepareRelationalQuery<T extends PreparedQueryConfig = PreparedQueryConfig>(\n\t\tquery: Query,\n\t\tfields: SelectedFieldsOrdered | undefined,\n\t\tname: string | undefined,\n\t\tcustomResultMapper: (\n\t\t\trows: Record<string, unknown>[],\n\t\t\tmapColumnValue?: (value: unknown) => unknown,\n\t\t) => T['execute'],\n\t): PgBasePreparedQuery;\n\n\tabstract execute(query: SQL): unknown;\n\n\tabstract all(query: SQL): unknown;\n}\n\nexport interface PgQueryResultHKT {\n\treadonly $brand: 'PgQueryResultHKT';\n\treadonly row: unknown;\n\treadonly type: unknown;\n}\n\nexport type PgQueryResultKind<TKind extends PgQueryResultHKT, TRow> = (TKind & {\n\treadonly row: TRow;\n})['type'];\n"],"mappings":";;;;AAaA,IAAsB,sBAAtB,MAAmE;CAClE,QAAiBA,0BAAsB;CAEvC,YAAY,AAAUC,OAAc;EAAd;;CAEtB,WAAkB;AACjB,SAAO,KAAK;;CAGb,UAAU,UAAmB,cAAiC;AAC7D,SAAO;;;CAIR;;AAwBD,IAAsB,YAAtB,MAAgC;CAC/B,QAAiBD,0BAAsB;CAEvC,YAAY,AAAUE,SAAoB;EAApB"}