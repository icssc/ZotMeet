{"version":3,"sources":["../../../../src/build/next-config-ts/transpile-config.ts"],"sourcesContent":["import type { Options as SWCOptions } from '@swc/core'\nimport type { CompilerOptions } from 'typescript'\n\nimport { resolve } from 'node:path'\nimport { readFile } from 'node:fs/promises'\nimport { pathToFileURL } from 'node:url'\nimport { deregisterHook, registerHook, requireFromString } from './require-hook'\nimport { warn, warnOnce } from '../output/log'\nimport { installDependencies } from '../../lib/install-dependencies'\nimport { getNodeOptionsArgs } from '../../server/lib/utils'\n\nfunction resolveSWCOptions(\n  cwd: string,\n  compilerOptions: CompilerOptions\n): SWCOptions {\n  return {\n    jsc: {\n      parser: {\n        syntax: 'typescript',\n      },\n      ...(compilerOptions.paths ? { paths: compilerOptions.paths } : {}),\n      ...(compilerOptions.baseUrl\n        ? // Needs to be an absolute path.\n          { baseUrl: resolve(cwd, compilerOptions.baseUrl) }\n        : compilerOptions.paths\n          ? // If paths is given, baseUrl is required.\n            { baseUrl: cwd }\n          : {}),\n    },\n    module: {\n      type: 'commonjs',\n    },\n    isModule: 'unknown',\n    env: {\n      targets: {\n        // Setting the Node.js version can reduce unnecessary code generation.\n        node: process?.versions?.node ?? '20.19.0',\n      },\n    },\n  } satisfies SWCOptions\n}\n\n// Ported from next/src/lib/verify-typescript-setup.ts\n// Although this overlaps with the later `verifyTypeScriptSetup`,\n// it is acceptable since the time difference in the worst case is trivial,\n// as we are only preparing to install the dependencies once more.\nasync function verifyTypeScriptSetup(cwd: string, configFileName: string) {\n  try {\n    // Quick module check.\n    require.resolve('typescript', { paths: [cwd] })\n  } catch (error) {\n    if (\n      error &&\n      typeof error === 'object' &&\n      'code' in error &&\n      error.code === 'MODULE_NOT_FOUND'\n    ) {\n      warn(\n        `Installing TypeScript as it was not found while loading \"${configFileName}\".`\n      )\n\n      await installDependencies(cwd, [{ pkg: 'typescript' }], true).catch(\n        (err) => {\n          if (err && typeof err === 'object' && 'command' in err) {\n            console.error(\n              `Failed to install TypeScript, please install it manually to continue:\\n` +\n                (err as any).command +\n                '\\n'\n            )\n          }\n          throw err\n        }\n      )\n    }\n  }\n}\n\nasync function getTsConfig(cwd: string): Promise<CompilerOptions> {\n  const ts: typeof import('typescript') = require(\n    require.resolve('typescript', { paths: [cwd] })\n  )\n\n  // NOTE: This doesn't fully cover the edge case for setting\n  // \"typescript.tsconfigPath\" in next config which is currently\n  // a restriction.\n  const tsConfigPath = ts.findConfigFile(\n    cwd,\n    ts.sys.fileExists,\n    'tsconfig.json'\n  )\n\n  if (!tsConfigPath) {\n    // It is ok to not return ts.getDefaultCompilerOptions() because\n    // we are only looking for paths and baseUrl from tsConfig.\n    return {}\n  }\n\n  const configFile = ts.readConfigFile(tsConfigPath, ts.sys.readFile)\n  const parsedCommandLine = ts.parseJsonConfigFileContent(\n    configFile.config,\n    ts.sys,\n    cwd\n  )\n\n  return parsedCommandLine.options\n}\n\nexport async function transpileConfig({\n  nextConfigPath,\n  configFileName,\n  cwd,\n}: {\n  nextConfigPath: string\n  configFileName: string\n  cwd: string\n}) {\n  try {\n    // envs are passed to the workers and preserve the flag\n    if (process.env.__NEXT_NODE_NATIVE_TS_LOADER_ENABLED === 'true') {\n      try {\n        // Node.js v22.10.0+\n        // Value is 'strip' or 'transform' based on how the feature is enabled.\n        // https://nodejs.org/api/process.html#processfeaturestypescript\n        // TODO: Remove `as any` once we bump @types/node to v22.10.0+\n        if ((process.features as any).typescript) {\n          // Run import() here to catch errors and fallback to legacy resolution.\n          return (await import(pathToFileURL(nextConfigPath).href)).default\n        }\n\n        if (\n          getNodeOptionsArgs().includes('--no-experimental-strip-types') ||\n          process.execArgv.includes('--no-experimental-strip-types')\n        ) {\n          warnOnce(\n            `Skipped resolving \"${configFileName}\" using Node.js native TypeScript resolution because it was disabled by the \"--no-experimental-strip-types\" flag.` +\n              ' Falling back to legacy resolution.' +\n              ' Learn more: https://nextjs.org/docs/app/api-reference/config/typescript#using-nodejs-native-typescript-resolver-for-nextconfigts'\n          )\n        }\n\n        // Feature is not enabled, fallback to legacy resolution for current session.\n        process.env.__NEXT_NODE_NATIVE_TS_LOADER_ENABLED = 'false'\n      } catch (cause) {\n        warnOnce(\n          `Failed to import \"${configFileName}\" using Node.js native TypeScript resolution.` +\n            ' Falling back to legacy resolution.' +\n            ' Learn more: https://nextjs.org/docs/app/api-reference/config/typescript#using-nodejs-native-typescript-resolver-for-nextconfigts',\n          { cause }\n        )\n        // Once failed, fallback to legacy resolution for current session.\n        process.env.__NEXT_NODE_NATIVE_TS_LOADER_ENABLED = 'false'\n      }\n    }\n\n    // Ensure TypeScript is installed to use the API.\n    await verifyTypeScriptSetup(cwd, configFileName)\n    const compilerOptions = await getTsConfig(cwd)\n\n    return handleCJS({ cwd, nextConfigPath, compilerOptions })\n  } catch (cause) {\n    throw new Error(`Failed to transpile \"${configFileName}\".`, { cause })\n  }\n}\n\nasync function handleCJS({\n  cwd,\n  nextConfigPath,\n  compilerOptions,\n}: {\n  cwd: string\n  nextConfigPath: string\n  compilerOptions: CompilerOptions\n}) {\n  const swcOptions = resolveSWCOptions(cwd, compilerOptions)\n  let hasRequire = false\n  try {\n    const nextConfigString = await readFile(nextConfigPath, 'utf8')\n    // lazy require swc since it loads React before even setting NODE_ENV\n    // resulting loading Development React on Production\n    const { loadBindings } = require('../swc') as typeof import('../swc')\n    const bindings = await loadBindings()\n    const { code } = await bindings.transform(nextConfigString, swcOptions)\n\n    // register require hook only if require exists\n    if (code.includes('require(')) {\n      registerHook(swcOptions)\n      hasRequire = true\n    }\n\n    // filename & extension don't matter here\n    const config = requireFromString(\n      code,\n      resolve(cwd, 'next.config.compiled.js')\n    )\n    // At this point we have already loaded the bindings without this configuration setting due to the `transform` call above.\n    // Possibly we fell back to wasm in which case, it all works out but if not we need to warn\n    // that the configuration was ignored.\n    if (config?.experimental?.useWasmBinary && !bindings.isWasm) {\n      warn(\n        'Using a next.config.ts file is incompatible with `experimental.useWasmBinary` unless ' +\n          '`--experimental-next-config-strip-types` is also passed.\\nSetting `useWasmBinary` to `false'\n      )\n      config.experimental.useWasmBinary = false\n    }\n    return config\n  } catch (error) {\n    throw error\n  } finally {\n    if (hasRequire) {\n      deregisterHook()\n    }\n  }\n}\n"],"names":["resolve","readFile","pathToFileURL","deregisterHook","registerHook","requireFromString","warn","warnOnce","installDependencies","getNodeOptionsArgs","resolveSWCOptions","cwd","compilerOptions","process","jsc","parser","syntax","paths","baseUrl","module","type","isModule","env","targets","node","versions","verifyTypeScriptSetup","configFileName","require","error","code","pkg","catch","err","console","command","getTsConfig","ts","tsConfigPath","findConfigFile","sys","fileExists","configFile","readConfigFile","parsedCommandLine","parseJsonConfigFileContent","config","options","transpileConfig","nextConfigPath","__NEXT_NODE_NATIVE_TS_LOADER_ENABLED","features","typescript","href","default","includes","execArgv","cause","handleCJS","Error","swcOptions","hasRequire","nextConfigString","loadBindings","bindings","transform","experimental","useWasmBinary","isWasm"],"mappings":"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","ignoreList":[0]}