{"version":3,"sources":["../../../src/server/node-environment-extensions/fast-set-immediate.external.ts"],"sourcesContent":["import { promisify } from 'node:util'\nimport { InvariantError } from '../../shared/lib/invariant-error'\nimport { bindSnapshot } from '../app-render/async-local-storage'\n\ntype Execution = {\n  state: ExecutionState\n  queuedImmediates: QueueItem[]\n}\n\nenum ExecutionState {\n  Waiting = 1,\n  Working = 2,\n  Finished = 3,\n  Abandoned = 4,\n}\n\nlet wasEnabledAtLeastOnce = false\n\nlet pendingNextTicks = 0\nlet currentExecution: Execution | null = null\n\nconst originalSetImmediate = globalThis.setImmediate\nconst originalClearImmediate = globalThis.clearImmediate\nconst originalNextTick = process.nextTick\n\nexport { originalSetImmediate as unpatchedSetImmediate }\n\nfunction install() {\n  if (process.env.NEXT_RUNTIME === 'edge') {\n    // Nothing to patch. The exported functions all error if used in the edge runtime,\n    // so we're not going to violate any assumptions by not patching.\n    return\n  } else {\n    debug?.('installing fast setImmediate patch')\n\n    const nodeTimers = require('node:timers') as typeof import('node:timers')\n    globalThis.setImmediate = nodeTimers.setImmediate =\n      // Workaround for missing __promisify__ which is not a real property\n      patchedSetImmediate as unknown as typeof setImmediate\n    globalThis.clearImmediate = nodeTimers.clearImmediate =\n      patchedClearImmediate\n\n    const nodeTimersPromises =\n      require('node:timers/promises') as typeof import('node:timers/promises')\n    nodeTimersPromises.setImmediate =\n      patchedSetImmediatePromise as typeof import('node:timers/promises').setImmediate\n\n    process.nextTick = patchedNextTick\n  }\n}\n\n/**\n * **WARNING: This function changes the usual behavior of the event loop!**\n * **Be VERY careful about where you call it.**\n *\n * Starts capturing calls to `setImmediate` to run them as \"fast immediates\".\n * All calls captured in this way will be executed after the current task\n * (after callbacks from `process.nextTick()`, microtasks, and nextTicks scheduled from microtasks).\n * This function needs to be called again in each task that needs the\n * \"fast immediates\" behavior.\n *\n * ### Motivation\n *\n * We don't want `setImmediate` to be considered IO in Cache Components.\n * To achieve this in a staged (pre)render, we want to allow immediates scheduled\n * in stage N to run before stage N+1.\n * Since we schedule stages using sequential `setTimeout`, this isn't possible without\n * intercepting `setImmediate` and doing the scheduling on our own.\n * We refer to this as a \"fast immediate\".\n *\n * Notably, this affects React's `scheduleWork` in render, which uses `setImmediate`.\n * This is desirable -- if async work was scheduled during a stage, then it should\n * get to run before we finish that stage.\n *\n * ### Example\n *\n * ```ts\n * setTimeout(() => {\n *   runPendingImmediatesAfterCurrentTask()\n *   console.log(\"timeout 1\")\n *   setImmediate(() => {\n *     console.log(\"immediate!!!\")\n *   })\n * })\n * setTimeout(() => {\n *   console.log(\"timeout 2\")\n * })\n * ```\n * will print\n *\n * ```\n * timeout 1\n * immediate!!!\n * timeout 2\n * ```\n *\n * instead of the usual order\n * ```\n * timeout 1\n * timeout 2\n * immediate!!!\n * ```\n * > **NOTE**\n * > The above is *most common* order, but it's not guaranteed.\n * > Under some circumstances (e.g. when the event loop is blocked on CPU work),\n * > Node will reorder things and run the immediate before timeout 2.\n * > So, in a sense, we're just making this reordering happen consistently.\n *\n * Recursive `setImmediate` calls will also be executed as \"fast immediates\".\n * If multiple immediates were scheduled, `process.nextTick()` (and associated microtasks)\n * will be allowed to execute between them.\n * See the unit tests for more examples.\n * */\nexport function DANGEROUSLY_runPendingImmediatesAfterCurrentTask() {\n  if (process.env.NEXT_RUNTIME === 'edge') {\n    throw new InvariantError(\n      'DANGEROUSLY_runPendingImmediatesAfterCurrentTask cannot be called in the edge runtime'\n    )\n  } else {\n    const execution = startCapturingImmediates()\n\n    try {\n      scheduleWorkAfterNextTicksAndMicrotasks(execution)\n    } catch (err) {\n      // If this error comes from a bail() call, rethrow it.\n      if (execution.state === ExecutionState.Abandoned) {\n        throw err\n      }\n      // Otherwise, bail out here.\n      bail(\n        execution,\n        new InvariantError(\n          'An unexpected error occurred while starting to capture immediates',\n          {\n            cause: err,\n          }\n        )\n      )\n    }\n  }\n}\n\n/**\n * This should always be called a task after `DANGEROUSLY_runPendingImmediatesAfterCurrentTask`\n * to make sure that everything executed as expected and we're not left in an inconsistent state.\n * Ideally, this wouldn't be necessary, but we're not in control of the event loop\n * and need to guard against unexpected behaviors not forseen in this implementation,\n * so we have to be defensive.\n */\nexport function expectNoPendingImmediates() {\n  if (process.env.NEXT_RUNTIME === 'edge') {\n    throw new InvariantError(\n      'expectNoPendingImmediates cannot be called in the edge runtime'\n    )\n  } else {\n    if (currentExecution !== null) {\n      bail(\n        currentExecution,\n        new InvariantError(\n          `Expected all captured immediates to have been executed (state: ${ExecutionState[currentExecution.state]})`\n        )\n      )\n    }\n  }\n}\n\n/**\n * Wait until all nextTicks and microtasks spawned from the current task are done,\n * then execute any immediates that they queued.\n * */\nfunction scheduleWorkAfterNextTicksAndMicrotasks(execution: Execution) {\n  if (execution.state !== ExecutionState.Waiting) {\n    throw new InvariantError(\n      `scheduleWorkAfterTicksAndMicrotasks can only be called while waiting (state: ${ExecutionState[execution.state]})`\n    )\n  }\n\n  // We want to execute \"fast immediates\" after all the nextTicks and microtasks\n  // spawned from the current task are done.\n  // The ordering here is:\n  //\n  // 1. sync code\n  // 2. process.nextTick (scheduled from sync code, or from one of these nextTicks)\n  // 3. microtasks\n  // 4. process.nextTick (scheduled from microtasks, e.g. `queueMicrotask(() => process.nextTick(callback))`)\n  //\n  // We want to run to run in step 4, because that's the latest point before the next tick.\n  // However, there might also be other callbacks scheduled to run in that step.\n  // But importantly, they had to be scheduled using a `process.nextTick`,\n  // so we can detect them by checking if `pendingNextTicks > 0`.\n  // In that case, we'll just reschedule ourselves in the same way again to let them run first.\n  // (this process can theoretically repeat multiple times, hence the recursion).\n\n  queueMicrotask(() => {\n    // (note that this call won't increment `pendingNextTicks`,\n    // only the patched `process.nextTick` does that, so this won't loop infinitely)\n    originalNextTick(() => {\n      // We're now in a nextTick, which means that we're executing inside `processTicksAndRejections`:\n      // https://github.com/nodejs/node/blob/d546e7fd0bc3cbb4bcc2baae6f3aa44d2e81a413/lib/internal/process/task_queues.js#L84\n      // All the work scheduled here will happen within that `processTicksAndRejections` loop.\n      // Reading the source of `processTicksAndRejections` can help understand the timing here --\n      // All we're really doing is strategically pushing callbacks into the two queues\n      // (nextTicks and microtasks) that that function is currently looping over.\n\n      try {\n        if (\n          execution.state === ExecutionState.Abandoned ||\n          currentExecution !== execution\n        ) {\n          debug?.(`scheduler :: the execution was abandoned`)\n          return\n        }\n        if (pendingNextTicks > 0) {\n          // Other nextTicks have been scheduled. Let those run first, then try again --\n          // we're simulating a event loop task, so all nextTicks should be exhausted before we execute.\n          debug?.(`scheduler :: yielding to ${pendingNextTicks} nextTicks`)\n          return scheduleWorkAfterNextTicksAndMicrotasks(execution)\n        }\n\n        // There's no other nextTicks, we're the last one, so we're about to move on to the next task (likely a timer).\n        // Now, we can try and execute any queued immediates.\n        return performWork(execution)\n      } catch (err) {\n        // If this error comes from a bail() call, rethrow it.\n\n        // typescript can't tell that the state might've been mutated\n        // and the narrowing from above is no longer valid\n        const executionAfterWork = execution as Execution\n        if (executionAfterWork.state === ExecutionState.Abandoned) {\n          throw err\n        }\n\n        // Otherwise, bail out here (which will trigger an uncaught exception)\n        // Note that we're using the same microtask trick as `safelyRunNextTickCallback`.\n        queueMicrotask(() => {\n          bail(\n            execution,\n            new InvariantError(\n              'An unexpected error occurred while executing immediates',\n              { cause: err }\n            )\n          )\n        })\n      }\n    })\n  })\n}\n\n/** Execute one immediate, and schedule a check for more (in case there's others in the queue) */\nfunction performWork(execution: Execution) {\n  if (execution.state === ExecutionState.Abandoned) {\n    return\n  }\n\n  debug?.(`scheduler :: performing work`)\n\n  if (execution.state !== ExecutionState.Waiting) {\n    throw new InvariantError(\n      `performWork can only be called while waiting (state: ${ExecutionState[execution.state]})`\n    )\n  }\n  execution.state = ExecutionState.Working\n\n  const queueItem = takeNextActiveQueueItem(execution)\n\n  if (queueItem === null) {\n    debug?.(`scheduler :: no immediates queued, exiting`)\n    stopCapturingImmediates(execution)\n    return\n  }\n\n  debug?.(`scheduler :: executing queued immediate`)\n\n  const { immediateObject, callback, args } = queueItem\n\n  immediateObject[INTERNALS].queueItem = null\n  clearQueueItem(queueItem)\n\n  // Execute the immediate.\n\n  // If a sync error was thrown in the immediate, we want to trigger a `uncaughtException`.\n  // However, we're executing in a nextTick, and if a nextTick callback errors,\n  // It'll break out of `processTicksAndRejections` (note the lack of a `catch` block):\n  //   https://github.com/nodejs/node/blob/d546e7fd0bc3cbb4bcc2baae6f3aa44d2e81a413/lib/internal/process/task_queues.js#L81-L97\n  // Meaning that the event loop will stop executing nextTicks and move on to the next timer\n  // (or other phase of the event loop, but we expect to be running in a sequence of timers here).\n  // Then, the remaining ticks will run after that timer, since they're still in the queue.\n  //\n  // This would completely break the timing we're trying to achieve here --\n  // The point of this patch is to execute immediates before the next timer!\n  // So, we need to work around this behavior. (both here and in our `process.nextTick` patch).\n  //\n  // We can sidestep this by catching the synchronous error and rethrowing it in a microtask.\n  // (NOTE: if we use `queueMicrotask`, it'll trigger `uncaughtException`, not `unhandledRejection`,\n  // because there's no promise being rejected.)\n  //\n  // This will make `uncaughtException` happen:\n  // - Before the next fast immediate (`scheduleWorkAfterNextTicksAndMicrotasks` also uses `queueMicrotask`).\n  //   This is good, and matches usual observable behavior of immediates.\n  // - AFTER nextTicks scheduled from the immediate itself.\n  //   This deviates from native setImmediate, which would call `uncaughtException` first,\n  //   and skip ahead to the next task as explained above.\n  //\n  // This is technically an observable difference in behavior, but it seems niche enough that\n  // it shouldn't cause problems -- we don't expect user code to use `uncaughtException` for control flow,\n  // only error reporting, so subtly changing the timing shouldn't matter.\n\n  let didThrow = false\n  let thrownValue: unknown = undefined\n  queueMicrotask(() => {\n    if (didThrow) {\n      debug?.('scheduler :: rethrowing sync error from immediate in microtask')\n      throw thrownValue\n    }\n  })\n\n  try {\n    if (args !== null) {\n      callback.apply(null, args)\n    } else {\n      callback()\n    }\n  } catch (err) {\n    // We'll rethrow the error in the microtask above.\n    didThrow = true\n    thrownValue = err\n  }\n\n  // Schedule the loop again in case there's more immediates after this one.\n  // Note that we can't just check if the queue is empty now, because new immediates\n  // might still be scheduled asynchronously, from an upcoming nextTick or microtask.\n  execution.state = ExecutionState.Waiting\n  scheduleWorkAfterNextTicksAndMicrotasks(execution)\n}\n\nfunction takeNextActiveQueueItem(execution: Execution): ActiveQueueItem | null {\n  // Find the first (if any) queued immediate that wasn't cleared.\n  // We don't remove immediates from the array when they're cleared,\n  // so this requires some legwork to exclude (and possibly drop) cleared items.\n  const { queuedImmediates } = execution\n\n  let firstActiveItem: ActiveQueueItem | null = null\n  let firstActiveItemIndex = -1\n  for (let i = 0; i < queuedImmediates.length; i++) {\n    const item = queuedImmediates[i]\n    if (!item.isCleared) {\n      firstActiveItem = item\n      firstActiveItemIndex = i\n      break\n    }\n  }\n\n  if (firstActiveItem === null) {\n    // We didn't find an active item.\n\n    // If the queue isn't empty, then it must only contain cleared items. Empty it.\n    if (queuedImmediates.length > 0) {\n      queuedImmediates.length = 0\n    }\n\n    return null\n  }\n\n  // Remove all items up to and including `nextActiveItemIndex` from the queue.\n  // (if it's not the first item, then it must be preceded by cleared items, which we want to drop anyway)\n  if (firstActiveItemIndex === 0) {\n    // Fast path - drop the first item\n    // (`splice` creates a result array for the removed items, so this is more efficient)\n    queuedImmediates.shift()\n  } else {\n    queuedImmediates.splice(0, firstActiveItemIndex + 1)\n  }\n\n  return firstActiveItem\n}\n\nfunction startCapturingImmediates(): Execution {\n  if (currentExecution !== null) {\n    bail(\n      currentExecution,\n      new InvariantError(\n        `Cannot start capturing immediates again without finishing the previous task (state: ${ExecutionState[currentExecution.state]})`\n      )\n    )\n  }\n  wasEnabledAtLeastOnce = true\n\n  const execution: Execution = {\n    state: ExecutionState.Waiting,\n    queuedImmediates: [],\n  }\n  currentExecution = execution\n\n  return execution\n}\n\nfunction stopCapturingImmediates(execution: Execution) {\n  if (execution.state === ExecutionState.Abandoned) {\n    return\n  }\n\n  // This check enforces that we run performWork at least once before stopping\n  // to make sure that we've waited for all the nextTicks and microtasks\n  // that might've scheduled some immediates after sync code.\n  if (execution.state !== ExecutionState.Working) {\n    throw new InvariantError(\n      `Cannot stop capturing immediates before execution is finished (state: ${ExecutionState[execution.state]})`\n    )\n  }\n\n  execution.state = ExecutionState.Finished\n\n  if (currentExecution === execution) {\n    currentExecution = null\n  }\n}\n\nfunction bail(execution: Execution, error: Error): never {\n  // Reset the state as best we can to prevent further crashes.\n  // Otherwise, any subsequent call to `DANGEROUSLY_runPendingImmediatesAfterCurrentTask`\n  // would error, requiring a server restart to fix.\n\n  if (currentExecution === execution) {\n    currentExecution = null\n  }\n\n  execution.state = ExecutionState.Abandoned\n\n  // If we have any queued immediates, schedule them with native `setImmediate` and clear the queue.\n  // We don't want to skip running them altogether, because that could lead to\n  // e.g. hanging promises (for `new Promise((resolve) => setImmediate(resolve))`),\n  // but we're in an inconsistent state and can't run them as fast immediates,\n  // so this is the next best thing.\n  for (const queueItem of execution.queuedImmediates) {\n    if (queueItem.isCleared) {\n      continue\n    }\n    scheduleQueuedImmediateAsNativeImmediate(queueItem)\n  }\n  execution.queuedImmediates.length = 0\n\n  // Don't reset `pendingNextTicks` -- it will reset to 0 on its own as the nextTicks execute.\n  // If we set it to 0 here while we still have pending ticks, they'd decrement it below 0.\n\n  throw error\n}\n\nfunction scheduleQueuedImmediateAsNativeImmediate(queueItem: ActiveQueueItem) {\n  const { callback, args, immediateObject } = queueItem\n  const hasRef = immediateObject[INTERNALS].hasRef\n\n  clearQueueItem(queueItem)\n\n  const nativeImmediate =\n    args !== null\n      ? originalSetImmediate(callback, ...args)\n      : originalSetImmediate(callback)\n\n  if (!hasRef) {\n    nativeImmediate.unref()\n  }\n\n  // Make our fake immediate object proxy all relevant operations\n  // (clearing, ref(), unref(), hasRef()) to the actual native immediate.\n  proxyQueuedImmediateToNativeImmediate(immediateObject, nativeImmediate)\n}\n\ntype QueueItem = ActiveQueueItem | ClearedQueueItem\ntype ActiveQueueItem = {\n  isCleared: false\n  callback: (...args: any[]) => any\n  args: any[] | null\n  immediateObject: NextImmediate\n}\ntype ClearedQueueItem = {\n  isCleared: true\n  callback: null\n  args: null\n  immediateObject: null\n}\n\nfunction clearQueueItem(originalQueueItem: QueueItem) {\n  const queueItem = originalQueueItem as ClearedQueueItem\n  queueItem.isCleared = true\n  queueItem.callback = null\n  queueItem.args = null\n  queueItem.immediateObject = null\n}\n\n//========================================================\n\nfunction patchedNextTick<TArgs extends any[]>(\n  callback: (...args: TArgs) => void,\n  ...args: TArgs\n): void\nfunction patchedNextTick() {\n  if (currentExecution === null) {\n    return originalNextTick.apply(\n      null,\n      // @ts-expect-error: this is valid, but typescript doesn't get it\n      arguments\n    )\n  }\n\n  if (arguments.length === 0 || typeof arguments[0] !== 'function') {\n    // Let the original nextTick error for invalid arguments\n    // so that we don't have to mirror the error message.\n    originalNextTick.apply(\n      null,\n      // @ts-expect-error: explicitly passing arguments that we know are invalid\n      arguments\n    )\n\n    // We expect the above call to throw. If it didn't, something's broken.\n    bail(\n      currentExecution,\n      new InvariantError(\n        'Expected process.nextTick to reject invalid arguments'\n      )\n    )\n  }\n\n  debug?.(\n    `scheduler :: process.nextTick called (previous pending: ${pendingNextTicks})`\n  )\n\n  const callback: (...args: any[]) => any = arguments[0]\n  const args: any[] | null =\n    arguments.length > 1 ? Array.prototype.slice.call(arguments, 1) : null\n\n  pendingNextTicks += 1\n  return originalNextTick(safelyRunNextTickCallback, callback, args)\n}\n\nfunction safelyRunNextTickCallback(\n  callback: (...args: any[]) => any,\n  args: any[] | null\n) {\n  pendingNextTicks -= 1\n  debug?.(\n    `scheduler :: process.nextTick executing (still pending: ${pendingNextTicks})`\n  )\n\n  // Synchronous errors in nextTick break out of `processTicksAndRejections` and cause us\n  // to move on to the next timer without having executed the whole nextTick queue,\n  // which breaks our entire scheduling mechanism. See `performWork` for more details.\n  try {\n    if (args !== null) {\n      callback.apply(null, args)\n    } else {\n      callback()\n    }\n  } catch (err) {\n    // We want to make sure `nextTick` is cheap, so unlike `performWork`,\n    // we only queue the microtask if an error actually occurs.\n    // This (observably) changes the timing of `uncaughtException` even more,\n    // because it'll run after microtasks queued from the nextTick,\n    // but hopefully this is niche enough to not affect any real world code.\n    queueMicrotask(() => {\n      debug?.(`scheduler :: rethrowing sync error from nextTick in a microtask`)\n      throw err\n    })\n  }\n}\n\nfunction patchedSetImmediate<TArgs extends any[]>(\n  callback: (...args: TArgs) => void,\n  ...args: TArgs\n): NodeJS.Immediate\nfunction patchedSetImmediate(callback: (args: void) => void): NodeJS.Immediate\nfunction patchedSetImmediate(): NodeJS.Immediate {\n  if (currentExecution === null) {\n    return originalSetImmediate.apply(\n      null,\n      // @ts-expect-error: this is valid, but typescript doesn't get it\n      arguments\n    )\n  }\n\n  if (arguments.length === 0 || typeof arguments[0] !== 'function') {\n    // Let the original setImmediate error for invalid arguments\n    // so that we don't have to mirror the error message.\n    originalSetImmediate.apply(\n      null,\n      // @ts-expect-error: explicitly passing arguments that we know are invalid\n      arguments\n    )\n\n    // We expect the above call to throw. If it didn't, something's broken.\n    bail(\n      currentExecution,\n      new InvariantError('Expected setImmediate to reject invalid arguments')\n    )\n  }\n\n  const callback: (...args: any[]) => any = arguments[0]\n  const args: any[] | null =\n    arguments.length > 1 ? Array.prototype.slice.call(arguments, 1) : null\n\n  // Normally, Node would capture and propagate the async context to the immediate.\n  // We'll be running it on our own queue, so we need to propagate it ourselves.\n  const callbackWithAsyncContext = bindSnapshot(callback)\n\n  const immediateObject = new NextImmediate()\n\n  const queueItem: ActiveQueueItem = {\n    isCleared: false,\n    callback: callbackWithAsyncContext,\n    args,\n    immediateObject,\n  }\n  currentExecution.queuedImmediates.push(queueItem)\n\n  immediateObject[INTERNALS].queueItem = queueItem\n\n  return immediateObject\n}\n\nfunction patchedSetImmediatePromise<T = void>(\n  value: T,\n  options?: import('node:timers').TimerOptions\n): Promise<T> {\n  if (currentExecution === null) {\n    const originalPromisify: (typeof setImmediate)['__promisify__'] =\n      // @ts-expect-error: the types for `promisify.custom` are strange\n      originalSetImmediate[promisify.custom]\n    return originalPromisify(value, options)\n  }\n\n  return new Promise<T>((resolve, reject) => {\n    // The abort signal makes the promise reject.\n    // If it is already aborted, we reject immediately.\n    const signal = options?.signal\n    if (signal && signal.aborted) {\n      return reject(signal.reason)\n    }\n\n    const immediate = patchedSetImmediate(resolve, value)\n\n    // Unref-ing only really has an observable effect if we bail out to a native immediate,\n    // but we do it for completeness\n    if (options?.ref === false) {\n      immediate.unref()\n    }\n\n    if (signal) {\n      signal.addEventListener(\n        'abort',\n        () => {\n          patchedClearImmediate(immediate)\n          reject(signal.reason)\n        },\n        { once: true }\n      )\n    }\n  })\n}\n\npatchedSetImmediate[promisify.custom] = patchedSetImmediatePromise\n\nconst patchedClearImmediate = (\n  immediateObject: NodeJS.Immediate | undefined\n) => {\n  // NOTE: we defensively check for patched immediates even if we're not\n  // currently capturing immediates, because the objects returned from\n  // the patched setImmediate can be kept around for arbitrarily long.\n  // As an optimization, we only do this if the patch was enabled at least once --\n  // otherwise, no patched objects could've been created.\n  if (\n    wasEnabledAtLeastOnce &&\n    immediateObject &&\n    typeof immediateObject === 'object' &&\n    INTERNALS in immediateObject\n  ) {\n    ;(immediateObject as NextImmediate)[Symbol.dispose]()\n  } else {\n    originalClearImmediate(immediateObject)\n  }\n}\n\n//========================================================\n\nconst INTERNALS: unique symbol = Symbol.for('next.Immediate.internals')\n\ntype NextImmediateInternals =\n  | {\n      /** Stored to reflect `ref()`/`unref()` calls, but has no effect otherwise */\n      hasRef: boolean\n      queueItem: ActiveQueueItem | null\n      nativeImmediate: null\n    }\n  | {\n      hasRef: null\n      queueItem: null\n      nativeImmediate: NodeJS.Immediate\n    }\n\nfunction proxyQueuedImmediateToNativeImmediate(\n  immediateObject: NextImmediate,\n  nativeImmediate: NodeJS.Immediate\n) {\n  immediateObject[INTERNALS].hasRef = null\n  immediateObject[INTERNALS].queueItem = null\n  immediateObject[INTERNALS].nativeImmediate = nativeImmediate\n}\n\n/** Makes sure that we're implementing all the public `Immediate` methods */\ninterface NativeImmediate extends NodeJS.Immediate {}\n\n/** Implements a shim for the native `Immediate` class returned by `setImmediate` */\nclass NextImmediate implements NativeImmediate {\n  [INTERNALS]: NextImmediateInternals = {\n    queueItem: null,\n    hasRef: true,\n    nativeImmediate: null,\n  }\n  hasRef() {\n    const internals = this[INTERNALS]\n    if (internals.queueItem) {\n      return internals.hasRef\n    } else if (internals.nativeImmediate) {\n      return internals.nativeImmediate.hasRef()\n    } else {\n      // if we're no longer queued (cleared or executed), hasRef is always false\n      return false\n    }\n  }\n  ref() {\n    const internals = this[INTERNALS]\n    if (internals.queueItem) {\n      internals.hasRef = true\n    } else if (internals.nativeImmediate) {\n      internals.nativeImmediate.ref()\n    }\n    return this\n  }\n  unref() {\n    const internals = this[INTERNALS]\n    if (internals.queueItem) {\n      internals.hasRef = false\n    } else if (internals.nativeImmediate) {\n      internals.nativeImmediate.unref()\n    }\n    return this\n  }\n\n  /**\n   * Node invokes `_onImmediate` when an immediate is executed:\n   * https://github.com/nodejs/node/blob/42d363205715ffa5a4a6d90f4be1311487053d65/lib/internal/timers.js#L504\n   * It's visible on the public types, so we want to have it here for parity, but it's a noop.\n   * */\n  _onImmediate() {}\n\n  [Symbol.dispose]() {\n    // This is equivalent to `clearImmediate`.\n    const internals = this[INTERNALS]\n    if (internals.queueItem) {\n      // this is still queued. drop it.\n      const queueItem = internals.queueItem\n      internals.queueItem = null\n      clearQueueItem(queueItem)\n    } else if (internals.nativeImmediate) {\n      internals.nativeImmediate[Symbol.dispose]()\n    }\n  }\n}\n\n// ==========================================\n\nconst debug =\n  process.env.NEXT_DEBUG_IMMEDIATES !== '1'\n    ? undefined\n    : (...args: any[]) => {\n        if (process.env.NEXT_RUNTIME === 'edge') {\n          throw new InvariantError(\n            'Fast setImmediate is not available in the edge runtime.'\n          )\n        } else {\n          const { inspect } = require('node:util') as typeof import('node:util')\n          const { writeFileSync } =\n            require('node:fs') as typeof import('node:fs')\n\n          let logLine =\n            args\n              .map((arg) =>\n                typeof arg === 'string' ? arg : inspect(arg, { colors: true })\n              )\n              .join(' ') + '\\n'\n\n          logLine = '\\x1B[2m' + logLine + '\\x1B[22m' // styleText('dim', logLine)\n          writeFileSync(process.stdout.fd, logLine)\n        }\n      }\n\n// ==========================================\n\ninstall()\n"],"names":["DANGEROUSLY_runPendingImmediatesAfterCurrentTask","expectNoPendingImmediates","unpatchedSetImmediate","originalSetImmediate","ExecutionState","wasEnabledAtLeastOnce","pendingNextTicks","currentExecution","globalThis","setImmediate","originalClearImmediate","clearImmediate","originalNextTick","process","nextTick","install","env","NEXT_RUNTIME","debug","nodeTimers","require","patchedSetImmediate","patchedClearImmediate","nodeTimersPromises","patchedSetImmediatePromise","patchedNextTick","InvariantError","execution","startCapturingImmediates","scheduleWorkAfterNextTicksAndMicrotasks","err","state","bail","cause","queueMicrotask","performWork","executionAfterWork","queueItem","takeNextActiveQueueItem","stopCapturingImmediates","immediateObject","callback","args","INTERNALS","clearQueueItem","didThrow","thrownValue","undefined","apply","queuedImmediates","firstActiveItem","firstActiveItemIndex","i","length","item","isCleared","shift","splice","error","scheduleQueuedImmediateAsNativeImmediate","hasRef","nativeImmediate","unref","proxyQueuedImmediateToNativeImmediate","originalQueueItem","arguments","Array","prototype","slice","call","safelyRunNextTickCallback","callbackWithAsyncContext","bindSnapshot","NextImmediate","push","value","options","originalPromisify","promisify","custom","Promise","resolve","reject","signal","aborted","reason","immediate","ref","addEventListener","once","Symbol","dispose","for","internals","_onImmediate","NEXT_DEBUG_IMMEDIATES","inspect","writeFileSync","logLine","map","arg","colors","join","stdout","fd"],"mappings":"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","ignoreList":[0]}