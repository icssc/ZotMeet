{"version":3,"file":"session.js","names":["client: XataHttpClient","logger: Logger","fields: SelectedFieldsOrdered | undefined","_isResponseInArrayMode: boolean","customResultMapper?: (\n\t\t\trows: TIsRqbV2 extends true ? Record<string, unknown>[] : unknown[][],\n\t\t) => T['execute']","isRqbV2Query?: TIsRqbV2","relations: TRelations","schema: V1.RelationalSchemaConfig<TSchema> | undefined","options: XataHttpSessionOptions"],"sources":["../../src/xata-http/session.ts"],"sourcesContent":["import type { SQLPluginResult, SQLQueryResult } from '@xata.io/client';\nimport type * as V1 from '~/_relations.ts';\nimport type { Cache } from '~/cache/core/index.ts';\nimport { NoopCache } from '~/cache/core/index.ts';\nimport type { WithCacheConfig } from '~/cache/core/types.ts';\nimport { entityKind } from '~/entity.ts';\nimport type { Logger } from '~/logger.ts';\nimport { NoopLogger } from '~/logger.ts';\nimport { PgAsyncPreparedQuery, PgAsyncSession, PgAsyncTransaction } from '~/pg-core/async/session.ts';\nimport type { PgDialect } from '~/pg-core/dialect.ts';\nimport type { SelectedFieldsOrdered } from '~/pg-core/query-builders/select.types.ts';\nimport type { PgQueryResultHKT, PgTransactionConfig, PreparedQueryConfig } from '~/pg-core/session.ts';\nimport type { AnyRelations } from '~/relations.ts';\nimport { fillPlaceholders, type Query } from '~/sql/sql.ts';\nimport { mapResultRow } from '~/utils.ts';\n\nexport type XataHttpClient = {\n\tsql: SQLPluginResult;\n};\n\nexport interface QueryResults<ArrayMode extends 'json' | 'array'> {\n\trowCount: number;\n\trows: ArrayMode extends 'array' ? any[][] : Record<string, any>[];\n\trowAsArray: ArrayMode extends 'array' ? true : false;\n}\n\nexport class XataHttpPreparedQuery<T extends PreparedQueryConfig, TIsRqbV2 extends boolean = false>\n\textends PgAsyncPreparedQuery<T>\n{\n\tstatic override readonly [entityKind]: string = 'XataHttpPreparedQuery';\n\n\tconstructor(\n\t\tprivate client: XataHttpClient,\n\t\tquery: Query,\n\t\tprivate logger: Logger,\n\t\tcache: Cache,\n\t\tqueryMetadata: {\n\t\t\ttype: 'select' | 'update' | 'delete' | 'insert';\n\t\t\ttables: string[];\n\t\t} | undefined,\n\t\tcacheConfig: WithCacheConfig | undefined,\n\t\tprivate fields: SelectedFieldsOrdered | undefined,\n\t\tprivate _isResponseInArrayMode: boolean,\n\t\tprivate customResultMapper?: (\n\t\t\trows: TIsRqbV2 extends true ? Record<string, unknown>[] : unknown[][],\n\t\t) => T['execute'],\n\t\tprivate isRqbV2Query?: TIsRqbV2,\n\t) {\n\t\tsuper(query, cache, queryMetadata, cacheConfig);\n\t}\n\n\tasync execute(placeholderValues: Record<string, unknown> | undefined = {}): Promise<T['execute']> {\n\t\tif (this.isRqbV2Query) return this.executeRqbV2(placeholderValues);\n\n\t\tconst params = fillPlaceholders(this.query.params, placeholderValues);\n\n\t\tthis.logger.logQuery(this.query.sql, params);\n\n\t\tconst { fields, client, query, customResultMapper, joinsNotNullableMap } = this;\n\n\t\tif (!fields && !customResultMapper) {\n\t\t\treturn this.queryWithCache(query.sql, params, async () => {\n\t\t\t\treturn await client.sql<Record<string, any>>({ statement: query.sql, params });\n\t\t\t});\n\t\t}\n\n\t\tconst { rows, warning } = await this.queryWithCache(query.sql, params, async () => {\n\t\t\treturn await client.sql({ statement: query.sql, params, responseType: 'array' });\n\t\t});\n\n\t\tif (warning) console.warn(warning);\n\n\t\treturn customResultMapper\n\t\t\t? (customResultMapper as (rows: unknown[][]) => T['execute'])(rows as unknown[][])\n\t\t\t: rows.map((row) => mapResultRow<T['execute']>(fields!, row as unknown[], joinsNotNullableMap));\n\t}\n\n\tprivate async executeRqbV2(placeholderValues: Record<string, unknown> | undefined = {}): Promise<T['execute']> {\n\t\tconst params = fillPlaceholders(this.query.params, placeholderValues);\n\n\t\tthis.logger.logQuery(this.query.sql, params);\n\n\t\tconst { client, query, customResultMapper } = this;\n\n\t\tconst { warning, records } = await client.sql<Record<string, any>>({\n\t\t\tstatement: query.sql,\n\t\t\tparams,\n\t\t\tresponseType: 'json',\n\t\t});\n\t\tif (warning) console.warn(warning);\n\n\t\treturn (customResultMapper as (rows: Record<string, unknown>[]) => T['execute'])(records);\n\t}\n\n\tall(placeholderValues: Record<string, unknown> | undefined = {}): Promise<T['all']> {\n\t\tconst params = fillPlaceholders(this.query.params, placeholderValues);\n\t\tthis.logger.logQuery(this.query.sql, params);\n\t\treturn this.queryWithCache(this.query.sql, params, async () => {\n\t\t\treturn this.client.sql({ statement: this.query.sql, params, responseType: 'array' });\n\t\t}).then((result) => result.rows);\n\t}\n\n\tvalues(placeholderValues: Record<string, unknown> | undefined = {}): Promise<T['values']> {\n\t\tconst params = fillPlaceholders(this.query.params, placeholderValues);\n\t\tthis.logger.logQuery(this.query.sql, params);\n\t\treturn this.queryWithCache(this.query.sql, params, async () => {\n\t\t\treturn this.client.sql({ statement: this.query.sql, params });\n\t\t}).then((result) => result.records);\n\t}\n\n\t/** @internal */\n\tisResponseInArrayMode() {\n\t\treturn this._isResponseInArrayMode;\n\t}\n}\n\nexport interface XataHttpSessionOptions {\n\tlogger?: Logger;\n\tcache?: Cache;\n}\n\nexport class XataHttpSession<\n\tTFullSchema extends Record<string, unknown>,\n\tTRelations extends AnyRelations,\n\tTSchema extends V1.TablesRelationalConfig,\n> extends PgAsyncSession<\n\tXataHttpQueryResultHKT,\n\tTFullSchema,\n\tTRelations,\n\tTSchema\n> {\n\tstatic override readonly [entityKind]: string = 'XataHttpSession';\n\n\tprivate logger: Logger;\n\tprivate cache: Cache;\n\n\tconstructor(\n\t\tprivate client: XataHttpClient,\n\t\tdialect: PgDialect,\n\t\tprivate relations: TRelations,\n\t\tprivate schema: V1.RelationalSchemaConfig<TSchema> | undefined,\n\t\tprivate options: XataHttpSessionOptions = {},\n\t) {\n\t\tsuper(dialect);\n\t\tthis.logger = options.logger ?? new NoopLogger();\n\t\tthis.cache = options.cache ?? new NoopCache();\n\t}\n\n\tprepareQuery<T extends PreparedQueryConfig = PreparedQueryConfig>(\n\t\tquery: Query,\n\t\tfields: SelectedFieldsOrdered | undefined,\n\t\tname: string | undefined,\n\t\tisResponseInArrayMode: boolean,\n\t\tcustomResultMapper?: (rows: unknown[][]) => T['execute'],\n\t\tqueryMetadata?: {\n\t\t\ttype: 'select' | 'update' | 'delete' | 'insert';\n\t\t\ttables: string[];\n\t\t},\n\t\tcacheConfig?: WithCacheConfig,\n\t): PgAsyncPreparedQuery<T> {\n\t\treturn new XataHttpPreparedQuery(\n\t\t\tthis.client,\n\t\t\tquery,\n\t\t\tthis.logger,\n\t\t\tthis.cache,\n\t\t\tqueryMetadata,\n\t\t\tcacheConfig,\n\t\t\tfields,\n\t\t\tisResponseInArrayMode,\n\t\t\tcustomResultMapper,\n\t\t);\n\t}\n\n\tprepareRelationalQuery<T extends PreparedQueryConfig = PreparedQueryConfig>(\n\t\tquery: Query,\n\t\tfields: SelectedFieldsOrdered | undefined,\n\t\tname: string | undefined,\n\t\tcustomResultMapper: (rows: Record<string, unknown>[]) => T['execute'],\n\t): PgAsyncPreparedQuery<T> {\n\t\treturn new XataHttpPreparedQuery(\n\t\t\tthis.client,\n\t\t\tquery,\n\t\t\tthis.logger,\n\t\t\tthis.cache,\n\t\t\tundefined,\n\t\t\tundefined,\n\t\t\tfields,\n\t\t\tfalse,\n\t\t\tcustomResultMapper,\n\t\t\ttrue,\n\t\t);\n\t}\n\n\tasync query(query: string, params: unknown[]): Promise<QueryResults<'array'>> {\n\t\tthis.logger.logQuery(query, params);\n\t\tconst result = await this.client.sql({ statement: query, params, responseType: 'array' });\n\n\t\treturn {\n\t\t\trowCount: result.rows.length,\n\t\t\trows: result.rows,\n\t\t\trowAsArray: true,\n\t\t};\n\t}\n\n\tasync queryObjects(query: string, params: unknown[]): Promise<QueryResults<'json'>> {\n\t\tconst result = await this.client.sql<Record<string, any>>({ statement: query, params });\n\n\t\treturn {\n\t\t\trowCount: result.records.length,\n\t\t\trows: result.records,\n\t\t\trowAsArray: false,\n\t\t};\n\t}\n\n\toverride async transaction<T>(\n\t\t_transaction: (tx: XataTransaction<TFullSchema, TRelations, TSchema>) => Promise<T>,\n\t\t// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\t\t_config: PgTransactionConfig = {},\n\t): Promise<T> {\n\t\tthrow new Error('No transactions support in Xata Http driver');\n\t}\n}\n\nexport class XataTransaction<\n\tTFullSchema extends Record<string, unknown>,\n\tTRelations extends AnyRelations,\n\tTSchema extends V1.TablesRelationalConfig,\n> extends PgAsyncTransaction<\n\tXataHttpQueryResultHKT,\n\tTFullSchema,\n\tTRelations,\n\tTSchema\n> {\n\tstatic override readonly [entityKind]: string = 'XataHttpTransaction';\n\n\toverride async transaction<T>(\n\t\t_transaction: (tx: XataTransaction<TFullSchema, TRelations, TSchema>) => Promise<T>,\n\t): Promise<T> {\n\t\tthrow new Error('No transactions support in Xata Http driver');\n\t}\n}\n\nexport interface XataHttpQueryResultHKT extends PgQueryResultHKT {\n\ttype: SQLQueryResult<this['row']>;\n}\n"],"mappings":"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"}