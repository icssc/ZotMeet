{"version":3,"file":"session.js","names":["cache: Cache | undefined","queryMetadata: {\n\t\t\ttype: 'select' | 'update' | 'delete' | 'insert';\n\t\t\ttables: string[];\n\t\t} | undefined","cacheConfig?: WithCacheConfig","relations: TRelations","schema: {\n\t\t\tfullSchema: Record<string, unknown>;\n\t\t\tschema: TSchema;\n\t\t\ttableNamesMap: Record<string, string>;\n\t\t} | undefined","chunks: string[]"],"sources":["../../../src/pg-core/async/session.ts"],"sourcesContent":["import type * as V1 from '~/_relations.ts';\nimport { type Cache, NoopCache, strategyFor } from '~/cache/core/cache.ts';\nimport type { WithCacheConfig } from '~/cache/core/types.ts';\nimport { entityKind } from '~/entity.ts';\nimport { is } from '~/entity.ts';\nimport { TransactionRollbackError } from '~/errors.ts';\nimport { DrizzleQueryError } from '~/errors.ts';\nimport type { MigrationConfig, MigrationMeta, MigratorInitFailResponse } from '~/migrator.ts';\nimport type { AnyRelations, EmptyRelations } from '~/relations.ts';\nimport { type Query, type SQL, sql } from '~/sql/sql.ts';\nimport { tracer } from '~/tracing.ts';\nimport type { NeonAuthToken } from '~/utils.ts';\nimport { assertUnreachable } from '~/utils.ts';\nimport type { PgDialect } from '../dialect.ts';\nimport type { SelectedFieldsOrdered } from '../query-builders/select.types.ts';\nimport type { PgQueryResultHKT, PgTransactionConfig, PreparedQueryConfig } from '../session.ts';\nimport { PgBasePreparedQuery, PgSession } from '../session.ts';\nimport { PgAsyncDatabase } from './db.ts';\n\nexport abstract class PgAsyncPreparedQuery<T extends PreparedQueryConfig> extends PgBasePreparedQuery {\n\tstatic override readonly [entityKind]: string = 'PgAsyncPreparedQuery';\n\n\tconstructor(\n\t\tquery: Query,\n\t\t// cache instance\n\t\tprivate cache: Cache | undefined,\n\t\t// per query related metadata\n\t\tprivate queryMetadata: {\n\t\t\ttype: 'select' | 'update' | 'delete' | 'insert';\n\t\t\ttables: string[];\n\t\t} | undefined,\n\t\t// config that was passed through $withCache\n\t\tprivate cacheConfig?: WithCacheConfig,\n\t) {\n\t\tsuper(query);\n\t\tif (cache && cache.strategy() === 'all' && cacheConfig === undefined) {\n\t\t\tthis.cacheConfig = { enabled: true, autoInvalidate: true };\n\t\t}\n\t\tif (!this.cacheConfig?.enabled) {\n\t\t\tthis.cacheConfig = undefined;\n\t\t}\n\t}\n\n\t/** @internal */\n\tprotected authToken?: NeonAuthToken;\n\t/** @internal */\n\tsetToken(token?: NeonAuthToken) {\n\t\tthis.authToken = token;\n\t\treturn this;\n\t}\n\n\tabstract override execute(placeholderValues?: Record<string, unknown>): Promise<T['execute']>;\n\n\t/** @internal */\n\tabstract override all(placeholderValues?: Record<string, unknown>): Promise<T['all']>;\n\n\t/** @internal */\n\tprotected async queryWithCache<T>(\n\t\tqueryString: string,\n\t\tparams: any[],\n\t\tquery: () => Promise<T>,\n\t): Promise<T> {\n\t\tconst cacheStrat = this.cache !== undefined && !is(this.cache, NoopCache)\n\t\t\t? await strategyFor(queryString, params, this.queryMetadata, this.cacheConfig)\n\t\t\t: { type: 'skip' as const };\n\n\t\tif (cacheStrat.type === 'skip') {\n\t\t\treturn query().catch((e) => {\n\t\t\t\tthrow new DrizzleQueryError(queryString, params, e as Error);\n\t\t\t});\n\t\t}\n\n\t\tconst cache = this.cache!;\n\n\t\t// For mutate queries, we should query the database, wait for a response, and then perform invalidation\n\t\tif (cacheStrat.type === 'invalidate') {\n\t\t\treturn Promise.all([\n\t\t\t\tquery(),\n\t\t\t\tcache.onMutate({ tables: cacheStrat.tables }),\n\t\t\t]).then((res) => res[0]).catch((e) => {\n\t\t\t\tthrow new DrizzleQueryError(queryString, params, e as Error);\n\t\t\t});\n\t\t}\n\n\t\tif (cacheStrat.type === 'try') {\n\t\t\tconst { tables, key, isTag, autoInvalidate, config } = cacheStrat;\n\t\t\tconst fromCache = await cache.get(\n\t\t\t\tkey,\n\t\t\t\ttables,\n\t\t\t\tisTag,\n\t\t\t\tautoInvalidate,\n\t\t\t);\n\n\t\t\tif (fromCache === undefined) {\n\t\t\t\tconst result = await query().catch((e) => {\n\t\t\t\t\tthrow new DrizzleQueryError(queryString, params, e as Error);\n\t\t\t\t});\n\t\t\t\t// put actual key\n\t\t\t\tawait cache.put(\n\t\t\t\t\tkey,\n\t\t\t\t\tresult,\n\t\t\t\t\t// make sure we send tables that were used in a query only if user wants to invalidate it on each write\n\t\t\t\t\tautoInvalidate ? tables : [],\n\t\t\t\t\tisTag,\n\t\t\t\t\tconfig,\n\t\t\t\t);\n\t\t\t\t// put flag if we should invalidate or not\n\t\t\t\treturn result;\n\t\t\t}\n\n\t\t\treturn fromCache as unknown as T;\n\t\t}\n\n\t\tassertUnreachable(cacheStrat);\n\t}\n}\n\nexport abstract class PgAsyncSession<\n\tTQueryResult extends PgQueryResultHKT = PgQueryResultHKT,\n\tTFullSchema extends Record<string, unknown> = Record<string, never>,\n\tTRelations extends AnyRelations = EmptyRelations,\n\tTSchema extends V1.TablesRelationalConfig = V1.ExtractTablesWithRelations<TFullSchema>,\n> extends PgSession {\n\tstatic override readonly [entityKind]: string = 'PgAsyncSession';\n\n\tconstructor(dialect: PgDialect) {\n\t\tsuper(dialect);\n\t}\n\n\tabstract override prepareQuery<T extends PreparedQueryConfig = PreparedQueryConfig>(\n\t\tquery: Query,\n\t\tfields: SelectedFieldsOrdered | undefined,\n\t\tname: string | undefined,\n\t\tisResponseInArrayMode: boolean,\n\t\tcustomResultMapper?: (rows: unknown[][], mapColumnValue?: (value: unknown) => unknown) => T['execute'],\n\t\tqueryMetadata?: {\n\t\t\ttype: 'select' | 'update' | 'delete' | 'insert';\n\t\t\ttables: string[];\n\t\t},\n\t\tcacheConfig?: WithCacheConfig,\n\t): PgAsyncPreparedQuery<T>;\n\n\tabstract override prepareRelationalQuery<T extends PreparedQueryConfig = PreparedQueryConfig>(\n\t\tquery: Query,\n\t\tfields: SelectedFieldsOrdered | undefined,\n\t\tname: string | undefined,\n\t\tcustomResultMapper: (\n\t\t\trows: Record<string, unknown>[],\n\t\t\tmapColumnValue?: (value: unknown) => unknown,\n\t\t) => T['execute'],\n\t): PgAsyncPreparedQuery<T>;\n\n\toverride execute<T>(query: SQL): Promise<T>;\n\t/** @internal */\n\toverride execute<T>(query: SQL, token?: NeonAuthToken): Promise<T>;\n\t/** @internal */\n\toverride execute<T>(query: SQL, token?: NeonAuthToken): Promise<T> {\n\t\treturn tracer.startActiveSpan('drizzle.operation', () => {\n\t\t\tconst prepared = tracer.startActiveSpan('drizzle.prepareQuery', () => {\n\t\t\t\treturn this.prepareQuery<PreparedQueryConfig & { execute: T }>(\n\t\t\t\t\tthis.dialect.sqlToQuery(query),\n\t\t\t\t\tundefined,\n\t\t\t\t\tundefined,\n\t\t\t\t\tfalse,\n\t\t\t\t);\n\t\t\t});\n\n\t\t\treturn prepared.setToken(token).execute();\n\t\t});\n\t}\n\n\toverride all<T = unknown>(query: SQL): Promise<T[]> {\n\t\treturn this.prepareQuery<PreparedQueryConfig & { all: T[] }>(\n\t\t\tthis.dialect.sqlToQuery(query),\n\t\t\tundefined,\n\t\t\tundefined,\n\t\t\tfalse,\n\t\t).all();\n\t}\n\n\tabstract transaction<T>(\n\t\ttransaction: (tx: PgAsyncTransaction<TQueryResult, TFullSchema, TRelations, TSchema>) => Promise<T>,\n\t\tconfig?: PgTransactionConfig,\n\t): Promise<T>;\n}\n\nexport abstract class PgAsyncTransaction<\n\tTQueryResult extends PgQueryResultHKT,\n\tTFullSchema extends Record<string, unknown> = Record<string, never>,\n\tTRelations extends AnyRelations = EmptyRelations,\n\tTSchema extends V1.TablesRelationalConfig = V1.ExtractTablesWithRelations<TFullSchema>,\n> extends PgAsyncDatabase<TQueryResult, TFullSchema, TRelations, TSchema> {\n\tstatic override readonly [entityKind]: string = 'PgAsyncTransaction';\n\n\tconstructor(\n\t\tdialect: PgDialect,\n\t\tsession: PgAsyncSession<any, any, any, any>,\n\t\tprotected relations: TRelations,\n\t\tprotected schema: {\n\t\t\tfullSchema: Record<string, unknown>;\n\t\t\tschema: TSchema;\n\t\t\ttableNamesMap: Record<string, string>;\n\t\t} | undefined,\n\t\tprotected readonly nestedIndex = 0,\n\t\tparseRqbJson?: boolean,\n\t) {\n\t\tsuper(dialect, session, relations, schema, parseRqbJson);\n\t}\n\n\trollback(): never {\n\t\tthrow new TransactionRollbackError();\n\t}\n\n\t/** @internal */\n\tgetTransactionConfigSQL(config: PgTransactionConfig): SQL {\n\t\tconst chunks: string[] = [];\n\t\tif (config.isolationLevel) {\n\t\t\tchunks.push(`isolation level ${config.isolationLevel}`);\n\t\t}\n\t\tif (config.accessMode) {\n\t\t\tchunks.push(config.accessMode);\n\t\t}\n\t\tif (typeof config.deferrable === 'boolean') {\n\t\t\tchunks.push(config.deferrable ? 'deferrable' : 'not deferrable');\n\t\t}\n\t\treturn sql.raw(chunks.join(' '));\n\t}\n\n\tsetTransaction(config: PgTransactionConfig): Promise<void> {\n\t\treturn this.session.execute(sql`set transaction ${this.getTransactionConfigSQL(config)}`);\n\t}\n\n\tabstract override transaction<T>(\n\t\ttransaction: (tx: PgAsyncTransaction<TQueryResult, TFullSchema, TRelations, TSchema>) => Promise<T>,\n\t): Promise<T>;\n}\n\nexport async function migrate(\n\tmigrations: MigrationMeta[],\n\tsession: PgAsyncSession,\n\tconfig: string | MigrationConfig,\n): Promise<void | MigratorInitFailResponse> {\n\tconst migrationsTable = typeof config === 'string'\n\t\t? '__drizzle_migrations'\n\t\t: config.migrationsTable ?? '__drizzle_migrations';\n\tconst migrationsSchema = typeof config === 'string' ? 'drizzle' : config.migrationsSchema ?? 'drizzle';\n\tconst migrationTableCreate = sql`\n\t\t\tCREATE TABLE IF NOT EXISTS ${sql.identifier(migrationsSchema)}.${sql.identifier(migrationsTable)} (\n\t\t\t\tid SERIAL PRIMARY KEY,\n\t\t\t\thash text NOT NULL,\n\t\t\t\tcreated_at bigint\n\t\t\t)\n\t\t`;\n\tawait session.execute(sql`CREATE SCHEMA IF NOT EXISTS ${sql.identifier(migrationsSchema)}`);\n\tawait session.execute(migrationTableCreate);\n\n\tconst dbMigrations = await session.all<{ id: number; hash: string; created_at: string }>(\n\t\tsql`select id, hash, created_at from ${sql.identifier(migrationsSchema)}.${\n\t\t\tsql.identifier(migrationsTable)\n\t\t} order by created_at desc limit 1`,\n\t);\n\n\tif (typeof config === 'object' && config.init) {\n\t\tif (dbMigrations.length) {\n\t\t\treturn { exitCode: 'databaseMigrations' as const };\n\t\t}\n\n\t\tif (migrations.length > 1) {\n\t\t\treturn { exitCode: 'localMigrations' as const };\n\t\t}\n\n\t\tconst [migration] = migrations;\n\n\t\tif (!migration) return;\n\n\t\tawait session.execute(\n\t\t\tsql`insert into ${sql.identifier(migrationsSchema)}.${\n\t\t\t\tsql.identifier(migrationsTable)\n\t\t\t} (\"hash\", \"created_at\") values(${migration.hash}, ${migration.folderMillis})`,\n\t\t);\n\n\t\treturn;\n\t}\n\n\tconst lastDbMigration = dbMigrations[0];\n\tawait session.transaction(async (tx) => {\n\t\tfor (const migration of migrations) {\n\t\t\tif (\n\t\t\t\t!lastDbMigration\n\t\t\t\t|| Number(lastDbMigration.created_at) < migration.folderMillis\n\t\t\t) {\n\t\t\t\tfor (const stmt of migration.sql) {\n\t\t\t\t\tawait tx.execute(sql.raw(stmt));\n\t\t\t\t}\n\t\t\t\tawait tx.execute(\n\t\t\t\t\tsql`insert into ${sql.identifier(migrationsSchema)}.${\n\t\t\t\t\t\tsql.identifier(migrationsTable)\n\t\t\t\t\t} (\"hash\", \"created_at\") values(${migration.hash}, ${migration.folderMillis})`,\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t});\n}\n"],"mappings":"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"}