{"version":3,"file":"insert.cjs","names":["entityKind","result: Record<string, Param | SQL>","Table","SQL","Param","QueryPromise","session: MsSqlSession","dialect: MsSqlDialect"],"sources":["../../../src/mssql-core/query-builders/insert.ts"],"sourcesContent":["import { entityKind, is } from '~/entity.ts';\nimport type { MsSqlDialect } from '~/mssql-core/dialect.ts';\nimport type {\n\tAnyQueryResultHKT,\n\tMsSqlSession,\n\tPreparedQueryConfig,\n\tPreparedQueryHKTBase,\n\tPreparedQueryKind,\n\tQueryResultHKT,\n\tQueryResultKind,\n} from '~/mssql-core/session.ts';\nimport type { MsSqlTable } from '~/mssql-core/table.ts';\nimport type { SelectResultFields } from '~/query-builders/select.types.ts';\nimport { QueryPromise } from '~/query-promise.ts';\nimport type { Placeholder, Query, SQLWrapper } from '~/sql/sql.ts';\nimport { Param, SQL } from '~/sql/sql.ts';\nimport { type InferInsertModel, type InferSelectModel, Table } from '~/table.ts';\nimport { orderSelectedFields } from '~/utils.ts';\nimport type { MsSqlColumn } from '../columns/common.ts';\nimport type { SelectedFieldsFlat, SelectedFieldsOrdered } from './select.types.ts';\n\nexport interface MsSqlInsertConfig<TTable extends MsSqlTable = MsSqlTable> {\n\ttable: TTable;\n\tvalues: Record<string, Param | SQL>[];\n\toutput?: SelectedFieldsOrdered;\n}\n\nexport type MsSqlInsertValue<\n\tTTable extends MsSqlTable,\n\tTModel extends Record<string, any> = InferInsertModel<TTable>,\n> =\n\t& {\n\t\t[Key in keyof TModel]: TModel[Key] | SQL | Placeholder;\n\t}\n\t& {};\n\nexport class MsSqlInsertBuilder<\n\tTTable extends MsSqlTable,\n\tTQueryResult extends QueryResultHKT,\n\tTPreparedQueryHKT extends PreparedQueryHKTBase,\n\tTOutput extends Record<string, unknown> | undefined = undefined,\n> {\n\tstatic readonly [entityKind]: string = 'MsSqlInsertBuilder';\n\n\tprivate config: {\n\t\toutput?: SelectedFieldsOrdered;\n\t\ttable: TTable;\n\t};\n\n\tprotected table: TTable;\n\tprotected session: MsSqlSession;\n\tprotected dialect: MsSqlDialect;\n\n\tconstructor(\n\t\ttable: TTable,\n\t\tsession: MsSqlSession,\n\t\tdialect: MsSqlDialect,\n\t\toutput?: SelectedFieldsOrdered,\n\t) {\n\t\tthis.table = table;\n\t\tthis.session = session;\n\t\tthis.dialect = dialect;\n\n\t\tthis.config = { table, output };\n\t}\n\n\tvalues(\n\t\tvalue: MsSqlInsertValue<TTable>,\n\t): MsSqlInsertBase<TTable, TQueryResult, TPreparedQueryHKT, TOutput>;\n\tvalues(values: MsSqlInsertValue<TTable>[]): MsSqlInsertBase<TTable, TQueryResult, TPreparedQueryHKT, TOutput>;\n\tvalues(\n\t\tvalues: MsSqlInsertValue<TTable> | MsSqlInsertValue<TTable>[],\n\t): MsSqlInsertBase<TTable, TQueryResult, TPreparedQueryHKT, TOutput> {\n\t\tvalues = Array.isArray(values) ? values : [values];\n\t\tif (values.length === 0) {\n\t\t\tthrow new Error('values() must be called with at least one value');\n\t\t}\n\t\tconst mappedValues = values.map((entry) => {\n\t\t\tconst result: Record<string, Param | SQL> = {};\n\t\t\tconst cols = this.table[Table.Symbol.Columns];\n\t\t\tfor (const colKey of Object.keys(entry)) {\n\t\t\t\tconst colValue = entry[colKey as keyof typeof entry];\n\t\t\t\tresult[colKey] = is(colValue, SQL) ? colValue : new Param(colValue, cols[colKey]);\n\t\t\t}\n\t\t\treturn result;\n\t\t});\n\n\t\treturn new MsSqlInsertBase(this.table, mappedValues, this.session, this.dialect, this.config.output);\n\t}\n\n\t/**\n\t * Adds an `output` clause to the query.\n\t *\n\t * Calling this method will return the specified fields of the inserted rows. If no fields are specified, all fields will be returned.\n\t *\n\t * @example\n\t * ```ts\n\t * // Insert one row and return all fields\n\t * const insertedCar: Car[] = await db.insert(cars)\n\t *   .output();\n\t *   .values({ brand: 'BMW' })\n\t *\n\t * // Insert one row and return only the id\n\t * const insertedCarId: { id: number }[] = await db.insert(cars)\n\t *   .output({ id: cars.id });\n\t *   .values({ brand: 'BMW' })\n\t * ```\n\t */\n\toutput(): Omit<MsSqlInsertBuilder<TTable, TQueryResult, TPreparedQueryHKT, InferSelectModel<TTable>>, 'output'>;\n\toutput<SelectedFields extends SelectedFieldsFlat>(\n\t\tfields: SelectedFields,\n\t): Omit<MsSqlInsertBuilder<TTable, TQueryResult, TPreparedQueryHKT, SelectResultFields<SelectedFields>>, 'output'>;\n\toutput(\n\t\tfields: SelectedFieldsFlat = this.table[Table.Symbol.Columns],\n\t) {\n\t\tthis.config.output = orderSelectedFields<MsSqlColumn>(fields);\n\t\treturn this as any;\n\t}\n}\n\nexport type MsSqlInsertWithout<T extends AnyMsSqlInsert, TDynamic extends boolean, K extends keyof T & string> =\n\tTDynamic extends true ? T\n\t\t: Omit<\n\t\t\tMsSqlInsertBase<\n\t\t\t\tT['_']['table'],\n\t\t\t\tT['_']['queryResult'],\n\t\t\t\tT['_']['preparedQueryHKT'],\n\t\t\t\tT['_']['output'],\n\t\t\t\tTDynamic,\n\t\t\t\tT['_']['excludedMethods'] | K\n\t\t\t>,\n\t\t\tT['_']['excludedMethods'] | K\n\t\t>;\n\nexport type MsSqlInsertDynamic<T extends AnyMsSqlInsert> = MsSqlInsert<\n\tT['_']['table'],\n\tT['_']['queryResult'],\n\tT['_']['preparedQueryHKT'],\n\tT['_']['output']\n>;\n\nexport type MsSqlInsertPrepare<T extends AnyMsSqlInsert> = PreparedQueryKind<\n\tT['_']['preparedQueryHKT'],\n\tPreparedQueryConfig & {\n\t\texecute: T['_']['output'] extends undefined ? QueryResultKind<T['_']['queryResult'], any> : T['_']['output'][];\n\t\titerator: never;\n\t}\n>;\n\nexport type MsSqlInsert<\n\tTTable extends MsSqlTable = MsSqlTable,\n\tTQueryResult extends QueryResultHKT = AnyQueryResultHKT,\n\tTPreparedQueryHKT extends PreparedQueryHKTBase = PreparedQueryHKTBase,\n\tTOutput extends Record<string, unknown> | undefined = Record<string, unknown> | undefined,\n> = MsSqlInsertBase<TTable, TQueryResult, TPreparedQueryHKT, TOutput, true, never>;\n\nexport type AnyMsSqlInsert = MsSqlInsertBase<any, any, any, any, any, any>;\n\nexport interface MsSqlInsertBase<\n\tTTable extends MsSqlTable,\n\tTQueryResult extends QueryResultHKT,\n\tTPreparedQueryHKT extends PreparedQueryHKTBase,\n\tTOutput extends Record<string, unknown> | undefined = undefined,\n\tTDynamic extends boolean = false,\n\tTExcludedMethods extends string = never,\n> extends QueryPromise<TOutput extends undefined ? QueryResultKind<TQueryResult, any> : TOutput[]>, SQLWrapper {\n\treadonly _: {\n\t\treadonly table: TTable;\n\t\treadonly queryResult: TQueryResult;\n\t\treadonly preparedQueryHKT: TPreparedQueryHKT;\n\t\treadonly output: TOutput;\n\t\treadonly dynamic: TDynamic;\n\t\treadonly excludedMethods: TExcludedMethods;\n\t};\n}\n\nexport class MsSqlInsertBase<\n\tTTable extends MsSqlTable,\n\tTQueryResult extends QueryResultHKT,\n\t// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\tTPreparedQueryHKT extends PreparedQueryHKTBase,\n\t// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\tTOutput extends Record<string, unknown> | undefined = undefined,\n\t// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\tTDynamic extends boolean = false,\n\t// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\tTExcludedMethods extends string = never,\n> extends QueryPromise<TOutput extends undefined ? QueryResultKind<TQueryResult, any> : TOutput[]>\n\timplements SQLWrapper\n{\n\tstatic override readonly [entityKind]: string = 'MsSqlInsert';\n\n\tdeclare protected $table: TTable;\n\n\tprivate config: MsSqlInsertConfig<TTable>;\n\n\tconstructor(\n\t\ttable: TTable,\n\t\tvalues: MsSqlInsertConfig['values'],\n\t\tprivate session: MsSqlSession,\n\t\tprivate dialect: MsSqlDialect,\n\t\toutput?: SelectedFieldsOrdered,\n\t) {\n\t\tsuper();\n\t\tthis.config = { table, values, output };\n\t}\n\n\t/** @internal */\n\tgetSQL(): SQL {\n\t\treturn this.dialect.buildInsertQuery(this.config);\n\t}\n\n\ttoSQL(): Query {\n\t\tconst { typings: _typings, ...rest } = this.dialect.sqlToQuery(this.getSQL());\n\t\treturn rest;\n\t}\n\n\tprepare(): MsSqlInsertPrepare<this> {\n\t\treturn this.session.prepareQuery(\n\t\t\tthis.dialect.sqlToQuery(this.getSQL()),\n\t\t\tthis.config.output,\n\t\t) as MsSqlInsertPrepare<this>;\n\t}\n\n\toverride execute(\n\t\tplaceholderValues?: Record<string, unknown>,\n\t): Promise<TOutput extends undefined ? QueryResultKind<TQueryResult, any> : TOutput[]> {\n\t\treturn this.prepare().execute(placeholderValues) as any;\n\t}\n\n\tprivate createIterator = (): ReturnType<this['prepare']>['iterator'] => {\n\t\tconst self = this;\n\t\treturn async function*(placeholderValues) {\n\t\t\tyield* self.prepare().iterator(placeholderValues);\n\t\t};\n\t};\n\n\titerator = this.createIterator();\n\n\t// $dynamic(): MsSqlInsertDynamic<this> {\n\t// \treturn this as any;\n\t// }\n}\n"],"mappings":";;;;;;;;AAoCA,IAAa,qBAAb,MAKE;CACD,QAAiBA,0BAAsB;CAEvC,AAAQ;CAKR,AAAU;CACV,AAAU;CACV,AAAU;CAEV,YACC,OACA,SACA,SACA,QACC;AACD,OAAK,QAAQ;AACb,OAAK,UAAU;AACf,OAAK,UAAU;AAEf,OAAK,SAAS;GAAE;GAAO;GAAQ;;CAOhC,OACC,QACoE;AACpE,WAAS,MAAM,QAAQ,OAAO,GAAG,SAAS,CAAC,OAAO;AAClD,MAAI,OAAO,WAAW,EACrB,OAAM,IAAI,MAAM,kDAAkD;EAEnE,MAAM,eAAe,OAAO,KAAK,UAAU;GAC1C,MAAMC,SAAsC,EAAE;GAC9C,MAAM,OAAO,KAAK,MAAMC,iBAAM,OAAO;AACrC,QAAK,MAAM,UAAU,OAAO,KAAK,MAAM,EAAE;IACxC,MAAM,WAAW,MAAM;AACvB,WAAO,8BAAa,UAAUC,iBAAI,GAAG,WAAW,IAAIC,mBAAM,UAAU,KAAK,QAAQ;;AAElF,UAAO;IACN;AAEF,SAAO,IAAI,gBAAgB,KAAK,OAAO,cAAc,KAAK,SAAS,KAAK,SAAS,KAAK,OAAO,OAAO;;CAyBrG,OACC,SAA6B,KAAK,MAAMF,iBAAM,OAAO,UACpD;AACD,OAAK,OAAO,6CAA0C,OAAO;AAC7D,SAAO;;;AA4DT,IAAa,kBAAb,cAWUG,gCAEV;CACC,QAA0BL,0BAAsB;CAIhD,AAAQ;CAER,YACC,OACA,QACA,AAAQM,SACR,AAAQC,SACR,QACC;AACD,SAAO;EAJC;EACA;AAIR,OAAK,SAAS;GAAE;GAAO;GAAQ;GAAQ;;;CAIxC,SAAc;AACb,SAAO,KAAK,QAAQ,iBAAiB,KAAK,OAAO;;CAGlD,QAAe;EACd,MAAM,EAAE,SAAS,UAAU,GAAG,SAAS,KAAK,QAAQ,WAAW,KAAK,QAAQ,CAAC;AAC7E,SAAO;;CAGR,UAAoC;AACnC,SAAO,KAAK,QAAQ,aACnB,KAAK,QAAQ,WAAW,KAAK,QAAQ,CAAC,EACtC,KAAK,OAAO,OACZ;;CAGF,AAAS,QACR,mBACsF;AACtF,SAAO,KAAK,SAAS,CAAC,QAAQ,kBAAkB;;CAGjD,AAAQ,uBAAgE;EACvE,MAAM,OAAO;AACb,SAAO,iBAAgB,mBAAmB;AACzC,UAAO,KAAK,SAAS,CAAC,SAAS,kBAAkB;;;CAInD,WAAW,KAAK,gBAAgB"}