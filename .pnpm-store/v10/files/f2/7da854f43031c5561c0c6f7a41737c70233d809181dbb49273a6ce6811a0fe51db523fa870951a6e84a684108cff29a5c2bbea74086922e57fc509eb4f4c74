{"version":3,"sources":["../../../../src/server/lib/router-utils/route-types-utils.ts"],"sourcesContent":["import path from 'path'\nimport {\n  getRouteRegex,\n  type Group,\n} from '../../../shared/lib/router/utils/route-regex'\nimport type { NextConfigComplete } from '../../config-shared'\n\nimport fs from 'fs'\nimport {\n  generateRouteTypesFile,\n  generateLinkTypesFile,\n  generateValidatorFile,\n} from './typegen'\nimport { tryToParsePath } from '../../../lib/try-to-parse-path'\nimport {\n  extractInterceptionRouteInformation,\n  isInterceptionRouteAppPath,\n} from '../../../shared/lib/router/utils/interception-routes'\nimport {\n  UNDERSCORE_GLOBAL_ERROR_ROUTE,\n  UNDERSCORE_NOT_FOUND_ROUTE,\n} from '../../../shared/lib/entry-constants'\nimport { normalizePathSep } from '../../../shared/lib/page-path/normalize-path-sep'\n\ninterface RouteInfo {\n  path: string\n  groups: { [groupName: string]: Group }\n}\n\nexport interface RouteTypesManifest {\n  appRoutes: Record<string, RouteInfo>\n  pageRoutes: Record<string, RouteInfo>\n  layoutRoutes: Record<string, RouteInfo & { slots: string[] }>\n  appRouteHandlerRoutes: Record<string, RouteInfo>\n  /** Map of redirect source => RouteInfo */\n  redirectRoutes: Record<string, RouteInfo>\n  /** Map of rewrite source => RouteInfo */\n  rewriteRoutes: Record<string, RouteInfo>\n  /** File paths for validation */\n  appPagePaths: Set<string>\n  pagesRouterPagePaths: Set<string>\n  layoutPaths: Set<string>\n  appRouteHandlers: Set<string>\n  pageApiRoutes: Set<string>\n  /** Direct mapping from file paths to routes for validation */\n  filePathToRoute: Map<string, string>\n}\n\n// Convert a custom-route source string (`/blog/:slug`, `/docs/:path*`, ...)\n// into the bracket-syntax used by other Next.js route helpers so that we can\n// reuse `getRouteRegex()` to extract groups.\nexport function convertCustomRouteSource(source: string): string[] {\n  const parseResult = tryToParsePath(source)\n\n  if (parseResult.error || !parseResult.tokens) {\n    // Fallback to original source if parsing fails\n    return source.startsWith('/') ? [source] : ['/' + source]\n  }\n\n  const possibleNormalizedRoutes = ['']\n  let slugCnt = 1\n\n  function append(suffix: string) {\n    for (let i = 0; i < possibleNormalizedRoutes.length; i++) {\n      possibleNormalizedRoutes[i] += suffix\n    }\n  }\n\n  function fork(suffix: string) {\n    const currentLength = possibleNormalizedRoutes.length\n    for (let i = 0; i < currentLength; i++) {\n      possibleNormalizedRoutes.push(possibleNormalizedRoutes[i] + suffix)\n    }\n  }\n\n  for (const token of parseResult.tokens) {\n    if (typeof token === 'object') {\n      // Make sure the slug is always named.\n      const slug = token.name || (slugCnt++ === 1 ? 'slug' : `slug${slugCnt}`)\n      if (token.modifier === '*') {\n        append(`${token.prefix}[[...${slug}]]`)\n      } else if (token.modifier === '+') {\n        append(`${token.prefix}[...${slug}]`)\n      } else if (token.modifier === '') {\n        if (token.pattern === '[^\\\\/#\\\\?]+?') {\n          // A safe slug\n          append(`${token.prefix}[${slug}]`)\n        } else if (token.pattern === '.*') {\n          // An optional catch-all slug\n          append(`${token.prefix}[[...${slug}]]`)\n        } else if (token.pattern === '.+') {\n          // A catch-all slug\n          append(`${token.prefix}[...${slug}]`)\n        } else {\n          // Other regex patterns are not supported. Skip this route.\n          return []\n        }\n      } else if (token.modifier === '?') {\n        if (/^[a-zA-Z0-9_/]*$/.test(token.pattern)) {\n          // An optional slug with plain text only, fork the route.\n          append(token.prefix)\n          fork(token.pattern)\n        } else {\n          // Optional modifier `?` and regex patterns are not supported.\n          return []\n        }\n      }\n    } else if (typeof token === 'string') {\n      append(token)\n    }\n  }\n\n  // Ensure leading slash\n  return possibleNormalizedRoutes.map((route) =>\n    route.startsWith('/') ? route : '/' + route\n  )\n}\n\n/**\n * Extracts route parameters from a route pattern\n */\nexport function extractRouteParams(route: string) {\n  const regex = getRouteRegex(route)\n  return regex.groups\n}\n\n/**\n * Resolves an intercepting route to its canonical equivalent\n * Example: /gallery/test/(..)photo/[id] -> /gallery/photo/[id]\n */\nfunction resolveInterceptingRoute(route: string): string {\n  // Reuse centralized interception route normalization logic\n  try {\n    if (!isInterceptionRouteAppPath(route)) return route\n    const { interceptedRoute } = extractInterceptionRouteInformation(route)\n    return interceptedRoute\n  } catch {\n    // If parsing fails, fall back to the original route\n    return route\n  }\n}\n\n/**\n * Creates a route types manifest from processed route data\n * (used for both build and dev)\n */\nexport async function createRouteTypesManifest({\n  dir,\n  pageRoutes,\n  appRoutes,\n  appRouteHandlers,\n  pageApiRoutes,\n  layoutRoutes,\n  slots,\n  redirects,\n  rewrites,\n  validatorFilePath,\n}: {\n  dir: string\n  pageRoutes: Array<{ route: string; filePath: string }>\n  appRoutes: Array<{ route: string; filePath: string }>\n  appRouteHandlers: Array<{ route: string; filePath: string }>\n  pageApiRoutes: Array<{ route: string; filePath: string }>\n  layoutRoutes: Array<{ route: string; filePath: string }>\n  slots: Array<{ name: string; parent: string }>\n  redirects?: NextConfigComplete['redirects']\n  rewrites?: NextConfigComplete['rewrites']\n  validatorFilePath?: string\n}): Promise<RouteTypesManifest> {\n  // Helper function to calculate the correct relative path\n  const getRelativePath = (filePath: string) => {\n    if (validatorFilePath) {\n      // For validator generation, calculate path relative to validator directory\n      return normalizePathSep(\n        path.relative(path.dirname(validatorFilePath), filePath)\n      )\n    }\n    // For other uses, calculate path relative to project directory\n    return normalizePathSep(path.relative(dir, filePath))\n  }\n\n  const manifest: RouteTypesManifest = {\n    appRoutes: {},\n    pageRoutes: {},\n    layoutRoutes: {},\n    appRouteHandlerRoutes: {},\n    redirectRoutes: {},\n    rewriteRoutes: {},\n    appRouteHandlers: new Set(\n      appRouteHandlers.map(({ filePath }) => getRelativePath(filePath))\n    ),\n    pageApiRoutes: new Set(\n      pageApiRoutes.map(({ filePath }) => getRelativePath(filePath))\n    ),\n    appPagePaths: new Set(\n      appRoutes.map(({ filePath }) => getRelativePath(filePath))\n    ),\n    pagesRouterPagePaths: new Set(\n      pageRoutes.map(({ filePath }) => getRelativePath(filePath))\n    ),\n    layoutPaths: new Set(\n      layoutRoutes.map(({ filePath }) => getRelativePath(filePath))\n    ),\n    filePathToRoute: new Map([\n      ...appRoutes.map(\n        ({ route, filePath }) =>\n          [getRelativePath(filePath), resolveInterceptingRoute(route)] as [\n            string,\n            string,\n          ]\n      ),\n      ...layoutRoutes.map(\n        ({ route, filePath }) =>\n          [getRelativePath(filePath), resolveInterceptingRoute(route)] as [\n            string,\n            string,\n          ]\n      ),\n      ...appRouteHandlers.map(\n        ({ route, filePath }) =>\n          [getRelativePath(filePath), resolveInterceptingRoute(route)] as [\n            string,\n            string,\n          ]\n      ),\n      ...pageRoutes.map(\n        ({ route, filePath }) =>\n          [getRelativePath(filePath), route] as [string, string]\n      ),\n      ...pageApiRoutes.map(\n        ({ route, filePath }) =>\n          [getRelativePath(filePath), route] as [string, string]\n      ),\n    ]),\n  }\n\n  // Process page routes\n  for (const { route, filePath } of pageRoutes) {\n    manifest.pageRoutes[route] = {\n      path: getRelativePath(filePath),\n      groups: extractRouteParams(route),\n    }\n  }\n\n  // Process layout routes (exclude internal app error/not-found layouts)\n  for (const { route, filePath } of layoutRoutes) {\n    if (\n      route === UNDERSCORE_GLOBAL_ERROR_ROUTE ||\n      route === UNDERSCORE_NOT_FOUND_ROUTE\n    )\n      continue\n    // Use the resolved route (for interception routes, this gives us the canonical route)\n    const resolvedRoute = resolveInterceptingRoute(route)\n    if (!manifest.layoutRoutes[resolvedRoute]) {\n      manifest.layoutRoutes[resolvedRoute] = {\n        path: getRelativePath(filePath),\n        groups: extractRouteParams(resolvedRoute),\n        slots: [],\n      }\n    }\n  }\n\n  // Process slots\n  for (const slot of slots) {\n    if (manifest.layoutRoutes[slot.parent]) {\n      manifest.layoutRoutes[slot.parent].slots.push(slot.name)\n    }\n  }\n\n  // Process app routes (exclude internal app routes)\n  for (const { route, filePath } of appRoutes) {\n    if (\n      route === UNDERSCORE_GLOBAL_ERROR_ROUTE ||\n      route === UNDERSCORE_NOT_FOUND_ROUTE\n    )\n      continue\n    // Don't include metadata routes or pages\n    if (\n      !filePath.endsWith('page.ts') &&\n      !filePath.endsWith('page.tsx') &&\n      !filePath.endsWith('.mdx') &&\n      !filePath.endsWith('.md')\n    ) {\n      continue\n    }\n\n    // Use the resolved route (for interception routes, this gives us the canonical route)\n    const resolvedRoute = resolveInterceptingRoute(route)\n\n    if (!manifest.appRoutes[resolvedRoute]) {\n      manifest.appRoutes[resolvedRoute] = {\n        path: getRelativePath(filePath),\n        groups: extractRouteParams(resolvedRoute),\n      }\n    }\n  }\n\n  // Process app route handlers\n  for (const { route, filePath } of appRouteHandlers) {\n    // Use the resolved route (for interception routes, this gives us the canonical route)\n    const resolvedRoute = resolveInterceptingRoute(route)\n\n    if (!manifest.appRouteHandlerRoutes[resolvedRoute]) {\n      manifest.appRouteHandlerRoutes[resolvedRoute] = {\n        path: getRelativePath(filePath),\n        groups: extractRouteParams(resolvedRoute),\n      }\n    }\n  }\n\n  // Process redirects\n  if (typeof redirects === 'function') {\n    const rd = await redirects()\n\n    for (const item of rd) {\n      const possibleRoutes = convertCustomRouteSource(item.source)\n      for (const route of possibleRoutes) {\n        manifest.redirectRoutes[route] = {\n          path: route,\n          groups: extractRouteParams(route),\n        }\n      }\n    }\n  }\n\n  // Process rewrites\n  if (typeof rewrites === 'function') {\n    const rw = await rewrites()\n\n    const allSources = Array.isArray(rw)\n      ? rw\n      : [\n          ...(rw?.beforeFiles || []),\n          ...(rw?.afterFiles || []),\n          ...(rw?.fallback || []),\n        ]\n\n    for (const item of allSources) {\n      const possibleRoutes = convertCustomRouteSource(item.source)\n      for (const route of possibleRoutes) {\n        manifest.rewriteRoutes[route] = {\n          path: route,\n          groups: extractRouteParams(route),\n        }\n      }\n    }\n  }\n\n  return manifest\n}\n\nexport async function writeRouteTypesManifest(\n  manifest: RouteTypesManifest,\n  filePath: string,\n  config: NextConfigComplete\n) {\n  const dirname = path.dirname(filePath)\n\n  if (!fs.existsSync(dirname)) {\n    await fs.promises.mkdir(dirname, { recursive: true })\n  }\n\n  // Write the main routes.d.ts file\n  await fs.promises.writeFile(filePath, generateRouteTypesFile(manifest))\n\n  // Write the link.d.ts file if typedRoutes is enabled\n  if (config.typedRoutes === true) {\n    const linkTypesPath = path.join(dirname, 'link.d.ts')\n    await fs.promises.writeFile(linkTypesPath, generateLinkTypesFile(manifest))\n  }\n}\n\nexport async function writeValidatorFile(\n  manifest: RouteTypesManifest,\n  filePath: string\n) {\n  const dirname = path.dirname(filePath)\n\n  if (!fs.existsSync(dirname)) {\n    await fs.promises.mkdir(dirname, { recursive: true })\n  }\n\n  await fs.promises.writeFile(filePath, generateValidatorFile(manifest))\n}\n"],"names":["convertCustomRouteSource","createRouteTypesManifest","extractRouteParams","writeRouteTypesManifest","writeValidatorFile","source","parseResult","tryToParsePath","error","tokens","startsWith","possibleNormalizedRoutes","slugCnt","append","suffix","i","length","fork","currentLength","push","token","slug","name","modifier","prefix","pattern","test","map","route","regex","getRouteRegex","groups","resolveInterceptingRoute","isInterceptionRouteAppPath","interceptedRoute","extractInterceptionRouteInformation","dir","pageRoutes","appRoutes","appRouteHandlers","pageApiRoutes","layoutRoutes","slots","redirects","rewrites","validatorFilePath","getRelativePath","filePath","normalizePathSep","path","relative","dirname","manifest","appRouteHandlerRoutes","redirectRoutes","rewriteRoutes","Set","appPagePaths","pagesRouterPagePaths","layoutPaths","filePathToRoute","Map","UNDERSCORE_GLOBAL_ERROR_ROUTE","UNDERSCORE_NOT_FOUND_ROUTE","resolvedRoute","slot","parent","endsWith","rd","item","possibleRoutes","rw","allSources","Array","isArray","beforeFiles","afterFiles","fallback","config","fs","existsSync","promises","mkdir","recursive","writeFile","generateRouteTypesFile","typedRoutes","linkTypesPath","join","generateLinkTypesFile","generateValidatorFile"],"mappings":"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","ignoreList":[0]}