{"version":3,"file":"dialect.cjs","names":["entityKind","CasingCache","sql","Table","SQL","chunk: SQLChunk[]","MsSqlColumn","Column","Subquery","MsSqlViewBase","ViewBaseConfig","table","withSql: SQL | undefined","View","joinsArray: SQL[]","MsSqlTable","forSQL: SQL | undefined","orderByValues: (SQL<unknown> | Name)[]","valuesSqlList: ((SQLChunk | SQL)[] | SQL)[]","columns: Record<string, MsSqlColumn>","colEntries: [string, MsSqlColumn][]","valueList: (SQLChunk | SQL)[]","Param","selection: V1.BuildRelationalQueryResult<MsSqlTable, MsSqlColumn>['selection']","orderBy: MsSqlSelectConfig['orderBy']","V1","fieldsSelection: { tsKey: string; value: MsSqlColumn | SQL.Aliased }[]","selectedColumns: string[]","selectedRelations: {\n\t\t\t\ttsKey: string;\n\t\t\t\tqueryConfig: true | V1.DBQueryConfig<'many', false>;\n\t\t\t\trelation: V1.Relation;\n\t\t\t}[]","joinOn","and","eq","field","DrizzleError"],"sources":["../../src/mssql-core/dialect.ts"],"sourcesContent":["import * as V1 from '~/_relations.ts';\nimport {\n\taliasedTable,\n\taliasedTableColumn,\n\tgetOriginalColumnFromAlias,\n\tmapColumnsInAliasedSQLToAlias,\n\tmapColumnsInSQLToAlias,\n} from '~/alias.ts';\nimport { CasingCache } from '~/casing.ts';\nimport { Column } from '~/column.ts';\nimport { entityKind, is } from '~/entity.ts';\nimport type { MigrationConfig, MigrationMeta, MigratorInitFailResponse } from '~/migrator.ts';\nimport { Param, type QueryWithTypings, SQL, sql, type SQLChunk, View } from '~/sql/sql.ts';\nimport { Subquery } from '~/subquery.ts';\nimport { getTableName, getTableUniqueName, Table } from '~/table.ts';\nimport { type Casing, orderSelectedFields, type UpdateSet } from '~/utils.ts';\nimport { and, DrizzleError, eq, type Name, ViewBaseConfig } from '../index.ts';\nimport { MsSqlColumn } from './columns/common.ts';\nimport type { MsSqlDeleteConfig } from './query-builders/delete.ts';\nimport type { MsSqlInsertConfig } from './query-builders/insert.ts';\nimport type { MsSqlSelectConfig, SelectedFieldsOrdered } from './query-builders/select.types.ts';\nimport type { MsSqlUpdateConfig } from './query-builders/update.ts';\nimport type { MsSqlSession } from './session.ts';\nimport { MsSqlTable } from './table.ts';\nimport { MsSqlViewBase } from './view-base.ts';\n\nexport interface MsSqlDialectConfig {\n\tcasing?: Casing;\n}\nexport class MsSqlDialect {\n\tstatic readonly [entityKind]: string = 'MsSqlDialect';\n\n\t/** @internal */\n\treadonly casing: CasingCache;\n\n\tconstructor(config?: MsSqlDialectConfig) {\n\t\tthis.casing = new CasingCache(config?.casing);\n\t}\n\n\tasync migrate(\n\t\tmigrations: MigrationMeta[],\n\t\tsession: MsSqlSession,\n\t\tconfig: MigrationConfig,\n\t): Promise<void | MigratorInitFailResponse> {\n\t\tconst migrationsTable = typeof config === 'string'\n\t\t\t? '__drizzle_migrations'\n\t\t\t: config.migrationsTable ?? '__drizzle_migrations';\n\t\tconst migrationsSchema = typeof config === 'string' ? 'drizzle' : config.migrationsSchema ?? 'drizzle';\n\t\tconst migrationTableCreate = sql`\n\t\t\tIF NOT EXISTS (\n\t\t\t\tSELECT 1 FROM INFORMATION_SCHEMA.TABLES \n\t\t\t\tWHERE TABLE_NAME = ${migrationsTable} AND TABLE_SCHEMA = ${migrationsSchema}\n\t\t\t)\n\t\t\tCREATE TABLE ${sql.identifier(migrationsSchema)}.${sql.identifier(migrationsTable)} (\n\t\t\t\tid bigint identity PRIMARY KEY,\n\t\t\t\thash text NOT NULL,\n\t\t\t\tcreated_at bigint\n\t\t\t)\n\t\t`;\n\n\t\tconst migrationSchemaCreate = sql`\n\t\t\tIF NOT EXISTS (\n\t\t\t\tSELECT 1 FROM sys.schemas WHERE name = ${migrationsSchema}\n\t\t\t)\n\t\t\tEXEC(\\'CREATE SCHEMA ${sql.identifier(migrationsSchema)}\\')\n\t\t`;\n\n\t\tawait session.execute(migrationSchemaCreate);\n\t\tawait session.execute(migrationTableCreate);\n\n\t\tconst { recordset: dbMigrations } = await session.execute<any>(\n\t\t\tsql`select id, hash, created_at from ${sql.identifier(migrationsSchema)}.${\n\t\t\t\tsql.identifier(migrationsTable)\n\t\t\t} order by created_at desc offset 0 rows fetch next 1 rows only`,\n\t\t);\n\n\t\tif (typeof config === 'object' && config.init) {\n\t\t\tif (dbMigrations.length) {\n\t\t\t\treturn { exitCode: 'databaseMigrations' as const };\n\t\t\t}\n\n\t\t\tif (migrations.length > 1) {\n\t\t\t\treturn { exitCode: 'localMigrations' as const };\n\t\t\t}\n\n\t\t\tconst [migration] = migrations;\n\n\t\t\tif (!migration) return;\n\n\t\t\tawait session.execute(\n\t\t\t\tsql`insert into ${sql.identifier(migrationsSchema)}.${\n\t\t\t\t\tsql.identifier(migrationsTable)\n\t\t\t\t} ([hash], [created_at]) values(${migration.hash}, ${migration.folderMillis})`,\n\t\t\t);\n\n\t\t\treturn;\n\t\t}\n\n\t\tconst lastDbMigration = dbMigrations[0];\n\t\tawait session.transaction(async (tx) => {\n\t\t\tfor (const migration of migrations) {\n\t\t\t\tif (\n\t\t\t\t\t!lastDbMigration\n\t\t\t\t\t|| Number(lastDbMigration.created_at) < migration.folderMillis\n\t\t\t\t) {\n\t\t\t\t\tfor (const stmt of migration.sql) {\n\t\t\t\t\t\tawait tx.execute(sql.raw(stmt));\n\t\t\t\t\t}\n\t\t\t\t\tawait tx.execute(\n\t\t\t\t\t\tsql`insert into ${sql.identifier(migrationsSchema)}.${\n\t\t\t\t\t\t\tsql.identifier(migrationsTable)\n\t\t\t\t\t\t} ([hash], [created_at]) values(${migration.hash}, ${migration.folderMillis})`,\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\tescapeName(name: string): string {\n\t\treturn `[${name}]`;\n\t}\n\n\tescapeParam(_num: number): string {\n\t\treturn `@par${_num}`;\n\t}\n\n\tescapeString(str: string): string {\n\t\treturn `'${str.replace(/'/g, \"''\")}'`;\n\t}\n\n\tbuildDeleteQuery({ table, where, output }: MsSqlDeleteConfig): SQL {\n\t\tconst outputSql = output\n\t\t\t? sql` output ${this.buildSelectionOutput(output, { type: 'DELETED' })}`\n\t\t\t: undefined;\n\n\t\tconst whereSql = where ? sql` where ${where}` : undefined;\n\n\t\treturn sql`delete from ${table}${outputSql}${whereSql}`;\n\t}\n\n\tbuildUpdateSet(table: MsSqlTable, set: UpdateSet): SQL {\n\t\tconst tableColumns = table[Table.Symbol.Columns];\n\n\t\tconst columnNames = Object.keys(tableColumns).filter((colName) =>\n\t\t\tset[colName] !== undefined || tableColumns[colName]?.onUpdateFn !== undefined\n\t\t);\n\n\t\tconst setSize = columnNames.length;\n\t\treturn sql.join(columnNames.flatMap((colName, i) => {\n\t\t\tconst col = tableColumns[colName]!;\n\n\t\t\tconst onUpdateFnResult = col.onUpdateFn?.();\n\t\t\tconst value = set[colName] ?? (is(onUpdateFnResult, SQL) ? onUpdateFnResult : sql.param(onUpdateFnResult, col));\n\t\t\tconst res = sql`${sql.identifier(this.casing.getColumnCasing(col))} = ${value}`;\n\n\t\t\tif (i < setSize - 1) {\n\t\t\t\treturn [res, sql.raw(', ')];\n\t\t\t}\n\t\t\treturn [res];\n\t\t}));\n\t\t// const setEntries = Object.entries(set);\n\t\t//\n\t\t// const setSize = setEntries.length;\n\t\t// return sql.join(\n\t\t// \tsetEntries\n\t\t// \t\t.flatMap(([colName, value], i): SQL[] => {\n\t\t// \t\t\tconst col: MsSqlColumn = table[Table.Symbol.Columns][colName]!;\n\t\t// \t\t\tconst res = sql`${sql.identifier(col.name)} = ${value}`;\n\t\t// \t\t\tif (i < setSize - 1) {\n\t\t// \t\t\t\treturn [res, sql.raw(', ')];\n\t\t// \t\t\t}\n\t\t// \t\t\treturn [res];\n\t\t// \t\t}),\n\t\t// );\n\t}\n\n\tbuildUpdateQuery({ table, set, where, output }: MsSqlUpdateConfig): SQL {\n\t\tconst setSql = this.buildUpdateSet(table, set);\n\n\t\tconst outputSql = sql``;\n\n\t\tif (output) {\n\t\t\toutputSql.append(sql` output `);\n\n\t\t\tif (output.inserted) {\n\t\t\t\toutputSql.append(this.buildSelectionOutput(output.inserted, { type: 'INSERTED' }));\n\t\t\t}\n\n\t\t\tif (output.deleted) {\n\t\t\t\tif (output.inserted) outputSql.append(sql`, `); // add space if both are present\n\t\t\t\toutputSql.append(this.buildSelectionOutput(output.deleted, { type: 'DELETED' }));\n\t\t\t}\n\t\t}\n\n\t\tconst whereSql = where ? sql` where ${where}` : undefined;\n\n\t\treturn sql`update ${table} set ${setSql}${outputSql}${whereSql}`;\n\t}\n\n\t/**\n\t * Builds selection SQL with provided fields/expressions\n\t *\n\t * Examples:\n\t *\n\t * `select <selection> from`\n\t *\n\t * `insert ... returning <selection>`\n\t *\n\t * If `isSingleTable` is true, then columns won't be prefixed with table name\n\t */\n\tprivate buildSelection(\n\t\tfields: SelectedFieldsOrdered,\n\t\t{ isSingleTable = false }: { isSingleTable?: boolean } = {},\n\t): SQL {\n\t\tconst columnsLen = fields.length;\n\n\t\tconst chunks = fields\n\t\t\t.flatMap(({ field }, i) => {\n\t\t\t\tconst chunk: SQLChunk[] = [];\n\n\t\t\t\tif (is(field, SQL.Aliased) && field.isSelectionField) {\n\t\t\t\t\tchunk.push(sql.identifier(field.fieldAlias));\n\t\t\t\t} else if (is(field, SQL.Aliased) || is(field, SQL)) {\n\t\t\t\t\tconst query = is(field, SQL.Aliased) ? field.sql : field;\n\n\t\t\t\t\tif (isSingleTable) {\n\t\t\t\t\t\tconst newSql = new SQL(\n\t\t\t\t\t\t\tquery.queryChunks.map((c) => {\n\t\t\t\t\t\t\t\tif (is(c, MsSqlColumn)) {\n\t\t\t\t\t\t\t\t\treturn sql.identifier(this.casing.getColumnCasing(c));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\treturn c;\n\t\t\t\t\t\t\t}),\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tchunk.push(query.shouldInlineParams ? newSql.inlineParams() : newSql);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tchunk.push(query);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (is(field, SQL.Aliased)) {\n\t\t\t\t\t\tchunk.push(sql` as ${sql.identifier(field.fieldAlias)}`);\n\t\t\t\t\t}\n\t\t\t\t} else if (is(field, Column)) {\n\t\t\t\t\tif (isSingleTable) {\n\t\t\t\t\t\tchunk.push(\n\t\t\t\t\t\t\tfield.isAlias\n\t\t\t\t\t\t\t\t? sql`${sql.identifier(this.casing.getColumnCasing(getOriginalColumnFromAlias(field)))} as ${field}`\n\t\t\t\t\t\t\t\t: sql.identifier(this.casing.getColumnCasing(field)),\n\t\t\t\t\t\t);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tchunk.push(field.isAlias ? sql`${getOriginalColumnFromAlias(field)} as ${field}` : field);\n\t\t\t\t\t}\n\t\t\t\t} else if (is(field, Subquery)) {\n\t\t\t\t\tconst entries = Object.entries(field._.selectedFields) as [string, SQL.Aliased | Column | SQL][];\n\n\t\t\t\t\tif (entries.length === 1) {\n\t\t\t\t\t\tconst entry = entries[0]![1];\n\n\t\t\t\t\t\tconst fieldDecoder = is(entry, SQL)\n\t\t\t\t\t\t\t? entry.decoder\n\t\t\t\t\t\t\t: is(entry, Column)\n\t\t\t\t\t\t\t? { mapFromDriverValue: (v: any) => entry.mapFromDriverValue(v) }\n\t\t\t\t\t\t\t: entry.sql.decoder;\n\n\t\t\t\t\t\tif (fieldDecoder) {\n\t\t\t\t\t\t\tfield._.sql.decoder = fieldDecoder;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tchunk.push(field);\n\t\t\t\t}\n\n\t\t\t\tif (i < columnsLen - 1) {\n\t\t\t\t\tchunk.push(sql`, `);\n\t\t\t\t}\n\n\t\t\t\treturn chunk;\n\t\t\t});\n\n\t\treturn sql.join(chunks);\n\t}\n\n\tprivate buildSelectionOutput(\n\t\tfields: SelectedFieldsOrdered,\n\t\t{ type }: { type: 'INSERTED' | 'DELETED' },\n\t): SQL {\n\t\tconst columnsLen = fields.length;\n\n\t\tconst chunks = fields\n\t\t\t.flatMap(({ field }, i) => {\n\t\t\t\tconst chunk: SQLChunk[] = [];\n\n\t\t\t\tif (is(field, SQL.Aliased) && field.isSelectionField) {\n\t\t\t\t\tchunk.push(sql.join([sql.raw(`${type}.`), sql.identifier(field.fieldAlias)]));\n\t\t\t\t} else if (is(field, SQL.Aliased) || is(field, SQL)) {\n\t\t\t\t\tconst query = is(field, SQL.Aliased) ? field.sql : field;\n\n\t\t\t\t\tchunk.push(\n\t\t\t\t\t\tnew SQL(\n\t\t\t\t\t\t\tquery.queryChunks.map((c) => {\n\t\t\t\t\t\t\t\tif (is(c, MsSqlColumn)) {\n\t\t\t\t\t\t\t\t\treturn sql.join([sql.raw(`${type}.`), sql.identifier(this.casing.getColumnCasing(c))]);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\treturn c;\n\t\t\t\t\t\t\t}),\n\t\t\t\t\t\t),\n\t\t\t\t\t);\n\n\t\t\t\t\tif (is(field, SQL.Aliased)) {\n\t\t\t\t\t\tchunk.push(sql` as ${sql.identifier(field.fieldAlias)}`);\n\t\t\t\t\t}\n\t\t\t\t} else if (is(field, Column)) {\n\t\t\t\t\tchunk.push(\n\t\t\t\t\t\tsql.join([\n\t\t\t\t\t\t\tsql.raw(`${type}.`),\n\t\t\t\t\t\t\tfield.isAlias\n\t\t\t\t\t\t\t\t? sql`${sql.identifier(this.casing.getColumnCasing(getOriginalColumnFromAlias(field)))} as ${field}`\n\t\t\t\t\t\t\t\t: sql.identifier(this.casing.getColumnCasing(field)),\n\t\t\t\t\t\t]),\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tif (i < columnsLen - 1) {\n\t\t\t\t\tchunk.push(sql`, `);\n\t\t\t\t}\n\n\t\t\t\treturn chunk;\n\t\t\t});\n\n\t\treturn sql.join(chunks);\n\t}\n\n\tbuildSelectQuery(\n\t\t{\n\t\t\twithList,\n\t\t\tfields,\n\t\t\tfieldsFlat,\n\t\t\twhere,\n\t\t\thaving,\n\t\t\ttable,\n\t\t\tjoins,\n\t\t\torderBy,\n\t\t\tgroupBy,\n\t\t\tfetch,\n\t\t\tfor: _for,\n\t\t\ttop,\n\t\t\toffset,\n\t\t\tdistinct,\n\t\t\tsetOperators,\n\t\t}: MsSqlSelectConfig,\n\t): SQL {\n\t\tconst fieldsList = fieldsFlat ?? orderSelectedFields<MsSqlColumn>(fields);\n\t\tfor (const f of fieldsList) {\n\t\t\tif (\n\t\t\t\tis(f.field, Column)\n\t\t\t\t&& getTableName(f.field.table)\n\t\t\t\t\t!== (is(table, Subquery)\n\t\t\t\t\t\t? table._.alias\n\t\t\t\t\t\t: is(table, MsSqlViewBase)\n\t\t\t\t\t\t? table[ViewBaseConfig].name\n\t\t\t\t\t\t: is(table, SQL)\n\t\t\t\t\t\t? undefined\n\t\t\t\t\t\t: getTableName(table))\n\t\t\t\t&& !((table) =>\n\t\t\t\t\tjoins?.some(({ alias }) =>\n\t\t\t\t\t\talias === (table[Table.Symbol.IsAlias] ? getTableName(table) : table[Table.Symbol.BaseName])\n\t\t\t\t\t))(f.field.table)\n\t\t\t) {\n\t\t\t\tconst tableName = getTableName(f.field.table);\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`Your \"${\n\t\t\t\t\t\tf.path.join('->')\n\t\t\t\t\t}\" field references a column \"${tableName}\".\"${f.field.name}\", but the table \"${tableName}\" is not part of the query! Did you forget to join it?`,\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\tconst isSingleTable = !joins || joins.length === 0;\n\n\t\tlet withSql: SQL | undefined;\n\t\tif (withList?.length) {\n\t\t\tconst withSqlChunks = [sql`with `];\n\t\t\tfor (const [i, w] of withList.entries()) {\n\t\t\t\twithSqlChunks.push(sql`${sql.identifier(w._.alias)} as (${w._.sql})`);\n\t\t\t\tif (i < withList.length - 1) {\n\t\t\t\t\twithSqlChunks.push(sql`, `);\n\t\t\t\t}\n\t\t\t}\n\t\t\twithSqlChunks.push(sql` `);\n\t\t\twithSql = sql.join(withSqlChunks);\n\t\t}\n\n\t\tconst distinctSql = distinct ? sql` distinct` : undefined;\n\n\t\tconst topSql = top\n\t\t\t? sql` top(${top})`\n\t\t\t: undefined;\n\n\t\tconst selection = this.buildSelection(fieldsList, { isSingleTable });\n\n\t\tconst tableSql = (() => {\n\t\t\tif (is(table, Table) && table[Table.Symbol.OriginalName] !== table[Table.Symbol.Name]) {\n\t\t\t\tlet fullName = sql`${sql.identifier(table[Table.Symbol.OriginalName])} ${\n\t\t\t\t\tsql.identifier(table[Table.Symbol.Name])\n\t\t\t\t}`;\n\t\t\t\tif (table[Table.Symbol.Schema]) {\n\t\t\t\t\tfullName = sql`${sql.identifier(table[Table.Symbol.Schema]!)}.${fullName}`;\n\t\t\t\t}\n\t\t\t\treturn fullName;\n\t\t\t}\n\n\t\t\tif (is(table, View) && table[ViewBaseConfig].isAlias) {\n\t\t\t\tlet fullName = sql`${sql.identifier(table[ViewBaseConfig].originalName)}`;\n\t\t\t\tif (table[ViewBaseConfig].schema) {\n\t\t\t\t\tfullName = sql`${sql.identifier(table[ViewBaseConfig].schema)}.${fullName}`;\n\t\t\t\t}\n\t\t\t\treturn sql`${fullName} ${sql.identifier(table[ViewBaseConfig].name)}`;\n\t\t\t}\n\n\t\t\treturn table;\n\t\t})();\n\n\t\tconst joinsArray: SQL[] = [];\n\n\t\tif (joins) {\n\t\t\tfor (const [index, joinMeta] of joins.entries()) {\n\t\t\t\tif (index === 0) {\n\t\t\t\t\tjoinsArray.push(sql` `);\n\t\t\t\t}\n\t\t\t\tconst table = joinMeta.table;\n\t\t\t\tconst lateralSql = joinMeta.lateral ? sql` lateral` : undefined;\n\n\t\t\t\tif (is(table, MsSqlTable)) {\n\t\t\t\t\tconst tableName = table[MsSqlTable.Symbol.Name];\n\t\t\t\t\tconst tableSchema = table[MsSqlTable.Symbol.Schema];\n\t\t\t\t\tconst origTableName = table[MsSqlTable.Symbol.OriginalName];\n\t\t\t\t\tconst alias = tableName === origTableName ? undefined : joinMeta.alias;\n\t\t\t\t\tjoinsArray.push(\n\t\t\t\t\t\tsql`${sql.raw(joinMeta.joinType)} join${lateralSql} ${\n\t\t\t\t\t\t\ttableSchema ? sql`${sql.identifier(tableSchema)}.` : undefined\n\t\t\t\t\t\t}${sql.identifier(origTableName)}${alias && sql` ${sql.identifier(alias)}`} on ${joinMeta.on}`,\n\t\t\t\t\t);\n\t\t\t\t} else if (is(table, View)) {\n\t\t\t\t\tconst viewName = table[ViewBaseConfig].name;\n\t\t\t\t\tconst viewSchema = table[ViewBaseConfig].schema;\n\t\t\t\t\tconst origViewName = table[ViewBaseConfig].originalName;\n\t\t\t\t\tconst alias = viewName === origViewName ? undefined : joinMeta.alias;\n\t\t\t\t\tjoinsArray.push(\n\t\t\t\t\t\tsql`${sql.raw(joinMeta.joinType)} join${lateralSql} ${\n\t\t\t\t\t\t\tviewSchema ? sql`${sql.identifier(viewSchema)}.` : undefined\n\t\t\t\t\t\t}${sql.identifier(origViewName)}${alias && sql` ${sql.identifier(alias)}`} on ${joinMeta.on}`,\n\t\t\t\t\t);\n\t\t\t\t} else {\n\t\t\t\t\tjoinsArray.push(\n\t\t\t\t\t\tsql`${sql.raw(joinMeta.joinType)} join${lateralSql} ${table} on ${joinMeta.on}`,\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tif (index < joins.length - 1) {\n\t\t\t\t\tjoinsArray.push(sql` `);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tconst joinsSql = sql.join(joinsArray);\n\n\t\tconst whereSql = where ? sql` where ${where}` : undefined;\n\n\t\tconst havingSql = having ? sql` having ${having}` : undefined;\n\n\t\tlet orderBySql;\n\t\tif (orderBy && orderBy.length > 0) {\n\t\t\torderBySql = sql` order by ${sql.join(orderBy, sql`, `)}`;\n\t\t}\n\n\t\tlet groupBySql;\n\t\tif (groupBy && groupBy.length > 0) {\n\t\t\tgroupBySql = sql` group by ${sql.join(groupBy, sql`, `)}`;\n\t\t}\n\n\t\tconst offsetSql = offset === undefined ? undefined : sql` offset ${offset} rows`;\n\n\t\tconst fetchSql = fetch === undefined ? undefined : sql` fetch next ${fetch} rows only`;\n\n\t\tlet forSQL: SQL | undefined;\n\t\tif (_for && _for.mode === 'json') {\n\t\t\tforSQL = sql` for json ${sql.raw(_for.type)}${\n\t\t\t\t_for.options?.root ? sql` root(${sql.identifier(_for.options.root)})` : undefined\n\t\t\t}${_for.options?.includeNullValues ? sql` include_null_values` : undefined}${\n\t\t\t\t_for.options?.withoutArrayWrapper ? sql` without_array_wrapper` : undefined\n\t\t\t}`;\n\t\t}\n\n\t\tconst finalQuery =\n\t\t\tsql`${withSql}select${distinctSql}${topSql} ${selection} from ${tableSql}${joinsSql}${whereSql}${groupBySql}${havingSql}${orderBySql}${offsetSql}${fetchSql}${forSQL}`;\n\n\t\tif (setOperators.length > 0) {\n\t\t\treturn this.buildSetOperations(finalQuery, setOperators);\n\t\t}\n\n\t\treturn finalQuery;\n\t}\n\n\tbuildSetOperations(leftSelect: SQL, setOperators: MsSqlSelectConfig['setOperators']): SQL {\n\t\tconst [setOperator, ...rest] = setOperators;\n\n\t\tif (!setOperator) {\n\t\t\tthrow new Error('Cannot pass undefined values to any set operator');\n\t\t}\n\n\t\tif (rest.length === 0) {\n\t\t\treturn this.buildSetOperationQuery({ leftSelect, setOperator });\n\t\t}\n\n\t\t// Some recursive magic here\n\t\treturn this.buildSetOperations(\n\t\t\tthis.buildSetOperationQuery({ leftSelect, setOperator }),\n\t\t\trest,\n\t\t);\n\t}\n\n\tbuildSetOperationQuery({\n\t\tleftSelect,\n\t\tsetOperator: { type, isAll, rightSelect, fetch, orderBy, offset },\n\t}: { leftSelect: SQL; setOperator: MsSqlSelectConfig['setOperators'][number] }): SQL {\n\t\tconst leftChunk = sql`(${leftSelect.getSQL()}) `;\n\t\tconst rightChunk = sql`(${rightSelect.getSQL()})`;\n\n\t\tlet orderBySql;\n\t\tif (orderBy && orderBy.length > 0) {\n\t\t\tconst orderByValues: (SQL<unknown> | Name)[] = [];\n\n\t\t\t// The next bit is necessary because the sql operator replaces ${table.column} with `table`.`column`\n\t\t\t// which is invalid MsSql syntax, Table from one of the SELECTs cannot be used in global ORDER clause\n\t\t\tfor (const orderByUnit of orderBy) {\n\t\t\t\tif (is(orderByUnit, MsSqlColumn)) {\n\t\t\t\t\torderByValues.push(sql.identifier(orderByUnit.name));\n\t\t\t\t} else if (is(orderByUnit, SQL)) {\n\t\t\t\t\tfor (let i = 0; i < orderByUnit.queryChunks.length; i++) {\n\t\t\t\t\t\tconst chunk = orderByUnit.queryChunks[i];\n\n\t\t\t\t\t\tif (is(chunk, MsSqlColumn)) {\n\t\t\t\t\t\t\torderByUnit.queryChunks[i] = sql.identifier(chunk.name);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\torderByValues.push(sql`${orderByUnit}`);\n\t\t\t\t} else {\n\t\t\t\t\torderByValues.push(sql`${orderByUnit}`);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\torderBySql = sql` order by ${sql.join(orderByValues, sql`, `)} `;\n\t\t}\n\n\t\tconst offsetSql = offset === undefined ? undefined : sql` offset ${offset} rows`;\n\n\t\tconst fetchSql = fetch === undefined ? undefined : sql` fetch next ${fetch} rows only`;\n\n\t\tconst operatorChunk = sql.raw(`${type} ${isAll ? 'all ' : ''}`);\n\n\t\treturn sql`${leftChunk}${operatorChunk}${rightChunk}${orderBySql}${offsetSql}${fetchSql}`;\n\t}\n\n\tbuildInsertQuery({ table, values, output }: MsSqlInsertConfig): SQL {\n\t\t// const isSingleValue = values.length === 1;\n\t\tconst valuesSqlList: ((SQLChunk | SQL)[] | SQL)[] = [];\n\t\tconst columns: Record<string, MsSqlColumn> = table[Table.Symbol.Columns];\n\t\tconst colEntries: [string, MsSqlColumn][] = Object.entries(columns).filter(\n\t\t\t([_, col]) => !col.shouldDisableInsert(),\n\t\t);\n\n\t\tconst insertOrder = colEntries.map(([, column]) => sql.identifier(this.casing.getColumnCasing(column)));\n\n\t\tfor (const [valueIndex, value] of values.entries()) {\n\t\t\tconst valueList: (SQLChunk | SQL)[] = [];\n\t\t\tfor (const [fieldName, col] of colEntries) {\n\t\t\t\tconst colValue = value[fieldName];\n\t\t\t\tif (colValue === undefined || (is(colValue, Param) && colValue.value === undefined)) {\n\t\t\t\t\tif (col.defaultFn !== undefined) {\n\t\t\t\t\t\tconst defaultFnResult = col.defaultFn();\n\t\t\t\t\t\tconst defaultValue = is(defaultFnResult, SQL) ? defaultFnResult : sql.param(defaultFnResult, col);\n\t\t\t\t\t\tvalueList.push(defaultValue);\n\t\t\t\t\t} else if (!col.default && col.onUpdateFn !== undefined) {\n\t\t\t\t\t\tconst onUpdateFnResult = col.onUpdateFn();\n\t\t\t\t\t\tconst newValue = is(onUpdateFnResult, SQL) ? onUpdateFnResult : sql.param(onUpdateFnResult, col);\n\t\t\t\t\t\tvalueList.push(newValue);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvalueList.push(sql`default`);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tvalueList.push(colValue);\n\t\t\t\t}\n\t\t\t}\n\t\t\tvaluesSqlList.push(valueList);\n\t\t\tif (valueIndex < values.length - 1) {\n\t\t\t\tvaluesSqlList.push(sql`, `);\n\t\t\t}\n\t\t}\n\n\t\tconst valuesSql = insertOrder.length === 0 ? undefined : sql.join(valuesSqlList);\n\n\t\tconst outputSql = output\n\t\t\t? sql` output ${this.buildSelectionOutput(output, { type: 'INSERTED' })}`\n\t\t\t: undefined;\n\n\t\treturn sql`insert into ${table} ${\n\t\t\tinsertOrder.length === 0 ? sql`default` : insertOrder\n\t\t}${outputSql} values ${valuesSql}`;\n\t}\n\n\tsqlToQuery(\n\t\tsql: SQL,\n\t\tinvokeSource?: 'indexes' | 'mssql-check' | 'mssql-view-with-schemabinding',\n\t): QueryWithTypings {\n\t\tconst res = sql.toQuery({\n\t\t\tcasing: this.casing,\n\t\t\tescapeName: this.escapeName,\n\t\t\tescapeParam: this.escapeParam,\n\t\t\tescapeString: this.escapeString,\n\t\t\tinvokeSource,\n\t\t});\n\t\treturn res;\n\t}\n\n\tbuildRelationalQuery({\n\t\tfullSchema,\n\t\tschema,\n\t\ttableNamesMap,\n\t\ttable,\n\t\ttableConfig,\n\t\tqueryConfig: config,\n\t\ttableAlias,\n\t\tnestedQueryRelation,\n\t\tjoinOn,\n\t}: {\n\t\tfullSchema: Record<string, unknown>;\n\t\tschema: V1.TablesRelationalConfig;\n\t\ttableNamesMap: Record<string, string>;\n\t\ttable: MsSqlTable;\n\t\ttableConfig: V1.TableRelationalConfig;\n\t\tqueryConfig: true | V1.DBQueryConfig<'many', true>;\n\t\ttableAlias: string;\n\t\tnestedQueryRelation?: V1.Relation;\n\t\tjoinOn?: SQL;\n\t}): V1.BuildRelationalQueryResult<MsSqlTable, MsSqlColumn> {\n\t\tlet selection: V1.BuildRelationalQueryResult<MsSqlTable, MsSqlColumn>['selection'] = [];\n\t\tlet limit, offset, orderBy: MsSqlSelectConfig['orderBy'] = [], where;\n\n\t\tif (config === true) {\n\t\t\tconst selectionEntries = Object.entries(tableConfig.columns);\n\t\t\tselection = selectionEntries.map((\n\t\t\t\t[key, value],\n\t\t\t) => ({\n\t\t\t\tdbKey: value.name,\n\t\t\t\ttsKey: key,\n\t\t\t\tfield: aliasedTableColumn(value as MsSqlColumn, tableAlias),\n\t\t\t\trelationTableTsKey: undefined,\n\t\t\t\tisJson: false,\n\t\t\t\tselection: [],\n\t\t\t}));\n\t\t} else {\n\t\t\tconst aliasedColumns = Object.fromEntries(\n\t\t\t\tObject.entries(tableConfig.columns).map(([key, value]) => [key, aliasedTableColumn(value, tableAlias)]),\n\t\t\t);\n\n\t\t\tif (config.where) {\n\t\t\t\tconst whereSql = typeof config.where === 'function'\n\t\t\t\t\t? config.where(aliasedColumns, V1.getOperators())\n\t\t\t\t\t: config.where;\n\t\t\t\twhere = whereSql && mapColumnsInSQLToAlias(whereSql, tableAlias);\n\t\t\t}\n\n\t\t\tconst fieldsSelection: { tsKey: string; value: MsSqlColumn | SQL.Aliased }[] = [];\n\t\t\tlet selectedColumns: string[] = [];\n\n\t\t\t// Figure out which columns to select\n\t\t\tif (config.columns) {\n\t\t\t\tlet isIncludeMode = false;\n\n\t\t\t\tfor (const [field, value] of Object.entries(config.columns)) {\n\t\t\t\t\tif (value === undefined) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (field in tableConfig.columns) {\n\t\t\t\t\t\tif (!isIncludeMode && value === true) {\n\t\t\t\t\t\t\tisIncludeMode = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tselectedColumns.push(field);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (selectedColumns.length > 0) {\n\t\t\t\t\tselectedColumns = isIncludeMode\n\t\t\t\t\t\t? selectedColumns.filter((c) => config.columns?.[c] === true)\n\t\t\t\t\t\t: Object.keys(tableConfig.columns).filter((key) => !selectedColumns.includes(key));\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Select all columns if selection is not specified\n\t\t\t\tselectedColumns = Object.keys(tableConfig.columns);\n\t\t\t}\n\n\t\t\tfor (const field of selectedColumns) {\n\t\t\t\tconst column = tableConfig.columns[field]! as MsSqlColumn;\n\t\t\t\tfieldsSelection.push({ tsKey: field, value: column });\n\t\t\t}\n\n\t\t\tlet selectedRelations: {\n\t\t\t\ttsKey: string;\n\t\t\t\tqueryConfig: true | V1.DBQueryConfig<'many', false>;\n\t\t\t\trelation: V1.Relation;\n\t\t\t}[] = [];\n\n\t\t\t// Figure out which relations to select\n\t\t\tif (config.with) {\n\t\t\t\tselectedRelations = Object.entries(config.with)\n\t\t\t\t\t.filter((entry): entry is [typeof entry[0], NonNullable<typeof entry[1]>] => !!entry[1])\n\t\t\t\t\t.map(([tsKey, queryConfig]) => ({ tsKey, queryConfig, relation: tableConfig.relations[tsKey]! }));\n\t\t\t}\n\n\t\t\tlet extras;\n\n\t\t\t// Figure out which extras to select\n\t\t\tif (config.extras) {\n\t\t\t\textras = typeof config.extras === 'function'\n\t\t\t\t\t? config.extras(aliasedColumns, { sql })\n\t\t\t\t\t: config.extras;\n\t\t\t\tfor (const [tsKey, value] of Object.entries(extras)) {\n\t\t\t\t\tfieldsSelection.push({\n\t\t\t\t\t\ttsKey,\n\t\t\t\t\t\tvalue: mapColumnsInAliasedSQLToAlias(value, tableAlias),\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Transform `fieldsSelection` into `selection`\n\t\t\t// `fieldsSelection` shouldn't be used after this point\n\t\t\tfor (const { tsKey, value } of fieldsSelection) {\n\t\t\t\tselection.push({\n\t\t\t\t\tdbKey: is(value, SQL.Aliased) ? value.fieldAlias : tableConfig.columns[tsKey]!.name,\n\t\t\t\t\ttsKey,\n\t\t\t\t\tfield: is(value, Column) ? aliasedTableColumn(value, tableAlias) : value,\n\t\t\t\t\trelationTableTsKey: undefined,\n\t\t\t\t\tisJson: false,\n\t\t\t\t\tselection: [],\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tlet orderByOrig = typeof config.orderBy === 'function'\n\t\t\t\t? config.orderBy(aliasedColumns, V1.getOrderByOperators())\n\t\t\t\t: config.orderBy ?? [];\n\t\t\tif (!Array.isArray(orderByOrig)) {\n\t\t\t\torderByOrig = [orderByOrig];\n\t\t\t}\n\t\t\torderBy = orderByOrig.map((orderByValue) => {\n\t\t\t\tif (is(orderByValue, Column)) {\n\t\t\t\t\treturn aliasedTableColumn(orderByValue, tableAlias) as MsSqlColumn;\n\t\t\t\t}\n\t\t\t\treturn mapColumnsInSQLToAlias(orderByValue, tableAlias);\n\t\t\t});\n\n\t\t\tlimit = config.limit;\n\t\t\toffset = config.offset;\n\n\t\t\t// Process all relations\n\t\t\tfor (\n\t\t\t\tconst {\n\t\t\t\t\ttsKey: selectedRelationTsKey,\n\t\t\t\t\tqueryConfig: selectedRelationConfigValue,\n\t\t\t\t\trelation,\n\t\t\t\t} of selectedRelations\n\t\t\t) {\n\t\t\t\tconst normalizedRelation = V1.normalizeRelation(schema, tableNamesMap, relation);\n\t\t\t\tconst relationTableName = getTableUniqueName(relation.referencedTable);\n\t\t\t\tconst relationTableTsName = tableNamesMap[relationTableName]!;\n\t\t\t\tconst relationTableAlias = `${tableAlias}_${selectedRelationTsKey}`;\n\t\t\t\tconst joinOn = and(\n\t\t\t\t\t...normalizedRelation.fields.map((field, i) =>\n\t\t\t\t\t\teq(\n\t\t\t\t\t\t\taliasedTableColumn(normalizedRelation.references[i]!, relationTableAlias),\n\t\t\t\t\t\t\taliasedTableColumn(field, tableAlias),\n\t\t\t\t\t\t)\n\t\t\t\t\t),\n\t\t\t\t);\n\t\t\t\tconst builtRelation = this.buildRelationalQuery({\n\t\t\t\t\tfullSchema,\n\t\t\t\t\tschema,\n\t\t\t\t\ttableNamesMap,\n\t\t\t\t\ttable: fullSchema[relationTableTsName] as MsSqlTable,\n\t\t\t\t\ttableConfig: schema[relationTableTsName]!,\n\t\t\t\t\tqueryConfig: is(relation, V1.One)\n\t\t\t\t\t\t? (selectedRelationConfigValue === true\n\t\t\t\t\t\t\t? { limit: 1 }\n\t\t\t\t\t\t\t: { ...selectedRelationConfigValue, limit: 1 })\n\t\t\t\t\t\t: selectedRelationConfigValue,\n\t\t\t\t\ttableAlias: relationTableAlias,\n\t\t\t\t\tjoinOn,\n\t\t\t\t\tnestedQueryRelation: relation,\n\t\t\t\t});\n\t\t\t\tlet fieldSql = sql`(${builtRelation.sql} for json auto, include_null_values)${\n\t\t\t\t\tnestedQueryRelation ? sql` as ${sql.identifier(relationTableAlias)}` : undefined\n\t\t\t\t}`;\n\t\t\t\tif (is(relation, V1.Many)) {\n\t\t\t\t\tfieldSql = sql`${fieldSql}`;\n\t\t\t\t}\n\t\t\t\tconst field = fieldSql.as(selectedRelationTsKey);\n\t\t\t\tselection.push({\n\t\t\t\t\tdbKey: selectedRelationTsKey,\n\t\t\t\t\ttsKey: selectedRelationTsKey,\n\t\t\t\t\tfield,\n\t\t\t\t\trelationTableTsKey: relationTableTsName,\n\t\t\t\t\tisJson: true,\n\t\t\t\t\tselection: builtRelation.selection,\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\tif (selection.length === 0) {\n\t\t\tthrow new DrizzleError({\n\t\t\t\tmessage:\n\t\t\t\t\t`No fields selected for table \"${tableConfig.tsName}\" (\"${tableAlias}\"). You need to have at least one item in \"columns\", \"with\" or \"extras\". If you need to select all columns, omit the \"columns\" key or set it to undefined.`,\n\t\t\t});\n\t\t}\n\n\t\tlet result;\n\n\t\twhere = and(joinOn, where);\n\n\t\tif (nestedQueryRelation) {\n\t\t\tlet field = sql`${\n\t\t\t\tsql.join(\n\t\t\t\t\tselection.map((sel) => {\n\t\t\t\t\t\treturn is(sel.field, MsSqlColumn)\n\t\t\t\t\t\t\t? sql.identifier(sel.field.name)\n\t\t\t\t\t\t\t: is(sel.field, SQL.Aliased)\n\t\t\t\t\t\t\t? sel.isJson\n\t\t\t\t\t\t\t\t? sel.field.sql\n\t\t\t\t\t\t\t\t: sql`${sel.field.sql} as ${sql.identifier(sel.field.fieldAlias)}`\n\t\t\t\t\t\t\t: sel.field;\n\t\t\t\t\t}),\n\t\t\t\t\tsql`, `,\n\t\t\t\t)\n\t\t\t}`;\n\t\t\tif (is(nestedQueryRelation, V1.Many)) {\n\t\t\t\tfield = sql`${field}`;\n\t\t\t}\n\t\t\tconst nestedSelection = [{\n\t\t\t\tdbKey: 'data',\n\t\t\t\ttsKey: 'data',\n\t\t\t\tfield,\n\t\t\t\tisJson: true,\n\t\t\t\trelationTableTsKey: tableConfig.tsName,\n\t\t\t\tselection,\n\t\t\t}];\n\n\t\t\tresult = aliasedTable(table, tableAlias);\n\n\t\t\tconst top = offset ? undefined : limit ?? undefined;\n\t\t\tconst fetch = offset && limit ? limit : undefined;\n\n\t\t\t// Mssql required order by to be present in the query if using offset and fetch(limit)\n\t\t\t// With order by 1, the query will be ordered by the first column in the selection\n\t\t\tif (orderBy.length === 0 && offset !== undefined && fetch !== undefined) {\n\t\t\t\torderBy = [sql`1`];\n\t\t\t}\n\n\t\t\tresult = this.buildSelectQuery({\n\t\t\t\ttable: is(result, MsSqlTable) ? result : new Subquery(result, {}, tableAlias),\n\t\t\t\tfields: {},\n\t\t\t\tfieldsFlat: nestedSelection.map(({ field }) => ({\n\t\t\t\t\tpath: [],\n\t\t\t\t\tfield: is(field, Column) ? aliasedTableColumn(field, tableAlias) : field,\n\t\t\t\t})),\n\t\t\t\twhere,\n\t\t\t\ttop,\n\t\t\t\toffset,\n\t\t\t\tfetch,\n\t\t\t\torderBy,\n\t\t\t\tsetOperators: [],\n\t\t\t});\n\t\t} else {\n\t\t\tconst top = offset ? undefined : limit ?? undefined;\n\t\t\tconst fetch = offset && limit ? limit : undefined;\n\n\t\t\tif (orderBy.length === 0 && offset !== undefined && fetch !== undefined) {\n\t\t\t\torderBy = [sql`1`];\n\t\t\t}\n\t\t\tresult = this.buildSelectQuery({\n\t\t\t\ttable: aliasedTable(table, tableAlias),\n\t\t\t\tfields: {},\n\t\t\t\tfieldsFlat: selection.map(({ field }) => ({\n\t\t\t\t\tpath: [],\n\t\t\t\t\tfield: is(field, Column) ? aliasedTableColumn(field, tableAlias) : field,\n\t\t\t\t})),\n\t\t\t\twhere,\n\t\t\t\ttop,\n\t\t\t\toffset,\n\t\t\t\tfetch,\n\t\t\t\torderBy,\n\t\t\t\tsetOperators: [],\n\t\t\t});\n\t\t}\n\n\t\treturn {\n\t\t\ttableTsKey: tableConfig.tsName,\n\t\t\tsql: result,\n\t\t\tselection,\n\t\t};\n\t}\n}\n"],"mappings":"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"}