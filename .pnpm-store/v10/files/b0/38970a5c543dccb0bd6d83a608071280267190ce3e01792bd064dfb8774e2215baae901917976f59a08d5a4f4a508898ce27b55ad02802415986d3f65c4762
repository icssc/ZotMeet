{"version":3,"sources":["../../../../src/server/dev/hot-reloader-rspack.ts"],"sourcesContent":["import path from 'path'\nimport fs from 'fs/promises'\nimport { createHash } from 'crypto'\nimport HotReloaderWebpack from './hot-reloader-webpack'\nimport { BUILT, EntryTypes, getEntries } from './on-demand-entry-handler'\nimport type { __ApiPreviewProps } from '../api-utils'\nimport type { RouteDefinition } from '../route-definitions/route-definition'\nimport type { MultiCompiler } from 'webpack'\nimport { COMPILER_NAMES } from '../../shared/lib/constants'\n\n/**\n * Rspack Persistent Cache Strategy for Next.js Development\n *\n * Rspack's persistent caching differs from Webpack in how it manages module graphs.\n * While Webpack incrementally updates modules, Rspack operates on complete module\n * graph snapshots for cache restoration.\n *\n * Problem:\n * - Next.js dev server starts with no page modules in the initial entry points\n * - When Rspack restores from persistent cache, it finds no modules and purges\n *   the entire module graph\n * - Later page requests find no cached module information, preventing cache reuse\n *\n * Solution:\n * - Track successfully built page entries after each compilation\n * - Restore these entries on dev server restart to maintain module graph continuity\n * - This ensures previously compiled pages can leverage persistent cache for faster builds\n */\nexport default class HotReloaderRspack extends HotReloaderWebpack {\n  private builtEntriesCachePath?: string\n\n  private isClientCacheEnabled = false\n  private isServerCacheEnabled = false\n  private isEdgeServerCacheEnabled = false\n\n  public async afterCompile(multiCompiler: MultiCompiler): Promise<void> {\n    // Always initialize the fallback error watcher for Rspack.\n    // Rspack may restore/retain the previous build's error state, so without this\n    // a page that previously failed to build might not be rebuilt on the next request.\n    await super.buildFallbackError()\n\n    const rspackStartSpan = this.hotReloaderSpan.traceChild(\n      'rspack-after-compile'\n    )\n    await rspackStartSpan.traceAsyncFn(async () => {\n      const hash = createHash('sha1')\n      multiCompiler.compilers.forEach((compiler) => {\n        const cache = compiler.options.cache\n        if (typeof cache === 'object' && 'version' in cache && cache.version) {\n          hash.update(cache.version)\n          if (compiler.name === COMPILER_NAMES.client) {\n            this.isClientCacheEnabled = true\n          } else if (compiler.name === COMPILER_NAMES.server) {\n            this.isServerCacheEnabled = true\n          } else if (compiler.name === COMPILER_NAMES.edgeServer) {\n            this.isEdgeServerCacheEnabled = true\n          }\n        } else {\n          hash.update('-')\n        }\n        return undefined\n      })\n      this.builtEntriesCachePath = path.join(\n        this.distDir,\n        'cache',\n        'rspack',\n        hash.digest('hex').substring(0, 16),\n        'built-entries.json'\n      )\n\n      const hasBuiltEntriesCache = await fs\n        .access(this.builtEntriesCachePath)\n        .then(\n          () => true,\n          () => false\n        )\n      if (hasBuiltEntriesCache) {\n        try {\n          const builtEntries: ReturnType<typeof getEntries> = JSON.parse(\n            (await fs.readFile(this.builtEntriesCachePath, 'utf-8')) || '{}'\n          )\n\n          await Promise.all(\n            Object.keys(builtEntries).map(async (entryKey) => {\n              const entryData = builtEntries[entryKey]\n\n              const isEntry = entryData.type === EntryTypes.ENTRY\n              const isChildEntry = entryData.type === EntryTypes.CHILD_ENTRY\n\n              // Check if the page was removed or disposed and remove it\n              if (isEntry) {\n                const pageExists =\n                  !entryData.dispose &&\n                  (await fs.access(entryData.absolutePagePath).then(\n                    () => true,\n                    () => false\n                  ))\n                if (!pageExists) {\n                  delete builtEntries[entryKey]\n                  return\n                } else if (\n                  !('hash' in builtEntries[entryKey]) ||\n                  builtEntries[entryKey].hash !==\n                    (await calculateFileHash(entryData.absolutePagePath))\n                ) {\n                  delete builtEntries[entryKey]\n                  return\n                }\n              }\n\n              // For child entries, if it has an entry file and it's gone, remove it\n              if (isChildEntry) {\n                if (entryData.absoluteEntryFilePath) {\n                  const pageExists =\n                    !entryData.dispose &&\n                    (await fs.access(entryData.absoluteEntryFilePath).then(\n                      () => true,\n                      () => false\n                    ))\n                  if (!pageExists) {\n                    delete builtEntries[entryKey]\n                    return\n                  } else {\n                    if (\n                      !('hash' in builtEntries[entryKey]) ||\n                      builtEntries[entryKey].hash !==\n                        (await calculateFileHash(\n                          entryData.absoluteEntryFilePath\n                        ))\n                    ) {\n                      delete builtEntries[entryKey]\n                      return\n                    }\n                  }\n                }\n              }\n            })\n          )\n          Object.assign(getEntries(multiCompiler.outputPath), builtEntries)\n        } catch (error) {\n          console.error('Rspack failed to read built entries cache: ', error)\n        }\n      }\n    })\n  }\n\n  public async ensurePage({\n    page,\n    clientOnly,\n    appPaths,\n    definition,\n    isApp,\n    url,\n  }: {\n    page: string\n    clientOnly: boolean\n    appPaths?: ReadonlyArray<string> | null\n    isApp?: boolean\n    definition?: RouteDefinition\n    url?: string\n  }): Promise<void> {\n    await super.ensurePage({\n      page,\n      clientOnly,\n      appPaths,\n      definition,\n      isApp,\n      url,\n    })\n    const entries = getEntries(this.multiCompiler!.outputPath)\n    const builtEntries: { [entryName: string]: any } = {}\n    await Promise.all(\n      Object.keys(entries).map(async (entryName) => {\n        const entry = entries[entryName]\n        if (entry.status !== BUILT) return\n        const result =\n          /^(client|server|edge-server)@(app|pages|root)@(.*)/g.exec(entryName)\n        const [, key /* pageType */, ,] = result! // this match should always happen\n        if (key === 'client' && !this.isClientCacheEnabled) return\n        if (key === 'server' && !this.isServerCacheEnabled) return\n        if (key === 'edge-server' && !this.isEdgeServerCacheEnabled) return\n\n        // TODO: Rspack does not store middleware entries in persistent cache, causing\n        // test/integration/middleware-src/test/index.test.ts to fail. This is a temporary\n        // workaround to skip middleware entry caching until Rspack properly supports it.\n        if (page === '/middleware') {\n          return\n        }\n\n        let hash: string | undefined\n        if (entry.type === EntryTypes.ENTRY) {\n          hash = await calculateFileHash(entry.absolutePagePath)\n        } else if (entry.absoluteEntryFilePath) {\n          hash = await calculateFileHash(entry.absoluteEntryFilePath)\n        }\n        if (!hash) {\n          return\n        }\n\n        builtEntries[entryName] = entry\n        builtEntries[entryName].hash = hash\n      })\n    )\n\n    const hasBuitEntriesCache = await fs\n      .access(this.builtEntriesCachePath!)\n      .then(\n        () => true,\n        () => false\n      )\n    try {\n      if (!hasBuitEntriesCache) {\n        await fs.mkdir(path.dirname(this.builtEntriesCachePath!), {\n          recursive: true,\n        })\n      }\n      await fs.writeFile(\n        this.builtEntriesCachePath!,\n        JSON.stringify(builtEntries, null, 2)\n      )\n    } catch (error) {\n      console.error('Rspack failed to write built entries cache: ', error)\n    }\n  }\n}\n\nasync function calculateFileHash(\n  filePath: string,\n  algorithm: string = 'sha256'\n): Promise<string | undefined> {\n  if (\n    !(await fs.access(filePath).then(\n      () => true,\n      () => false\n    ))\n  ) {\n    return\n  }\n  const fileBuffer = await fs.readFile(filePath)\n  const hash = createHash(algorithm)\n  hash.update(fileBuffer)\n  return hash.digest('hex')\n}\n"],"names":["path","fs","createHash","HotReloaderWebpack","BUILT","EntryTypes","getEntries","COMPILER_NAMES","HotReloaderRspack","afterCompile","multiCompiler","buildFallbackError","rspackStartSpan","hotReloaderSpan","traceChild","traceAsyncFn","hash","compilers","forEach","compiler","cache","options","version","update","name","client","isClientCacheEnabled","server","isServerCacheEnabled","edgeServer","isEdgeServerCacheEnabled","undefined","builtEntriesCachePath","join","distDir","digest","substring","hasBuiltEntriesCache","access","then","builtEntries","JSON","parse","readFile","Promise","all","Object","keys","map","entryKey","entryData","isEntry","type","ENTRY","isChildEntry","CHILD_ENTRY","pageExists","dispose","absolutePagePath","calculateFileHash","absoluteEntryFilePath","assign","outputPath","error","console","ensurePage","page","clientOnly","appPaths","definition","isApp","url","entries","entryName","entry","status","result","exec","key","hasBuitEntriesCache","mkdir","dirname","recursive","writeFile","stringify","filePath","algorithm","fileBuffer"],"mappings":"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","ignoreList":[0]}