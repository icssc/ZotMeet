{"version":3,"sources":["../../../../src/server/use-cache/use-cache-wrapper.ts"],"sourcesContent":["import type { DeepReadonly } from '../../shared/lib/deep-readonly'\n/* eslint-disable import/no-extraneous-dependencies */\nimport {\n  renderToReadableStream,\n  decodeReply,\n  decodeReplyFromAsyncIterable,\n  createTemporaryReferenceSet as createServerTemporaryReferenceSet,\n} from 'react-server-dom-webpack/server'\nimport {\n  createFromReadableStream,\n  encodeReply,\n  createTemporaryReferenceSet as createClientTemporaryReferenceSet,\n} from 'react-server-dom-webpack/client'\nimport { prerender } from 'react-server-dom-webpack/static'\n/* eslint-enable import/no-extraneous-dependencies */\n\nimport type { WorkStore } from '../app-render/work-async-storage.external'\nimport { workAsyncStorage } from '../app-render/work-async-storage.external'\nimport type {\n  PrerenderStoreModernClient,\n  PrerenderStoreModernRuntime,\n  PrivateUseCacheStore,\n  RequestStore,\n  RevalidateStore,\n  UseCacheStore,\n  WorkUnitStore,\n} from '../app-render/work-unit-async-storage.external'\nimport {\n  getHmrRefreshHash,\n  getRenderResumeDataCache,\n  getPrerenderResumeDataCache,\n  workUnitAsyncStorage,\n  getDraftModeProviderForCacheScope,\n  getCacheSignal,\n  isHmrRefresh,\n  getServerComponentsHmrCache,\n  getRuntimeStagePromise,\n} from '../app-render/work-unit-async-storage.external'\n\nimport {\n  makeDevtoolsIOAwarePromise,\n  makeHangingPromise,\n} from '../dynamic-rendering-utils'\n\nimport type { ClientReferenceManifest } from '../../build/webpack/plugins/flight-manifest-plugin'\n\nimport {\n  getClientReferenceManifest,\n  getServerModuleMap,\n} from '../app-render/manifests-singleton'\nimport type { CacheEntry } from '../lib/cache-handlers/types'\nimport type { CacheSignal } from '../app-render/cache-signal'\nimport { decryptActionBoundArgs } from '../app-render/encryption'\nimport { InvariantError } from '../../shared/lib/invariant-error'\nimport { createReactServerErrorHandler } from '../app-render/create-error-handler'\nimport { DYNAMIC_EXPIRE, RUNTIME_PREFETCH_DYNAMIC_STALE } from './constants'\nimport { getCacheHandler } from './handlers'\nimport { UseCacheTimeoutError } from './use-cache-errors'\nimport {\n  createHangingInputAbortSignal,\n  postponeWithTracking,\n  throwToInterruptStaticGeneration,\n} from '../app-render/dynamic-rendering'\nimport {\n  makeErroringSearchParamsForUseCache,\n  type SearchParams,\n} from '../request/search-params'\nimport type { Params } from '../request/params'\nimport { createLazyResult, isResolvedLazyResult } from '../lib/lazy-result'\nimport { dynamicAccessAsyncStorage } from '../app-render/dynamic-access-async-storage.external'\nimport type { CacheLife } from './cache-life'\nimport { RenderStage } from '../app-render/staged-rendering'\nimport * as Log from '../../build/output/log'\n\ninterface PrivateCacheContext {\n  readonly kind: 'private'\n  readonly outerWorkUnitStore:\n    | RequestStore\n    | PrivateUseCacheStore\n    | PrerenderStoreModernRuntime\n}\n\ninterface PublicCacheContext {\n  readonly kind: 'public'\n  // TODO: We should probably forbid nesting \"use cache\" inside unstable_cache.\n  readonly outerWorkUnitStore:\n    | Exclude<WorkUnitStore, PrerenderStoreModernClient>\n    | undefined\n}\n\ntype CacheContext = PrivateCacheContext | PublicCacheContext\n\ntype CacheKeyParts =\n  | [buildId: string, id: string, args: unknown[]]\n  | [buildId: string, id: string, args: unknown[], hmrRefreshHash: string]\n\ninterface UseCachePageInnerProps {\n  params: Promise<Params>\n  searchParams?: Promise<SearchParams>\n}\n\nexport interface UseCachePageProps {\n  params: Promise<Params>\n  searchParams: Promise<SearchParams>\n  $$isPage: true\n}\n\nexport type UseCacheLayoutProps = {\n  params: Promise<Params>\n  $$isLayout: true\n} & {\n  // The value type should be React.ReactNode. But such an index signature would\n  // be incompatible with the other two props.\n  [slot: string]: any\n}\n\nconst isEdgeRuntime = process.env.NEXT_RUNTIME === 'edge'\n\nconst debug = process.env.NEXT_PRIVATE_DEBUG_CACHE\n  ? console.debug.bind(console, 'use-cache:')\n  : undefined\n\nconst filterStackFrame =\n  process.env.NODE_ENV !== 'production'\n    ? (require('../lib/source-maps') as typeof import('../lib/source-maps'))\n        .filterStackFrameDEV\n    : undefined\nconst findSourceMapURL =\n  process.env.NODE_ENV !== 'production'\n    ? (require('../lib/source-maps') as typeof import('../lib/source-maps'))\n        .findSourceMapURLDEV\n    : undefined\n\nfunction generateCacheEntry(\n  workStore: WorkStore,\n  cacheContext: CacheContext,\n  clientReferenceManifest: DeepReadonly<ClientReferenceManifest>,\n  encodedArguments: FormData | string,\n  fn: (...args: unknown[]) => Promise<unknown>,\n  timeoutError: UseCacheTimeoutError\n) {\n  // We need to run this inside a clean AsyncLocalStorage snapshot so that the cache\n  // generation cannot read anything from the context we're currently executing which\n  // might include request specific things like cookies() inside a React.cache().\n  // Note: It is important that we await at least once before this because it lets us\n  // pop out of any stack specific contexts as well - aka \"Sync\" Local Storage.\n  return workStore.runInCleanSnapshot(\n    generateCacheEntryWithRestoredWorkStore,\n    workStore,\n    cacheContext,\n    clientReferenceManifest,\n    encodedArguments,\n    fn,\n    timeoutError\n  )\n}\n\nfunction generateCacheEntryWithRestoredWorkStore(\n  workStore: WorkStore,\n  cacheContext: CacheContext,\n  clientReferenceManifest: DeepReadonly<ClientReferenceManifest>,\n  encodedArguments: FormData | string,\n  fn: (...args: unknown[]) => Promise<unknown>,\n  timeoutError: UseCacheTimeoutError\n) {\n  // Since we cleared the AsyncLocalStorage we need to restore the workStore.\n  // Note: We explicitly don't restore the RequestStore nor the PrerenderStore.\n  // We don't want any request specific information leaking an we don't want to create a\n  // bloated fake request mock for every cache call. So any feature that currently lives\n  // in RequestStore but should be available to Caches need to move to WorkStore.\n  // PrerenderStore is not needed inside the cache scope because the outer most one will\n  // be the one to report its result to the outer Prerender.\n  return workAsyncStorage.run(\n    workStore,\n    generateCacheEntryWithCacheContext,\n    workStore,\n    cacheContext,\n    clientReferenceManifest,\n    encodedArguments,\n    fn,\n    timeoutError\n  )\n}\n\nfunction createUseCacheStore(\n  workStore: WorkStore,\n  cacheContext: CacheContext,\n  defaultCacheLife: Required<CacheLife>\n): UseCacheStore {\n  if (cacheContext.kind === 'private') {\n    const outerWorkUnitStore = cacheContext.outerWorkUnitStore\n\n    return {\n      type: 'private-cache',\n      phase: 'render',\n      implicitTags: outerWorkUnitStore?.implicitTags,\n      revalidate: defaultCacheLife.revalidate,\n      expire: defaultCacheLife.expire,\n      stale: defaultCacheLife.stale,\n      explicitRevalidate: undefined,\n      explicitExpire: undefined,\n      explicitStale: undefined,\n      tags: null,\n      hmrRefreshHash: getHmrRefreshHash(workStore, outerWorkUnitStore),\n      isHmrRefresh: isHmrRefresh(workStore, outerWorkUnitStore),\n      serverComponentsHmrCache: getServerComponentsHmrCache(\n        workStore,\n        outerWorkUnitStore\n      ),\n      forceRevalidate: shouldForceRevalidate(workStore, outerWorkUnitStore),\n      runtimeStagePromise: getRuntimeStagePromise(outerWorkUnitStore),\n      draftMode: getDraftModeProviderForCacheScope(\n        workStore,\n        outerWorkUnitStore\n      ),\n      rootParams: outerWorkUnitStore.rootParams,\n      headers: outerWorkUnitStore.headers,\n      cookies: outerWorkUnitStore.cookies,\n    }\n  } else {\n    let useCacheOrRequestStore: RequestStore | UseCacheStore | undefined\n    const outerWorkUnitStore = cacheContext.outerWorkUnitStore\n\n    if (outerWorkUnitStore) {\n      switch (outerWorkUnitStore?.type) {\n        case 'cache':\n        case 'private-cache':\n        case 'request':\n          useCacheOrRequestStore = outerWorkUnitStore\n          break\n        case 'prerender-runtime':\n        case 'prerender':\n        case 'prerender-ppr':\n        case 'prerender-legacy':\n        case 'unstable-cache':\n          break\n        default:\n          outerWorkUnitStore satisfies never\n      }\n    }\n\n    return {\n      type: 'cache',\n      phase: 'render',\n      implicitTags: outerWorkUnitStore?.implicitTags,\n      revalidate: defaultCacheLife.revalidate,\n      expire: defaultCacheLife.expire,\n      stale: defaultCacheLife.stale,\n      explicitRevalidate: undefined,\n      explicitExpire: undefined,\n      explicitStale: undefined,\n      tags: null,\n      hmrRefreshHash:\n        outerWorkUnitStore && getHmrRefreshHash(workStore, outerWorkUnitStore),\n      isHmrRefresh: useCacheOrRequestStore?.isHmrRefresh ?? false,\n      serverComponentsHmrCache:\n        useCacheOrRequestStore?.serverComponentsHmrCache,\n      forceRevalidate: shouldForceRevalidate(workStore, outerWorkUnitStore),\n      draftMode:\n        outerWorkUnitStore &&\n        getDraftModeProviderForCacheScope(workStore, outerWorkUnitStore),\n    }\n  }\n}\n\nfunction assertDefaultCacheLife(\n  defaultCacheLife: CacheLife | undefined\n): asserts defaultCacheLife is Required<CacheLife> {\n  if (\n    !defaultCacheLife ||\n    defaultCacheLife.revalidate == null ||\n    defaultCacheLife.expire == null ||\n    defaultCacheLife.stale == null\n  ) {\n    throw new InvariantError(\n      'A default cacheLife profile must always be provided.'\n    )\n  }\n}\n\nfunction generateCacheEntryWithCacheContext(\n  workStore: WorkStore,\n  cacheContext: CacheContext,\n  clientReferenceManifest: DeepReadonly<ClientReferenceManifest>,\n  encodedArguments: FormData | string,\n  fn: (...args: unknown[]) => Promise<unknown>,\n  timeoutError: UseCacheTimeoutError\n) {\n  if (!workStore.cacheLifeProfiles) {\n    throw new InvariantError('cacheLifeProfiles should always be provided.')\n  }\n  const defaultCacheLife = workStore.cacheLifeProfiles['default']\n  assertDefaultCacheLife(defaultCacheLife)\n\n  // Initialize the Store for this Cache entry.\n  const cacheStore = createUseCacheStore(\n    workStore,\n    cacheContext,\n    defaultCacheLife\n  )\n\n  return workUnitAsyncStorage.run(cacheStore, () =>\n    dynamicAccessAsyncStorage.run(\n      { abortController: new AbortController() },\n      generateCacheEntryImpl,\n      workStore,\n      cacheContext,\n      cacheStore,\n      clientReferenceManifest,\n      encodedArguments,\n      fn,\n      timeoutError\n    )\n  )\n}\n\nfunction propagateCacheLifeAndTagsToRevalidateStore(\n  revalidateStore: RevalidateStore,\n  entry: CacheEntry\n): void {\n  const outerTags = (revalidateStore.tags ??= [])\n\n  for (const tag of entry.tags) {\n    if (!outerTags.includes(tag)) {\n      outerTags.push(tag)\n    }\n  }\n\n  if (revalidateStore.stale > entry.stale) {\n    revalidateStore.stale = entry.stale\n  }\n\n  if (revalidateStore.revalidate > entry.revalidate) {\n    revalidateStore.revalidate = entry.revalidate\n  }\n\n  if (revalidateStore.expire > entry.expire) {\n    revalidateStore.expire = entry.expire\n  }\n}\n\nfunction propagateCacheLifeAndTags(\n  cacheContext: CacheContext,\n  entry: CacheEntry\n): void {\n  if (cacheContext.kind === 'private') {\n    switch (cacheContext.outerWorkUnitStore.type) {\n      case 'prerender-runtime':\n      case 'private-cache':\n        propagateCacheLifeAndTagsToRevalidateStore(\n          cacheContext.outerWorkUnitStore,\n          entry\n        )\n        break\n      case 'request':\n      case undefined:\n        break\n      default:\n        cacheContext.outerWorkUnitStore satisfies never\n    }\n  } else {\n    switch (cacheContext.outerWorkUnitStore?.type) {\n      case 'cache':\n      case 'private-cache':\n      case 'prerender':\n      case 'prerender-runtime':\n      case 'prerender-ppr':\n      case 'prerender-legacy':\n        propagateCacheLifeAndTagsToRevalidateStore(\n          cacheContext.outerWorkUnitStore,\n          entry\n        )\n        break\n      case 'request':\n      case 'unstable-cache':\n      case undefined:\n        break\n      default:\n        cacheContext.outerWorkUnitStore satisfies never\n    }\n  }\n}\n\nasync function collectResult(\n  savedStream: ReadableStream<Uint8Array>,\n  workStore: WorkStore,\n  cacheContext: CacheContext,\n  innerCacheStore: UseCacheStore,\n  startTime: number,\n  errors: Array<unknown> // This is a live array that gets pushed into.\n): Promise<CacheEntry> {\n  // We create a buffered stream that collects all chunks until the end to\n  // ensure that RSC has finished rendering and therefore we have collected\n  // all tags. In the future the RSC API might allow for the equivalent of\n  // the allReady Promise that exists on SSR streams.\n  //\n  // If something errored or rejected anywhere in the render, we close\n  // the stream as errored. This lets a CacheHandler choose to save the\n  // partial result up until that point for future hits for a while to avoid\n  // unnecessary retries or not to retry. We use the end of the stream for\n  // this to avoid another complicated side-channel. A receiver has to consider\n  // that the stream might also error for other reasons anyway such as losing\n  // connection.\n\n  const buffer: Uint8Array[] = []\n  const reader = savedStream.getReader()\n\n  try {\n    for (let entry; !(entry = await reader.read()).done; ) {\n      buffer.push(entry.value)\n    }\n  } catch (error) {\n    errors.push(error)\n  }\n\n  let idx = 0\n  const bufferStream = new ReadableStream<Uint8Array>({\n    pull(controller) {\n      if (workStore.invalidDynamicUsageError) {\n        controller.error(workStore.invalidDynamicUsageError)\n      } else if (idx < buffer.length) {\n        controller.enqueue(buffer[idx++])\n      } else if (errors.length > 0) {\n        // TODO: Should we use AggregateError here?\n        controller.error(errors[0])\n      } else {\n        controller.close()\n      }\n    },\n  })\n\n  const collectedTags = innerCacheStore.tags\n  // If cacheLife() was used to set an explicit revalidate time we use that.\n  // Otherwise, we use the lowest of all inner fetch()/unstable_cache() or nested \"use cache\".\n  // If they're lower than our default.\n  const collectedRevalidate =\n    innerCacheStore.explicitRevalidate !== undefined\n      ? innerCacheStore.explicitRevalidate\n      : innerCacheStore.revalidate\n  const collectedExpire =\n    innerCacheStore.explicitExpire !== undefined\n      ? innerCacheStore.explicitExpire\n      : innerCacheStore.expire\n  const collectedStale =\n    innerCacheStore.explicitStale !== undefined\n      ? innerCacheStore.explicitStale\n      : innerCacheStore.stale\n\n  const entry: CacheEntry = {\n    value: bufferStream,\n    timestamp: startTime,\n    revalidate: collectedRevalidate,\n    expire: collectedExpire,\n    stale: collectedStale,\n    tags: collectedTags === null ? [] : collectedTags,\n  }\n\n  if (cacheContext.outerWorkUnitStore) {\n    const outerWorkUnitStore = cacheContext.outerWorkUnitStore\n\n    // Propagate cache life & tags to the parent context if appropriate.\n    switch (outerWorkUnitStore.type) {\n      case 'prerender':\n      case 'prerender-runtime': {\n        // If we've just created a cache result, and we're filling caches for a\n        // Cache Components prerender, then we don't want to propagate cache\n        // life & tags yet, in case the entry ends up being omitted from the\n        // final prerender due to short expire/stale times. If it is omitted,\n        // then it shouldn't have any effects on the prerender. We'll decide\n        // whether or not this cache should have its life & tags propagated when\n        // we read the entry in the final prerender from the resume data cache.\n\n        break\n      }\n      case 'request': {\n        if (\n          process.env.NODE_ENV === 'development' &&\n          outerWorkUnitStore.cacheSignal\n        ) {\n          // If we're filling caches for a dev request, apply the same logic as prerenders do above,\n          // and don't propagate cache life/tags yet.\n          break\n        }\n        // fallthrough\n      }\n\n      case 'private-cache':\n      case 'cache':\n      case 'unstable-cache':\n      case 'prerender-legacy':\n      case 'prerender-ppr': {\n        propagateCacheLifeAndTags(cacheContext, entry)\n        break\n      }\n      default: {\n        outerWorkUnitStore satisfies never\n      }\n    }\n\n    const cacheSignal = getCacheSignal(outerWorkUnitStore)\n    if (cacheSignal) {\n      cacheSignal.endRead()\n    }\n  }\n\n  return entry\n}\n\ntype GenerateCacheEntryResult =\n  | {\n      readonly type: 'cached'\n      readonly stream: ReadableStream\n      readonly pendingCacheEntry: Promise<CacheEntry>\n    }\n  | {\n      readonly type: 'prerender-dynamic'\n      readonly hangingPromise: Promise<never>\n    }\n\nasync function generateCacheEntryImpl(\n  workStore: WorkStore,\n  cacheContext: CacheContext,\n  innerCacheStore: UseCacheStore,\n  clientReferenceManifest: DeepReadonly<ClientReferenceManifest>,\n  encodedArguments: FormData | string,\n  fn: (...args: unknown[]) => Promise<unknown>,\n  timeoutError: UseCacheTimeoutError\n): Promise<GenerateCacheEntryResult> {\n  const temporaryReferences = createServerTemporaryReferenceSet()\n  const outerWorkUnitStore = cacheContext.outerWorkUnitStore\n\n  const [, , args] =\n    typeof encodedArguments === 'string'\n      ? await decodeReply<CacheKeyParts>(\n          encodedArguments,\n          getServerModuleMap(),\n          { temporaryReferences }\n        )\n      : await decodeReplyFromAsyncIterable<CacheKeyParts>(\n          {\n            async *[Symbol.asyncIterator]() {\n              for (const entry of encodedArguments) {\n                yield entry\n              }\n\n              if (outerWorkUnitStore) {\n                switch (outerWorkUnitStore.type) {\n                  case 'prerender-runtime':\n                  case 'prerender':\n                    // The encoded arguments might contain hanging promises. In\n                    // this case we don't want to reject with \"Error: Connection\n                    // closed.\", so we intentionally keep the iterable alive.\n                    // This is similar to the halting trick that we do while\n                    // rendering.\n                    await new Promise<void>((resolve) => {\n                      if (outerWorkUnitStore.renderSignal.aborted) {\n                        resolve()\n                      } else {\n                        outerWorkUnitStore.renderSignal.addEventListener(\n                          'abort',\n                          () => resolve(),\n                          { once: true }\n                        )\n                      }\n                    })\n                    break\n                  case 'prerender-ppr':\n                  case 'prerender-legacy':\n                  case 'request':\n                  case 'cache':\n                  case 'private-cache':\n                  case 'unstable-cache':\n                    break\n                  default:\n                    outerWorkUnitStore satisfies never\n                }\n              }\n            },\n          },\n          getServerModuleMap(),\n          { temporaryReferences }\n        )\n\n  // Track the timestamp when we started computing the result.\n  const startTime = performance.timeOrigin + performance.now()\n\n  // Invoke the inner function to load a new result. We delay the invocation\n  // though, until React awaits the promise so that React's request store (ALS)\n  // is available when the function is invoked. This allows us, for example, to\n  // capture logs so that we can later replay them.\n  const resultPromise = createLazyResult(fn.bind(null, ...args))\n\n  let errors: Array<unknown> = []\n\n  // In the \"Cache\" environment, we only need to make sure that the error\n  // digests are handled correctly. Error formatting and reporting is not\n  // necessary here; the errors are encoded in the stream, and will be reported\n  // in the \"Server\" environment.\n  const handleError = createReactServerErrorHandler(\n    workStore.dev,\n    workStore.isBuildTimePrerendering ?? false,\n    workStore.reactServerErrorsByDigest,\n    (error) => {\n      // In production, we log the original error here. It gets a digest that\n      // can be used to associate the error with the obfuscated error that might\n      // be logged if the error is caught. In development, we prefer logging the\n      // transported error in the server environment. It's not obfuscated and\n      // also includes the (dev-only) environment name.\n      if (process.env.NODE_ENV === 'production') {\n        Log.error(error)\n      }\n\n      errors.push(error)\n    }\n  )\n\n  let stream: ReadableStream<Uint8Array>\n\n  switch (outerWorkUnitStore?.type) {\n    case 'prerender-runtime':\n    case 'prerender':\n      const timeoutAbortController = new AbortController()\n\n      // If we're prerendering, we give you 50 seconds to fill a cache entry.\n      // Otherwise we assume you stalled on hanging input and de-opt. This needs\n      // to be lower than just the general timeout of 60 seconds.\n      const timer = setTimeout(() => {\n        workStore.invalidDynamicUsageError = timeoutError\n        timeoutAbortController.abort(timeoutError)\n      }, 50000)\n\n      const dynamicAccessAbortSignal =\n        dynamicAccessAsyncStorage.getStore()?.abortController.signal\n\n      const abortSignal = dynamicAccessAbortSignal\n        ? AbortSignal.any([\n            dynamicAccessAbortSignal,\n            outerWorkUnitStore.renderSignal,\n            timeoutAbortController.signal,\n          ])\n        : timeoutAbortController.signal\n\n      const { prelude } = await prerender(\n        resultPromise,\n        clientReferenceManifest.clientModules,\n        {\n          environmentName: 'Cache',\n          filterStackFrame,\n          signal: abortSignal,\n          temporaryReferences,\n          onError(error) {\n            if (abortSignal.aborted && abortSignal.reason === error) {\n              return undefined\n            }\n\n            return handleError(error)\n          },\n        }\n      )\n\n      clearTimeout(timer)\n\n      if (timeoutAbortController.signal.aborted) {\n        // When the timeout is reached we always error the stream. Even for\n        // fallback shell prerenders we don't want to return a hanging promise,\n        // which would allow the function to become a dynamic hole. Because that\n        // would mean that a non-empty shell could be generated which would be\n        // subject to revalidation, and we don't want to create long\n        // revalidation times.\n        stream = new ReadableStream({\n          start(controller) {\n            controller.error(timeoutAbortController.signal.reason)\n          },\n        })\n      } else if (dynamicAccessAbortSignal?.aborted) {\n        // If the prerender is aborted because of dynamic access (e.g. reading\n        // fallback params), we return a hanging promise. This essentially makes\n        // the \"use cache\" function dynamic.\n        const hangingPromise = makeHangingPromise<never>(\n          outerWorkUnitStore.renderSignal,\n          workStore.route,\n          'dynamic \"use cache\"'\n        )\n\n        if (outerWorkUnitStore.cacheSignal) {\n          outerWorkUnitStore.cacheSignal.endRead()\n        }\n\n        return { type: 'prerender-dynamic', hangingPromise }\n      } else {\n        stream = prelude\n      }\n      break\n    case 'request':\n      // If we're filling caches for a staged render, make sure that\n      // it takes at least a task, so we'll always notice a cache miss between stages.\n      //\n      // TODO(restart-on-cache-miss): This is suboptimal.\n      // Ideally we wouldn't need to restart for microtasky caches,\n      // but the current logic for omitting short-lived caches only works correctly\n      // if we do a second render, so that's the best we can do until we refactor that.\n      if (\n        process.env.NODE_ENV === 'development' &&\n        outerWorkUnitStore.cacheSignal\n      ) {\n        await new Promise((resolve) => setTimeout(resolve))\n      }\n    // fallthrough\n    case 'prerender-ppr':\n    case 'prerender-legacy':\n    case 'cache':\n    case 'private-cache':\n    case 'unstable-cache':\n    case undefined:\n      stream = renderToReadableStream(\n        resultPromise,\n        clientReferenceManifest.clientModules,\n        {\n          environmentName: 'Cache',\n          filterStackFrame,\n          temporaryReferences,\n          onError: handleError,\n        }\n      )\n      break\n    default:\n      return outerWorkUnitStore satisfies never\n  }\n\n  const [returnStream, savedStream] = stream.tee()\n\n  const pendingCacheEntry = collectResult(\n    savedStream,\n    workStore,\n    cacheContext,\n    innerCacheStore,\n    startTime,\n    errors\n  )\n\n  if (process.env.NODE_ENV === 'development') {\n    // Name the stream for React DevTools.\n    // @ts-expect-error\n    returnStream.name = 'use cache'\n  }\n\n  return {\n    type: 'cached',\n    // Return the stream as we're creating it. This means that if it ends up\n    // erroring we cannot return a stale-if-error version but it allows\n    // streaming back the result earlier.\n    stream: returnStream,\n    pendingCacheEntry,\n  }\n}\n\nfunction cloneCacheEntry(entry: CacheEntry): [CacheEntry, CacheEntry] {\n  const [streamA, streamB] = entry.value.tee()\n  entry.value = streamA\n  const clonedEntry: CacheEntry = {\n    value: streamB,\n    timestamp: entry.timestamp,\n    revalidate: entry.revalidate,\n    expire: entry.expire,\n    stale: entry.stale,\n    tags: entry.tags,\n  }\n  return [entry, clonedEntry]\n}\n\nasync function clonePendingCacheEntry(\n  pendingCacheEntry: Promise<CacheEntry>\n): Promise<[CacheEntry, CacheEntry]> {\n  const entry = await pendingCacheEntry\n  return cloneCacheEntry(entry)\n}\n\nasync function getNthCacheEntry(\n  split: Promise<[CacheEntry, CacheEntry]>,\n  i: number\n): Promise<CacheEntry> {\n  return (await split)[i]\n}\n\nasync function encodeFormData(formData: FormData): Promise<string> {\n  let result = ''\n  for (let [key, value] of formData) {\n    // We don't need this key to be serializable but from a security perspective it should not be\n    // possible to generate a string that looks the same from a different structure. To ensure this\n    // we need a delimeter between fields but just using a delimeter is not enough since a string\n    // might contain that delimeter. We use the length of each field as the delimeter to avoid\n    // escaping the values.\n    result += key.length.toString(16) + ':' + key\n    let stringValue\n    if (typeof value === 'string') {\n      stringValue = value\n    } else {\n      // The FormData might contain binary data that is not valid UTF-8 so this cache\n      // key may generate a UCS-2 string. Passing this to another service needs to be\n      // aware that the key might not be compatible.\n      const arrayBuffer = await value.arrayBuffer()\n      if (arrayBuffer.byteLength % 2 === 0) {\n        stringValue = String.fromCodePoint(...new Uint16Array(arrayBuffer))\n      } else {\n        stringValue =\n          String.fromCodePoint(\n            ...new Uint16Array(arrayBuffer, 0, (arrayBuffer.byteLength - 1) / 2)\n          ) +\n          String.fromCodePoint(\n            new Uint8Array(arrayBuffer, arrayBuffer.byteLength - 1, 1)[0]\n          )\n      }\n    }\n    result += stringValue.length.toString(16) + ':' + stringValue\n  }\n  return result\n}\n\nfunction createTrackedReadableStream(\n  stream: ReadableStream,\n  cacheSignal: CacheSignal\n) {\n  const reader = stream.getReader()\n  return new ReadableStream({\n    async pull(controller) {\n      const { done, value } = await reader.read()\n      if (done) {\n        controller.close()\n        cacheSignal.endRead()\n      } else {\n        controller.enqueue(value)\n      }\n    },\n  })\n}\n\nexport async function cache(\n  kind: string,\n  id: string,\n  boundArgsLength: number,\n  originalFn: (...args: unknown[]) => Promise<unknown>,\n  argsObj: IArguments\n) {\n  let args = Array.prototype.slice.call(argsObj)\n\n  const isPrivate = kind === 'private'\n\n  // Private caches are currently only stored in the Resume Data Cache (RDC),\n  // and not in cache handlers.\n  const cacheHandler = isPrivate ? undefined : getCacheHandler(kind)\n\n  if (!isPrivate && !cacheHandler) {\n    throw new Error('Unknown cache handler: ' + kind)\n  }\n\n  const timeoutError = new UseCacheTimeoutError()\n  Error.captureStackTrace(timeoutError, cache)\n\n  const wrapAsInvalidDynamicUsageError = (\n    error: Error,\n    workStore: WorkStore\n  ) => {\n    Error.captureStackTrace(error, cache)\n    workStore.invalidDynamicUsageError ??= error\n\n    return error\n  }\n\n  const workStore = workAsyncStorage.getStore()\n  if (workStore === undefined) {\n    throw new Error(\n      '\"use cache\" cannot be used outside of App Router. Expected a WorkStore.'\n    )\n  }\n\n  const workUnitStore = workUnitAsyncStorage.getStore()\n  const name = originalFn.name\n  let fn = originalFn\n  let cacheContext: CacheContext\n\n  if (isPrivate) {\n    const expression = '\"use cache: private\"'\n\n    switch (workUnitStore?.type) {\n      // \"use cache: private\" is dynamic in prerendering contexts.\n      case 'prerender':\n        return makeHangingPromise(\n          workUnitStore.renderSignal,\n          workStore.route,\n          expression\n        )\n      case 'prerender-ppr':\n        return postponeWithTracking(\n          workStore.route,\n          expression,\n          workUnitStore.dynamicTracking\n        )\n      case 'prerender-legacy':\n        return throwToInterruptStaticGeneration(\n          expression,\n          workStore,\n          workUnitStore\n        )\n      case 'prerender-client':\n        throw new InvariantError(\n          `${expression} must not be used within a client component. Next.js should be preventing ${expression} from being allowed in client components statically, but did not in this case.`\n        )\n      case 'unstable-cache': {\n        throw wrapAsInvalidDynamicUsageError(\n          new Error(\n            // TODO: Add a link to an error documentation page when we have one.\n            `${expression} must not be used within \\`unstable_cache()\\`.`\n          ),\n          workStore\n        )\n      }\n      case 'cache': {\n        throw wrapAsInvalidDynamicUsageError(\n          new Error(\n            // TODO: Add a link to an error documentation page when we have one.\n            `${expression} must not be used within \"use cache\". It can only be nested inside of another ${expression}.`\n          ),\n          workStore\n        )\n      }\n      case 'request':\n      case 'prerender-runtime':\n      case 'private-cache':\n        cacheContext = {\n          kind: 'private',\n          outerWorkUnitStore: workUnitStore,\n        }\n        break\n      case undefined:\n        throw wrapAsInvalidDynamicUsageError(\n          new Error(\n            // TODO: Add a link to an error documentation page when we have one.\n            `${expression} cannot be used outside of a request context.`\n          ),\n          workStore\n        )\n      default:\n        workUnitStore satisfies never\n        // This is dead code, but without throwing an error here, TypeScript\n        // will assume that cacheContext is used before being assigned.\n        throw new InvariantError(`Unexpected work unit store.`)\n    }\n  } else {\n    switch (workUnitStore?.type) {\n      case 'prerender-client':\n        const expression = '\"use cache\"'\n        throw new InvariantError(\n          `${expression} must not be used within a client component. Next.js should be preventing ${expression} from being allowed in client components statically, but did not in this case.`\n        )\n      case 'prerender':\n      case 'prerender-runtime':\n      case 'prerender-ppr':\n      case 'prerender-legacy':\n      case 'request':\n      case 'cache':\n      case 'private-cache':\n      // TODO: We should probably forbid nesting \"use cache\" inside\n      // unstable_cache. (fallthrough)\n      case 'unstable-cache':\n      case undefined:\n        cacheContext = {\n          kind: 'public',\n          outerWorkUnitStore: workUnitStore,\n        }\n        break\n      default:\n        workUnitStore satisfies never\n        // This is dead code, but without throwing an error here, TypeScript\n        // will assume that cacheContext is used before being assigned.\n        throw new InvariantError(`Unexpected work unit store.`)\n    }\n  }\n\n  // Get the clientReferenceManifest while we're still in the outer Context.\n  // In case getClientReferenceManifestSingleton is implemented using AsyncLocalStorage.\n  const clientReferenceManifest = getClientReferenceManifest()\n\n  // Because the Action ID is not yet unique per implementation of that Action we can't\n  // safely reuse the results across builds yet. In the meantime we add the buildId to the\n  // arguments as a seed to ensure they're not reused. Remove this once Action IDs hash\n  // the implementation.\n  const buildId = workStore.buildId\n\n  // In dev mode, when the HMR refresh hash is set, we include it in the\n  // cache key. This ensures that cache entries are not reused when server\n  // components have been edited. This is a very coarse approach. But it's\n  // also only a temporary solution until Action IDs are unique per\n  // implementation. Remove this once Action IDs hash the implementation.\n  const hmrRefreshHash =\n    workUnitStore && getHmrRefreshHash(workStore, workUnitStore)\n\n  const hangingInputAbortSignal = workUnitStore\n    ? createHangingInputAbortSignal(workUnitStore)\n    : undefined\n\n  if (cacheContext.kind === 'private') {\n    const { outerWorkUnitStore } = cacheContext\n    switch (outerWorkUnitStore.type) {\n      case 'prerender-runtime': {\n        // In a runtime prerender, we have to make sure that APIs that would hang during a static prerender\n        // are resolved with a delay, in the runtime stage. Private caches are one of these.\n        if (outerWorkUnitStore.runtimeStagePromise) {\n          await outerWorkUnitStore.runtimeStagePromise\n        }\n        break\n      }\n      case 'request': {\n        if (process.env.NODE_ENV === 'development') {\n          // Similar to runtime prerenders, private caches should not resolve in the static stage\n          // of a dev request, so we delay them.\n          await makeDevtoolsIOAwarePromise(\n            undefined,\n            outerWorkUnitStore,\n            RenderStage.Runtime\n          )\n        }\n        break\n      }\n      case 'private-cache':\n        break\n      default: {\n        outerWorkUnitStore satisfies never\n      }\n    }\n  }\n\n  let isPageOrLayoutSegmentFunction = false\n\n  // For page and layout segment functions (i.e. the page/layout component,\n  // or generateMetadata/generateViewport), the cache function is\n  // overwritten, which allows us to apply special handling for params and\n  // searchParams. For pages and layouts we're using the outer params prop,\n  // and not the inner one that was serialized/deserialized. While it's not\n  // generally true for \"use cache\" args, in the case of `params` the inner\n  // and outer object are essentially equivalent, so this is safe to do\n  // (including fallback params that are hanging promises). It allows us to\n  // avoid waiting for the timeout, when prerendering a fallback shell of a\n  // cached page or layout that awaits params.\n  if (isPageSegmentFunction(args)) {\n    isPageOrLayoutSegmentFunction = true\n\n    const [\n      { params: outerParams, searchParams: outerSearchParams },\n      ...otherOuterArgs\n    ] = args\n\n    const props: UseCachePageInnerProps = {\n      params: outerParams,\n      // Omit searchParams and $$isPage.\n    }\n\n    if (isPrivate) {\n      // Private caches allow accessing search params. We need to include\n      // them in the serialized args and when generating the cache key.\n      props.searchParams = outerSearchParams\n    }\n\n    args = [props, ...otherOuterArgs]\n\n    fn = {\n      [name]: async (\n        {\n          params: _innerParams,\n          searchParams: innerSearchParams,\n        }: UseCachePageInnerProps,\n        ...otherInnerArgs: unknown[]\n      ) =>\n        originalFn.apply(null, [\n          {\n            params: outerParams,\n            searchParams:\n              innerSearchParams ??\n              // For public caches, search params are omitted from the cache\n              // key (and the serialized args) to avoid mismatches between\n              // prerendering and resuming a cached page that does not\n              // access search params. This is also the reason why we're not\n              // using a hanging promise for search params. For cached pages\n              // that do access them, which is an invalid dynamic usage, we\n              // need to ensure that an error is shown.\n              makeErroringSearchParamsForUseCache(workStore),\n          },\n          ...otherInnerArgs,\n        ]),\n    }[name] as (...args: unknown[]) => Promise<unknown>\n  } else if (isLayoutSegmentFunction(args)) {\n    isPageOrLayoutSegmentFunction = true\n\n    const [\n      { params: outerParams, $$isLayout, ...outerSlots },\n      ...otherOuterArgs\n    ] = args\n\n    // Overwrite the props to omit $$isLayout. Note that slots are only\n    // passed to the layout component (if any are defined), and not to\n    // generateMetadata nor generateViewport. For those functions,\n    // outerSlots/innerSlots is an empty object, which is fine because we're\n    // just spreading it into the props.\n    args = [{ params: outerParams, ...outerSlots }, ...otherOuterArgs]\n\n    fn = {\n      [name]: async (\n        {\n          params: _innerParams,\n          ...innerSlots\n        }: Omit<UseCacheLayoutProps, '$$isLayout'>,\n        ...otherInnerArgs: unknown[]\n      ) =>\n        originalFn.apply(null, [\n          { params: outerParams, ...innerSlots },\n          ...otherInnerArgs,\n        ]),\n    }[name] as (...args: unknown[]) => Promise<unknown>\n  }\n\n  if (boundArgsLength > 0) {\n    if (args.length === 0) {\n      throw new InvariantError(\n        `Expected the \"use cache\" function ${JSON.stringify(fn.name)} to receive its encrypted bound arguments as the first argument.`\n      )\n    }\n\n    const encryptedBoundArgs = args.shift()\n    const boundArgs = await decryptActionBoundArgs(id, encryptedBoundArgs)\n\n    if (!Array.isArray(boundArgs)) {\n      throw new InvariantError(\n        `Expected the bound arguments of \"use cache\" function ${JSON.stringify(fn.name)} to deserialize into an array, got ${typeof boundArgs} instead.`\n      )\n    }\n\n    if (boundArgsLength !== boundArgs.length) {\n      throw new InvariantError(\n        `Expected the \"use cache\" function ${JSON.stringify(fn.name)} to receive ${boundArgsLength} bound arguments, got ${boundArgs.length} instead.`\n      )\n    }\n\n    args.unshift(boundArgs)\n  }\n\n  const temporaryReferences = createClientTemporaryReferenceSet()\n\n  // For private caches, which are allowed to read cookies, we still don't\n  // need to include the cookies in the cache key. This is because we don't\n  // store the cache entries in a cache handler, but only in the Resume Data\n  // Cache (RDC). Private caches are only used during dynamic requests and\n  // runtime prefetches. For dynamic requests, the RDC is immutable, so it\n  // does not include any private caches. For runtime prefetches, the RDC is\n  // mutable, but only lives as long as the request, so the key does not\n  // need to include cookies.\n  const cacheKeyParts: CacheKeyParts = hmrRefreshHash\n    ? [buildId, id, args, hmrRefreshHash]\n    : [buildId, id, args]\n\n  const encodeCacheKeyParts = () =>\n    encodeReply(cacheKeyParts, {\n      temporaryReferences,\n      signal: hangingInputAbortSignal,\n    })\n\n  let encodedCacheKeyParts: FormData | string\n\n  switch (workUnitStore?.type) {\n    case 'prerender-runtime':\n    // We're currently only using `dynamicAccessAsyncStorage` for params,\n    // which are always available in a runtime prerender, so they will never hang,\n    // effectively making the tracking below a no-op.\n    // However, a runtime prerender shares a lot of the semantics with a static prerender,\n    // and might need to follow this codepath in the future\n    // if we start using `dynamicAccessAsyncStorage` for other APIs.\n    //\n    // fallthrough\n    case 'prerender':\n      if (!isPageOrLayoutSegmentFunction) {\n        // If the \"use cache\" function is not a page or layout segment\n        // function, we need to track dynamic access already when encoding\n        // the arguments. If params are passed explicitly into a \"use cache\"\n        // function (as opposed to receiving them automatically in a page or\n        // layout), we assume that the params are also accessed. This allows\n        // us to abort early, and treat the function as dynamic, instead of\n        // waiting for the timeout to be reached.\n        const dynamicAccessAbortController = new AbortController()\n\n        encodedCacheKeyParts = await dynamicAccessAsyncStorage.run(\n          { abortController: dynamicAccessAbortController },\n          encodeCacheKeyParts\n        )\n\n        if (dynamicAccessAbortController.signal.aborted) {\n          return makeHangingPromise(\n            workUnitStore.renderSignal,\n            workStore.route,\n            'dynamic \"use cache\"'\n          )\n        }\n        break\n      }\n    // fallthrough\n    case 'prerender-ppr':\n    case 'prerender-legacy':\n    case 'request':\n    // TODO(restart-on-cache-miss): We need to handle params/searchParams on page components.\n    // the promises will be tasky, so `encodeCacheKeyParts` will not resolve in the static stage.\n    // We have not started a cache read at this point, so we might just miss the cache completely.\n    // fallthrough\n    case 'cache':\n    case 'private-cache':\n    case 'unstable-cache':\n    case undefined:\n      encodedCacheKeyParts = await encodeCacheKeyParts()\n      break\n    default:\n      return workUnitStore satisfies never\n  }\n\n  const serializedCacheKey =\n    typeof encodedCacheKeyParts === 'string'\n      ? // Fast path for the simple case for simple inputs. We let the CacheHandler\n        // Convert it to an ArrayBuffer if it wants to.\n        encodedCacheKeyParts\n      : await encodeFormData(encodedCacheKeyParts)\n\n  let stream: undefined | ReadableStream = undefined\n\n  // Get an immutable and mutable versions of the resume data cache.\n  const prerenderResumeDataCache = workUnitStore\n    ? getPrerenderResumeDataCache(workUnitStore)\n    : null\n  const renderResumeDataCache = workUnitStore\n    ? getRenderResumeDataCache(workUnitStore)\n    : null\n\n  if (renderResumeDataCache) {\n    const cacheSignal = workUnitStore ? getCacheSignal(workUnitStore) : null\n\n    if (cacheSignal) {\n      cacheSignal.beginRead()\n    }\n    const cachedEntry = renderResumeDataCache.cache.get(serializedCacheKey)\n    if (cachedEntry !== undefined) {\n      const existingEntry = await cachedEntry\n      if (workUnitStore !== undefined && existingEntry !== undefined) {\n        if (\n          existingEntry.revalidate === 0 ||\n          existingEntry.expire < DYNAMIC_EXPIRE\n        ) {\n          switch (workUnitStore.type) {\n            case 'prerender':\n              // In a Dynamic I/O prerender, if the cache entry has\n              // revalidate: 0 or if the expire time is under 5 minutes,\n              // then we consider this cache entry dynamic as it's not worth\n              // generating static pages for such data. It's better to leave\n              // a dynamic hole that can be filled in during the resume with\n              // a potentially cached entry.\n              if (cacheSignal) {\n                cacheSignal.endRead()\n              }\n              return makeHangingPromise(\n                workUnitStore.renderSignal,\n                workStore.route,\n                'dynamic \"use cache\"'\n              )\n            case 'prerender-runtime': {\n              // In the final phase of a runtime prerender, we have to make\n              // sure that APIs that would hang during a static prerender\n              // are resolved with a delay, in the runtime stage.\n              if (workUnitStore.runtimeStagePromise) {\n                await workUnitStore.runtimeStagePromise\n              }\n              break\n            }\n            case 'request': {\n              if (process.env.NODE_ENV === 'development') {\n                // We delay the cache here so that it doesn't resolve in the static task --\n                // in a regular static prerender, it'd be a hanging promise, and we need to reflect that,\n                // so it has to resolve later.\n                // TODO(restart-on-cache-miss): Optimize this to avoid unnecessary restarts.\n                // We don't end the cache read here, so this will always appear as a cache miss in the static stage,\n                // and thus will cause a restart even if all caches are filled.\n                await makeDevtoolsIOAwarePromise(\n                  undefined,\n                  workUnitStore,\n                  RenderStage.Runtime\n                )\n              }\n              break\n            }\n            case 'prerender-ppr':\n            case 'prerender-legacy':\n            case 'cache':\n            case 'private-cache':\n            case 'unstable-cache':\n              break\n            default:\n              workUnitStore satisfies never\n          }\n        }\n\n        if (existingEntry.stale < RUNTIME_PREFETCH_DYNAMIC_STALE) {\n          switch (workUnitStore.type) {\n            case 'prerender-runtime':\n              // In a runtime prerender, if the cache entry will become\n              // stale in less then 30 seconds, we consider this cache entry\n              // dynamic as it's not worth prefetching. It's better to leave\n              // a dynamic hole that can be filled during the navigation.\n              if (cacheSignal) {\n                cacheSignal.endRead()\n              }\n              return makeHangingPromise(\n                workUnitStore.renderSignal,\n                workStore.route,\n                'dynamic \"use cache\"'\n              )\n            case 'request': {\n              if (process.env.NODE_ENV === 'development') {\n                // We delay the cache here so that it doesn't resolve in the runtime phase --\n                // in a regular runtime prerender, it'd be a hanging promise, and we need to reflect that,\n                // so it has to resolve later.\n                // TODO(restart-on-cache-miss): Optimize this to avoid unnecessary restarts.\n                // We don't end the cache read here, so this will always appear as a cache miss in the runtime stage,\n                // and thus will cause a restart even if all caches are filled.\n                await makeDevtoolsIOAwarePromise(\n                  undefined,\n                  workUnitStore,\n                  RenderStage.Dynamic\n                )\n              }\n              break\n            }\n            case 'prerender':\n            case 'prerender-ppr':\n            case 'prerender-legacy':\n            case 'cache':\n            case 'private-cache':\n            case 'unstable-cache':\n              break\n            default:\n              workUnitStore satisfies never\n          }\n        }\n      }\n\n      // We want to make sure we only propagate cache life & tags if the\n      // entry was *not* omitted from the prerender. So we only do this\n      // after the above early returns.\n      propagateCacheLifeAndTags(cacheContext, existingEntry)\n\n      const [streamA, streamB] = existingEntry.value.tee()\n      existingEntry.value = streamB\n\n      if (cacheSignal) {\n        // When we have a cacheSignal we need to block on reading the cache\n        // entry before ending the read.\n        stream = createTrackedReadableStream(streamA, cacheSignal)\n      } else {\n        stream = streamA\n      }\n    } else {\n      if (cacheSignal) {\n        cacheSignal.endRead()\n      }\n\n      if (workUnitStore) {\n        switch (workUnitStore.type) {\n          case 'prerender':\n            // If `allowEmptyStaticShell` is true, and thus a prefilled\n            // resume data cache was provided, then a cache miss means that\n            // params were part of the cache key. In this case, we can make\n            // this cache function a dynamic hole in the shell (or produce\n            // an empty shell if there's no parent suspense boundary).\n            // Currently, this also includes layouts and pages that don't\n            // read params, which will be improved when we implement\n            // NAR-136. Otherwise, we assume that if params are passed\n            // explicitly into a \"use cache\" function, that the params are\n            // also accessed. This allows us to abort early, and treat the\n            // function as dynamic, instead of waiting for the timeout to be\n            // reached. Compared to the instrumentation-based params bailout\n            // we do here, this also covers the case where params are\n            // transformed with an async function, before being passed into\n            // the \"use cache\" function, which escapes the instrumentation.\n            if (workUnitStore.allowEmptyStaticShell) {\n              return makeHangingPromise(\n                workUnitStore.renderSignal,\n                workStore.route,\n                'dynamic \"use cache\"'\n              )\n            }\n            break\n          case 'prerender-runtime':\n          case 'prerender-ppr':\n          case 'prerender-legacy':\n          case 'request':\n          case 'cache':\n          case 'private-cache':\n          case 'unstable-cache':\n            break\n          default:\n            workUnitStore satisfies never\n        }\n      }\n    }\n  }\n\n  if (stream === undefined) {\n    const cacheSignal = workUnitStore ? getCacheSignal(workUnitStore) : null\n    if (cacheSignal) {\n      // Either the cache handler or the generation can be using I/O at this point.\n      // We need to track when they start and when they complete.\n      cacheSignal.beginRead()\n    }\n\n    const lazyRefreshTags = workStore.refreshTagsByCacheKind.get(kind)\n\n    if (lazyRefreshTags && !isResolvedLazyResult(lazyRefreshTags)) {\n      await lazyRefreshTags\n    }\n\n    let entry: CacheEntry | undefined\n\n    // We ignore existing cache entries when force revalidating.\n    if (cacheHandler && !shouldForceRevalidate(workStore, workUnitStore)) {\n      entry = await cacheHandler.get(\n        serializedCacheKey,\n        workUnitStore?.implicitTags?.tags ?? []\n      )\n    }\n\n    if (entry) {\n      const implicitTags = workUnitStore?.implicitTags?.tags ?? []\n      let implicitTagsExpiration = 0\n\n      if (workUnitStore?.implicitTags) {\n        const lazyExpiration =\n          workUnitStore.implicitTags.expirationsByCacheKind.get(kind)\n\n        if (lazyExpiration) {\n          const expiration = isResolvedLazyResult(lazyExpiration)\n            ? lazyExpiration.value\n            : await lazyExpiration\n\n          // If a cache handler returns an expiration time of Infinity, it\n          // signals to Next.js that it handles checking cache entries for\n          // staleness based on the expiration of the implicit tags passed\n          // into the `get` method. In this case, we keep the default of 0,\n          // which means that the implicit tags are not considered expired.\n          if (expiration < Infinity) {\n            implicitTagsExpiration = expiration\n          }\n        }\n      }\n\n      if (\n        shouldDiscardCacheEntry(\n          entry,\n          workStore,\n          workUnitStore,\n          implicitTags,\n          implicitTagsExpiration\n        )\n      ) {\n        debug?.('discarding expired entry', serializedCacheKey)\n        entry = undefined\n      }\n    }\n\n    const currentTime = performance.timeOrigin + performance.now()\n    if (\n      workUnitStore !== undefined &&\n      entry !== undefined &&\n      (entry.revalidate === 0 || entry.expire < DYNAMIC_EXPIRE)\n    ) {\n      switch (workUnitStore.type) {\n        case 'prerender':\n          // In a Dynamic I/O prerender, if the cache entry has revalidate:\n          // 0 or if the expire time is under 5 minutes, then we consider\n          // this cache entry dynamic as it's not worth generating static\n          // pages for such data. It's better to leave a dynamic hole that\n          // can be filled in during the resume with a potentially cached\n          // entry.\n          if (cacheSignal) {\n            cacheSignal.endRead()\n          }\n          return makeHangingPromise(\n            workUnitStore.renderSignal,\n            workStore.route,\n            'dynamic \"use cache\"'\n          )\n        case 'request': {\n          if (process.env.NODE_ENV === 'development') {\n            // We delay the cache here so that it doesn't resolve in the static task --\n            // in a regular static prerender, it'd be a hanging promise, and we need to reflect that,\n            // so it has to resolve later.\n            // TODO(restart-on-cache-miss): Optimize this to avoid unnecessary restarts.\n            // We don't end the cache read here, so this will always appear as a cache miss in the static stage,\n            // and thus will cause a restart even if all caches are filled.\n            await makeDevtoolsIOAwarePromise(\n              undefined,\n              workUnitStore,\n              RenderStage.Runtime\n            )\n          }\n          break\n        }\n        case 'prerender-runtime':\n        case 'prerender-ppr':\n        case 'prerender-legacy':\n        case 'cache':\n        case 'private-cache':\n        case 'unstable-cache':\n          break\n        default:\n          workUnitStore satisfies never\n      }\n    }\n\n    if (\n      entry === undefined ||\n      currentTime > entry.timestamp + entry.expire * 1000 ||\n      (workStore.isStaticGeneration &&\n        currentTime > entry.timestamp + entry.revalidate * 1000)\n    ) {\n      // Miss. Generate a new result.\n\n      // If the cache entry is stale and we're prerendering, we don't want to use the\n      // stale entry since it would unnecessarily need to shorten the lifetime of the\n      // prerender. We're not time constrained here so we can re-generated it now.\n\n      // We need to run this inside a clean AsyncLocalStorage snapshot so that the cache\n      // generation cannot read anything from the context we're currently executing which\n      // might include request specific things like cookies() inside a React.cache().\n      // Note: It is important that we await at least once before this because it lets us\n      // pop out of any stack specific contexts as well - aka \"Sync\" Local Storage.\n\n      if (entry) {\n        if (currentTime > entry.timestamp + entry.expire * 1000) {\n          debug?.('entry is expired', serializedCacheKey)\n        }\n\n        if (\n          workStore.isStaticGeneration &&\n          currentTime > entry.timestamp + entry.revalidate * 1000\n        ) {\n          debug?.('static generation, entry is stale', serializedCacheKey)\n        }\n      }\n\n      const result = await generateCacheEntry(\n        workStore,\n        cacheContext,\n        clientReferenceManifest,\n        encodedCacheKeyParts,\n        fn,\n        timeoutError\n      )\n\n      if (result.type === 'prerender-dynamic') {\n        return result.hangingPromise\n      }\n\n      const { stream: newStream, pendingCacheEntry } = result\n\n      // When draft mode is enabled, we must not save the cache entry.\n      if (!workStore.isDraftMode) {\n        let savedCacheEntry\n\n        if (prerenderResumeDataCache) {\n          // Create a clone that goes into the cache scope memory cache.\n          const split = clonePendingCacheEntry(pendingCacheEntry)\n          savedCacheEntry = getNthCacheEntry(split, 0)\n          prerenderResumeDataCache.cache.set(\n            serializedCacheKey,\n            getNthCacheEntry(split, 1)\n          )\n        } else {\n          savedCacheEntry = pendingCacheEntry\n        }\n\n        if (cacheHandler) {\n          const promise = cacheHandler.set(serializedCacheKey, savedCacheEntry)\n\n          workStore.pendingRevalidateWrites ??= []\n          workStore.pendingRevalidateWrites.push(promise)\n        }\n      }\n\n      stream = newStream\n    } else {\n      // If we have an entry at this point, this can't be a private cache\n      // entry.\n      if (cacheContext.kind === 'private') {\n        throw new InvariantError(\n          `A private cache entry must not be retrieved from the cache handler.`\n        )\n      }\n\n      propagateCacheLifeAndTags(cacheContext, entry)\n\n      // We want to return this stream, even if it's stale.\n      stream = entry.value\n\n      // If we have a cache scope, we need to clone the entry and set it on\n      // the inner cache scope.\n      if (prerenderResumeDataCache) {\n        const [entryLeft, entryRight] = cloneCacheEntry(entry)\n        if (cacheSignal) {\n          stream = createTrackedReadableStream(entryLeft.value, cacheSignal)\n        } else {\n          stream = entryLeft.value\n        }\n\n        prerenderResumeDataCache.cache.set(\n          serializedCacheKey,\n          Promise.resolve(entryRight)\n        )\n      } else {\n        // If we're not regenerating we need to signal that we've finished\n        // putting the entry into the cache scope at this point. Otherwise we do\n        // that inside generateCacheEntry.\n        cacheSignal?.endRead()\n      }\n\n      if (currentTime > entry.timestamp + entry.revalidate * 1000) {\n        // If this is stale, and we're not in a prerender (i.e. this is\n        // dynamic render), then we should warm up the cache with a fresh\n        // revalidated entry.\n        const result = await generateCacheEntry(\n          workStore,\n          // This is not running within the context of this unit.\n          { kind: cacheContext.kind, outerWorkUnitStore: undefined },\n          clientReferenceManifest,\n          encodedCacheKeyParts,\n          fn,\n          timeoutError\n        )\n\n        if (result.type === 'cached') {\n          const { stream: ignoredStream, pendingCacheEntry } = result\n          let savedCacheEntry: Promise<CacheEntry>\n\n          if (prerenderResumeDataCache) {\n            const split = clonePendingCacheEntry(pendingCacheEntry)\n            savedCacheEntry = getNthCacheEntry(split, 0)\n            prerenderResumeDataCache.cache.set(\n              serializedCacheKey,\n              getNthCacheEntry(split, 1)\n            )\n          } else {\n            savedCacheEntry = pendingCacheEntry\n          }\n\n          if (cacheHandler) {\n            const promise = cacheHandler.set(\n              serializedCacheKey,\n              savedCacheEntry\n            )\n\n            workStore.pendingRevalidateWrites ??= []\n            workStore.pendingRevalidateWrites.push(promise)\n          }\n\n          await ignoredStream.cancel()\n        }\n      }\n    }\n  }\n\n  // Logs are replayed even if it's a hit - to ensure we see them on the client eventually.\n  // If we didn't then the client wouldn't see the logs if it was seeded from a prewarm that\n  // never made it to the client. However, this also means that you see logs even when the\n  // cached function isn't actually re-executed. We should instead ensure prewarms always\n  // make it to the client. Another issue is that this will cause double logging in the\n  // server terminal. Once while generating the cache entry and once when replaying it on\n  // the server, which is required to pick it up for replaying again on the client.\n  const replayConsoleLogs = true\n\n  const serverConsumerManifest = {\n    // moduleLoading must be null because we don't want to trigger preloads of ClientReferences\n    // to be added to the consumer. Instead, we'll wait for any ClientReference to be emitted\n    // which themselves will handle the preloading.\n    moduleLoading: null,\n    moduleMap: isEdgeRuntime\n      ? clientReferenceManifest.edgeRscModuleMapping\n      : clientReferenceManifest.rscModuleMapping,\n    serverModuleMap: getServerModuleMap(),\n  }\n\n  return createFromReadableStream(stream, {\n    findSourceMapURL,\n    serverConsumerManifest,\n    temporaryReferences,\n    replayConsoleLogs,\n    environmentName: 'Cache',\n  })\n}\n\n/**\n * Returns `true` if the `'use cache'` function is the page component itself,\n * or `generateMetadata`/`generateViewport` in a page file.\n */\nfunction isPageSegmentFunction(\n  args: any[]\n): args is [UseCachePageProps, ...unknown[]] {\n  const [maybeProps] = args\n\n  return (\n    maybeProps !== null &&\n    typeof maybeProps === 'object' &&\n    (maybeProps as UseCachePageProps).$$isPage === true\n  )\n}\n\n/**\n * Returns `true` if the `'use cache'` function is the layout component itself,\n * or `generateMetadata`/`generateViewport` in a layout file.\n */\nfunction isLayoutSegmentFunction(\n  args: any[]\n): args is [UseCacheLayoutProps, ...unknown[]] {\n  const [maybeProps] = args\n\n  return (\n    maybeProps !== null &&\n    typeof maybeProps === 'object' &&\n    (maybeProps as UseCacheLayoutProps).$$isLayout === true\n  )\n}\n\nfunction shouldForceRevalidate(\n  workStore: WorkStore,\n  workUnitStore: WorkUnitStore | undefined\n): boolean {\n  if (workStore.isOnDemandRevalidate || workStore.isDraftMode) {\n    return true\n  }\n\n  if (workStore.dev && workUnitStore) {\n    switch (workUnitStore.type) {\n      case 'request':\n        return workUnitStore.headers.get('cache-control') === 'no-cache'\n      case 'cache':\n      case 'private-cache':\n        return workUnitStore.forceRevalidate\n      case 'prerender-runtime':\n      case 'prerender':\n      case 'prerender-client':\n      case 'prerender-ppr':\n      case 'prerender-legacy':\n      case 'unstable-cache':\n        break\n      default:\n        workUnitStore satisfies never\n    }\n  }\n\n  return false\n}\n\nfunction shouldDiscardCacheEntry(\n  entry: CacheEntry,\n  workStore: WorkStore,\n  workUnitStore: WorkUnitStore | undefined,\n  implicitTags: string[],\n  implicitTagsExpiration: number\n): boolean {\n  // If the cache entry was created before any of the implicit tags were\n  // revalidated last, we need to discard it.\n  if (entry.timestamp <= implicitTagsExpiration) {\n    debug?.(\n      'entry was created at',\n      entry.timestamp,\n      'before implicit tags were revalidated at',\n      implicitTagsExpiration\n    )\n\n    return true\n  }\n\n  // During prerendering, we ignore recently revalidated tags. In dev mode, we\n  // can assume that the dynamic dev rendering will have discarded and recreated\n  // the affected cache entries, and we don't want to discard those again during\n  // the prerender validation. During build-time prerendering, there will never\n  // be any pending revalidated tags.\n  if (workUnitStore) {\n    switch (workUnitStore.type) {\n      case 'prerender':\n        return false\n      case 'prerender-runtime':\n      case 'prerender-client':\n      case 'prerender-ppr':\n      case 'prerender-legacy':\n      case 'request':\n      case 'cache':\n      case 'private-cache':\n      case 'unstable-cache':\n        break\n      default:\n        workUnitStore satisfies never\n    }\n  }\n\n  // If the cache entry contains revalidated tags that the cache handler might\n  // not know about yet, we need to discard it.\n  if (entry.tags.some((tag) => isRecentlyRevalidatedTag(tag, workStore))) {\n    return true\n  }\n\n  // Finally, if any of the implicit tags have been revalidated recently, we\n  // also need to discard the cache entry.\n  if (implicitTags.some((tag) => isRecentlyRevalidatedTag(tag, workStore))) {\n    return true\n  }\n\n  return false\n}\n\nfunction isRecentlyRevalidatedTag(tag: string, workStore: WorkStore): boolean {\n  const { previouslyRevalidatedTags, pendingRevalidatedTags } = workStore\n\n  // Was the tag previously revalidated (e.g. by a redirecting server action)?\n  if (previouslyRevalidatedTags.includes(tag)) {\n    debug?.('tag', tag, 'was previously revalidated')\n\n    return true\n  }\n\n  // It could also have been revalidated by the currently running server action.\n  // In this case the revalidation might not have been fully propagated by a\n  // remote cache handler yet, so we read it from the pending tags in the work\n  // store.\n  if (pendingRevalidatedTags?.some((item) => item.tag === tag)) {\n    debug?.('tag', tag, 'was just revalidated')\n\n    return true\n  }\n\n  return false\n}\n"],"names":["renderToReadableStream","decodeReply","decodeReplyFromAsyncIterable","createTemporaryReferenceSet","createServerTemporaryReferenceSet","createFromReadableStream","encodeReply","createClientTemporaryReferenceSet","prerender","workAsyncStorage","getHmrRefreshHash","getRenderResumeDataCache","getPrerenderResumeDataCache","workUnitAsyncStorage","getDraftModeProviderForCacheScope","getCacheSignal","isHmrRefresh","getServerComponentsHmrCache","getRuntimeStagePromise","makeDevtoolsIOAwarePromise","makeHangingPromise","getClientReferenceManifest","getServerModuleMap","decryptActionBoundArgs","InvariantError","createReactServerErrorHandler","DYNAMIC_EXPIRE","RUNTIME_PREFETCH_DYNAMIC_STALE","getCacheHandler","UseCacheTimeoutError","createHangingInputAbortSignal","postponeWithTracking","throwToInterruptStaticGeneration","makeErroringSearchParamsForUseCache","createLazyResult","isResolvedLazyResult","dynamicAccessAsyncStorage","RenderStage","Log","isEdgeRuntime","process","env","NEXT_RUNTIME","debug","NEXT_PRIVATE_DEBUG_CACHE","console","bind","undefined","filterStackFrame","NODE_ENV","require","filterStackFrameDEV","findSourceMapURL","findSourceMapURLDEV","generateCacheEntry","workStore","cacheContext","clientReferenceManifest","encodedArguments","fn","timeoutError","runInCleanSnapshot","generateCacheEntryWithRestoredWorkStore","run","generateCacheEntryWithCacheContext","createUseCacheStore","defaultCacheLife","kind","outerWorkUnitStore","type","phase","implicitTags","revalidate","expire","stale","explicitRevalidate","explicitExpire","explicitStale","tags","hmrRefreshHash","serverComponentsHmrCache","forceRevalidate","shouldForceRevalidate","runtimeStagePromise","draftMode","rootParams","headers","cookies","useCacheOrRequestStore","assertDefaultCacheLife","cacheLifeProfiles","cacheStore","abortController","AbortController","generateCacheEntryImpl","propagateCacheLifeAndTagsToRevalidateStore","revalidateStore","entry","outerTags","tag","includes","push","propagateCacheLifeAndTags","collectResult","savedStream","innerCacheStore","startTime","errors","buffer","reader","getReader","read","done","value","error","idx","bufferStream","ReadableStream","pull","controller","invalidDynamicUsageError","length","enqueue","close","collectedTags","collectedRevalidate","collectedExpire","collectedStale","timestamp","cacheSignal","endRead","temporaryReferences","args","Symbol","asyncIterator","Promise","resolve","renderSignal","aborted","addEventListener","once","performance","timeOrigin","now","resultPromise","handleError","dev","isBuildTimePrerendering","reactServerErrorsByDigest","stream","timeoutAbortController","timer","setTimeout","abort","dynamicAccessAbortSignal","getStore","signal","abortSignal","AbortSignal","any","prelude","clientModules","environmentName","onError","reason","clearTimeout","start","hangingPromise","route","returnStream","tee","pendingCacheEntry","name","cloneCacheEntry","streamA","streamB","clonedEntry","clonePendingCacheEntry","getNthCacheEntry","split","i","encodeFormData","formData","result","key","toString","stringValue","arrayBuffer","byteLength","String","fromCodePoint","Uint16Array","Uint8Array","createTrackedReadableStream","cache","id","boundArgsLength","originalFn","argsObj","Array","prototype","slice","call","isPrivate","cacheHandler","Error","captureStackTrace","wrapAsInvalidDynamicUsageError","workUnitStore","expression","dynamicTracking","buildId","hangingInputAbortSignal","Runtime","isPageOrLayoutSegmentFunction","isPageSegmentFunction","params","outerParams","searchParams","outerSearchParams","otherOuterArgs","props","_innerParams","innerSearchParams","otherInnerArgs","apply","isLayoutSegmentFunction","$$isLayout","outerSlots","innerSlots","JSON","stringify","encryptedBoundArgs","shift","boundArgs","isArray","unshift","cacheKeyParts","encodeCacheKeyParts","encodedCacheKeyParts","dynamicAccessAbortController","serializedCacheKey","prerenderResumeDataCache","renderResumeDataCache","beginRead","cachedEntry","get","existingEntry","Dynamic","allowEmptyStaticShell","lazyRefreshTags","refreshTagsByCacheKind","implicitTagsExpiration","lazyExpiration","expirationsByCacheKind","expiration","Infinity","shouldDiscardCacheEntry","currentTime","isStaticGeneration","newStream","isDraftMode","savedCacheEntry","set","promise","pendingRevalidateWrites","entryLeft","entryRight","ignoredStream","cancel","replayConsoleLogs","serverConsumerManifest","moduleLoading","moduleMap","edgeRscModuleMapping","rscModuleMapping","serverModuleMap","maybeProps","$$isPage","isOnDemandRevalidate","some","isRecentlyRevalidatedTag","previouslyRevalidatedTags","pendingRevalidatedTags","item"],"mappings":"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","ignoreList":[0]}