const require_rolldown_runtime = require('../../_virtual/rolldown_runtime.cjs');
const require_pg_core_async_db = require('./db.cjs');
const require_pg_core_session = require('../session.cjs');
let __entity_ts = require("../../entity.cjs");
let __tracing_ts = require("../../tracing.cjs");
let __utils_ts = require("../../utils.cjs");
let __sql_sql_ts = require("../../sql/sql.cjs");
let __cache_core_cache_ts = require("../../cache/core/cache.cjs");
let __errors_ts = require("../../errors.cjs");

//#region src/pg-core/async/session.ts
var PgAsyncPreparedQuery = class extends require_pg_core_session.PgBasePreparedQuery {
	static [__entity_ts.entityKind] = "PgAsyncPreparedQuery";
	constructor(query, cache, queryMetadata, cacheConfig) {
		super(query);
		this.cache = cache;
		this.queryMetadata = queryMetadata;
		this.cacheConfig = cacheConfig;
		if (cache && cache.strategy() === "all" && cacheConfig === void 0) this.cacheConfig = {
			enabled: true,
			autoInvalidate: true
		};
		if (!this.cacheConfig?.enabled) this.cacheConfig = void 0;
	}
	/** @internal */
	authToken;
	/** @internal */
	setToken(token) {
		this.authToken = token;
		return this;
	}
	/** @internal */
	async queryWithCache(queryString, params, query) {
		const cacheStrat = this.cache !== void 0 && !(0, __entity_ts.is)(this.cache, __cache_core_cache_ts.NoopCache) ? await (0, __cache_core_cache_ts.strategyFor)(queryString, params, this.queryMetadata, this.cacheConfig) : { type: "skip" };
		if (cacheStrat.type === "skip") return query().catch((e) => {
			throw new __errors_ts.DrizzleQueryError(queryString, params, e);
		});
		const cache = this.cache;
		if (cacheStrat.type === "invalidate") return Promise.all([query(), cache.onMutate({ tables: cacheStrat.tables })]).then((res) => res[0]).catch((e) => {
			throw new __errors_ts.DrizzleQueryError(queryString, params, e);
		});
		if (cacheStrat.type === "try") {
			const { tables, key, isTag, autoInvalidate, config } = cacheStrat;
			const fromCache = await cache.get(key, tables, isTag, autoInvalidate);
			if (fromCache === void 0) {
				const result = await query().catch((e) => {
					throw new __errors_ts.DrizzleQueryError(queryString, params, e);
				});
				await cache.put(key, result, autoInvalidate ? tables : [], isTag, config);
				return result;
			}
			return fromCache;
		}
		(0, __utils_ts.assertUnreachable)(cacheStrat);
	}
};
var PgAsyncSession = class extends require_pg_core_session.PgSession {
	static [__entity_ts.entityKind] = "PgAsyncSession";
	constructor(dialect) {
		super(dialect);
	}
	/** @internal */
	execute(query, token) {
		return __tracing_ts.tracer.startActiveSpan("drizzle.operation", () => {
			return __tracing_ts.tracer.startActiveSpan("drizzle.prepareQuery", () => {
				return this.prepareQuery(this.dialect.sqlToQuery(query), void 0, void 0, false);
			}).setToken(token).execute();
		});
	}
	all(query) {
		return this.prepareQuery(this.dialect.sqlToQuery(query), void 0, void 0, false).all();
	}
};
var PgAsyncTransaction = class extends require_pg_core_async_db.PgAsyncDatabase {
	static [__entity_ts.entityKind] = "PgAsyncTransaction";
	constructor(dialect, session, relations, schema, nestedIndex = 0, parseRqbJson) {
		super(dialect, session, relations, schema, parseRqbJson);
		this.relations = relations;
		this.schema = schema;
		this.nestedIndex = nestedIndex;
	}
	rollback() {
		throw new __errors_ts.TransactionRollbackError();
	}
	/** @internal */
	getTransactionConfigSQL(config) {
		const chunks = [];
		if (config.isolationLevel) chunks.push(`isolation level ${config.isolationLevel}`);
		if (config.accessMode) chunks.push(config.accessMode);
		if (typeof config.deferrable === "boolean") chunks.push(config.deferrable ? "deferrable" : "not deferrable");
		return __sql_sql_ts.sql.raw(chunks.join(" "));
	}
	setTransaction(config) {
		return this.session.execute(__sql_sql_ts.sql`set transaction ${this.getTransactionConfigSQL(config)}`);
	}
};
async function migrate(migrations, session, config) {
	const migrationsTable = typeof config === "string" ? "__drizzle_migrations" : config.migrationsTable ?? "__drizzle_migrations";
	const migrationsSchema = typeof config === "string" ? "drizzle" : config.migrationsSchema ?? "drizzle";
	const migrationTableCreate = __sql_sql_ts.sql`
			CREATE TABLE IF NOT EXISTS ${__sql_sql_ts.sql.identifier(migrationsSchema)}.${__sql_sql_ts.sql.identifier(migrationsTable)} (
				id SERIAL PRIMARY KEY,
				hash text NOT NULL,
				created_at bigint
			)
		`;
	await session.execute(__sql_sql_ts.sql`CREATE SCHEMA IF NOT EXISTS ${__sql_sql_ts.sql.identifier(migrationsSchema)}`);
	await session.execute(migrationTableCreate);
	const dbMigrations = await session.all(__sql_sql_ts.sql`select id, hash, created_at from ${__sql_sql_ts.sql.identifier(migrationsSchema)}.${__sql_sql_ts.sql.identifier(migrationsTable)} order by created_at desc limit 1`);
	if (typeof config === "object" && config.init) {
		if (dbMigrations.length) return { exitCode: "databaseMigrations" };
		if (migrations.length > 1) return { exitCode: "localMigrations" };
		const [migration] = migrations;
		if (!migration) return;
		await session.execute(__sql_sql_ts.sql`insert into ${__sql_sql_ts.sql.identifier(migrationsSchema)}.${__sql_sql_ts.sql.identifier(migrationsTable)} ("hash", "created_at") values(${migration.hash}, ${migration.folderMillis})`);
		return;
	}
	const lastDbMigration = dbMigrations[0];
	await session.transaction(async (tx) => {
		for (const migration of migrations) if (!lastDbMigration || Number(lastDbMigration.created_at) < migration.folderMillis) {
			for (const stmt of migration.sql) await tx.execute(__sql_sql_ts.sql.raw(stmt));
			await tx.execute(__sql_sql_ts.sql`insert into ${__sql_sql_ts.sql.identifier(migrationsSchema)}.${__sql_sql_ts.sql.identifier(migrationsTable)} ("hash", "created_at") values(${migration.hash}, ${migration.folderMillis})`);
		}
	});
}

//#endregion
exports.PgAsyncPreparedQuery = PgAsyncPreparedQuery;
exports.PgAsyncSession = PgAsyncSession;
exports.PgAsyncTransaction = PgAsyncTransaction;
exports.migrate = migrate;
//# sourceMappingURL=session.cjs.map