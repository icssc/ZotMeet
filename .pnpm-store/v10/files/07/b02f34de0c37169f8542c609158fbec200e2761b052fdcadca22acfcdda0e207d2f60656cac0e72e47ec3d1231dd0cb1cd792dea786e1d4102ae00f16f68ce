{"version":3,"sources":["../../../../src/server/dev/static-paths-worker.ts"],"sourcesContent":["import type { NextConfigComplete } from '../config-shared'\nimport type {\n  AppPageModule,\n  AppPageRouteModule,\n} from '../route-modules/app-page/module'\nimport type {\n  AppRouteModule,\n  AppRouteRouteModule,\n} from '../route-modules/app-route/module.compiled'\n\nimport '../require-hook'\nimport '../node-environment'\n\nimport { collectSegments } from '../../build/segment-config/app/app-segments'\nimport type { StaticPathsResult } from '../../build/static-paths/types'\nimport { loadComponents } from '../load-components'\nimport { setHttpClientAndAgentOptions } from '../setup-http-agent-env'\nimport type { IncrementalCache } from '../lib/incremental-cache'\nimport { isAppPageRouteModule } from '../route-modules/checks'\nimport {\n  checkIsRoutePPREnabled,\n  type ExperimentalPPRConfig,\n} from '../lib/experimental/ppr'\nimport { InvariantError } from '../../shared/lib/invariant-error'\nimport { collectRootParamKeys } from '../../build/segment-config/app/collect-root-param-keys'\nimport { buildAppStaticPaths } from '../../build/static-paths/app'\nimport { buildPagesStaticPaths } from '../../build/static-paths/pages'\nimport { createIncrementalCache } from '../../export/helpers/create-incremental-cache'\nimport { parseAppRoute } from '../../shared/lib/router/routes/app'\n\ntype RuntimeConfig = {\n  pprConfig: ExperimentalPPRConfig | undefined\n  configFileName: string\n  cacheComponents: boolean\n}\n\n// we call getStaticPaths in a separate process to ensure\n// side-effects aren't relied on in dev that will break\n// during a production build\nexport async function loadStaticPaths({\n  dir,\n  distDir,\n  pathname,\n  config,\n  httpAgentOptions,\n  locales,\n  defaultLocale,\n  isAppPath,\n  page,\n  isrFlushToDisk,\n  fetchCacheKeyPrefix,\n  cacheMaxMemorySize,\n  requestHeaders,\n  cacheHandler,\n  cacheHandlers,\n  cacheLifeProfiles,\n  nextConfigOutput,\n  buildId,\n  authInterrupts,\n  sriEnabled,\n}: {\n  dir: string\n  distDir: string\n  pathname: string\n  config: RuntimeConfig\n  httpAgentOptions: NextConfigComplete['httpAgentOptions']\n  locales?: readonly string[]\n  defaultLocale?: string\n  isAppPath: boolean\n  page: string\n  isrFlushToDisk?: boolean\n  fetchCacheKeyPrefix?: string\n  cacheMaxMemorySize: number\n  requestHeaders: IncrementalCache['requestHeaders']\n  cacheHandler?: string\n  cacheHandlers?: NextConfigComplete['cacheHandlers']\n  cacheLifeProfiles?: {\n    [profile: string]: import('../../server/use-cache/cache-life').CacheLife\n  }\n  nextConfigOutput: 'standalone' | 'export' | undefined\n  buildId: string\n  authInterrupts: boolean\n  sriEnabled: boolean\n}): Promise<StaticPathsResult> {\n  // this needs to be initialized before loadComponents otherwise\n  // \"use cache\" could be missing it's cache handlers\n  await createIncrementalCache({\n    dir,\n    distDir,\n    cacheHandler,\n    cacheHandlers,\n    requestHeaders,\n    fetchCacheKeyPrefix,\n    flushToDisk: isrFlushToDisk,\n    cacheMaxMemorySize,\n  })\n\n  // update work memory runtime-config\n  setHttpClientAndAgentOptions({\n    httpAgentOptions,\n  })\n\n  const components = await loadComponents<AppPageModule | AppRouteModule>({\n    distDir,\n    // In `pages/`, the page is the same as the pathname.\n    page: page || pathname,\n    isAppPath,\n    isDev: true,\n    sriEnabled,\n    needsManifestsForLegacyReasons: true,\n  })\n\n  if (isAppPath) {\n    const routeModule = components.routeModule\n    const segments = await collectSegments(\n      // We know this is an app page or app route module because we checked\n      // above that the page type is 'app'.\n      routeModule as AppPageRouteModule | AppRouteRouteModule\n    )\n\n    const route = parseAppRoute(pathname, true)\n    if (route.dynamicSegments.length === 0) {\n      throw new InvariantError(\n        `Expected a dynamic route, but got a static route: ${pathname}`\n      )\n    }\n\n    const isRoutePPREnabled =\n      isAppPageRouteModule(routeModule) &&\n      checkIsRoutePPREnabled(config.pprConfig)\n\n    const rootParamKeys = collectRootParamKeys(routeModule)\n\n    return buildAppStaticPaths({\n      dir,\n      page: pathname,\n      route,\n      cacheComponents: config.cacheComponents,\n      segments,\n      distDir,\n      requestHeaders,\n      cacheHandler,\n      cacheLifeProfiles,\n      isrFlushToDisk,\n      fetchCacheKeyPrefix,\n      cacheMaxMemorySize,\n      ComponentMod: components.ComponentMod,\n      nextConfigOutput,\n      isRoutePPREnabled,\n      buildId,\n      authInterrupts,\n      rootParamKeys,\n    })\n  } else if (!components.getStaticPaths) {\n    // We shouldn't get to this point since the worker should only be called for\n    // SSG pages with getStaticPaths.\n    throw new InvariantError(\n      `Failed to load page with getStaticPaths for ${pathname}`\n    )\n  }\n\n  return buildPagesStaticPaths({\n    page: pathname,\n    getStaticPaths: components.getStaticPaths,\n    configFileName: config.configFileName,\n    locales,\n    defaultLocale,\n  })\n}\n"],"names":["collectSegments","loadComponents","setHttpClientAndAgentOptions","isAppPageRouteModule","checkIsRoutePPREnabled","InvariantError","collectRootParamKeys","buildAppStaticPaths","buildPagesStaticPaths","createIncrementalCache","parseAppRoute","loadStaticPaths","dir","distDir","pathname","config","httpAgentOptions","locales","defaultLocale","isAppPath","page","isrFlushToDisk","fetchCacheKeyPrefix","cacheMaxMemorySize","requestHeaders","cacheHandler","cacheHandlers","cacheLifeProfiles","nextConfigOutput","buildId","authInterrupts","sriEnabled","flushToDisk","components","isDev","needsManifestsForLegacyReasons","routeModule","segments","route","dynamicSegments","length","isRoutePPREnabled","pprConfig","rootParamKeys","cacheComponents","ComponentMod","getStaticPaths","configFileName"],"mappings":"AAUA,OAAO,kBAAiB;AACxB,OAAO,sBAAqB;AAE5B,SAASA,eAAe,QAAQ,8CAA6C;AAE7E,SAASC,cAAc,QAAQ,qBAAoB;AACnD,SAASC,4BAA4B,QAAQ,0BAAyB;AAEtE,SAASC,oBAAoB,QAAQ,0BAAyB;AAC9D,SACEC,sBAAsB,QAEjB,0BAAyB;AAChC,SAASC,cAAc,QAAQ,mCAAkC;AACjE,SAASC,oBAAoB,QAAQ,yDAAwD;AAC7F,SAASC,mBAAmB,QAAQ,+BAA8B;AAClE,SAASC,qBAAqB,QAAQ,iCAAgC;AACtE,SAASC,sBAAsB,QAAQ,gDAA+C;AACtF,SAASC,aAAa,QAAQ,qCAAoC;AAQlE,yDAAyD;AACzD,uDAAuD;AACvD,4BAA4B;AAC5B,OAAO,eAAeC,gBAAgB,EACpCC,GAAG,EACHC,OAAO,EACPC,QAAQ,EACRC,MAAM,EACNC,gBAAgB,EAChBC,OAAO,EACPC,aAAa,EACbC,SAAS,EACTC,IAAI,EACJC,cAAc,EACdC,mBAAmB,EACnBC,kBAAkB,EAClBC,cAAc,EACdC,YAAY,EACZC,aAAa,EACbC,iBAAiB,EACjBC,gBAAgB,EAChBC,OAAO,EACPC,cAAc,EACdC,UAAU,EAwBX;IACC,+DAA+D;IAC/D,mDAAmD;IACnD,MAAMtB,uBAAuB;QAC3BG;QACAC;QACAY;QACAC;QACAF;QACAF;QACAU,aAAaX;QACbE;IACF;IAEA,oCAAoC;IACpCrB,6BAA6B;QAC3Bc;IACF;IAEA,MAAMiB,aAAa,MAAMhC,eAA+C;QACtEY;QACA,qDAAqD;QACrDO,MAAMA,QAAQN;QACdK;QACAe,OAAO;QACPH;QACAI,gCAAgC;IAClC;IAEA,IAAIhB,WAAW;QACb,MAAMiB,cAAcH,WAAWG,WAAW;QAC1C,MAAMC,WAAW,MAAMrC,gBACrB,qEAAqE;QACrE,qCAAqC;QACrCoC;QAGF,MAAME,QAAQ5B,cAAcI,UAAU;QACtC,IAAIwB,MAAMC,eAAe,CAACC,MAAM,KAAK,GAAG;YACtC,MAAM,qBAEL,CAFK,IAAInC,eACR,CAAC,kDAAkD,EAAES,UAAU,GAD3D,qBAAA;uBAAA;4BAAA;8BAAA;YAEN;QACF;QAEA,MAAM2B,oBACJtC,qBAAqBiC,gBACrBhC,uBAAuBW,OAAO2B,SAAS;QAEzC,MAAMC,gBAAgBrC,qBAAqB8B;QAE3C,OAAO7B,oBAAoB;YACzBK;YACAQ,MAAMN;YACNwB;YACAM,iBAAiB7B,OAAO6B,eAAe;YACvCP;YACAxB;YACAW;YACAC;YACAE;YACAN;YACAC;YACAC;YACAsB,cAAcZ,WAAWY,YAAY;YACrCjB;YACAa;YACAZ;YACAC;YACAa;QACF;IACF,OAAO,IAAI,CAACV,WAAWa,cAAc,EAAE;QACrC,4EAA4E;QAC5E,iCAAiC;QACjC,MAAM,qBAEL,CAFK,IAAIzC,eACR,CAAC,4CAA4C,EAAES,UAAU,GADrD,qBAAA;mBAAA;wBAAA;0BAAA;QAEN;IACF;IAEA,OAAON,sBAAsB;QAC3BY,MAAMN;QACNgC,gBAAgBb,WAAWa,cAAc;QACzCC,gBAAgBhC,OAAOgC,cAAc;QACrC9B;QACAC;IACF;AACF","ignoreList":[0]}