{"version":3,"file":"common.cjs","names":["entityKind","ForeignKeyBuilder","ref","config","Column","parsePgArray","makePgArray"],"sources":["../../../src/pg-core/columns/common.ts"],"sourcesContent":["import type { ColumnType, GeneratedColumnConfig, GeneratedIdentityConfig } from '~/column-builder.ts';\nimport { Column } from '~/column.ts';\nimport { entityKind } from '~/entity.ts';\nimport type { ForeignKey, UpdateDeleteAction } from '~/pg-core/foreign-keys.ts';\nimport { ForeignKeyBuilder } from '~/pg-core/foreign-keys.ts';\nimport type { AnyPgTable, PgTable } from '~/pg-core/table.ts';\nimport type { SQL } from '~/sql/sql.ts';\nimport { iife } from '~/tracing-utils.ts';\nimport type { Update } from '~/utils.ts';\nimport type { PgIndexOpClass } from '../indexes.ts';\nimport { makePgArray, parsePgArray } from '../utils/array.ts';\n\ndeclare const PgColumnBuilderBrand: unique symbol;\nexport type PgColumnBuilderBrand = typeof PgColumnBuilderBrand;\n\ndeclare const PgColumnBrand: unique symbol;\nexport type PgColumnBrand = typeof PgColumnBrand;\n\nexport type PgArrayDimension = 0 | 1 | 2 | 3 | 4 | 5;\ntype PgArrayDimensionString = '[]' | '[][]' | '[][][]' | '[][][][]' | '[][][][][]';\n\ntype ArrayDimensionStringToNumber<T extends PgArrayDimensionString> = T extends '[]' ? 1\n\t: T extends '[][]' ? 2\n\t: T extends '[][][]' ? 3\n\t: T extends '[][][][]' ? 4\n\t: T extends '[][][][][]' ? 5\n\t: never;\n\nexport interface PgColumnBuilderConfig {\n\tdataType: ColumnType;\n\tdata: unknown;\n\tdriverParam: unknown;\n\t// Optional - set via chain methods\n\tnotNull?: boolean;\n\thasDefault?: boolean;\n\tisPrimaryKey?: boolean;\n\tisAutoincrement?: boolean;\n\thasRuntimeDefault?: boolean;\n\tenumValues?: string[];\n\tidentity?: 'always' | 'byDefault';\n\tgenerated?: unknown;\n\tdimensions?: PgArrayDimension;\n\t$type?: unknown;\n}\n\nexport interface PgColumnBuilderRuntimeConfig<TData> {\n\tname: string;\n\tkeyAsName: boolean;\n\tnotNull: boolean;\n\tdefault: TData | SQL | undefined;\n\tdefaultFn: (() => TData | SQL) | undefined;\n\tonUpdateFn: (() => TData | SQL) | undefined;\n\thasDefault: boolean;\n\tprimaryKey: boolean;\n\tisUnique: boolean;\n\tuniqueName: string | undefined;\n\tuniqueType: string | undefined;\n\tdataType: string;\n\tcolumnType: string;\n\tgenerated: GeneratedColumnConfig<TData> | undefined;\n\tgeneratedIdentity: GeneratedIdentityConfig | undefined;\n\tdimensions?: PgArrayDimension;\n}\n\n// TODO: remove isAutoincrement and hasRuntimeDefault\nexport interface PgColumnBaseConfig<out TDataType extends ColumnType = ColumnType> {\n\tname: string;\n\tdataType: TDataType;\n\ttableName: string;\n\tnotNull: boolean;\n\thasDefault: boolean;\n\tisPrimaryKey: boolean;\n\tisAutoincrement: boolean;\n\thasRuntimeDefault: boolean;\n\tdata: unknown;\n\tdriverParam: unknown;\n\tenumValues: string[] | undefined;\n\tgenerated: unknown;\n\tidentity: undefined | 'always' | 'byDefault';\n\t// insertType: unknown;\n}\n\ntype WrapArray<T, N extends number> = N extends 1 ? T[]\n\t: N extends 2 ? T[][]\n\t: N extends 3 ? T[][][]\n\t: N extends 4 ? T[][][][]\n\t: N extends 5 ? T[][][][][]\n\t: T;\n\nexport type SetNotNull<T> = T & { readonly [PgColumnBuilderBrand]: { notNull: true } };\nexport type SetHasDefault<T> = T & { readonly [PgColumnBuilderBrand]: { hasDefault: true } };\nexport type SetIsPrimaryKey<T> = T & { readonly [PgColumnBuilderBrand]: { isPrimaryKey: true; notNull: true } };\nexport type SetHasRuntimeDefault<T> = T & {\n\treadonly [PgColumnBuilderBrand]: { hasRuntimeDefault: true; hasDefault: true };\n};\nexport type Set$Type<T, TType> = T & { readonly [PgColumnBuilderBrand]: { $type: TType } };\nexport type SetHasGenerated<T> = T & {\n\treadonly [PgColumnBuilderBrand]: { hasDefault: true; generated: true };\n};\nexport type SetDimensions<T, TDim extends PgArrayDimension> = T & {\n\treadonly [PgColumnBuilderBrand]: { dimensions: TDim };\n};\nexport type SetIdentity<T, TType extends 'always' | 'byDefault'> = T & {\n\treadonly [PgColumnBuilderBrand]: { notNull: true; hasDefault: true; identity: TType };\n};\n\nexport type HasIdentity<T, TType extends 'always' | 'byDefault'> = SetIdentity<T, TType>;\n\ntype GetBaseData<T> = T extends { $type: infer U } ? U : T extends { data: infer D } ? D : unknown;\n\nexport type ResolvePgColumnConfig<\n\tout T extends PgColumnBuilderConfig,\n\tout TTableName extends string,\n\tout TData extends unknown = T['dimensions'] extends 1 | 2 | 3 | 4 | 5 ? WrapArray<GetBaseData<T>, T['dimensions']>\n\t\t: GetBaseData<T>,\n> = {\n\tname: string;\n\ttableName: TTableName;\n\tdataType: T['dataType'];\n\tdata: TData;\n\tdriverParam: T['dimensions'] extends 1 | 2 | 3 | 4 | 5 ? WrapArray<T['driverParam'], T['dimensions']> | string\n\t\t: T['driverParam'];\n\tnotNull: T['notNull'] extends true ? true : false;\n\thasDefault: T['hasDefault'] extends true ? true : false;\n\tisPrimaryKey: false;\n\tisAutoincrement: false;\n\thasRuntimeDefault: false;\n\tenumValues: T extends { enumValues: infer E extends string[] } ? E : undefined;\n\tidentity: T['identity'] extends 'always' | 'byDefault' ? T['identity'] : undefined;\n\tgenerated: T['generated'] extends true ? true : undefined;\n\t// insertType: T['generated'] extends true ? never\n\t// \t: T['identity'] extends 'always' ? never\n\t// \t: T['notNull'] extends true ? T['hasDefault'] extends true ? TData | undefined : TData\n\t// \t: TData | null | undefined;\n} & {};\n\nexport interface AnyPgColumnBuilder {\n\treadonly [PgColumnBuilderBrand]: PgColumnBuilderConfig;\n}\n\nexport interface AnyPostgresColumn {\n\treadonly [PgColumnBrand]: PgColumnBaseConfig;\n}\n\nexport type PgBuildColumn<\n\tTTableName extends string,\n\tTBuilder extends AnyPgColumnBuilder,\n\tTBuiltConfig extends PgColumnBaseConfig<ColumnType> = ResolvePgColumnConfig<\n\t\tTBuilder[PgColumnBuilderBrand],\n\t\tTTableName\n\t>,\n> = PgColumn<ColumnType, TBuiltConfig, {}>;\n\nexport type PgBuildColumns<\n\tout TTableName extends string,\n\tout TConfigMap extends Record<string, AnyPgColumnBuilder>,\n> =\n\t& {\n\t\t[Key in keyof TConfigMap]: PgBuildColumn<TTableName, TConfigMap[Key]>;\n\t}\n\t& {};\n\nexport type PgBuildExtraConfigColumns<\n\tout TConfigMap extends Record<string, AnyPgColumnBuilder>,\n> =\n\t& {\n\t\t[Key in keyof TConfigMap]: ExtraConfigColumn;\n\t}\n\t& {};\n\nexport type PgColumns = Record<string, PgColumn>;\n\nexport interface ReferenceConfig {\n\tref: () => PgColumn;\n\tconfig: {\n\t\tname?: string;\n\t\tonUpdate?: UpdateDeleteAction;\n\t\tonDelete?: UpdateDeleteAction;\n\t};\n}\n\nexport abstract class PgColumnBuilder<\n\tout T extends PgColumnBuilderConfig = PgColumnBuilderConfig,\n\tout TRuntimeConfig extends object = object,\n> {\n\tstatic readonly [entityKind]: string = 'PgColumnBuilder';\n\n\tdeclare readonly [PgColumnBuilderBrand]: T;\n\n\tprivate foreignKeyConfigs: ReferenceConfig[] = [];\n\n\tprotected config: PgColumnBuilderRuntimeConfig<T['data']> & TRuntimeConfig;\n\n\tconstructor(name: string, dataType: ColumnType, columnType: string) {\n\t\tthis.config = {\n\t\t\tname,\n\t\t\tkeyAsName: name === '',\n\t\t\tnotNull: false,\n\t\t\tdefault: undefined,\n\t\t\thasDefault: false,\n\t\t\tprimaryKey: false,\n\t\t\tisUnique: false,\n\t\t\tuniqueName: undefined,\n\t\t\tuniqueType: undefined,\n\t\t\tdataType,\n\t\t\tcolumnType,\n\t\t\tgenerated: undefined,\n\t\t\tdefaultFn: undefined,\n\t\t\tonUpdateFn: undefined,\n\t\t\tgeneratedIdentity: undefined,\n\t\t} as PgColumnBuilderRuntimeConfig<T['data']> & TRuntimeConfig;\n\t}\n\n\t/**\n\t * Changes the data type of the column. Commonly used with `json` columns. Also, useful for branded types.\n\t *\n\t * @example\n\t * ```ts\n\t * const users = pgTable('users', {\n\t * \tid: integer('id').$type<UserId>().primaryKey(),\n\t * \tdetails: json('details').$type<UserDetails>().notNull(),\n\t * });\n\t * ```\n\t */\n\t$type<TType>(): Set$Type<this, TType> {\n\t\treturn this as Set$Type<this, TType>;\n\t}\n\n\t/**\n\t * Adds a `not null` clause to the column definition.\n\t *\n\t * Affects the `select` model of the table - columns *without* `not null` will be nullable on select.\n\t */\n\tnotNull(): SetNotNull<this> {\n\t\tthis.config.notNull = true;\n\t\treturn this as SetNotNull<this>;\n\t}\n\n\t/**\n\t * Adds a `default <value>` clause to the column definition.\n\t *\n\t * Affects the `insert` model of the table - columns *with* `default` are optional on insert.\n\t *\n\t * If you need to set a dynamic default value, use {@link $defaultFn} instead.\n\t */\n\tdefault(\n\t\tvalue:\n\t\t\t| (this[PgColumnBuilderBrand] extends { dimensions: 1 | 2 | 3 | 4 | 5 } ? WrapArray<\n\t\t\t\t\tthis[PgColumnBuilderBrand] extends { $type: infer U } ? U : this[PgColumnBuilderBrand]['data'],\n\t\t\t\t\tthis[PgColumnBuilderBrand]['dimensions']\n\t\t\t\t>\n\t\t\t\t: this[PgColumnBuilderBrand] extends { $type: infer U } ? U\n\t\t\t\t: this[PgColumnBuilderBrand]['data'])\n\t\t\t| SQL,\n\t): SetHasDefault<this> {\n\t\tthis.config.default = value;\n\t\tthis.config.hasDefault = true;\n\t\treturn this as SetHasDefault<this>;\n\t}\n\n\t/**\n\t * Adds a dynamic default value to the column.\n\t * The function will be called when the row is inserted, and the returned value will be used as the column value.\n\t *\n\t * **Note:** This value does not affect the `drizzle-kit` behavior, it is only used at runtime in `drizzle-orm`.\n\t */\n\t$defaultFn(\n\t\tfn: () =>\n\t\t\t| (this[PgColumnBuilderBrand] extends { dimensions: 1 | 2 | 3 | 4 | 5 } ? WrapArray<\n\t\t\t\t\tthis[PgColumnBuilderBrand] extends { $type: infer U } ? U : this[PgColumnBuilderBrand]['data'],\n\t\t\t\t\tthis[PgColumnBuilderBrand]['dimensions']\n\t\t\t\t>\n\t\t\t\t: this[PgColumnBuilderBrand] extends { $type: infer U } ? U\n\t\t\t\t: this[PgColumnBuilderBrand]['data'])\n\t\t\t| SQL,\n\t): SetHasRuntimeDefault<this> {\n\t\tthis.config.defaultFn = fn;\n\t\tthis.config.hasDefault = true;\n\t\treturn this as SetHasRuntimeDefault<this>;\n\t}\n\n\t/**\n\t * Alias for {@link $defaultFn}.\n\t */\n\t$default = this.$defaultFn;\n\n\t/**\n\t * Adds a dynamic update value to the column.\n\t * The function will be called when the row is updated, and the returned value will be used as the column value if none is provided.\n\t * If no `default` (or `$defaultFn`) value is provided, the function will be called when the row is inserted as well, and the returned value will be used as the column value.\n\t *\n\t * **Note:** This value does not affect the `drizzle-kit` behavior, it is only used at runtime in `drizzle-orm`.\n\t */\n\t$onUpdateFn(\n\t\tfn: () =>\n\t\t\t| (this[PgColumnBuilderBrand] extends { dimensions: 1 | 2 | 3 | 4 | 5 } ? WrapArray<\n\t\t\t\t\tthis[PgColumnBuilderBrand] extends { $type: infer U } ? U : this[PgColumnBuilderBrand]['data'],\n\t\t\t\t\tthis[PgColumnBuilderBrand]['dimensions']\n\t\t\t\t>\n\t\t\t\t: this[PgColumnBuilderBrand] extends { $type: infer U } ? U\n\t\t\t\t: this[PgColumnBuilderBrand]['data'])\n\t\t\t| SQL,\n\t): SetHasDefault<this> {\n\t\tthis.config.onUpdateFn = fn;\n\t\tthis.config.hasDefault = true;\n\t\treturn this as SetHasDefault<this>;\n\t}\n\n\t/**\n\t * Alias for {@link $onUpdateFn}.\n\t */\n\t$onUpdate = this.$onUpdateFn;\n\n\t/**\n\t * Adds a `primary key` clause to the column definition. This implicitly makes the column `not null`.\n\t *\n\t * In SQLite, `integer primary key` implicitly makes the column auto-incrementing.\n\t */\n\tprimaryKey(): SetIsPrimaryKey<this> {\n\t\tthis.config.primaryKey = true;\n\t\tthis.config.notNull = true;\n\t\treturn this as SetIsPrimaryKey<this>;\n\t}\n\n\t/** @internal Sets the name of the column to the key within the table definition if a name was not given. */\n\tsetName(name: string) {\n\t\tif (this.config.name !== '') return;\n\t\tthis.config.name = name;\n\t}\n\n\t/**\n\t * Makes this column a PostgreSQL array column.\n\t *\n\t * @example\n\t * ```ts\n\t * const t = pgTable('t', {\n\t *   // 1D array: number[]\n\t *   tags: integer().array(),\n\t *   // Or explicitly: integer().array('[]')\n\t *   // 2D array: number[][]\n\t *   matrix: integer().array('[][]'),\n\t * });\n\t * ```\n\t */\n\tarray(): SetDimensions<this, 1>;\n\tarray<TDim extends PgArrayDimensionString>(\n\t\tdimensions: TDim,\n\t): SetDimensions<this, ArrayDimensionStringToNumber<TDim>>;\n\tarray<TDim extends PgArrayDimensionString>(\n\t\tdimensions?: TDim,\n\t): SetDimensions<this, ArrayDimensionStringToNumber<TDim>> {\n\t\t// Calculate dimensions as number from string notation\n\t\tconst dim = dimensions ?? '[]';\n\t\t(this.config as any).dimensions = (dim.length / 2) as PgArrayDimension;\n\t\treturn this as SetDimensions<this, ArrayDimensionStringToNumber<TDim>>;\n\t}\n\n\treferences(\n\t\tref: ReferenceConfig['ref'],\n\t\tconfig: ReferenceConfig['config'] = {},\n\t): this {\n\t\tthis.foreignKeyConfigs.push({ ref, config });\n\t\treturn this;\n\t}\n\n\tunique(\n\t\tname?: string,\n\t\tconfig?: { nulls: 'distinct' | 'not distinct' },\n\t): this {\n\t\tthis.config.isUnique = true;\n\t\tthis.config.uniqueName = name;\n\t\tthis.config.uniqueType = config?.nulls;\n\t\treturn this;\n\t}\n\n\tgeneratedAlwaysAs(\n\t\tas:\n\t\t\t| SQL\n\t\t\t| (() => SQL),\n\t): SetHasGenerated<this> {\n\t\tthis.config.generated = {\n\t\t\tas,\n\t\t\ttype: 'always',\n\t\t\tmode: 'stored',\n\t\t};\n\t\treturn this as SetHasGenerated<this>;\n\t}\n\n\t/** @internal */\n\tbuildForeignKeys(column: PgColumn, table: PgTable): ForeignKey[] {\n\t\treturn this.foreignKeyConfigs.map(({ ref, config }) => {\n\t\t\treturn iife(\n\t\t\t\t(ref, config) => {\n\t\t\t\t\tconst builder = new ForeignKeyBuilder(() => {\n\t\t\t\t\t\tconst foreignColumn = ref();\n\t\t\t\t\t\treturn { name: config.name, columns: [column], foreignColumns: [foreignColumn] };\n\t\t\t\t\t});\n\t\t\t\t\tif (config.onUpdate) {\n\t\t\t\t\t\tbuilder.onUpdate(config.onUpdate);\n\t\t\t\t\t}\n\t\t\t\t\tif (config.onDelete) {\n\t\t\t\t\t\tbuilder.onDelete(config.onDelete);\n\t\t\t\t\t}\n\t\t\t\t\treturn builder.build(table);\n\t\t\t\t},\n\t\t\t\tref,\n\t\t\t\tconfig,\n\t\t\t);\n\t\t});\n\t}\n\n\t/** @internal */\n\tabstract build(table: PgTable): PgColumn<any>;\n\n\t/** @internal */\n\tbuildExtraConfigColumn<TTableName extends string>(\n\t\ttable: AnyPgTable<{ name: TTableName }>,\n\t): ExtraConfigColumn {\n\t\treturn new ExtraConfigColumn(table, { ...this.config, dimensions: (this.config as any).dimensions ?? 0 });\n\t}\n}\n\n// TODO: we should potenitally do column to be\n// in charge of map value/array of values/json value and json array of values in 1 place\nexport abstract class PgColumn<\n\tout TColumnType extends ColumnType = any,\n\tout T extends PgColumnBaseConfig<TColumnType> = PgColumnBaseConfig<TColumnType>,\n\tout TRuntimeConfig extends object = {},\n> extends Column<T, TRuntimeConfig> {\n\tstatic override readonly [entityKind]: string = 'PgColumn';\n\n\t/** @internal */\n\toverride readonly table: PgTable;\n\n\treadonly dimensions: PgArrayDimension;\n\n\tconstructor(\n\t\ttable: PgTable,\n\t\tconfig: PgColumnBuilderRuntimeConfig<T['data']> & TRuntimeConfig,\n\t) {\n\t\tsuper(table, config);\n\t\tthis.table = table;\n\t\tthis.dimensions = config.dimensions ?? 0;\n\n\t\t// Wrap mapFromDriverValue/mapToDriverValue with array handling if this is an array column\n\t\tif (this.dimensions) {\n\t\t\tconst originalFromDriver = this.mapFromDriverValue.bind(this);\n\t\t\tconst originalToDriver = this.mapToDriverValue.bind(this);\n\n\t\t\tthis.mapFromDriverValue = (value: unknown): unknown => {\n\t\t\t\tif (value === null) return value;\n\t\t\t\t// Parse string representation if needed (e.g., from node-postgres for enum arrays)\n\t\t\t\tconst arr = typeof value === 'string' ? parsePgArray(value) : value as unknown[];\n\t\t\t\treturn this.mapArrayElements(arr, originalFromDriver, this.dimensions);\n\t\t\t};\n\n\t\t\tthis.mapToDriverValue = (value: unknown): unknown => {\n\t\t\t\tif (value === null) return value;\n\t\t\t\tconst mapped = this.mapArrayElements(value as unknown[], originalToDriver, this.dimensions);\n\t\t\t\treturn makePgArray(mapped as any[]);\n\t\t\t};\n\t\t}\n\t}\n\n\t/** @internal */\n\tprivate mapArrayElements(value: unknown, mapper: (v: unknown) => unknown, depth: number): unknown {\n\t\tif (depth > 0 && Array.isArray(value)) {\n\t\t\treturn value.map((v) => v === null ? null : this.mapArrayElements(v, mapper, depth - 1));\n\t\t}\n\t\treturn mapper(value);\n\t}\n}\n\nexport type IndexedExtraConfigType = { order?: 'asc' | 'desc'; nulls?: 'first' | 'last'; opClass?: string };\n\nexport class ExtraConfigColumn<\n\tout T extends PgColumnBaseConfig<ColumnType> = PgColumnBaseConfig<ColumnType>,\n> extends PgColumn<ColumnType, T, IndexedExtraConfigType> {\n\tstatic override readonly [entityKind]: string = 'ExtraConfigColumn';\n\n\toverride getSQLType(): string {\n\t\treturn this.getSQLType();\n\t}\n\n\tindexConfig: IndexedExtraConfigType = {\n\t\torder: this.config.order ?? 'asc',\n\t\tnulls: this.config.nulls ?? 'last',\n\t\topClass: this.config.opClass,\n\t};\n\tdefaultConfig: IndexedExtraConfigType = {\n\t\torder: 'asc',\n\t\tnulls: 'last',\n\t\topClass: undefined,\n\t};\n\n\tasc(): Omit<this, 'asc' | 'desc'> {\n\t\tthis.indexConfig.order = 'asc';\n\t\treturn this;\n\t}\n\n\tdesc(): Omit<this, 'asc' | 'desc'> {\n\t\tthis.indexConfig.order = 'desc';\n\t\treturn this;\n\t}\n\n\tnullsFirst(): Omit<this, 'nullsFirst' | 'nullsLast'> {\n\t\tthis.indexConfig.nulls = 'first';\n\t\treturn this;\n\t}\n\n\tnullsLast(): Omit<this, 'nullsFirst' | 'nullsLast'> {\n\t\tthis.indexConfig.nulls = 'last';\n\t\treturn this;\n\t}\n\n\t/**\n\t * ### PostgreSQL documentation quote\n\t *\n\t * > An operator class with optional parameters can be specified for each column of an index.\n\t * The operator class identifies the operators to be used by the index for that column.\n\t * For example, a B-tree index on four-byte integers would use the int4_ops class;\n\t * this operator class includes comparison functions for four-byte integers.\n\t * In practice the default operator class for the column's data type is usually sufficient.\n\t * The main point of having operator classes is that for some data types, there could be more than one meaningful ordering.\n\t * For example, we might want to sort a complex-number data type either by absolute value or by real part.\n\t * We could do this by defining two operator classes for the data type and then selecting the proper class when creating an index.\n\t * More information about operator classes check:\n\t *\n\t * ### Useful links\n\t * https://www.postgresql.org/docs/current/sql-createindex.html\n\t *\n\t * https://www.postgresql.org/docs/current/indexes-opclass.html\n\t *\n\t * https://www.postgresql.org/docs/current/xindex.html\n\t *\n\t * ### Additional types\n\t * If you have the `pg_vector` extension installed in your database, you can use the\n\t * `vector_l2_ops`, `vector_ip_ops`, `vector_cosine_ops`, `vector_l1_ops`, `bit_hamming_ops`, `bit_jaccard_ops`, `halfvec_l2_ops`, `sparsevec_l2_ops` options, which are predefined types.\n\t *\n\t * **You can always specify any string you want in the operator class, in case Drizzle doesn't have it natively in its types**\n\t *\n\t * @param opClass\n\t * @returns\n\t */\n\top(opClass: PgIndexOpClass): Omit<this, 'op'> {\n\t\tthis.indexConfig.opClass = opClass;\n\t\treturn this;\n\t}\n}\n\nexport class IndexedColumn {\n\tstatic readonly [entityKind]: string = 'IndexedColumn';\n\tconstructor(\n\t\tname: string | undefined,\n\t\tkeyAsName: boolean,\n\t\ttype: string,\n\t\tindexConfig: IndexedExtraConfigType,\n\t) {\n\t\tthis.name = name;\n\t\tthis.keyAsName = keyAsName;\n\t\tthis.type = type;\n\t\tthis.indexConfig = indexConfig;\n\t}\n\n\tname: string | undefined;\n\tkeyAsName: boolean;\n\ttype: string;\n\tindexConfig: IndexedExtraConfigType;\n}\n\nexport type AnyPgColumn<\n\tTPartial extends Partial<PgColumnBaseConfig<ColumnType>> = {},\n> = PgColumn<\n\tany,\n\tRequired<Update<PgColumnBaseConfig<ColumnType>, TPartial>>\n>;\n"],"mappings":"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"}