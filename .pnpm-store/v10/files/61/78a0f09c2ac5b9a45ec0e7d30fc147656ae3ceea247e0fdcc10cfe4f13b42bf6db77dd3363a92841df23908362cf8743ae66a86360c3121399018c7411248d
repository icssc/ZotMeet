import { formatToMillis } from "../migrator.utils.js";
import { sql } from "../sql/index.js";

//#region src/durable-sqlite/migrator.ts
function readMigrationFiles({ migrations }) {
	const migrationQueries = [];
	const sortedMigrations = Object.keys(migrations).sort();
	for (const key of sortedMigrations) {
		const query = migrations[key];
		if (!query) throw new Error(`Missing migration: ${key}`);
		try {
			const result = query.split("--> statement-breakpoint").map((it) => {
				return it;
			});
			const migrationDate = formatToMillis(key.slice(0, 14));
			migrationQueries.push({
				sql: result,
				bps: true,
				folderMillis: migrationDate,
				hash: ""
			});
		} catch {
			throw new Error(`Failed to parse migration: ${key}`);
		}
	}
	return migrationQueries;
}
async function migrate(db, config) {
	const migrations = readMigrationFiles(config);
	return await db.transaction((tx) => {
		try {
			const migrationsTable = "__drizzle_migrations";
			const migrationTableCreate = sql`
				CREATE TABLE IF NOT EXISTS ${sql.identifier(migrationsTable)} (
					id SERIAL PRIMARY KEY,
					hash text NOT NULL,
					created_at numeric
				)
			`;
			db.run(migrationTableCreate);
			const dbMigrations = db.values(sql`SELECT id, hash, created_at FROM ${sql.identifier(migrationsTable)} ORDER BY created_at DESC LIMIT 1`);
			if (config.init) {
				if (dbMigrations.length) return { exitCode: "databaseMigrations" };
				if (migrations.length > 1) return { exitCode: "localMigrations" };
				const [migration] = migrations;
				if (!migration) return;
				db.run(sql`insert into ${sql.identifier(migrationsTable)} ("hash", "created_at") values(${migration.hash}, ${migration.folderMillis})`);
				return;
			}
			const lastDbMigration = dbMigrations[0] ?? void 0;
			for (const migration of migrations) if (!lastDbMigration || Number(lastDbMigration[2]) < migration.folderMillis) {
				for (const stmt of migration.sql) db.run(sql.raw(stmt));
				db.run(sql`INSERT INTO ${sql.identifier(migrationsTable)} ("hash", "created_at") VALUES(${migration.hash}, ${migration.folderMillis})`);
			}
			return;
		} catch (error) {
			tx.rollback();
			throw error;
		}
	});
}

//#endregion
export { migrate };
//# sourceMappingURL=migrator.js.map