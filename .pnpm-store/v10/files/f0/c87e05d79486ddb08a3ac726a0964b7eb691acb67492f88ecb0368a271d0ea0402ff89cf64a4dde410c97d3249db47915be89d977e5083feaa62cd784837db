{"version":3,"sources":["../../../../../../src/client/components/router-reducer/reducers/restore-reducer.ts"],"sourcesContent":["import { createHrefFromUrl } from '../create-href-from-url'\nimport type {\n  ReadonlyReducerState,\n  ReducerState,\n  RestoreAction,\n} from '../router-reducer-types'\nimport { extractPathFromFlightRouterState } from '../compute-changed-path'\nimport {\n  FreshnessPolicy,\n  spawnDynamicRequests,\n  startPPRNavigation,\n  type NavigationRequestAccumulation,\n} from '../ppr-navigations'\nimport type { FlightRouterState } from '../../../../shared/lib/app-router-types'\nimport { handleExternalUrl } from './navigate-reducer'\nimport type { Mutable } from '../router-reducer-types'\n\nexport function restoreReducer(\n  state: ReadonlyReducerState,\n  action: RestoreAction\n): ReducerState {\n  // This action is used to restore the router state from the history state.\n  // However, it's possible that the history state no longer contains the `FlightRouterState`.\n  // We will copy over the internal state on pushState/replaceState events, but if a history entry\n  // occurred before hydration, or if the user navigated to a hash using a regular anchor link,\n  // the history state will not contain the `FlightRouterState`.\n  // In this case, we'll continue to use the existing tree so the router doesn't get into an invalid state.\n  let treeToRestore: FlightRouterState | undefined\n  let renderedSearch: string | undefined\n  const historyState = action.historyState\n  if (historyState) {\n    treeToRestore = historyState.tree\n    renderedSearch = historyState.renderedSearch\n  } else {\n    treeToRestore = state.tree\n    renderedSearch = state.renderedSearch\n  }\n\n  const currentUrl = new URL(state.canonicalUrl, location.origin)\n  const restoredUrl = action.url\n  const restoredCanonicalUrl = createHrefFromUrl(restoredUrl)\n  const restoredNextUrl =\n    extractPathFromFlightRouterState(treeToRestore) ?? restoredUrl.pathname\n\n  const now = Date.now()\n  const accumulation: NavigationRequestAccumulation = {\n    scrollableSegments: null,\n    separateRefreshUrls: null,\n  }\n  const task = startPPRNavigation(\n    now,\n    currentUrl,\n    state.cache,\n    state.tree,\n    treeToRestore,\n    FreshnessPolicy.HistoryTraversal,\n    null,\n    null,\n    null,\n    null,\n    false,\n    false,\n    accumulation\n  )\n\n  if (task === null) {\n    const mutable: Mutable = {\n      preserveCustomHistoryState: true,\n    }\n    return handleExternalUrl(state, mutable, restoredCanonicalUrl, false)\n  }\n\n  spawnDynamicRequests(\n    task,\n    restoredUrl,\n    restoredNextUrl,\n    FreshnessPolicy.HistoryTraversal,\n    accumulation\n  )\n\n  return {\n    // Set canonical url\n    canonicalUrl: restoredCanonicalUrl,\n    renderedSearch,\n    pushRef: {\n      pendingPush: false,\n      mpaNavigation: false,\n      // Ensures that the custom history state that was set is preserved when applying this update.\n      preserveCustomHistoryState: true,\n    },\n    focusAndScrollRef: state.focusAndScrollRef,\n    cache: task.node,\n    // Restore provided tree\n    tree: treeToRestore,\n\n    nextUrl: restoredNextUrl,\n    // TODO: We need to restore previousNextUrl, too, which represents the\n    // Next-Url that was used to fetch the data. Anywhere we fetch using the\n    // canonical URL, there should be a corresponding Next-Url.\n    previousNextUrl: null,\n    debugInfo: null,\n  }\n}\n"],"names":["createHrefFromUrl","extractPathFromFlightRouterState","FreshnessPolicy","spawnDynamicRequests","startPPRNavigation","handleExternalUrl","restoreReducer","state","action","treeToRestore","renderedSearch","historyState","tree","currentUrl","URL","canonicalUrl","location","origin","restoredUrl","url","restoredCanonicalUrl","restoredNextUrl","pathname","now","Date","accumulation","scrollableSegments","separateRefreshUrls","task","cache","HistoryTraversal","mutable","preserveCustomHistoryState","pushRef","pendingPush","mpaNavigation","focusAndScrollRef","node","nextUrl","previousNextUrl","debugInfo"],"mappings":"AAAA,SAASA,iBAAiB,QAAQ,0BAAyB;AAM3D,SAASC,gCAAgC,QAAQ,0BAAyB;AAC1E,SACEC,eAAe,EACfC,oBAAoB,EACpBC,kBAAkB,QAEb,qBAAoB;AAE3B,SAASC,iBAAiB,QAAQ,qBAAoB;AAGtD,OAAO,SAASC,eACdC,KAA2B,EAC3BC,MAAqB;IAErB,0EAA0E;IAC1E,4FAA4F;IAC5F,gGAAgG;IAChG,6FAA6F;IAC7F,8DAA8D;IAC9D,yGAAyG;IACzG,IAAIC;IACJ,IAAIC;IACJ,MAAMC,eAAeH,OAAOG,YAAY;IACxC,IAAIA,cAAc;QAChBF,gBAAgBE,aAAaC,IAAI;QACjCF,iBAAiBC,aAAaD,cAAc;IAC9C,OAAO;QACLD,gBAAgBF,MAAMK,IAAI;QAC1BF,iBAAiBH,MAAMG,cAAc;IACvC;IAEA,MAAMG,aAAa,IAAIC,IAAIP,MAAMQ,YAAY,EAAEC,SAASC,MAAM;IAC9D,MAAMC,cAAcV,OAAOW,GAAG;IAC9B,MAAMC,uBAAuBpB,kBAAkBkB;IAC/C,MAAMG,kBACJpB,iCAAiCQ,kBAAkBS,YAAYI,QAAQ;IAEzE,MAAMC,MAAMC,KAAKD,GAAG;IACpB,MAAME,eAA8C;QAClDC,oBAAoB;QACpBC,qBAAqB;IACvB;IACA,MAAMC,OAAOxB,mBACXmB,KACAV,YACAN,MAAMsB,KAAK,EACXtB,MAAMK,IAAI,EACVH,eACAP,gBAAgB4B,gBAAgB,EAChC,MACA,MACA,MACA,MACA,OACA,OACAL;IAGF,IAAIG,SAAS,MAAM;QACjB,MAAMG,UAAmB;YACvBC,4BAA4B;QAC9B;QACA,OAAO3B,kBAAkBE,OAAOwB,SAASX,sBAAsB;IACjE;IAEAjB,qBACEyB,MACAV,aACAG,iBACAnB,gBAAgB4B,gBAAgB,EAChCL;IAGF,OAAO;QACL,oBAAoB;QACpBV,cAAcK;QACdV;QACAuB,SAAS;YACPC,aAAa;YACbC,eAAe;YACf,6FAA6F;YAC7FH,4BAA4B;QAC9B;QACAI,mBAAmB7B,MAAM6B,iBAAiB;QAC1CP,OAAOD,KAAKS,IAAI;QAChB,wBAAwB;QACxBzB,MAAMH;QAEN6B,SAASjB;QACT,sEAAsE;QACtE,wEAAwE;QACxE,2DAA2D;QAC3DkB,iBAAiB;QACjBC,WAAW;IACb;AACF","ignoreList":[0]}