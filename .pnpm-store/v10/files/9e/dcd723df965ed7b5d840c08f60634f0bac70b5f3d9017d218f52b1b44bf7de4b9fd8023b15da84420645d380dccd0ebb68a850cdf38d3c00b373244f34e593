const require_chunk = require('./chunk-CdAKIUsw.js');
const require_utils = require('./utils-D2E5ChQ0.js');
const require_grammar = require('./grammar-B2XVJ90y.js');
const require_drizzle = require('./drizzle-BfPXPbBQ.js');
let drizzle_orm = require("drizzle-orm");
let drizzle_orm__relations = require("drizzle-orm/_relations");
let drizzle_orm_pg_core = require("drizzle-orm/pg-core");

//#region src/dialects/postgres/drizzle.ts
const policyFrom = (policy, dialect) => {
	const mappedTo = !policy.to ? ["public"] : typeof policy.to === "string" ? [policy.to] : (0, drizzle_orm.is)(policy.to, drizzle_orm_pg_core.PgRole) ? [policy.to.name] : Array.isArray(policy.to) ? policy.to.map((it) => {
		if (typeof it === "string") return it;
		else if ((0, drizzle_orm.is)(it, drizzle_orm_pg_core.PgRole)) return it.name;
		return "";
	}) : "";
	const policyAs = policy.as?.toUpperCase() ?? "PERMISSIVE";
	const policyFor = policy.for?.toUpperCase() ?? "ALL";
	const policyTo = mappedTo.sort();
	const policyUsing = (0, drizzle_orm.is)(policy.using, drizzle_orm.SQL) ? dialect.sqlToQuery(policy.using).sql : null;
	const withCheck = (0, drizzle_orm.is)(policy.withCheck, drizzle_orm.SQL) ? dialect.sqlToQuery(policy.withCheck).sql : null;
	return {
		name: policy.name,
		as: policyAs,
		for: policyFor,
		roles: policyTo,
		using: policyUsing,
		withCheck
	};
};
const unwrapColumn = (column) => {
	const dimensions = column.dimensions ?? 0;
	const baseColumn = column;
	const isEnum = (0, drizzle_orm.is)(baseColumn, drizzle_orm_pg_core.PgEnumColumn) || (0, drizzle_orm.is)(baseColumn, drizzle_orm_pg_core.PgEnumObjectColumn);
	const typeSchema = isEnum ? baseColumn.enum.schema || "public" : null;
	let sqlBaseType = baseColumn.getSQLType();
	sqlBaseType = sqlBaseType.replace(", ", ",");
	sqlBaseType = sqlBaseType.startsWith("timestamp (") ? sqlBaseType.replace("timestamp (", "timestamp(") : sqlBaseType;
	const { type, options } = require_grammar.splitSqlType(sqlBaseType);
	return {
		baseColumn,
		dimensions,
		isEnum,
		typeSchema,
		sqlType: dimensions > 0 ? `${sqlBaseType}${"[]".repeat(dimensions)}` : sqlBaseType,
		baseType: type,
		options
	};
};
const transformOnUpdateDelete = (on) => {
	if (on === "no action") return "NO ACTION";
	if (on === "cascade") return "CASCADE";
	if (on === "restrict") return "RESTRICT";
	if (on === "set default") return "SET DEFAULT";
	if (on === "set null") return "SET NULL";
	require_utils.assertUnreachable(on);
};
const defaultFromColumn = (base, def, dimensions, dialect) => {
	if (typeof def === "undefined") return null;
	if ((0, drizzle_orm.is)(def, drizzle_orm.SQL)) {
		let sql = dialect.sqlToQuery(def).sql;
		sql = require_grammar.trimDefaultValueSuffix(sql);
		return sql;
	}
	const { baseColumn, isEnum } = unwrapColumn(base);
	const grammarType = require_grammar.typeFor(base.getSQLType(), isEnum);
	if ((0, drizzle_orm.is)(baseColumn, drizzle_orm_pg_core.PgPointTuple) || (0, drizzle_orm.is)(baseColumn, drizzle_orm_pg_core.PgPointObject)) return dimensions > 0 && Array.isArray(def) ? def.flat(5).length === 0 ? "'{}'" : require_grammar.Point.defaultArrayFromDrizzle(def, dimensions, baseColumn.mode) : require_grammar.Point.defaultFromDrizzle(def, baseColumn.mode);
	if ((0, drizzle_orm.is)(baseColumn, drizzle_orm_pg_core.PgLineABC) || (0, drizzle_orm.is)(baseColumn, drizzle_orm_pg_core.PgLineTuple)) return dimensions > 0 && Array.isArray(def) ? def.flat(5).length === 0 ? "'{}'" : require_grammar.Line.defaultArrayFromDrizzle(def, dimensions, baseColumn.mode) : require_grammar.Line.defaultFromDrizzle(def, baseColumn.mode);
	if ((0, drizzle_orm.is)(baseColumn, drizzle_orm_pg_core.PgGeometry) || (0, drizzle_orm.is)(baseColumn, drizzle_orm_pg_core.PgGeometryObject)) return dimensions > 0 && Array.isArray(def) ? def.flat(5).length === 0 ? "'{}'" : require_grammar.GeometryPoint.defaultArrayFromDrizzle(def, dimensions, baseColumn.mode, baseColumn.srid) : require_grammar.GeometryPoint.defaultFromDrizzle(def, baseColumn.mode, baseColumn.srid);
	if (dimensions > 0 && Array.isArray(def)) {
		if (def.flat(5).length === 0) return "'{}'";
		return grammarType.defaultArrayFromDrizzle(def, dimensions);
	}
	return grammarType.defaultFromDrizzle(def);
};
const fromDrizzleSchema = (schema, casing, filter) => {
	const dialect = new drizzle_orm_pg_core.PgDialect({ casing });
	const errors = [];
	const warnings = [];
	const res = {
		indexes: [],
		pks: [],
		fks: [],
		uniques: [],
		checks: [],
		columns: [],
		policies: [],
		enums: [],
		roles: [],
		privileges: [],
		schemas: [],
		sequences: [],
		tables: [],
		viewColumns: [],
		views: []
	};
	res.schemas = schema.schemas.filter((it) => {
		return !it.isExisting && it.schemaName !== "public" && filter({
			type: "schema",
			name: it.schemaName
		});
	}).map((it) => ({
		entityType: "schemas",
		name: it.schemaName
	}));
	const tableConfigPairs = schema.tables.map((it) => {
		return {
			config: (0, drizzle_orm_pg_core.getTableConfig)(it),
			table: it
		};
	}).filter((x) => {
		return filter({
			type: "table",
			schema: x.config.schema ?? "public",
			name: x.config.name
		});
	});
	for (const policy of schema.policies) {
		if (!("_linkedTable" in policy) || typeof policy._linkedTable === "undefined") {
			warnings.push({
				type: "policy_not_linked",
				policy: policy.name
			});
			continue;
		}
		const { schema: configSchema, name: tableName } = (0, drizzle_orm_pg_core.getTableConfig)(policy._linkedTable);
		const p = policyFrom(policy, dialect);
		res.policies.push({
			entityType: "policies",
			schema: configSchema ?? "public",
			table: tableName,
			name: p.name,
			as: p.as,
			for: p.for,
			roles: p.roles,
			using: p.using,
			withCheck: p.withCheck
		});
	}
	res.tables = tableConfigPairs.map((it) => {
		const config = it.config;
		const schema$1 = config.schema ?? "public";
		const isRlsEnabled = config.enableRLS || config.policies.length > 0 || res.policies.some((x) => x.schema === schema$1 && x.table === config.name);
		return {
			entityType: "tables",
			schema: schema$1,
			name: config.name,
			isRlsEnabled
		};
	});
	for (const { table, config } of tableConfigPairs) {
		const { name: tableName, columns: drizzleColumns, indexes: drizzleIndexes, foreignKeys: drizzleFKs, checks: drizzleChecks, schema: drizzleSchema, primaryKeys: drizzlePKs, uniqueConstraints: drizzleUniques, policies: drizzlePolicies } = config;
		const schema$1 = drizzleSchema || "public";
		res.columns.push(...drizzleColumns.map((column) => {
			const name = require_drizzle.getColumnCasing(column, casing);
			const isPk = column.primary || config.primaryKeys.find((pk) => pk.columns.some((col) => col.name ? col.name === column.name : col.keyAsName === column.keyAsName)) !== void 0;
			const notNull = column.notNull || isPk;
			const generated = column.generated;
			const identity = column.generatedIdentity;
			const increment = require_grammar.stringFromIdentityProperty(identity?.sequenceOptions?.increment) ?? "1";
			const minValue = require_grammar.stringFromIdentityProperty(identity?.sequenceOptions?.minValue) ?? (parseFloat(increment) < 0 ? require_grammar.minRangeForIdentityBasedOn(column.columnType) : "1");
			const maxValue = require_grammar.stringFromIdentityProperty(identity?.sequenceOptions?.maxValue) ?? (parseFloat(increment) < 0 ? "-1" : require_grammar.maxRangeForIdentityBasedOn(column.getSQLType()));
			const startWith = require_grammar.stringFromIdentityProperty(identity?.sequenceOptions?.startWith) ?? (parseFloat(increment) < 0 ? maxValue : minValue);
			const cache = Number(require_grammar.stringFromIdentityProperty(identity?.sequenceOptions?.cache) ?? 1);
			const generatedValue = generated ? {
				as: (0, drizzle_orm.is)(generated.as, drizzle_orm.SQL) ? dialect.sqlToQuery(generated.as).sql : typeof generated.as === "function" ? dialect.sqlToQuery(generated.as()).sql : String(generated.as),
				type: "stored"
			} : null;
			const identityValue = identity ? {
				type: identity.type,
				name: identity.sequenceName ?? `${tableName}_${name}_seq`,
				increment,
				startWith,
				minValue,
				maxValue,
				cache,
				cycle: identity?.sequenceOptions?.cycle ?? false
			} : null;
			const { baseColumn, dimensions, typeSchema, sqlType } = unwrapColumn(column);
			const columnDefault = defaultFromColumn(baseColumn, column.default, dimensions, dialect);
			return {
				entityType: "columns",
				schema: schema$1,
				table: tableName,
				name,
				type: sqlType.replaceAll("[]", ""),
				typeSchema: typeSchema ?? null,
				dimensions,
				pk: column.primary,
				pkName: null,
				notNull,
				default: columnDefault,
				generated: generatedValue,
				unique: column.isUnique,
				uniqueName: column.uniqueName ?? null,
				uniqueNullsNotDistinct: column.uniqueType === "not distinct",
				identity: identityValue
			};
		}));
		res.pks.push(...drizzlePKs.map((pk) => {
			const columnNames = pk.columns.map((c) => require_drizzle.getColumnCasing(c, casing));
			return {
				entityType: "pks",
				schema: schema$1,
				table: tableName,
				name: pk.name || require_grammar.defaultNameForPK(tableName),
				columns: columnNames,
				nameExplicit: pk.isNameExplicit
			};
		}));
		res.uniques.push(...drizzleUniques.map((unq) => {
			const columnNames = unq.columns.map((c) => require_drizzle.getColumnCasing(c, casing));
			return {
				entityType: "uniques",
				schema: schema$1,
				table: tableName,
				name: unq.isNameExplicit ? unq.name : (0, drizzle_orm_pg_core.uniqueKeyName)(table, columnNames),
				nameExplicit: unq.isNameExplicit,
				nullsNotDistinct: unq.nullsNotDistinct,
				columns: columnNames
			};
		}));
		res.fks.push(...drizzleFKs.map((fk) => {
			const onDelete = fk.onDelete;
			const onUpdate = fk.onUpdate;
			const reference = fk.reference();
			const tableTo = (0, drizzle_orm.getTableName)(reference.foreignTable);
			const schemaTo = (0, drizzle_orm_pg_core.getTableConfig)(reference.foreignTable).schema || "public";
			const columnsFrom = reference.columns.map((it) => require_drizzle.getColumnCasing(it, casing));
			const columnsTo = reference.foreignColumns.map((it) => require_drizzle.getColumnCasing(it, casing));
			return {
				entityType: "fks",
				schema: schema$1,
				table: tableName,
				name: fk.isNameExplicit() ? fk.getName() : require_grammar.defaultNameForFK(tableName, columnsFrom, tableTo, columnsTo),
				nameExplicit: fk.isNameExplicit(),
				tableTo,
				schemaTo,
				columns: columnsFrom,
				columnsTo,
				onDelete: onDelete ? transformOnUpdateDelete(onDelete) : null,
				onUpdate: onUpdate ? transformOnUpdateDelete(onUpdate) : null
			};
		}));
		for (const index of drizzleIndexes) {
			const columns = index.config.columns;
			for (const column of columns) {
				if ((0, drizzle_orm.is)(column, drizzle_orm_pg_core.IndexedColumn) && column.type !== "PgVector") continue;
				if ((0, drizzle_orm.is)(column, drizzle_orm.SQL) && !index.config.name) {
					errors.push({
						type: "index_no_name",
						schema: schema$1,
						table: (0, drizzle_orm.getTableName)(index.config.table),
						sql: dialect.sqlToQuery(column).sql
					});
					continue;
				}
				if ((0, drizzle_orm.is)(column, drizzle_orm_pg_core.IndexedColumn) && column.type === "PgVector" && !column.indexConfig.opClass) {
					const columnName = require_drizzle.getColumnCasing(column, casing);
					errors.push({
						type: "pgvector_index_noop",
						table: tableName,
						column: columnName,
						indexName: index.config.name,
						method: index.config.method
					});
				}
			}
		}
		res.indexes.push(...drizzleIndexes.map((value) => {
			const columns = value.config.columns;
			let indexColumnNames = columns.map((it) => {
				return require_drizzle.getColumnCasing(it, casing);
			});
			const name = value.config.name ?? require_grammar.indexName(tableName, indexColumnNames);
			let indexColumns = columns.map((it) => {
				if ((0, drizzle_orm.is)(it, drizzle_orm.SQL)) return {
					value: dialect.sqlToQuery(it, "indexes").sql,
					isExpression: true,
					asc: true,
					nullsFirst: false,
					opclass: null
				};
				else {
					it = it;
					let nullsFirst = false;
					let asc = it.indexConfig?.order ? it.indexConfig.order === "asc" : true;
					if (!asc && !it.indexConfig?.nulls) nullsFirst = true;
					else nullsFirst = it.indexConfig?.nulls ? it.indexConfig.nulls === "first" : nullsFirst;
					return {
						value: require_drizzle.getColumnCasing(it, casing),
						isExpression: false,
						asc,
						nullsFirst,
						opclass: it.indexConfig?.opClass ? {
							name: it.indexConfig.opClass,
							default: false
						} : null
					};
				}
			});
			const withOpt = Object.entries(value.config.with || {}).map((it) => `${it[0]}=${it[1]}`).join(", ");
			let where = value.config.where ? dialect.sqlToQuery(value.config.where.inlineParams(), "indexes").sql : "";
			where = where === "true" ? "" : where;
			return {
				entityType: "indexes",
				schema: schema$1,
				table: tableName,
				name,
				nameExplicit: value.isNameExplicit,
				columns: indexColumns,
				isUnique: value.config.unique,
				where: where ? where : null,
				concurrently: value.config.concurrently ?? false,
				method: value.config.method ?? "btree",
				with: withOpt,
				forPK: false,
				forUnique: false
			};
		}));
		res.policies.push(...drizzlePolicies.map((policy) => {
			const p = policyFrom(policy, dialect);
			return {
				entityType: "policies",
				schema: schema$1,
				table: tableName,
				name: p.name,
				as: p.as,
				for: p.for,
				roles: p.roles,
				using: p.using,
				withCheck: p.withCheck
			};
		}));
		res.checks.push(...drizzleChecks.map((check) => {
			const value = dialect.sqlToQuery(check.value.inlineParams(), "indexes").sql;
			return {
				entityType: "checks",
				schema: schema$1,
				table: tableName,
				name: check.name,
				value
			};
		}));
	}
	for (const sequence of schema.sequences) {
		const name = sequence.seqName;
		const increment = require_grammar.stringFromIdentityProperty(sequence.seqOptions?.increment) ?? "1";
		const minValue = require_grammar.stringFromIdentityProperty(sequence.seqOptions?.minValue) ?? (parseFloat(increment) < 0 ? "-9223372036854775808" : "1");
		const maxValue = require_grammar.stringFromIdentityProperty(sequence.seqOptions?.maxValue) ?? (parseFloat(increment) < 0 ? "-1" : "9223372036854775807");
		const startWith = require_grammar.stringFromIdentityProperty(sequence.seqOptions?.startWith) ?? (parseFloat(increment) < 0 ? maxValue : minValue);
		const cache = Number(require_grammar.stringFromIdentityProperty(sequence.seqOptions?.cache) ?? 1);
		res.sequences.push({
			entityType: "sequences",
			name,
			schema: sequence.schema ?? "public",
			incrementBy: increment,
			startWith,
			minValue,
			maxValue,
			cacheSize: cache,
			cycle: sequence.seqOptions?.cycle ?? false
		});
	}
	for (const _role of schema.roles) {
		const role = _role;
		if (role._existing) continue;
		res.roles.push({
			entityType: "roles",
			name: role.name,
			superuser: role.superuser ?? false,
			inherit: role.inherit ?? true,
			createRole: role.createRole ?? false,
			createDb: role.createDb ?? false,
			canLogin: role.canLogin ?? false,
			replication: role.replication ?? false,
			bypassRls: role.bypassRls ?? false,
			connLimit: role.connLimit ?? -1,
			password: role.password ?? null,
			validUntil: role.validUntil ?? null
		});
	}
	const combinedViews = [...schema.views, ...schema.matViews].map((it) => {
		if ((0, drizzle_orm.is)(it, drizzle_orm_pg_core.PgView)) return {
			...(0, drizzle_orm_pg_core.getViewConfig)(it),
			materialized: false,
			tablespace: void 0,
			using: void 0,
			withNoData: void 0
		};
		else return {
			...(0, drizzle_orm_pg_core.getMaterializedViewConfig)(it),
			materialized: true
		};
	});
	for (const view of combinedViews) {
		if (view.isExisting || !filter({
			type: "table",
			schema: view.schema ?? "public",
			name: view.name
		})) continue;
		const { name: viewName, schema: schema$1, query, tablespace, using, withNoData, materialized } = view;
		const viewSchema = schema$1 ?? "public";
		const opt = view.with;
		const withOpt = opt ? {
			checkOption: require_grammar.getOrNull(opt, "checkOption"),
			securityBarrier: require_grammar.getOrNull(opt, "securityBarrier"),
			securityInvoker: require_grammar.getOrNull(opt, "securityInvoker"),
			autovacuumEnabled: require_grammar.getOrNull(opt, "autovacuumEnabled"),
			autovacuumFreezeMaxAge: require_grammar.getOrNull(opt, "autovacuumFreezeMaxAge"),
			autovacuumFreezeMinAge: require_grammar.getOrNull(opt, "autovacuumFreezeMinAge"),
			autovacuumFreezeTableAge: require_grammar.getOrNull(opt, "autovacuumFreezeTableAge"),
			autovacuumMultixactFreezeMaxAge: require_grammar.getOrNull(opt, "autovacuumMultixactFreezeMaxAge"),
			autovacuumMultixactFreezeMinAge: require_grammar.getOrNull(opt, "autovacuumMultixactFreezeMinAge"),
			autovacuumMultixactFreezeTableAge: require_grammar.getOrNull(opt, "autovacuumMultixactFreezeTableAge"),
			autovacuumVacuumCostDelay: require_grammar.getOrNull(opt, "autovacuumVacuumCostDelay"),
			autovacuumVacuumCostLimit: require_grammar.getOrNull(opt, "autovacuumVacuumCostLimit"),
			autovacuumVacuumScaleFactor: require_grammar.getOrNull(opt, "autovacuumVacuumScaleFactor"),
			autovacuumVacuumThreshold: require_grammar.getOrNull(opt, "autovacuumVacuumThreshold"),
			fillfactor: require_grammar.getOrNull(opt, "fillfactor"),
			logAutovacuumMinDuration: require_grammar.getOrNull(opt, "logAutovacuumMinDuration"),
			parallelWorkers: require_grammar.getOrNull(opt, "parallelWorkers"),
			toastTupleTarget: require_grammar.getOrNull(opt, "toastTupleTarget"),
			userCatalogTable: require_grammar.getOrNull(opt, "userCatalogTable"),
			vacuumIndexCleanup: require_grammar.getOrNull(opt, "vacuumIndexCleanup"),
			vacuumTruncate: require_grammar.getOrNull(opt, "vacuumTruncate")
		} : null;
		const hasNonNullOpts = Object.values(withOpt ?? {}).filter((x) => x !== null).length > 0;
		res.views.push({
			entityType: "views",
			definition: dialect.sqlToQuery(query).sql,
			name: viewName,
			schema: viewSchema,
			with: hasNonNullOpts ? withOpt : null,
			withNoData: withNoData ?? null,
			materialized,
			tablespace: tablespace ?? null,
			using: using ?? null
		});
	}
	res.enums = schema.enums.map((e) => {
		return {
			entityType: "enums",
			name: e.enumName,
			schema: e.schema || "public",
			values: e.enumValues
		};
	});
	return {
		schema: res,
		errors,
		warnings
	};
};
const fromExports = (exports$1) => {
	const tables = [];
	const enums = [];
	const schemas = [];
	const sequences = [];
	const roles = [];
	const policies = [];
	const views = [];
	const matViews = [];
	const relations = [];
	Object.values(exports$1).forEach((t) => {
		if ((0, drizzle_orm_pg_core.isPgEnum)(t)) {
			enums.push(t);
			return;
		}
		if ((0, drizzle_orm.is)(t, drizzle_orm_pg_core.PgTable)) tables.push(t);
		if ((0, drizzle_orm.is)(t, drizzle_orm_pg_core.PgSchema)) schemas.push(t);
		if ((0, drizzle_orm_pg_core.isPgView)(t)) views.push(t);
		if ((0, drizzle_orm_pg_core.isPgMaterializedView)(t)) matViews.push(t);
		if ((0, drizzle_orm_pg_core.isPgSequence)(t)) sequences.push(t);
		if ((0, drizzle_orm.is)(t, drizzle_orm_pg_core.PgRole)) roles.push(t);
		if ((0, drizzle_orm.is)(t, drizzle_orm_pg_core.PgPolicy)) policies.push(t);
		if ((0, drizzle_orm.is)(t, drizzle_orm__relations.Relations)) relations.push(t);
	});
	return {
		tables,
		enums,
		schemas,
		sequences,
		views,
		matViews,
		roles,
		policies,
		relations
	};
};

//#endregion
Object.defineProperty(exports, 'defaultFromColumn', {
  enumerable: true,
  get: function () {
    return defaultFromColumn;
  }
});
Object.defineProperty(exports, 'fromDrizzleSchema', {
  enumerable: true,
  get: function () {
    return fromDrizzleSchema;
  }
});
Object.defineProperty(exports, 'fromExports', {
  enumerable: true,
  get: function () {
    return fromExports;
  }
});
Object.defineProperty(exports, 'policyFrom', {
  enumerable: true,
  get: function () {
    return policyFrom;
  }
});
Object.defineProperty(exports, 'transformOnUpdateDelete', {
  enumerable: true,
  get: function () {
    return transformOnUpdateDelete;
  }
});
Object.defineProperty(exports, 'unwrapColumn', {
  enumerable: true,
  get: function () {
    return unwrapColumn;
  }
});