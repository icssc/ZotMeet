{"version":3,"file":"select.js","names":[],"sources":["../../../src/pg-core/async/select.ts"],"sourcesContent":["import { entityKind } from '~/entity.ts';\nimport type {\n\tBuildSubquerySelection,\n\tJoinNullability,\n\tSelectMode,\n\tSelectResult,\n} from '~/query-builders/select.types.ts';\nimport { QueryPromise } from '~/query-promise.ts';\nimport type { ColumnsSelection } from '~/sql/sql.ts';\nimport { tracer } from '~/tracing.ts';\nimport { applyMixins, type Assume, type NeonAuthToken, orderSelectedFields } from '~/utils.ts';\nimport type { PgColumn } from '../columns/index.ts';\nimport { PgSelectBase, type PgSelectBuilder } from '../query-builders/select.ts';\nimport type { PgSelectHKTBase, SelectedFields } from '../query-builders/select.types.ts';\nimport type { PreparedQueryConfig } from '../session.ts';\nimport type { PgAsyncPreparedQuery, PgAsyncSession } from './session.ts';\n\nexport type PgAsyncSelectPrepare<T extends AnyPgAsyncSelect> = PgAsyncPreparedQuery<\n\tPreparedQueryConfig & {\n\t\texecute: T['_']['result'];\n\t}\n>;\n\nexport type PgAsyncSelectBuilder<\n\tTSelection extends SelectedFields | undefined,\n> = PgSelectBuilder<TSelection, PgAsyncSelectHKT>;\n\nexport type PgAsyncSelect<\n\tTTableName extends string | undefined = string | undefined,\n\tTSelection extends ColumnsSelection = Record<string, any>,\n\tTSelectMode extends SelectMode = SelectMode,\n\tTNullabilityMap extends Record<string, JoinNullability> = Record<string, JoinNullability>,\n> = PgAsyncSelectBase<\n\tTTableName,\n\tTSelection,\n\tTSelectMode,\n\tTNullabilityMap,\n\ttrue,\n\tnever\n>;\n\nexport interface PgAsyncSelectHKT extends PgSelectHKTBase {\n\t_type: PgAsyncSelectBase<\n\t\tthis['tableName'],\n\t\tAssume<this['selection'], ColumnsSelection>,\n\t\tthis['selectMode'],\n\t\tAssume<this['nullabilityMap'], Record<string, JoinNullability>>,\n\t\tthis['dynamic'],\n\t\tthis['excludedMethods'],\n\t\tAssume<this['result'], any[]>,\n\t\tAssume<this['selectedFields'], ColumnsSelection>\n\t>;\n}\n\nexport interface PgAsyncSelectBase<\n\tTTableName extends string | undefined,\n\tTSelection extends ColumnsSelection | undefined,\n\tTSelectMode extends SelectMode,\n\tTNullabilityMap extends Record<string, JoinNullability> = TTableName extends string ? Record<TTableName, 'not-null'>\n\t\t: {},\n\t// oxlint-disable-next-line no-unused-vars\n\tTDynamic extends boolean = false,\n\t// oxlint-disable-next-line no-unused-vars\n\tTExcludedMethods extends string = never,\n\t// oxlint-disable-next-line no-unused-vars\n\tTResult extends any[] = SelectResult<TSelection, TSelectMode, TNullabilityMap>[],\n\t// oxlint-disable-next-line no-unused-vars\n\tTSelectedFields extends ColumnsSelection = BuildSubquerySelection<\n\t\tAssume<TSelection, ColumnsSelection>,\n\t\tTNullabilityMap\n\t>,\n> extends QueryPromise<TResult> {\n}\n\nexport class PgAsyncSelectBase<\n\tTTableName extends string | undefined,\n\tTSelection extends ColumnsSelection | undefined,\n\tTSelectMode extends SelectMode,\n\tTNullabilityMap extends Record<string, JoinNullability> = TTableName extends string ? Record<TTableName, 'not-null'>\n\t\t: {},\n\tTDynamic extends boolean = false,\n\tTExcludedMethods extends string = never,\n\tTResult extends any[] = SelectResult<TSelection, TSelectMode, TNullabilityMap>[],\n\tTSelectedFields extends ColumnsSelection = BuildSubquerySelection<\n\t\tAssume<TSelection, ColumnsSelection>,\n\t\tTNullabilityMap\n\t>,\n> extends PgSelectBase<\n\tPgAsyncSelectHKT,\n\tTTableName,\n\tTSelection,\n\tTSelectMode,\n\tTNullabilityMap,\n\tTDynamic,\n\tTExcludedMethods,\n\tTResult,\n\tTSelectedFields\n> {\n\tstatic override readonly [entityKind]: string = 'PgAsyncSelectQueryBuilder';\n\n\tdeclare protected session: PgAsyncSession;\n\n\t/** @internal */\n\t_prepare(\n\t\tname?: string,\n\t): PgAsyncSelectPrepare<this> {\n\t\tconst { session, config, dialect, joinsNotNullableMap, authToken, cacheConfig, usedTables } = this;\n\t\tconst { fields } = config;\n\n\t\treturn tracer.startActiveSpan('drizzle.prepareQuery', () => {\n\t\t\tconst fieldsList = orderSelectedFields<PgColumn>(fields);\n\t\t\tconst query = session.prepareQuery<\n\t\t\t\tPreparedQueryConfig & { execute: any }\n\t\t\t>(dialect.sqlToQuery(this.getSQL()), fieldsList, name, true, undefined, {\n\t\t\t\ttype: 'select',\n\t\t\t\ttables: [...usedTables],\n\t\t\t}, cacheConfig);\n\t\t\tquery.joinsNotNullableMap = joinsNotNullableMap;\n\n\t\t\treturn query.setToken(authToken);\n\t\t}) as any;\n\t}\n\n\t/**\n\t * Create a prepared statement for this query. This allows\n\t * the database to remember this query for the given session\n\t * and call it by name, rather than specifying the full query.\n\t *\n\t * {@link https://www.postgresql.org/docs/current/sql-prepare.html | Postgres prepare documentation}\n\t */\n\tprepare(\n\t\tname: string,\n\t): PgAsyncSelectPrepare<this> {\n\t\treturn this._prepare(name);\n\t}\n\n\t/** @internal */\n\tprivate authToken?: NeonAuthToken;\n\t/** @internal */\n\tsetToken(token?: NeonAuthToken) {\n\t\tthis.authToken = token;\n\t\treturn this;\n\t}\n\n\texecute(placeholderValues?: Record<string, unknown>) {\n\t\treturn tracer.startActiveSpan('drizzle.operation', () => {\n\t\t\treturn this._prepare().execute(placeholderValues);\n\t\t});\n\t}\n}\n\napplyMixins(PgAsyncSelectBase, [QueryPromise]);\n\nexport type AnyPgAsyncSelect = PgAsyncSelectBase<any, any, any, any, any, any, any, any>;\n"],"mappings":";;;;;;;AA0EA,IAAa,oBAAb,cAaU,aAUR;CACD,QAA0B,cAAsB;;CAKhD,SACC,MAC6B;EAC7B,MAAM,EAAE,SAAS,QAAQ,SAAS,qBAAqB,WAAW,aAAa,eAAe;EAC9F,MAAM,EAAE,WAAW;AAEnB,SAAO,OAAO,gBAAgB,8BAA8B;GAC3D,MAAM,aAAa,oBAA8B,OAAO;GACxD,MAAM,QAAQ,QAAQ,aAEpB,QAAQ,WAAW,KAAK,QAAQ,CAAC,EAAE,YAAY,MAAM,MAAM,QAAW;IACvE,MAAM;IACN,QAAQ,CAAC,GAAG,WAAW;IACvB,EAAE,YAAY;AACf,SAAM,sBAAsB;AAE5B,UAAO,MAAM,SAAS,UAAU;IAC/B;;;;;;;;;CAUH,QACC,MAC6B;AAC7B,SAAO,KAAK,SAAS,KAAK;;;CAI3B,AAAQ;;CAER,SAAS,OAAuB;AAC/B,OAAK,YAAY;AACjB,SAAO;;CAGR,QAAQ,mBAA6C;AACpD,SAAO,OAAO,gBAAgB,2BAA2B;AACxD,UAAO,KAAK,UAAU,CAAC,QAAQ,kBAAkB;IAChD;;;AAIJ,YAAY,mBAAmB,CAAC,aAAa,CAAC"}