{"version":3,"sources":["../../../../../src/client/components/router-reducer/reducers/server-patch-reducer.ts"],"sourcesContent":["import { createHrefFromUrl } from '../create-href-from-url'\nimport type {\n  ServerPatchAction,\n  ReducerState,\n  ReadonlyReducerState,\n  Mutable,\n} from '../router-reducer-types'\nimport { handleExternalUrl, handleNavigationResult } from './navigate-reducer'\nimport { navigateToSeededRoute } from '../../segment-cache/navigation'\nimport { refreshReducer } from './refresh-reducer'\nimport { FreshnessPolicy } from '../ppr-navigations'\n\nexport function serverPatchReducer(\n  state: ReadonlyReducerState,\n  action: ServerPatchAction\n): ReducerState {\n  const mutable: Mutable = {}\n  mutable.preserveCustomHistoryState = false\n\n  // A \"retry\" is a navigation that happens due to a route mismatch. It's\n  // similar to a refresh, because we will omit any existing dynamic data on\n  // the page. But we seed the retry navigation with the exact tree that the\n  // server just responded with.\n  const retryMpa = action.mpa\n  const retryUrl = new URL(action.url, location.origin)\n  const retrySeed = action.seed\n  if (retryMpa || retrySeed === null) {\n    // If the server did not send back data during the mismatch, fall back to\n    // an MPA navigation.\n    return handleExternalUrl(state, mutable, retryUrl.href, false)\n  }\n  const currentUrl = new URL(state.canonicalUrl, location.origin)\n  if (action.previousTree !== state.tree) {\n    // There was another, more recent navigation since the once that\n    // mismatched. We can abort the retry, but we still need to refresh the\n    // page to evict any stale dynamic data.\n    return refreshReducer(state)\n  }\n  // There have been no new navigations since the mismatched one. Refresh,\n  // using the tree we just received from the server.\n  const retryCanonicalUrl = createHrefFromUrl(retryUrl)\n  const retryNextUrl = action.nextUrl\n  // A retry should not create a new history entry.\n  const pendingPush = false\n  const shouldScroll = true\n  const now = Date.now()\n  const result = navigateToSeededRoute(\n    now,\n    retryUrl,\n    retryCanonicalUrl,\n    retrySeed,\n    currentUrl,\n    state.cache,\n    state.tree,\n    FreshnessPolicy.RefreshAll,\n    retryNextUrl,\n    shouldScroll\n  )\n  return handleNavigationResult(retryUrl, state, mutable, pendingPush, result)\n}\n"],"names":["serverPatchReducer","state","action","mutable","preserveCustomHistoryState","retryMpa","mpa","retryUrl","URL","url","location","origin","retrySeed","seed","handleExternalUrl","href","currentUrl","canonicalUrl","previousTree","tree","refreshReducer","retryCanonicalUrl","createHrefFromUrl","retryNextUrl","nextUrl","pendingPush","shouldScroll","now","Date","result","navigateToSeededRoute","cache","FreshnessPolicy","RefreshAll","handleNavigationResult"],"mappings":";;;;+BAYgBA;;;eAAAA;;;mCAZkB;iCAOwB;4BACpB;gCACP;gCACC;AAEzB,SAASA,mBACdC,KAA2B,EAC3BC,MAAyB;IAEzB,MAAMC,UAAmB,CAAC;IAC1BA,QAAQC,0BAA0B,GAAG;IAErC,uEAAuE;IACvE,0EAA0E;IAC1E,0EAA0E;IAC1E,8BAA8B;IAC9B,MAAMC,WAAWH,OAAOI,GAAG;IAC3B,MAAMC,WAAW,IAAIC,IAAIN,OAAOO,GAAG,EAAEC,SAASC,MAAM;IACpD,MAAMC,YAAYV,OAAOW,IAAI;IAC7B,IAAIR,YAAYO,cAAc,MAAM;QAClC,yEAAyE;QACzE,qBAAqB;QACrB,OAAOE,IAAAA,kCAAiB,EAACb,OAAOE,SAASI,SAASQ,IAAI,EAAE;IAC1D;IACA,MAAMC,aAAa,IAAIR,IAAIP,MAAMgB,YAAY,EAAEP,SAASC,MAAM;IAC9D,IAAIT,OAAOgB,YAAY,KAAKjB,MAAMkB,IAAI,EAAE;QACtC,gEAAgE;QAChE,uEAAuE;QACvE,wCAAwC;QACxC,OAAOC,IAAAA,8BAAc,EAACnB;IACxB;IACA,wEAAwE;IACxE,mDAAmD;IACnD,MAAMoB,oBAAoBC,IAAAA,oCAAiB,EAACf;IAC5C,MAAMgB,eAAerB,OAAOsB,OAAO;IACnC,iDAAiD;IACjD,MAAMC,cAAc;IACpB,MAAMC,eAAe;IACrB,MAAMC,MAAMC,KAAKD,GAAG;IACpB,MAAME,SAASC,IAAAA,iCAAqB,EAClCH,KACApB,UACAc,mBACAT,WACAI,YACAf,MAAM8B,KAAK,EACX9B,MAAMkB,IAAI,EACVa,+BAAe,CAACC,UAAU,EAC1BV,cACAG;IAEF,OAAOQ,IAAAA,uCAAsB,EAAC3B,UAAUN,OAAOE,SAASsB,aAAaI;AACvE","ignoreList":[0]}