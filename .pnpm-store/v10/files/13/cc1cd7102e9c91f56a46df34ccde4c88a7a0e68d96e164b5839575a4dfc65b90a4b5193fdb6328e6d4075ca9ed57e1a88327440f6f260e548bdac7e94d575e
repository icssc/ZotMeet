{"version":3,"file":"_relations.cjs","names":["entityKind","sourceTable: Table","referencedTable: AnyTable<{ name: TTableName }>","relationName: string | undefined","Table","table: AnyTable<{ name: TTableName }>","config: (helpers: TableRelationsHelpers<TTableName>) => TConfig","config:\n\t\t\t| RelationConfig<\n\t\t\t\tTTableName,\n\t\t\t\tstring,\n\t\t\t\tAnyColumn<{ tableName: TTableName }>[]\n\t\t\t>\n\t\t\t| undefined","isNullable: TIsNullable","config: { relationName: string } | undefined","is","tableNamesMap: Record<string, string>","relationsBuffer: Record<\n\t\tstring,\n\t\t{ relations: Record<string, Relation>; primaryKey?: AnyColumn[] }\n\t>","tablesConfig: TablesRelationalConfig","PrimaryKeyBuilder","relations: Record<string, Relation>","relations","reverseRelations: Relation[]","result: Record<string, unknown>","Column","SQL"],"sources":["../src/_relations.ts"],"sourcesContent":["import { type AnyTable, getTableUniqueName, type InferModelFromColumns, Table } from '~/table.ts';\nimport { type AnyColumn, Column } from './column.ts';\nimport { entityKind, is } from './entity.ts';\nimport { PrimaryKeyBuilder } from './pg-core/primary-keys.ts';\nimport {\n\tand,\n\tasc,\n\tbetween,\n\tdesc,\n\teq,\n\texists,\n\tgt,\n\tgte,\n\tilike,\n\tinArray,\n\tisNotNull,\n\tisNull,\n\tlike,\n\tlt,\n\tlte,\n\tne,\n\tnot,\n\tnotBetween,\n\tnotExists,\n\tnotIlike,\n\tnotInArray,\n\tnotLike,\n\tor,\n} from './sql/expressions/index.ts';\nimport { type Placeholder, SQL, sql } from './sql/sql.ts';\nimport type { Assume, ColumnsWithTable, Equal, Simplify, ValueOrArray } from './utils.ts';\n\nexport abstract class Relation<TTableName extends string = string> {\n\tstatic readonly [entityKind]: string = 'Relation';\n\n\tdeclare readonly $brand: 'Relation';\n\treadonly referencedTableName: TTableName;\n\tfieldName!: string;\n\n\tconstructor(\n\t\treadonly sourceTable: Table,\n\t\treadonly referencedTable: AnyTable<{ name: TTableName }>,\n\t\treadonly relationName: string | undefined,\n\t) {\n\t\tthis.referencedTableName = referencedTable[Table.Symbol.Name] as TTableName;\n\t}\n\n\tabstract withFieldName(fieldName: string): Relation<TTableName>;\n}\n\nexport class Relations<\n\tTTableName extends string = string,\n\tTConfig extends Record<string, Relation> = Record<string, Relation>,\n> {\n\tstatic readonly [entityKind]: string = 'Relations';\n\n\tdeclare readonly $brand: 'Relations';\n\n\tconstructor(\n\t\treadonly table: AnyTable<{ name: TTableName }>,\n\t\treadonly config: (helpers: TableRelationsHelpers<TTableName>) => TConfig,\n\t) {}\n}\n\nexport class One<\n\tTTableName extends string = string,\n\tTIsNullable extends boolean = boolean,\n> extends Relation<TTableName> {\n\tstatic override readonly [entityKind]: string = 'One';\n\n\tdeclare protected $relationBrand: 'One';\n\n\tconstructor(\n\t\tsourceTable: Table,\n\t\treferencedTable: AnyTable<{ name: TTableName }>,\n\t\treadonly config:\n\t\t\t| RelationConfig<\n\t\t\t\tTTableName,\n\t\t\t\tstring,\n\t\t\t\tAnyColumn<{ tableName: TTableName }>[]\n\t\t\t>\n\t\t\t| undefined,\n\t\treadonly isNullable: TIsNullable,\n\t) {\n\t\tsuper(sourceTable, referencedTable, config?.relationName);\n\t}\n\n\twithFieldName(fieldName: string): One<TTableName> {\n\t\tconst relation = new One(\n\t\t\tthis.sourceTable,\n\t\t\tthis.referencedTable,\n\t\t\tthis.config,\n\t\t\tthis.isNullable,\n\t\t);\n\t\trelation.fieldName = fieldName;\n\t\treturn relation;\n\t}\n}\n\nexport class Many<TTableName extends string> extends Relation<TTableName> {\n\tstatic override readonly [entityKind]: string = 'Many';\n\n\tdeclare protected $relationBrand: 'Many';\n\n\tconstructor(\n\t\tsourceTable: Table,\n\t\treferencedTable: AnyTable<{ name: TTableName }>,\n\t\treadonly config: { relationName: string } | undefined,\n\t) {\n\t\tsuper(sourceTable, referencedTable, config?.relationName);\n\t}\n\n\twithFieldName(fieldName: string): Many<TTableName> {\n\t\tconst relation = new Many(\n\t\t\tthis.sourceTable,\n\t\t\tthis.referencedTable,\n\t\t\tthis.config,\n\t\t);\n\t\trelation.fieldName = fieldName;\n\t\treturn relation;\n\t}\n}\n\nexport type TableRelationsKeysOnly<\n\tTSchema extends Record<string, unknown>,\n\tTTableName extends string,\n\tK extends keyof TSchema,\n> = TSchema[K] extends Relations<TTableName> ? K : never;\n\nexport type ExtractTableRelationsFromSchema<\n\tTSchema extends Record<string, unknown>,\n\tTTableName extends string,\n> = ExtractObjectValues<\n\t{\n\t\t[\n\t\t\tK in keyof TSchema as TableRelationsKeysOnly<\n\t\t\t\tTSchema,\n\t\t\t\tTTableName,\n\t\t\t\tK\n\t\t\t>\n\t\t]: TSchema[K] extends Relations<TTableName, infer TConfig> ? TConfig : never;\n\t}\n>;\n\nexport type ExtractObjectValues<T> = T[keyof T];\n\nexport type ExtractRelationsFromTableExtraConfigSchema<\n\tTConfig extends unknown[],\n> = ExtractObjectValues<\n\t{\n\t\t[\n\t\t\tK in keyof TConfig as TConfig[K] extends Relations<any> ? K\n\t\t\t\t: never\n\t\t]: TConfig[K] extends Relations<infer TRelationConfig> ? TRelationConfig\n\t\t\t: never;\n\t}\n>;\n\nexport function getOperators() {\n\treturn {\n\t\tand,\n\t\tbetween,\n\t\teq,\n\t\texists,\n\t\tgt,\n\t\tgte,\n\t\tilike,\n\t\tinArray,\n\t\tisNull,\n\t\tisNotNull,\n\t\tlike,\n\t\tlt,\n\t\tlte,\n\t\tne,\n\t\tnot,\n\t\tnotBetween,\n\t\tnotExists,\n\t\tnotLike,\n\t\tnotIlike,\n\t\tnotInArray,\n\t\tor,\n\t\tsql,\n\t};\n}\n\nexport type Operators = ReturnType<typeof getOperators>;\n\nexport function getOrderByOperators() {\n\treturn {\n\t\tsql,\n\t\tasc,\n\t\tdesc,\n\t};\n}\n\nexport type OrderByOperators = ReturnType<typeof getOrderByOperators>;\n\nexport type FindTableByDBName<\n\tTSchema extends TablesRelationalConfig,\n\tTTableName extends string,\n> = ExtractObjectValues<\n\t{\n\t\t[\n\t\t\tK in keyof TSchema as TSchema[K]['dbName'] extends TTableName ? K\n\t\t\t\t: never\n\t\t]: TSchema[K];\n\t}\n>;\n\nexport type DBQueryConfig<\n\tTRelationType extends 'one' | 'many' = 'one' | 'many',\n\tTIsRoot extends boolean = boolean,\n\tTSchema extends TablesRelationalConfig = TablesRelationalConfig,\n\tTTableConfig extends TableRelationalConfig = TableRelationalConfig,\n> =\n\t& {\n\t\tcolumns?:\n\t\t\t| {\n\t\t\t\t[K in keyof TTableConfig['columns']]?: boolean;\n\t\t\t}\n\t\t\t| undefined;\n\t\twith?:\n\t\t\t| {\n\t\t\t\t[K in keyof TTableConfig['relations']]?:\n\t\t\t\t\t| true\n\t\t\t\t\t| DBQueryConfig<\n\t\t\t\t\t\tTTableConfig['relations'][K] extends One ? 'one' : 'many',\n\t\t\t\t\t\tfalse,\n\t\t\t\t\t\tTSchema,\n\t\t\t\t\t\tFindTableByDBName<\n\t\t\t\t\t\t\tTSchema,\n\t\t\t\t\t\t\tTTableConfig['relations'][K]['referencedTableName']\n\t\t\t\t\t\t>\n\t\t\t\t\t>\n\t\t\t\t\t| undefined;\n\t\t\t}\n\t\t\t| undefined;\n\t\textras?:\n\t\t\t| Record<string, SQL.Aliased>\n\t\t\t| ((\n\t\t\t\tfields: Simplify<\n\t\t\t\t\t[TTableConfig['columns']] extends [never] ? {}\n\t\t\t\t\t\t: TTableConfig['columns']\n\t\t\t\t>,\n\t\t\t\toperators: { sql: Operators['sql'] },\n\t\t\t) => Record<string, SQL.Aliased>)\n\t\t\t| undefined;\n\t}\n\t& (TRelationType extends 'many' ?\n\t\t\t& {\n\t\t\t\twhere?:\n\t\t\t\t\t| SQL\n\t\t\t\t\t| undefined\n\t\t\t\t\t| ((\n\t\t\t\t\t\tfields: Simplify<\n\t\t\t\t\t\t\t[TTableConfig['columns']] extends [never] ? {}\n\t\t\t\t\t\t\t\t: TTableConfig['columns']\n\t\t\t\t\t\t>,\n\t\t\t\t\t\toperators: Operators,\n\t\t\t\t\t) => SQL | undefined);\n\t\t\t\torderBy?:\n\t\t\t\t\t| ValueOrArray<AnyColumn | SQL>\n\t\t\t\t\t| ((\n\t\t\t\t\t\tfields: Simplify<\n\t\t\t\t\t\t\t[TTableConfig['columns']] extends [never] ? {}\n\t\t\t\t\t\t\t\t: TTableConfig['columns']\n\t\t\t\t\t\t>,\n\t\t\t\t\t\toperators: OrderByOperators,\n\t\t\t\t\t) => ValueOrArray<AnyColumn | SQL>)\n\t\t\t\t\t| undefined;\n\t\t\t\tlimit?: number | Placeholder | undefined;\n\t\t\t}\n\t\t\t& (TIsRoot extends true ? {\n\t\t\t\t\toffset?: number | Placeholder | undefined;\n\t\t\t\t}\n\t\t\t\t: {})\n\t\t: {});\n\nexport interface TableRelationalConfig {\n\ttsName: string;\n\tdbName: string;\n\tcolumns: Record<string, Column>;\n\trelations: Record<string, Relation>;\n\tprimaryKey: AnyColumn[];\n\tschema?: string;\n}\n\nexport type TablesRelationalConfig = Record<string, TableRelationalConfig>;\n\nexport interface RelationalSchemaConfig<\n\tTSchema extends TablesRelationalConfig,\n> {\n\tfullSchema: Record<string, unknown>;\n\tschema: TSchema;\n\ttableNamesMap: Record<string, string>;\n}\n\nexport type ExtractTablesWithRelations<\n\tTSchema extends Record<string, unknown>,\n> = {\n\t[\n\t\tK in keyof TSchema as TSchema[K] extends Table ? K\n\t\t\t: never\n\t]: TSchema[K] extends Table ? {\n\t\t\ttsName: K & string;\n\t\t\tdbName: TSchema[K]['_']['name'];\n\t\t\tcolumns: TSchema[K]['_']['columns'];\n\t\t\trelations: ExtractTableRelationsFromSchema<\n\t\t\t\tTSchema,\n\t\t\t\tTSchema[K]['_']['name']\n\t\t\t>;\n\t\t\tprimaryKey: AnyColumn[];\n\t\t}\n\t\t: never;\n};\n\nexport type ReturnTypeOrValue<T> = T extends (...args: any[]) => infer R ? R\n\t: T;\n\nexport type BuildRelationResult<\n\tTSchema extends TablesRelationalConfig,\n\tTInclude,\n\tTRelations extends Record<string, Relation>,\n> = {\n\t[\n\t\tK in\n\t\t\t& NonUndefinedKeysOnly<TInclude>\n\t\t\t& keyof TRelations\n\t]: TRelations[K] extends infer TRel extends Relation ? BuildQueryResult<\n\t\t\tTSchema,\n\t\t\tFindTableByDBName<TSchema, TRel['referencedTableName']>,\n\t\t\tAssume<TInclude[K], true | Record<string, unknown>>\n\t\t> extends infer TResult ? TRel extends One ?\n\t\t\t\t\t| TResult\n\t\t\t\t\t| (Equal<TRel['isNullable'], false> extends true ? null : never)\n\t\t\t: TResult[]\n\t\t: never\n\t\t: never;\n};\n\nexport type NonUndefinedKeysOnly<T> =\n\t& ExtractObjectValues<\n\t\t{\n\t\t\t[K in keyof T as T[K] extends undefined ? never : K]: K;\n\t\t}\n\t>\n\t& keyof T;\n\nexport type BuildQueryResult<\n\tTSchema extends TablesRelationalConfig,\n\tTTableConfig extends TableRelationalConfig,\n\tTFullSelection extends true | Record<string, unknown>,\n> = Equal<TFullSelection, true> extends true ? InferModelFromColumns<TTableConfig['columns']>\n\t: TFullSelection extends Record<string, unknown> ? Simplify<\n\t\t\t& (TFullSelection['columns'] extends Record<string, unknown> ? InferModelFromColumns<\n\t\t\t\t\t{\n\t\t\t\t\t\t[\n\t\t\t\t\t\t\tK in Equal<\n\t\t\t\t\t\t\t\tExclude<\n\t\t\t\t\t\t\t\t\tTFullSelection['columns'][\n\t\t\t\t\t\t\t\t\t\t& keyof TFullSelection['columns']\n\t\t\t\t\t\t\t\t\t\t& keyof TTableConfig['columns']\n\t\t\t\t\t\t\t\t\t],\n\t\t\t\t\t\t\t\t\tundefined\n\t\t\t\t\t\t\t\t>,\n\t\t\t\t\t\t\t\tfalse\n\t\t\t\t\t\t\t> extends true ? Exclude<\n\t\t\t\t\t\t\t\t\tkeyof TTableConfig['columns'],\n\t\t\t\t\t\t\t\t\tNonUndefinedKeysOnly<TFullSelection['columns']>\n\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t:\n\t\t\t\t\t\t\t\t\t& {\n\t\t\t\t\t\t\t\t\t\t[K in keyof TFullSelection['columns']]: Equal<\n\t\t\t\t\t\t\t\t\t\t\tTFullSelection['columns'][K],\n\t\t\t\t\t\t\t\t\t\t\ttrue\n\t\t\t\t\t\t\t\t\t\t> extends true ? K\n\t\t\t\t\t\t\t\t\t\t\t: never;\n\t\t\t\t\t\t\t\t\t}[keyof TFullSelection['columns']]\n\t\t\t\t\t\t\t\t\t& keyof TTableConfig['columns']\n\t\t\t\t\t\t]: TTableConfig['columns'][K];\n\t\t\t\t\t}\n\t\t\t\t>\n\t\t\t\t: InferModelFromColumns<TTableConfig['columns']>)\n\t\t\t& (TFullSelection['extras'] extends\n\t\t\t\t| Record<string, unknown>\n\t\t\t\t| ((...args: any[]) => Record<string, unknown>) ? {\n\t\t\t\t\t[\n\t\t\t\t\t\tK in NonUndefinedKeysOnly<\n\t\t\t\t\t\t\tReturnTypeOrValue<TFullSelection['extras']>\n\t\t\t\t\t\t>\n\t\t\t\t\t]: Assume<\n\t\t\t\t\t\tReturnTypeOrValue<TFullSelection['extras']>[K],\n\t\t\t\t\t\tSQL.Aliased\n\t\t\t\t\t>['_']['type'];\n\t\t\t\t}\n\t\t\t\t: {})\n\t\t\t& (TFullSelection['with'] extends Record<string, unknown> ? BuildRelationResult<\n\t\t\t\t\tTSchema,\n\t\t\t\t\tTFullSelection['with'],\n\t\t\t\t\tTTableConfig['relations']\n\t\t\t\t>\n\t\t\t\t: {})\n\t\t>\n\t: never;\n\nexport interface RelationConfig<\n\tTTableName extends string,\n\tTForeignTableName extends string,\n\tTColumns extends AnyColumn<{ tableName: TTableName }>[],\n> {\n\trelationName?: string;\n\tfields: TColumns;\n\treferences: ColumnsWithTable<TTableName, TForeignTableName, TColumns>;\n}\n\nexport function extractTablesRelationalConfig<\n\tTTables extends TablesRelationalConfig,\n>(\n\tschema: Record<string, unknown>,\n\tconfigHelpers: (table: Table) => any,\n): { tables: TTables; tableNamesMap: Record<string, string> } {\n\tif (\n\t\tObject.keys(schema).length === 1\n\t\t&& 'default' in schema\n\t\t&& !is(schema['default'], Table)\n\t) {\n\t\tschema = schema['default'] as Record<string, unknown>;\n\t}\n\n\t// table DB name -> schema table key\n\tconst tableNamesMap: Record<string, string> = {};\n\t// Table relations found before their tables - need to buffer them until we know the schema table key\n\tconst relationsBuffer: Record<\n\t\tstring,\n\t\t{ relations: Record<string, Relation>; primaryKey?: AnyColumn[] }\n\t> = {};\n\tconst tablesConfig: TablesRelationalConfig = {};\n\tfor (const [key, value] of Object.entries(schema)) {\n\t\tif (is(value, Table)) {\n\t\t\tconst dbName = getTableUniqueName(value);\n\t\t\tconst bufferedRelations = relationsBuffer[dbName];\n\t\t\ttableNamesMap[dbName] = key;\n\t\t\ttablesConfig[key] = {\n\t\t\t\ttsName: key,\n\t\t\t\tdbName: value[Table.Symbol.Name],\n\t\t\t\tschema: value[Table.Symbol.Schema],\n\t\t\t\tcolumns: value[Table.Symbol.Columns],\n\t\t\t\trelations: bufferedRelations?.relations ?? {},\n\t\t\t\tprimaryKey: bufferedRelations?.primaryKey ?? [],\n\t\t\t};\n\n\t\t\t// Fill in primary keys\n\t\t\tfor (\n\t\t\t\tconst column of Object.values(\n\t\t\t\t\t(value as Table)[Table.Symbol.Columns],\n\t\t\t\t)\n\t\t\t) {\n\t\t\t\tif (column.primary) {\n\t\t\t\t\ttablesConfig[key]!.primaryKey.push(column);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst extraConfig = value[Table.Symbol.ExtraConfigBuilder]?.((value as Table)[Table.Symbol.ExtraConfigColumns]);\n\t\t\tif (extraConfig) {\n\t\t\t\tfor (const configEntry of Object.values(extraConfig)) {\n\t\t\t\t\tif (is(configEntry, PrimaryKeyBuilder)) {\n\t\t\t\t\t\ttablesConfig[key]!.primaryKey.push(...configEntry.columns);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (is(value, Relations)) {\n\t\t\tconst dbName = getTableUniqueName(value.table);\n\t\t\tconst tableName = tableNamesMap[dbName];\n\t\t\tconst relations: Record<string, Relation> = value.config(\n\t\t\t\tconfigHelpers(value.table),\n\t\t\t);\n\t\t\t// let primaryKey: AnyColumn[] | undefined;\n\n\t\t\tfor (const [relationName, relation] of Object.entries(relations)) {\n\t\t\t\tif (tableName) {\n\t\t\t\t\tconst tableConfig = tablesConfig[tableName]!;\n\t\t\t\t\ttableConfig.relations[relationName] = relation;\n\t\t\t\t\t// if (primaryKey) {\n\t\t\t\t\t// \ttableConfig.primaryKey.push(...primaryKey);\n\t\t\t\t\t// }\n\t\t\t\t} else {\n\t\t\t\t\tif (!(dbName in relationsBuffer)) {\n\t\t\t\t\t\trelationsBuffer[dbName] = {\n\t\t\t\t\t\t\trelations: {},\n\t\t\t\t\t\t\t// primaryKey,\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t\trelationsBuffer[dbName]!.relations[relationName] = relation;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn { tables: tablesConfig as TTables, tableNamesMap };\n}\n\nexport function relations<\n\tTTableName extends string,\n\tTRelations extends Record<string, Relation<any>>,\n>(\n\ttable: AnyTable<{ name: TTableName }>,\n\trelations: (helpers: TableRelationsHelpers<TTableName>) => TRelations,\n): Relations<TTableName, TRelations> {\n\treturn new Relations<TTableName, TRelations>(\n\t\ttable,\n\t\t(helpers: TableRelationsHelpers<TTableName>) =>\n\t\t\tObject.fromEntries(\n\t\t\t\tObject.entries(relations(helpers)).map(([key, value]) => [\n\t\t\t\t\tkey,\n\t\t\t\t\tvalue.withFieldName(key),\n\t\t\t\t]),\n\t\t\t) as TRelations,\n\t);\n}\n\nexport function createOne<TTableName extends string>(sourceTable: Table) {\n\treturn function one<\n\t\tTForeignTable extends Table,\n\t\tTColumns extends [\n\t\t\tAnyColumn<{ tableName: TTableName }>,\n\t\t\t...AnyColumn<{ tableName: TTableName }>[],\n\t\t],\n\t>(\n\t\ttable: TForeignTable,\n\t\tconfig?: RelationConfig<TTableName, TForeignTable['_']['name'], TColumns>,\n\t): One<\n\t\tTForeignTable['_']['name'],\n\t\tEqual<TColumns[number]['_']['notNull'], true>\n\t> {\n\t\treturn new One(\n\t\t\tsourceTable,\n\t\t\ttable,\n\t\t\tconfig,\n\t\t\t(config?.fields.reduce<boolean>((res, f) => res && f.notNull, true)\n\t\t\t\t?? false) as Equal<TColumns[number]['_']['notNull'], true>,\n\t\t);\n\t};\n}\n\nexport function createMany(sourceTable: Table) {\n\treturn function many<TForeignTable extends Table>(\n\t\treferencedTable: TForeignTable,\n\t\tconfig?: { relationName: string },\n\t): Many<TForeignTable['_']['name']> {\n\t\treturn new Many(sourceTable, referencedTable, config);\n\t};\n}\n\nexport interface NormalizedRelation {\n\tfields: AnyColumn[];\n\treferences: AnyColumn[];\n}\n\nexport function normalizeRelation(\n\tschema: TablesRelationalConfig,\n\ttableNamesMap: Record<string, string>,\n\trelation: Relation,\n): NormalizedRelation {\n\tif (is(relation, One) && relation.config) {\n\t\treturn {\n\t\t\tfields: relation.config.fields,\n\t\t\treferences: relation.config.references,\n\t\t};\n\t}\n\n\tconst referencedTableTsName = tableNamesMap[getTableUniqueName(relation.referencedTable)];\n\tif (!referencedTableTsName) {\n\t\tthrow new Error(\n\t\t\t`Table \"${relation.referencedTable[Table.Symbol.Name]}\" not found in schema`,\n\t\t);\n\t}\n\n\tconst referencedTableConfig = schema[referencedTableTsName];\n\tif (!referencedTableConfig) {\n\t\tthrow new Error(`Table \"${referencedTableTsName}\" not found in schema`);\n\t}\n\n\tconst sourceTable = relation.sourceTable;\n\tconst sourceTableTsName = tableNamesMap[getTableUniqueName(sourceTable)];\n\tif (!sourceTableTsName) {\n\t\tthrow new Error(\n\t\t\t`Table \"${sourceTable[Table.Symbol.Name]}\" not found in schema`,\n\t\t);\n\t}\n\n\tconst reverseRelations: Relation[] = [];\n\tfor (\n\t\tconst referencedTableRelation of Object.values(\n\t\t\treferencedTableConfig.relations,\n\t\t)\n\t) {\n\t\tif (\n\t\t\t(relation.relationName\n\t\t\t\t&& relation !== referencedTableRelation\n\t\t\t\t&& referencedTableRelation.relationName === relation.relationName)\n\t\t\t|| (!relation.relationName\n\t\t\t\t&& referencedTableRelation.referencedTable === relation.sourceTable)\n\t\t) {\n\t\t\treverseRelations.push(referencedTableRelation);\n\t\t}\n\t}\n\n\tif (reverseRelations.length > 1) {\n\t\tthrow relation.relationName\n\t\t\t? new Error(\n\t\t\t\t`There are multiple relations with name \"${relation.relationName}\" in table \"${referencedTableTsName}\"`,\n\t\t\t)\n\t\t\t: new Error(\n\t\t\t\t`There are multiple relations between \"${referencedTableTsName}\" and \"${\n\t\t\t\t\trelation.sourceTable[Table.Symbol.Name]\n\t\t\t\t}\". Please specify relation name`,\n\t\t\t);\n\t}\n\n\tif (\n\t\treverseRelations[0]\n\t\t&& is(reverseRelations[0], One)\n\t\t&& reverseRelations[0].config\n\t) {\n\t\treturn {\n\t\t\tfields: reverseRelations[0].config.references,\n\t\t\treferences: reverseRelations[0].config.fields,\n\t\t};\n\t}\n\n\tthrow new Error(\n\t\t`There is not enough information to infer relation \"${sourceTableTsName}.${relation.fieldName}\"`,\n\t);\n}\n\nexport function createTableRelationsHelpers<TTableName extends string>(\n\tsourceTable: AnyTable<{ name: TTableName }>,\n) {\n\treturn {\n\t\tone: createOne<TTableName>(sourceTable),\n\t\tmany: createMany(sourceTable),\n\t};\n}\n\nexport type TableRelationsHelpers<TTableName extends string> = ReturnType<\n\ttypeof createTableRelationsHelpers<TTableName>\n>;\n\nexport interface BuildRelationalQueryResult<\n\tTTable extends Table = Table,\n\tTColumn extends Column = Column,\n> {\n\ttableTsKey: string;\n\tselection: {\n\t\tdbKey: string;\n\t\ttsKey: string;\n\t\tfield: TColumn | SQL | SQL.Aliased;\n\t\trelationTableTsKey: string | undefined;\n\t\tisJson: boolean;\n\t\tisExtra?: boolean;\n\t\tselection: BuildRelationalQueryResult<TTable>['selection'];\n\t}[];\n\tsql: TTable | SQL;\n}\n\nexport function mapRelationalRow(\n\ttablesConfig: TablesRelationalConfig,\n\ttableConfig: TableRelationalConfig,\n\trow: unknown[],\n\tbuildQueryResultSelection: BuildRelationalQueryResult['selection'],\n\tmapColumnValue: (value: unknown) => unknown = (value) => value,\n): Record<string, unknown> {\n\tconst result: Record<string, unknown> = {};\n\n\tfor (\n\t\tconst [\n\t\t\tselectionItemIndex,\n\t\t\tselectionItem,\n\t\t] of buildQueryResultSelection.entries()\n\t) {\n\t\tif (selectionItem.isJson) {\n\t\t\tconst relation = tableConfig.relations[selectionItem.tsKey]!;\n\t\t\tconst rawSubRows = row[selectionItemIndex] as\n\t\t\t\t| unknown[]\n\t\t\t\t| null\n\t\t\t\t| [null]\n\t\t\t\t| string;\n\t\t\tconst subRows = typeof rawSubRows === 'string'\n\t\t\t\t? (JSON.parse(rawSubRows) as unknown[])\n\t\t\t\t: rawSubRows;\n\t\t\tresult[selectionItem.tsKey] = is(relation, One)\n\t\t\t\t? subRows\n\t\t\t\t\t&& mapRelationalRow(\n\t\t\t\t\t\ttablesConfig,\n\t\t\t\t\t\ttablesConfig[selectionItem.relationTableTsKey!]!,\n\t\t\t\t\t\tsubRows,\n\t\t\t\t\t\tselectionItem.selection,\n\t\t\t\t\t\tmapColumnValue,\n\t\t\t\t\t)\n\t\t\t\t: (subRows as unknown[][]).map((subRow) =>\n\t\t\t\t\tmapRelationalRow(\n\t\t\t\t\t\ttablesConfig,\n\t\t\t\t\t\ttablesConfig[selectionItem.relationTableTsKey!]!,\n\t\t\t\t\t\tsubRow,\n\t\t\t\t\t\tselectionItem.selection,\n\t\t\t\t\t\tmapColumnValue,\n\t\t\t\t\t)\n\t\t\t\t);\n\t\t} else {\n\t\t\tconst value = mapColumnValue(row[selectionItemIndex]);\n\t\t\tconst field = selectionItem.field!;\n\t\t\tlet decoder;\n\t\t\tif (is(field, Column)) {\n\t\t\t\tdecoder = field;\n\t\t\t} else if (is(field, SQL)) {\n\t\t\t\tdecoder = field.decoder;\n\t\t\t} else {\n\t\t\t\tdecoder = field.sql.decoder;\n\t\t\t}\n\t\t\tresult[selectionItem.tsKey] = value === null ? null : decoder.mapFromDriverValue(value);\n\t\t}\n\t}\n\n\treturn result;\n}\n\nexport function mapRelationalRowFromObj(\n\ttablesConfig: TablesRelationalConfig,\n\ttableConfig: TableRelationalConfig,\n\trow: unknown[],\n\tbuildQueryResultSelection: BuildRelationalQueryResult['selection'],\n\tmapColumnValue: (value: unknown) => unknown = (value) => value,\n): Record<string, unknown> {\n\tconst result: Record<string, unknown> = {};\n\n\tfor (\n\t\tconst [\n\t\t\tselectionItemIndex,\n\t\t\tselectionItem,\n\t\t] of buildQueryResultSelection.entries()\n\t) {\n\t\tif (selectionItem.isJson) {\n\t\t\tconst relation = tableConfig.relations[selectionItem.tsKey]!;\n\t\t\tconst isOne = is(relation, One);\n\t\t\tconst rawSubRows = row[selectionItemIndex] as unknown[] | null | [null] | string;\n\n\t\t\tlet subRows = rawSubRows as unknown[] | null;\n\t\t\tif (subRows || Array.isArray(subRows)) {\n\t\t\t\tsubRows = (typeof rawSubRows === 'string' ? JSON.parse(rawSubRows) : rawSubRows) as unknown[];\n\n\t\t\t\tsubRows = isOne\n\t\t\t\t\t? subRows.flatMap((r) => Array.isArray(r) ? r : Object.values(r as any))\n\t\t\t\t\t: subRows.map((r) => Array.isArray(r) ? r : Object.values(r as any));\n\t\t\t}\n\n\t\t\tresult[selectionItem.tsKey] = isOne\n\t\t\t\t? subRows\n\t\t\t\t\t&& mapRelationalRowFromObj(\n\t\t\t\t\t\ttablesConfig,\n\t\t\t\t\t\ttablesConfig[selectionItem.relationTableTsKey!]!,\n\t\t\t\t\t\tsubRows,\n\t\t\t\t\t\tselectionItem.selection,\n\t\t\t\t\t\tmapColumnValue,\n\t\t\t\t\t)\n\t\t\t\t: ((subRows ?? []) as unknown[][]).map((subRow) =>\n\t\t\t\t\tmapRelationalRowFromObj(\n\t\t\t\t\t\ttablesConfig,\n\t\t\t\t\t\ttablesConfig[selectionItem.relationTableTsKey!]!,\n\t\t\t\t\t\tsubRow,\n\t\t\t\t\t\tselectionItem.selection,\n\t\t\t\t\t\tmapColumnValue,\n\t\t\t\t\t)\n\t\t\t\t);\n\t\t} else {\n\t\t\tconst value = mapColumnValue(row[selectionItemIndex]);\n\t\t\tconst field = selectionItem.field!;\n\t\t\tlet decoder;\n\t\t\tif (is(field, Column)) {\n\t\t\t\tdecoder = field;\n\t\t\t} else if (is(field, SQL)) {\n\t\t\t\tdecoder = field.decoder;\n\t\t\t} else {\n\t\t\t\tdecoder = field.sql.decoder;\n\t\t\t}\n\t\t\tresult[selectionItem.tsKey] = value === null ? null : decoder.mapFromDriverValue(value);\n\t\t}\n\t}\n\n\treturn result;\n}\n"],"mappings":"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"}