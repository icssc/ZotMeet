import { CockroachColumn } from "../columns/common.cjs";
import { CockroachViewBase } from "../view-base.cjs";
import { CockroachSelectJoinConfig, SelectedFields, SelectedFieldsOrdered, TableLikeHasEmptySelection } from "./select.types.cjs";
import { entityKind } from "../../entity.cjs";
import { CockroachTable } from "../table.cjs";
import { TypedQueryBuilder } from "../../query-builders/query-builder.cjs";
import { AppendToNullabilityMap, AppendToResult, GetSelectTableName, GetSelectTableSelection, JoinNullability, JoinType, SelectMode, SelectResult } from "../../query-builders/select.types.cjs";
import { ColumnsSelection, Placeholder, Query, SQL, SQLWrapper } from "../../sql/sql.cjs";
import { Subquery } from "../../subquery.cjs";
import { InferInsertModel, Table } from "../../table.cjs";
import { Assume, DrizzleTypeError, Equal, Simplify, UpdateSet } from "../../utils.cjs";
import { CockroachDialect } from "../dialect.cjs";
import { CockroachPreparedQuery, CockroachQueryResultHKT, CockroachQueryResultKind, CockroachSession, PreparedQueryConfig } from "../session.cjs";
import { GetColumnData } from "../../column.cjs";
import { QueryPromise } from "../../query-promise.cjs";
import { RunnableQuery } from "../../runnable-query.cjs";

//#region src/cockroach-core/query-builders/update.d.ts
interface CockroachUpdateConfig {
  where?: SQL | undefined;
  set: UpdateSet;
  table: CockroachTable;
  from?: CockroachTable | Subquery | CockroachViewBase | SQL;
  joins: CockroachSelectJoinConfig[];
  returningFields?: SelectedFields;
  returning?: SelectedFieldsOrdered;
  withList?: Subquery[];
}
type CockroachUpdateSetSource<TTable extends CockroachTable> = { [Key in keyof InferInsertModel<TTable>]?: GetColumnData<TTable['_']['columns'][Key]> | SQL | CockroachColumn | Placeholder | undefined } & {};
declare class CockroachUpdateBuilder<TTable extends CockroachTable, TQueryResult extends CockroachQueryResultHKT> {
  private table;
  private session;
  private dialect;
  private withList?;
  static readonly [entityKind]: string;
  readonly _: {
    readonly table: TTable;
  };
  constructor(table: TTable, session: CockroachSession, dialect: CockroachDialect, withList?: Subquery[] | undefined);
  set(values: CockroachUpdateSetSource<TTable>): CockroachUpdateWithout<CockroachUpdateBase<TTable, TQueryResult>, false, 'leftJoin' | 'rightJoin' | 'innerJoin' | 'fullJoin'>;
}
type CockroachUpdateWithout<T extends AnyCockroachUpdate, TDynamic extends boolean, K$1 extends keyof T & string> = TDynamic extends true ? T : Omit<CockroachUpdateBase<T['_']['table'], T['_']['queryResult'], T['_']['from'], T['_']['selectedFields'], T['_']['returning'], T['_']['nullabilityMap'], T['_']['joins'], TDynamic, T['_']['excludedMethods'] | K$1>, T['_']['excludedMethods'] | K$1>;
type CockroachUpdateWithJoins<T extends AnyCockroachUpdate, TDynamic extends boolean, TFrom extends CockroachTable | Subquery | CockroachViewBase | SQL> = TDynamic extends true ? T : Omit<CockroachUpdateBase<T['_']['table'], T['_']['queryResult'], TFrom, T['_']['selectedFields'], T['_']['returning'], AppendToNullabilityMap<T['_']['nullabilityMap'], GetSelectTableName<TFrom>, 'inner'>, [...T['_']['joins'], {
  name: GetSelectTableName<TFrom>;
  joinType: 'inner';
  table: TFrom;
}], TDynamic, Exclude<T['_']['excludedMethods'] | 'from', 'leftJoin' | 'rightJoin' | 'innerJoin' | 'fullJoin'>>, Exclude<T['_']['excludedMethods'] | 'from', 'leftJoin' | 'rightJoin' | 'innerJoin' | 'fullJoin'>>;
type CockroachUpdateJoinFn<T extends AnyCockroachUpdate, TDynamic extends boolean, TJoinType extends JoinType> = <TJoinedTable extends CockroachTable | Subquery | CockroachViewBase | SQL>(table: TableLikeHasEmptySelection<TJoinedTable> extends true ? DrizzleTypeError<"Cannot reference a data-modifying statement subquery if it doesn't contain a `returning` clause"> : TJoinedTable, on: ((updateTable: T['_']['table']['_']['columns'], from: T['_']['from'] extends CockroachTable ? T['_']['from']['_']['columns'] : T['_']['from'] extends Subquery | CockroachViewBase ? T['_']['from']['_']['selectedFields'] : never) => SQL | undefined) | SQL | undefined) => CockroachUpdateJoin<T, TDynamic, TJoinType, TJoinedTable>;
type CockroachUpdateJoin<T extends AnyCockroachUpdate, TDynamic extends boolean, TJoinType extends JoinType, TJoinedTable extends CockroachTable | Subquery | CockroachViewBase | SQL> = TDynamic extends true ? T : CockroachUpdateBase<T['_']['table'], T['_']['queryResult'], T['_']['from'], T['_']['selectedFields'], T['_']['returning'], AppendToNullabilityMap<T['_']['nullabilityMap'], GetSelectTableName<TJoinedTable>, TJoinType>, [...T['_']['joins'], {
  name: GetSelectTableName<TJoinedTable>;
  joinType: TJoinType;
  table: TJoinedTable;
}], TDynamic, T['_']['excludedMethods']>;
type Join = {
  name: string | undefined;
  joinType: JoinType;
  table: CockroachTable | Subquery | CockroachViewBase | SQL;
};
type AccumulateToResult<T extends AnyCockroachUpdate, TSelectMode extends SelectMode, TJoins extends Join[], TSelectedFields extends ColumnsSelection> = TJoins extends [infer TJoin extends Join, ...infer TRest extends Join[]] ? AccumulateToResult<T, TSelectMode extends 'partial' ? TSelectMode : 'multiple', TRest, AppendToResult<T['_']['table']['_']['name'], TSelectedFields, TJoin['name'], TJoin['table'] extends Table ? TJoin['table']['_']['columns'] : TJoin['table'] extends Subquery ? Assume<TJoin['table']['_']['selectedFields'], SelectedFields> : never, TSelectMode extends 'partial' ? TSelectMode : 'multiple'>> : TSelectedFields;
type CockroachUpdateReturningAll<T extends AnyCockroachUpdate, TDynamic extends boolean> = CockroachUpdateWithout<CockroachUpdateBase<T['_']['table'], T['_']['queryResult'], T['_']['from'], Equal<T['_']['joins'], []> extends true ? T['_']['table']['_']['columns'] : Simplify<Record<T['_']['table']['_']['name'], T['_']['table']['_']['columns']> & { [K in keyof T['_']['joins'] as T['_']['joins'][K]['table']['_']['name']]: T['_']['joins'][K]['table']['_']['columns'] }>, SelectResult<AccumulateToResult<T, 'single', T['_']['joins'], GetSelectTableSelection<T['_']['table']>>, 'partial', T['_']['nullabilityMap']>, T['_']['nullabilityMap'], T['_']['joins'], TDynamic, T['_']['excludedMethods']>, TDynamic, 'returning'>;
type CockroachUpdateReturning<T extends AnyCockroachUpdate, TDynamic extends boolean, TSelectedFields extends SelectedFields> = CockroachUpdateWithout<CockroachUpdateBase<T['_']['table'], T['_']['queryResult'], T['_']['from'], TSelectedFields, SelectResult<AccumulateToResult<T, 'partial', T['_']['joins'], TSelectedFields>, 'partial', T['_']['nullabilityMap']>, T['_']['nullabilityMap'], T['_']['joins'], TDynamic, T['_']['excludedMethods']>, TDynamic, 'returning'>;
type CockroachUpdatePrepare<T extends AnyCockroachUpdate> = CockroachPreparedQuery<PreparedQueryConfig & {
  execute: T['_']['returning'] extends undefined ? CockroachQueryResultKind<T['_']['queryResult'], never> : T['_']['returning'][];
}>;
type CockroachUpdateDynamic<T extends AnyCockroachUpdate> = CockroachUpdate<T['_']['table'], T['_']['queryResult'], T['_']['from'], T['_']['returning'], T['_']['nullabilityMap']>;
type CockroachUpdate<TTable extends CockroachTable = CockroachTable, TQueryResult extends CockroachQueryResultHKT = CockroachQueryResultHKT, TFrom extends CockroachTable | Subquery | CockroachViewBase | SQL | undefined = undefined, TSelectedFields extends ColumnsSelection | undefined = undefined, TReturning extends Record<string, unknown> | undefined = Record<string, unknown> | undefined, TNullabilityMap extends Record<string, JoinNullability> = Record<TTable['_']['name'], 'not-null'>, TJoins extends Join[] = []> = CockroachUpdateBase<TTable, TQueryResult, TFrom, TSelectedFields, TReturning, TNullabilityMap, TJoins, true, never>;
type AnyCockroachUpdate = CockroachUpdateBase<any, any, any, any, any, any, any, any, any>;
interface CockroachUpdateBase<TTable extends CockroachTable, TQueryResult extends CockroachQueryResultHKT, TFrom extends CockroachTable | Subquery | CockroachViewBase | SQL | undefined = undefined, TSelectedFields extends ColumnsSelection | undefined = undefined, TReturning extends Record<string, unknown> | undefined = undefined, TNullabilityMap extends Record<string, JoinNullability> = Record<TTable['_']['name'], 'not-null'>, TJoins extends Join[] = [], TDynamic extends boolean = false, TExcludedMethods extends string = never> extends TypedQueryBuilder<TSelectedFields, TReturning extends undefined ? CockroachQueryResultKind<TQueryResult, never> : TReturning[]>, QueryPromise<TReturning extends undefined ? CockroachQueryResultKind<TQueryResult, never> : TReturning[]>, RunnableQuery<TReturning extends undefined ? CockroachQueryResultKind<TQueryResult, never> : TReturning[], 'cockroach'>, SQLWrapper {
  readonly _: {
    readonly dialect: 'cockroach';
    readonly table: TTable;
    readonly joins: TJoins;
    readonly nullabilityMap: TNullabilityMap;
    readonly queryResult: TQueryResult;
    readonly from: TFrom;
    readonly selectedFields: TSelectedFields;
    readonly returning: TReturning;
    readonly dynamic: TDynamic;
    readonly excludedMethods: TExcludedMethods;
    readonly result: TReturning extends undefined ? CockroachQueryResultKind<TQueryResult, never> : TReturning[];
  };
}
declare class CockroachUpdateBase<TTable extends CockroachTable, TQueryResult extends CockroachQueryResultHKT, TFrom extends CockroachTable | Subquery | CockroachViewBase | SQL | undefined = undefined, TSelectedFields extends ColumnsSelection | undefined = undefined, TReturning extends Record<string, unknown> | undefined = undefined, TNullabilityMap extends Record<string, JoinNullability> = Record<TTable['_']['name'], 'not-null'>, TJoins extends Join[] = [], TDynamic extends boolean = false, TExcludedMethods extends string = never> extends QueryPromise<TReturning extends undefined ? CockroachQueryResultKind<TQueryResult, never> : TReturning[]> implements RunnableQuery<TReturning extends undefined ? CockroachQueryResultKind<TQueryResult, never> : TReturning[], 'cockroach'>, SQLWrapper {
  private session;
  private dialect;
  static readonly [entityKind]: string;
  private config;
  private tableName;
  private joinsNotNullableMap;
  constructor(table: TTable, set: UpdateSet, session: CockroachSession, dialect: CockroachDialect, withList?: Subquery[]);
  from<TFrom extends CockroachTable | Subquery | CockroachViewBase | SQL>(source: TableLikeHasEmptySelection<TFrom> extends true ? DrizzleTypeError<"Cannot reference a data-modifying statement subquery if it doesn't contain a `returning` clause"> : TFrom): CockroachUpdateWithJoins<this, TDynamic, TFrom>;
  private getTableLikeFields;
  private createJoin;
  leftJoin: CockroachUpdateJoinFn<this, TDynamic, "left">;
  rightJoin: CockroachUpdateJoinFn<this, TDynamic, "right">;
  innerJoin: CockroachUpdateJoinFn<this, TDynamic, "inner">;
  fullJoin: CockroachUpdateJoinFn<this, TDynamic, "full">;
  /**
   * Adds a 'where' clause to the query.
   *
   * Calling this method will update only those rows that fulfill a specified condition.
   *
   * See docs: {@link https://orm.drizzle.team/docs/update}
   *
   * @param where the 'where' clause.
   *
   * @example
   * You can use conditional operators and `sql function` to filter the rows to be updated.
   *
   * ```ts
   * // Update all cars with green color
   * await db.update(cars).set({ color: 'red' })
   *   .where(eq(cars.color, 'green'));
   * // or
   * await db.update(cars).set({ color: 'red' })
   *   .where(sql`${cars.color} = 'green'`)
   * ```
   *
   * You can logically combine conditional operators with `and()` and `or()` operators:
   *
   * ```ts
   * // Update all BMW cars with a green color
   * await db.update(cars).set({ color: 'red' })
   *   .where(and(eq(cars.color, 'green'), eq(cars.brand, 'BMW')));
   *
   * // Update all cars with the green or blue color
   * await db.update(cars).set({ color: 'red' })
   *   .where(or(eq(cars.color, 'green'), eq(cars.color, 'blue')));
   * ```
   */
  where(where: SQL | undefined): CockroachUpdateWithout<this, TDynamic, 'where'>;
  /**
   * Adds a `returning` clause to the query.
   *
   * Calling this method will return the specified fields of the updated rows. If no fields are specified, all fields will be returned.
   *
   * See docs: {@link https://orm.drizzle.team/docs/update#update-with-returning}
   *
   * @example
   * ```ts
   * // Update all cars with the green color and return all fields
   * const updatedCars: Car[] = await db.update(cars)
   *   .set({ color: 'red' })
   *   .where(eq(cars.color, 'green'))
   *   .returning();
   *
   * // Update all cars with the green color and return only their id and brand fields
   * const updatedCarsIdsAndBrands: { id: number, brand: string }[] = await db.update(cars)
   *   .set({ color: 'red' })
   *   .where(eq(cars.color, 'green'))
   *   .returning({ id: cars.id, brand: cars.brand });
   * ```
   */
  returning(): CockroachUpdateReturningAll<this, TDynamic>;
  returning<TSelectedFields extends SelectedFields>(fields: TSelectedFields): CockroachUpdateReturning<this, TDynamic, TSelectedFields>;
  toSQL(): Query;
  prepare(name: string): CockroachUpdatePrepare<this>;
  private authToken?;
  execute: ReturnType<this['prepare']>['execute'];
  $dynamic(): CockroachUpdateDynamic<this>;
}
//#endregion
export { AnyCockroachUpdate, CockroachUpdate, CockroachUpdateBase, CockroachUpdateBuilder, CockroachUpdateConfig, CockroachUpdateDynamic, CockroachUpdateJoin, CockroachUpdateJoinFn, CockroachUpdatePrepare, CockroachUpdateReturning, CockroachUpdateReturningAll, CockroachUpdateSetSource, CockroachUpdateWithJoins, CockroachUpdateWithout };
//# sourceMappingURL=update.d.cts.map